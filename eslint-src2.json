[{"filePath":"F:\\Group Guard scratch\\electron\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\preload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\AuditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\AuthService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'app' is defined but never used.","line":1,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'restoredUser' is assigned a value but never used.","line":427,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":427,"endColumn":32}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":14,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":14,"endColumn":38,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, app } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('AuthService');\r\nimport path from 'path';\r\nimport { saveCredentials, clearCredentials, loadCredentials, hasSavedCredentials } from './CredentialsService';\r\nimport { onUserLoggedIn, onUserLoggedOut } from './PipelineService';\r\n\r\n// Import the VRChat SDK and Keyv for session persistence\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst { VRChat } = require('vrchat');\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst Keyv = require('keyv').default;\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst KeyvFile = require('keyv-file').default;\r\n\r\n// Store the VRChat SDK instance in memory (Main Process)\r\nlet vrchatClient: InstanceType<typeof VRChat> | null = null;\r\nlet currentUser: Record<string, unknown> | null = null;\r\nlet pendingLoginCredentials: { username: string; password: string; rememberMe?: boolean; authCookie?: string } | null = null;\r\n\r\n// Persistent session storage using Keyv with SQLite\r\nlet sessionStore: InstanceType<typeof Keyv> | null = null;\r\n\r\nimport { storageService } from './StorageService';\r\n\r\n// ...\r\n\r\nfunction getSessionStore(): InstanceType<typeof Keyv> {\r\n  if (!sessionStore) {\r\n    // Store sessions in the configured data directory\r\n    const userDataPath = storageService.getDataDir();\r\n    const filePath = path.join(userDataPath, 'vrchat-session.json');\r\n    logger.info(`Session store path: ${filePath}`);\r\n    \r\n    const store = new KeyvFile({ filename: filePath });\r\n    \r\n    // WORKAROUND: Keyv v5+ crashes if store.opts.url is undefined during _checkIterableAdapter\r\n    // We patch the store to satisfy Keyv's internal check\r\n    if (!store.opts) store.opts = {};\r\n    if (!store.opts.url) store.opts.url = 'file://';\r\n    \r\n    sessionStore = new Keyv({ store, namespace: 'vrchat' });\r\n    \r\n    // WORKAROUND 2: VRChat library might re-wrap our Keyv instance if it detects a version/instance mismatch.\r\n    // This wrapper will check our instance's .opts.url, so we must ensure it exists.\r\n    if (sessionStore.opts) {\r\n        sessionStore.opts.url = 'file://';\r\n    } else {\r\n        // @ts-expect-error - forcing opts if missing\r\n        sessionStore.opts = { url: 'file://' };\r\n    }\r\n    \r\n    sessionStore.on('error', (err: Error) => {\r\n      logger.error('Session store error:', err);\r\n    });\r\n  }\r\n  return sessionStore;\r\n}\r\n\r\n// Application info for VRChat API User-Agent requirement\r\nconst APP_INFO = {\r\n  name: 'VRChatGroupGuard',\r\n  version: '1.0.0',\r\n  contact: 'admin@groupguard.app'\r\n};\r\n\r\n// VRChat API base URL\r\nconst VRCHAT_API_BASE = 'https://api.vrchat.cloud/api/1';\r\n\r\n// Type for cookie jar interfaces (tough-cookie compatible)\r\ninterface CookieLike {\r\n  key?: string;\r\n  name?: string;\r\n  value?: string;\r\n}\r\n\r\ninterface CookieJarLike {\r\n  getCookiesSync?: (url: string) => CookieLike[];\r\n  _jar?: CookieJarLike;\r\n}\r\n\r\n// Helper to extract auth cookie from client\r\nfunction extractAuthCookie(client: { jar?: CookieJarLike; cookieJar?: CookieJarLike; cookies?: CookieLike[] | CookieJarLike }): string | undefined {\r\n  try {\r\n    // Check various common places for cookies in HTTP clients\r\n    const jar = client.jar || client.cookieJar || client.cookies;\r\n    \r\n    if (!jar) {\r\n      logger.debug('No cookie jar found on client');\r\n      return undefined;\r\n    }\r\n\r\n    let cookies: CookieLike[] = [];\r\n    \r\n    // If it's a tough-cookie jar or similar with getCookiesSync\r\n    try {\r\n      const jarObj = jar as CookieJarLike;\r\n      if (jarObj && typeof jarObj.getCookiesSync === 'function') {\r\n        cookies = jarObj.getCookiesSync(VRCHAT_API_BASE);\r\n      } else if (Array.isArray(jar)) {\r\n        cookies = jar as CookieLike[];\r\n      } else if (jarObj._jar && typeof jarObj._jar.getCookiesSync === 'function') {\r\n        // tough-cookie wrapped\r\n        cookies = jarObj._jar.getCookiesSync(VRCHAT_API_BASE);\r\n      }\r\n    } catch (jarError) {\r\n      logger.warn('Error accessing cookie jar:', jarError);\r\n      return undefined;\r\n    }\r\n\r\n    if (!Array.isArray(cookies)) {\r\n      logger.warn('Cookies is not an array:', typeof cookies);\r\n      return undefined;\r\n    }\r\n\r\n    // Find the 'auth' cookie - be extremely defensive\r\n    const authCookie = cookies.find((c) => {\r\n      if (!c) return false;\r\n      // Handle various cookie shapes (tough-cookie, electron cookie, simple object)\r\n      const key = c.key || c.name; \r\n      if (!key) return false;\r\n      \r\n      // Safe check for 'auth'\r\n      return key === 'auth' || (typeof key === 'string' && key.includes('auth'));\r\n    });\r\n    \r\n    if (authCookie) {\r\n      logger.debug('Found auth cookie');\r\n      // Return in format key=value\r\n      const key = authCookie.key || authCookie.name;\r\n      const value = authCookie.value;\r\n      return `${key}=${value}`;\r\n    }\r\n    \r\n  } catch (err) {\r\n    logger.warn('Failed to extract auth cookie:', err);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Try to restore a session using the persisted Keyv session store\r\n * Returns the user if successful, null if the session is invalid/expired\r\n */\r\nasync function tryRestoreSession(): Promise<{\r\n  success: boolean;\r\n  user?: Record<string, unknown>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    logger.info('Attempting to restore session from persistent store...');\r\n    \r\n    // Create a client with the persistent session store\r\n    // The SDK will automatically load any saved cookies from the Keyv store\r\n    const clientOptions = {\r\n      baseUrl: VRCHAT_API_BASE,\r\n      application: APP_INFO,\r\n      keyv: getSessionStore()\r\n    };\r\n    \r\n    logger.info('Creating VRChat client for session check...');\r\n    const client = new VRChat(clientOptions);\r\n    \r\n    // Try to get the current user - this will work if there's a valid session\r\n    try {\r\n      logger.info('Checking for existing session...');\r\n      const userResponse = await client.getCurrentUser({ throwOnError: true });\r\n      const user = userResponse?.data;\r\n      \r\n      if (user && user.id) {\r\n        logger.info(`Session restored successfully for: ${user.displayName}`);\r\n        \r\n        // Store the client and user globally\r\n        vrchatClient = client;\r\n        \r\n        // Sanitize ID\r\n        if (user.id && typeof user.id === 'string') {\r\n            user.id = user.id.trim();\r\n        }\r\n        \r\n        currentUser = user as Record<string, unknown>;\r\n        \r\n        return { success: true, user: currentUser };\r\n      }\r\n      \r\n      logger.info('No user data returned, session invalid');\r\n      return { success: false, error: 'No user data' };\r\n      \r\n    } catch (err: unknown) {\r\n      const error = err as { response?: { status?: number }; message?: string };\r\n      \r\n      // 401 = no valid session, this is expected on first launch\r\n      if (error.response?.status === 401) {\r\n        logger.info('No valid session found (401), will need to authenticate');\r\n        return { success: false, error: 'No valid session' };\r\n      }\r\n      \r\n      // Log and handle any other errors gracefully\r\n      logger.warn('Session check failed with error:', error.message || String(err));\r\n      return { success: false, error: error.message || 'Session check failed' };\r\n    }\r\n    \r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string };\r\n    logger.error('Session restoration error:', err.message || String(error));\r\n    return { success: false, error: err.message || 'Session restoration failed' };\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Internal login function - shared between manual and auto-login\r\n */\r\nasync function performLogin(username: string, password: string, twoFactorCode?: string): Promise<{\r\n  success: boolean;\r\n  user?: Record<string, unknown>;\r\n  requires2FA?: boolean;\r\n  twoFactorMethods?: string[];\r\n  error?: string;\r\n  authCookie?: string;\r\n}> {\r\n  try {\r\n    logger.info('Attempting VRChat login...');\r\n    logger.debug(`performLogin called for user ${username}`);\r\n\r\n    // Create a fresh VRChat client instance\r\n    let client = vrchatClient;\r\n    \r\n    // Create new client if needed\r\n    if (!client || !twoFactorCode) {\r\n         const clientOptions = {\r\n            baseUrl: VRCHAT_API_BASE,\r\n            application: APP_INFO,\r\n            // Use Keyv for persistent session storage (cookies persist across restarts!)\r\n            keyv: getSessionStore()\r\n         };\r\n         \r\n         logger.info('Creating VRChat client with persistent session store for login...');\r\n         client = new VRChat(clientOptions);\r\n    }\r\n\r\n    logger.info('VRChat client created (or reused), attempting login...');\r\n    \r\n    // Attempt login - the SDK's login method handles the authentication flow\r\n    try {\r\n      // If we have a cookie, we might strictly speaking purely verify credentials, \r\n      // but calling login ensure we get the user object and refresh session.\r\n      // If the cookie is valid, login() should succeed without 2FA even if 2FA is enabled.\r\n      \r\n      const user = await client.login({ username, password, twoFactorCode });\r\n      \r\n      // ... User validation logic ...\r\n      \r\n      logger.debug('Login successful. Inspecting client for cookies...');\r\n      \r\n      // Extract and save new auth cookie\r\n      const newAuthCookie = extractAuthCookie(client);\r\n      if (newAuthCookie) {\r\n         // Update the current credentials with the new cookie\r\n         if (pendingLoginCredentials) {\r\n            pendingLoginCredentials.authCookie = newAuthCookie;\r\n         } else {\r\n             // If manual login, we will save it in the auth:login handler\r\n             // If auto-login, we should update the store\r\n             // We can return it in the result or update global state? \r\n             // Best to just update the storage directly if we know who we are?\r\n             // Actually, saveCredentials handles it.\r\n         }\r\n      }\r\n      \r\n      // ... (validation logic continues from previous file content)\r\n\r\n      \r\n      // Check if we got a valid user object\r\n      let validUser: Record<string, unknown> = user;\r\n      \r\n      // ... (rest of validation) - REMOVED\r\n      \r\n      // Handle case where user is wrapped in data property\r\n      // @ts-expect-error - Checking for data wrapper\r\n      if (!validUser.id && validUser.data && validUser.data.id) {\r\n         // @ts-expect-error - Unwrap data\r\n         validUser = validUser.data;\r\n      }\r\n      \r\n      // Check if it's an error response\r\n      if (validUser.error) {\r\n        // @ts-expect-error - Accessing error message\r\n        throw new Error(validUser.error.message || 'Login returned an error');\r\n      }\r\n      \r\n      // Validate we have an ID\r\n      if (!validUser || !validUser.id) {\r\n        logger.error('Login response missing ID:', validUser);\r\n        throw new Error('Login failed: Invalid user object received');\r\n      }\r\n\r\n      // Success - store the client and user with Sanitized ID\r\n      if (validUser.id && typeof validUser.id === 'string') {\r\n          validUser.id = validUser.id.trim();\r\n      }\r\n      vrchatClient = client;\r\n      currentUser = validUser;\r\n      \r\n      const userId = validUser.id as string;\r\n      const displayName = validUser.displayName as string;\r\n      \r\n      logger.info(`User logged in successfully: ${displayName} (${userId})`);\r\n      logger.debug('Login successful', { id: userId, name: displayName });\r\n      \r\n      logger.info(`Global vrchatClient set: ${!!vrchatClient}`);\r\n\r\n      // Connect to Pipeline WebSocket for real-time events\r\n      onUserLoggedIn();\r\n\r\n      return { success: true, user: currentUser, authCookie: newAuthCookie };\r\n      \r\n    } catch (loginError: unknown) {\r\n      // Check if this is a 2FA requirement\r\n      const err = loginError as { message?: string; stack?: string; twoFactorMethods?: string[]; code?: string };\r\n      \r\n      const errorMsg = err?.message || 'Unknown login error';\r\n      // Ensure errorMsg is a string before using string methods\r\n      const errorMsgSafe = typeof errorMsg === 'string' ? errorMsg : String(errorMsg);\r\n      const errorMsgLower = errorMsgSafe.toLowerCase();\r\n      \r\n      logger.info('Login error details:', {\r\n        message: errorMsgSafe,\r\n        twoFactorMethods: err?.twoFactorMethods,\r\n        code: err?.code\r\n      });\r\n      \r\n      // The SDK throws with twoFactorMethods array when 2FA is required\r\n      if (err?.twoFactorMethods && Array.isArray(err.twoFactorMethods) && err.twoFactorMethods.length > 0) {\r\n        logger.info('2FA required, methods:', err.twoFactorMethods);\r\n        logger.debug('2FA required');\r\n        \r\n        // Store credentials and client for 2FA verification\r\n        vrchatClient = client;\r\n        \r\n        return { \r\n          success: false, \r\n          requires2FA: true,\r\n          twoFactorMethods: err.twoFactorMethods\r\n        };\r\n      }\r\n      \r\n      // WORKAROUND: If the library crashes with \"Cannot read properties of undefined (reading 'includes')\",\r\n      // it is often due to a bug in handling the 2FA response (missing headers/cookies handling).\r\n      // We assume this means 2FA is required if we haven't sent a code yet.\r\n      if (errorMsgSafe.includes(\"Cannot read properties of undefined (reading 'includes')\")) {\r\n        logger.warn(\"Caught library crash compatible with 2FA response bug. Assuming 2FA required.\");\r\n        logger.debug(\"Stack trace:\", err?.stack);\r\n        \r\n        vrchatClient = client;\r\n        return { success: false, requires2FA: true };\r\n      }\r\n\r\n      // Check for common 2FA indicators in error message\r\n      if (\r\n        errorMsgLower.includes('two-factor') ||\r\n        errorMsgLower.includes('2fa') ||\r\n        errorMsgSafe.includes('TOTP') ||\r\n        errorMsgSafe.includes('emailotp') ||\r\n        errorMsgLower.includes('totp') ||\r\n        errorMsgLower.includes('otp')\r\n      ) {\r\n        vrchatClient = client;\r\n        logger.debug('2FA required (text check)');\r\n        return { success: false, requires2FA: true };\r\n      }\r\n      \r\n      \r\n      // Re-throw for general error handling\r\n      throw loginError;\r\n    }\r\n\r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string; stack?: string; response?: { data?: { error?: { message?: string } } } };\r\n    logger.error('Login Failed (Outer Catch):', error);\r\n    if (err && err.stack) {\r\n        logger.error('Stack Trace:', err.stack);\r\n    }\r\n    \r\n    // Extract meaningful error message\r\n    let errorMessage = 'Unknown login error';\r\n    \r\n    if (err?.response?.data?.error?.message) {\r\n      errorMessage = err.response.data.error.message;\r\n    } else if (err?.message) {\r\n      errorMessage = err.message;\r\n    }\r\n    \r\n    if (typeof errorMessage !== 'string') {\r\n        errorMessage = String(errorMessage);\r\n    }\r\n    \r\n    // Append stack trace for debugging if available\r\n    if (err?.stack) {\r\n        errorMessage += `\\n\\nStack:\\n${err.stack}`;\r\n    }\r\n    \r\n    return { success: false, error: errorMessage };\r\n  }\r\n}\r\n\r\nexport function setupAuthHandlers() {\r\n  \r\n  // LOGIN Handler - accepts rememberMe flag\r\n  ipcMain.handle('auth:login', async (_event, { username, password, rememberMe = false }: { \r\n    username: string; \r\n    password: string;\r\n    rememberMe?: boolean;\r\n  }) => {\r\n    // Check if we have saved credentials that match these inputs\r\n    const saved = loadCredentials();\r\n    const isSavedUser = saved && saved.username === username;\r\n    \r\n    // If we have saved credentials for this user, try to restore session first to skip 2FA\r\n    if (isSavedUser) {\r\n        logger.info('Login matches saved user, attempting session restoration to bypass 2FA...');\r\n        const restoreResult = await tryRestoreSession();\r\n        \r\n        // If restoration worked, we are logged in!\r\n        // We do strictly verify the user ID to ensure we aren't using a stale cookie for the wrong account (though username check helps)\r\n        if (restoreResult.success && restoreResult.user) {\r\n             const restoredUser = restoreResult.user as { username?: string; displayName?: string };\r\n             // Basic check to ensure it's the same person if possible (though API returns current user)\r\n             logger.info('Session restored successfully during manual login!');\r\n             return { success: true, user: restoreResult.user };\r\n        }\r\n    }\r\n    \r\n    // Fallback to standard login\r\n    const result = await performLogin(username, password);\r\n    \r\n    if (result.success && rememberMe) {\r\n      // Save credentials on successful direct login (no 2FA)\r\n      // Save authCookie if we got one\r\n      saveCredentials(username, password, result.authCookie);\r\n      logger.info('Credentials saved for auto-login');\r\n      logger.debug('Credentials saved manually');\r\n    } else if (result.requires2FA) {\r\n      // Store credentials for 2FA completion (will save after 2FA if rememberMe is set)\r\n      // NOTE: We don't have authCookie yet usually for 2FA flow, but if we did we could store it\r\n      pendingLoginCredentials = { username, password, rememberMe };\r\n    }\r\n    \r\n    return result;\r\n  });\r\n\r\n  // 2FA Verification Handler\r\n  ipcMain.handle('auth:verify2fa', async (_event, { code }: { code: string }) => {\r\n    if (!vrchatClient || !pendingLoginCredentials) {\r\n      return { success: false, error: \"No pending login session. Please try logging in again.\" };\r\n    }\r\n    \r\n    try {\r\n      logger.info('Verifying 2FA code...');\r\n      \r\n      const result = await performLogin(\r\n        pendingLoginCredentials.username,\r\n        pendingLoginCredentials.password,\r\n        code\r\n      );\r\n\r\n      if (!result.success || !result.user) {\r\n        throw new Error(result.error || '2FA verification failed');\r\n      }\r\n\r\n      // Save credentials if rememberMe was set during initial login\r\n      if (pendingLoginCredentials.rememberMe) {\r\n        // Save with the new authCookie from the result\r\n        saveCredentials(pendingLoginCredentials.username, pendingLoginCredentials.password, result.authCookie);\r\n        logger.info('Credentials saved for auto-login after 2FA');\r\n        logger.debug('Credentials saved after 2FA');\r\n      }\r\n      \r\n      pendingLoginCredentials = null; // Clear pending credentials\r\n      \r\n      // Note: performLogin sets currentUser and vrchatClient already\r\n      \r\n      return { success: true, user: currentUser };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error(\"2FA Verification Error:\", error);\r\n      \r\n      const errorMessage = err.message || 'Invalid 2FA code';\r\n      \r\n      // Check for specific error types\r\n      if (errorMessage.toLowerCase().includes('invalid') || errorMessage.toLowerCase().includes('incorrect')) {\r\n        return { success: false, error: 'Invalid 2FA code. Please try again.' };\r\n      }\r\n      \r\n      return { success: false, error: errorMessage };\r\n    }\r\n  });\r\n\r\n  // AUTO-LOGIN Handler - attempts login with saved credentials\r\n  ipcMain.handle('auth:auto-login', async () => {\r\n    logger.info('Checking for saved credentials for auto-login...');\r\n    \r\n    if (!hasSavedCredentials()) {\r\n      logger.info('No saved credentials found');\r\n      return { success: false, noCredentials: true };\r\n    }\r\n    \r\n    const credentials = loadCredentials();\r\n    if (!credentials) {\r\n      logger.info('Failed to load credentials');\r\n      return { success: false, error: 'Failed to load saved credentials' };\r\n    }\r\n    \r\n    logger.info('Found saved credentials, attempting session restoration...');\r\n    \r\n    // FIRST: Try to restore session from Keyv store (no 2FA required!)\r\n    const sessionResult = await tryRestoreSession();\r\n    \r\n    if (sessionResult.success && sessionResult.user) {\r\n      logger.info('Session restored successfully without re-authentication!');\r\n      return { success: true, user: sessionResult.user };\r\n    }\r\n    \r\n    logger.info('Session restoration failed, falling back to full login...');\r\n    \r\n    // FALLBACK: Full login (will require 2FA if enabled)\r\n    logger.info(`Attempting full login for ${credentials.username}...`);\r\n    const result = await performLogin(credentials.username, credentials.password);\r\n    \r\n    if (result.success) {\r\n       // Update the cookie if it changed\r\n       if (result.authCookie && result.authCookie !== credentials.authCookie) {\r\n          saveCredentials(credentials.username, credentials.password, result.authCookie);\r\n          logger.debug('Auth cookie updated after auto-login');\r\n       }\r\n    }\r\n    \r\n    if (result.requires2FA) {\r\n      // Store pending credentials with rememberMe for 2FA\r\n      pendingLoginCredentials = { \r\n        username: credentials.username, \r\n        password: credentials.password, \r\n        rememberMe: true,\r\n        authCookie: credentials.authCookie\r\n      };\r\n    }\r\n    \r\n    return result;\r\n  });\r\n\r\n  // Check Session - returns current user if logged in\r\n  ipcMain.handle('auth:check-session', () => {\r\n    if (currentUser && vrchatClient) {\r\n      return { isLoggedIn: true, user: currentUser };\r\n    }\r\n    return { isLoggedIn: false };\r\n  });\r\n  \r\n  // Check if saved credentials exist\r\n  ipcMain.handle('auth:has-saved-credentials', () => {\r\n    return hasSavedCredentials();\r\n  });\r\n\r\n  // Logout Handler - optionally clears saved credentials\r\n  ipcMain.handle('auth:logout', async (_event, { clearSaved = false }: { clearSaved?: boolean } = {}) => {\r\n    try {\r\n      // The SDK may have a logout method, but we mainly need to clear local state\r\n      // VRChat doesn't have a traditional logout endpoint - sessions are cookie-based\r\n      logger.info('Logging out user...');\r\n      logger.debug('Logging out');\r\n      \r\n      if (clearSaved) {\r\n        clearCredentials();\r\n        logger.info('Saved credentials cleared');\r\n        logger.debug('Saved credentials cleared');\r\n      }\r\n    } catch (e) {\r\n      logger.warn('Logout cleanup:', e);\r\n    }\r\n    \r\n    vrchatClient = null;\r\n    currentUser = null;\r\n    pendingLoginCredentials = null;\r\n    \r\n    // Disconnect from Pipeline WebSocket\r\n    onUserLoggedOut();\r\n    \r\n    return { success: true };\r\n  });\r\n}\r\n\r\n// Helper to share client with other services (Groups, Audit, etc.)\r\nexport function getVRChatClient() {\r\n  logger.debug(`getVRChatClient called. Result exists: ${!!vrchatClient}`);\r\n  return vrchatClient;\r\n}\r\n\r\n// Helper to check if authenticated\r\nexport function isAuthenticated(): boolean {\r\n  return vrchatClient !== null && currentUser !== null;\r\n}\r\n\r\n// Helper to get current user's ID\r\nexport function getCurrentUserId(): string | null {\r\n  logger.debug(`getCurrentUserId called. ID: ${currentUser?.id}`);\r\n  logger.debug('Full currentUser keys:', Object.keys(currentUser || {}));\r\n  return currentUser?.id as string | null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\AutoModService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_user' is defined but never used.","line":35,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\CredentialsService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":3,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":13}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":7,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":7,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[775,778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[775,778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, safeStorage } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('CredentialsService');\r\n\r\n// electron-store is ESM in v9+, we need to use dynamic import or require\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst Store = require('electron-store');\r\n\r\n// Schema for our stored data\r\ninterface StoredCredentials {\r\n  username: string;\r\n  // Password is encrypted using Electron's safeStorage\r\n  encryptedPassword: string;\r\n  // Auth cookie from VRChat for session restoration\r\n  authCookie?: string;\r\n}\r\n\r\n// Initialize electron-store with encryption\r\n// Using any type since electron-store types are complex with ESM/CJS interop\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst store: any = new Store({\r\n  name: 'group-guard-credentials',\r\n  encryptionKey: 'group-guard-secure-storage-v1', // Additional layer of encryption\r\n  defaults: {\r\n    rememberMe: false\r\n  }\r\n});\r\n\r\n/**\r\n * Save credentials securely\r\n * Uses Electron's safeStorage for password encryption when available\r\n */\r\nexport function saveCredentials(username: string, password: string, authCookie?: string): boolean {\r\n  try {\r\n    let encryptedPassword: string;\r\n    \r\n    // Use safeStorage if available (uses OS keychain/credential manager)\r\n    if (safeStorage.isEncryptionAvailable()) {\r\n      const encrypted = safeStorage.encryptString(password);\r\n      encryptedPassword = encrypted.toString('base64');\r\n    } else {\r\n      // Fallback to base64 (less secure, but electron-store already encrypts)\r\n      encryptedPassword = Buffer.from(password).toString('base64');\r\n      log.warn('safeStorage not available, using fallback encryption');\r\n    }\r\n    \r\n    const credentials: StoredCredentials = {\r\n      username,\r\n      encryptedPassword,\r\n      authCookie\r\n    };\r\n    \r\n    store.set('savedCredentials', credentials);\r\n    store.set('rememberMe', true);\r\n    \r\n    log.info('Credentials saved securely');\r\n    return true;\r\n  } catch (error) {\r\n    log.error('Failed to save credentials:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Load saved credentials\r\n */\r\nexport function loadCredentials(): { username: string; password: string; authCookie?: string } | null {\r\n  try {\r\n    const saved = store.get('savedCredentials') as StoredCredentials | undefined;\r\n    if (!saved) {\r\n      return null;\r\n    }\r\n    \r\n    let password: string;\r\n    \r\n    // Decrypt using safeStorage if available\r\n    if (safeStorage.isEncryptionAvailable()) {\r\n      try {\r\n        const encrypted = Buffer.from(saved.encryptedPassword, 'base64');\r\n        password = safeStorage.decryptString(encrypted);\r\n      } catch {\r\n        // If decryption fails (e.g., different machine), try base64 fallback\r\n        password = Buffer.from(saved.encryptedPassword, 'base64').toString('utf-8');\r\n      }\r\n    } else {\r\n      // Fallback from base64\r\n      password = Buffer.from(saved.encryptedPassword, 'base64').toString('utf-8');\r\n    }\r\n    \r\n    return {\r\n      username: saved.username,\r\n      password,\r\n      authCookie: saved.authCookie\r\n    };\r\n  } catch (error) {\r\n    log.error('Failed to load credentials:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update the auth cookie for saved credentials\r\n */\r\nexport function updateAuthCookie(authCookie: string): boolean {\r\n  try {\r\n    const saved = store.get('savedCredentials') as StoredCredentials | undefined;\r\n    if (!saved) {\r\n      return false;\r\n    }\r\n    \r\n    store.set('savedCredentials', {\r\n      ...saved,\r\n      authCookie\r\n    });\r\n    \r\n    log.info('Auth cookie updated');\r\n    return true;\r\n  } catch (error) {\r\n    log.error('Failed to update auth cookie:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear all saved credentials\r\n */\r\nexport function clearCredentials(): void {\r\n  try {\r\n    store.delete('savedCredentials');\r\n    store.set('rememberMe', false);\r\n    log.info('Credentials cleared');\r\n  } catch (error) {\r\n    log.error('Failed to clear credentials:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Check if credentials are saved\r\n */\r\nexport function hasSavedCredentials(): boolean {\r\n  return store.has('savedCredentials') && store.get('rememberMe', false);\r\n}\r\n\r\n/**\r\n * Get the remember me preference\r\n */\r\nexport function getRememberMe(): boolean {\r\n  return store.get('rememberMe', false);\r\n}\r\n\r\n/**\r\n * Setup IPC handlers for credentials\r\n */\r\nexport function setupCredentialsHandlers() {\r\n  // Check if credentials are saved\r\n  ipcMain.handle('credentials:has-saved', () => {\r\n    return hasSavedCredentials();\r\n  });\r\n  \r\n  // Get remember me state\r\n  ipcMain.handle('credentials:get-remember-me', () => {\r\n    return getRememberMe();\r\n  });\r\n  \r\n  // Save credentials (called after successful login)\r\n  ipcMain.handle('credentials:save', (_event, { username, password, authCookie }: { \r\n    username: string; \r\n    password: string; \r\n    authCookie?: string \r\n  }) => {\r\n    return saveCredentials(username, password, authCookie);\r\n  });\r\n  \r\n  // Clear credentials\r\n  ipcMain.handle('credentials:clear', () => {\r\n    clearCredentials();\r\n    return true;\r\n  });\r\n  \r\n  // Load credentials for auto-login\r\n  ipcMain.handle('credentials:load', () => {\r\n    return loadCredentials();\r\n  });\r\n  \r\n  log.info('Credentials handlers initialized');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\GroupService.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":77,"column":45,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":77,"endColumn":79}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('GroupService');\r\nimport { getVRChatClient, getCurrentUserId } from './AuthService';\r\n\r\nexport function setupGroupHandlers() {\r\n\r\n  // Get user's groups (groups where user is a member)\r\n  ipcMain.handle('groups:get-my-groups', async () => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      const userId = getCurrentUserId();\r\n      \r\n      logger.debug('groups:get-my-groups called', { hasClient: !!client, userId });\r\n      \r\n      if (!client || !userId) {\r\n        logger.warn('Auth check failed in GroupService');\r\n        throw new Error(\"Not authenticated. Please log in first.\");\r\n      }\r\n\r\n      logger.info(`Fetching user groups for user ID: \"${userId}\" (type: ${typeof userId})`);\r\n      \r\n      // Sanitize userId\r\n      const safeUserId = userId.trim();\r\n      if (!safeUserId.startsWith('usr_')) {\r\n          logger.error(`Invalid User ID format: ${safeUserId}`);\r\n          throw new Error(`Invalid User ID: ${safeUserId}`);\r\n      }\r\n      \r\n      // Reverting to Object Syntax as positional caused \"malformed url\"\r\n      const response = await client.getUserGroups({ \r\n        path: { userId: safeUserId },\r\n        query: { n: 100, offset: 0 }\r\n      });\r\n\r\n      if (response.error) {\r\n        logger.error('getUserGroups returned error:', response.error);\r\n        throw new Error((response.error as { message?: string }).message || 'Failed to fetch groups');\r\n      }\r\n\r\n      const groups = response.data || [];\r\n      \r\n      // Filter for groups where user has moderation powers\r\n      interface GroupMembershipData {\r\n        id: string;\r\n        groupId?: string;\r\n        ownerId?: string;\r\n        myMember?: { permissions?: string[] };\r\n        [key: string]: unknown;\r\n      }\r\n      const moderatableGroups = (groups as GroupMembershipData[]).filter((g) => {\r\n        const isOwner = g.ownerId === safeUserId;\r\n        const hasPermissions = g.myMember?.permissions && Array.isArray(g.myMember.permissions) && g.myMember.permissions.length > 0;\r\n        return isOwner || hasPermissions;\r\n      });\r\n\r\n      // map the groups to ensure 'id' is the Group ID (grp_), not the Member ID (gmem_)\r\n      const mappedGroups = moderatableGroups.map((g) => {\r\n        // VRChat API getUserGroups returns membership objects.\r\n        // g.id is the Membership ID (gmem_...)\r\n        // g.groupId is the actual Group ID (grp_...)\r\n        // We want the frontend to see 'id' as the Group ID.\r\n        if (g.groupId && typeof g.groupId === 'string' && g.groupId.startsWith('grp_')) {\r\n            return {\r\n                ...g,\r\n                id: g.groupId,      // helper for frontend\r\n                _memberId: g.id     // preserve original membership ID\r\n            };\r\n        }\r\n        return g;\r\n      });\r\n\r\n      logger.info(`Fetched ${groups.length} total groups. Filtered to ${mappedGroups.length} moderatable groups.`);\r\n      \r\n      // Update InstanceLoggerService with allowed groups\r\n      try {\r\n          const { instanceLoggerService } = require('./InstanceLoggerService');\r\n          instanceLoggerService.setAllowedGroups(mappedGroups.map(g => g.id));\r\n      } catch (e) {\r\n          logger.error('Failed to update instance logger allowed groups', e);\r\n      }\r\n\r\n      return { success: true, groups: mappedGroups };\r\n\r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string; response?: { status?: number }; stack?: string; config?: unknown };\r\n      logger.error('Failed to fetch groups:', { message: err.message, stack: err.stack });\r\n      if (err.response?.status === 401) return { success: false, error: 'Session expired. Please log in again.' };\r\n      return { success: false, error: err.message || 'Failed to fetch groups' };\r\n    }\r\n  });\r\n\r\n  // Get specific group details\r\n  ipcMain.handle('groups:get-details', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroup({ path: { groupId } });\r\n      \r\n      if (response.error) throw response.error;\r\n      return { success: true, group: response.data };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch group details:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch group' };\r\n    }\r\n  });\r\n\r\n  // Get world details\r\n  ipcMain.handle('worlds:get-details', async (_event, { worldId }: { worldId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getWorld({ path: { worldId } });\r\n      \r\n      if (response.error) throw response.error;\r\n      return { success: true, world: response.data };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch world details:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch world' };\r\n    }\r\n  });\r\n\r\n  // Get group members\r\n  ipcMain.handle('groups:get-members', async (_event, { groupId, n = 100, offset = 0 }: { groupId: string; n?: number; offset?: number }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupMembers({ \r\n        path: { groupId },\r\n        query: { n, offset }\r\n      });\r\n      \r\n      if (response.error) throw response.error;\r\n      return { success: true, members: response.data ?? [] };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch group members:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch members' };\r\n    }\r\n  });\r\n\r\n  // Helper to extract array from VRChat API response\r\n  // Some endpoints return Array, others return { results: Array } or { instances: Array }\r\n  const extractArray = (data: unknown): unknown[] => {\r\n      if (Array.isArray(data)) return data;\r\n      const obj = data as Record<string, unknown> | null;\r\n      if (obj && Array.isArray(obj.results)) return obj.results;\r\n      if (obj && Array.isArray(obj.instances)) return obj.instances;\r\n      return [];\r\n  };\r\n\r\n  // Get group join requests\r\n  ipcMain.handle('groups:get-requests', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      logger.info(`Fetching requests for group ${groupId}`);\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupRequests({ \r\n          path: { groupId },\r\n          query: { n: 100, offset: 0 }\r\n      });\r\n      \r\n      const requests = extractArray(response.data);\r\n      logger.info(`Requests fetch detected ${requests.length} items for ${groupId}`);\r\n      \r\n      if (response.error) {\r\n        logger.error('API Error in getGroupRequests:', response.error);\r\n        throw response.error;\r\n      }\r\n      return { success: true, requests };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch join requests:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch requests' };\r\n    }\r\n  });\r\n\r\n  // Get group bans\r\n  ipcMain.handle('groups:get-bans', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      logger.info(`Fetching bans for group ${groupId}`);\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupBans({ \r\n        path: { groupId },\r\n        query: { n: 100, offset: 0 }\r\n      });\r\n      \r\n      const bans = extractArray(response.data);\r\n      logger.info(`Bans fetch detected ${bans.length} items for ${groupId}`);\r\n\r\n      if (response.error) {\r\n         logger.error('API Error in getGroupBans:', response.error);\r\n         throw response.error;\r\n      }\r\n      return { success: true, bans };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch bans:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch bans' };\r\n    }\r\n  });\r\n\r\n  // Get group audit logs\r\n  ipcMain.handle('groups:get-audit-logs', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n      \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupAuditLogs({ \r\n          path: { groupId },\r\n          query: { n: 100, offset: 0 }\r\n      });\r\n      \r\n      if (response.error) throw response.error;\r\n      const logs = extractArray(response.data);\r\n      return { success: true, logs };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch audit logs:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch audit logs' };\r\n    }\r\n  });\r\n\r\n  // Get active group instances - using direct HTTP to bypass SDK quirks\r\n  ipcMain.handle('groups:get-instances', async (_event, { groupId }: { groupId: string }) => {\r\n    // Helper to safely stringify objects with BigInt values\r\n    const safeStringify = (obj: unknown): string => {\r\n      try {\r\n        return JSON.stringify(obj, (_key, value) => \r\n          typeof value === 'bigint' ? value.toString() : value\r\n        );\r\n      } catch {\r\n        return String(obj);\r\n      }\r\n    };\r\n\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n      \r\n      const userId = getCurrentUserId();\r\n      if (!userId) throw new Error(\"No user ID found\");\r\n\r\n      logger.info(`[INSTANCES] Fetching for group: ${groupId}, user: ${userId}`);\r\n\r\n      // Strategy 1: Try the SDK method getUserGroupInstancesForGroup\r\n      let instances: unknown[] = [];\r\n      \r\n      try {\r\n        const clientAny = client as Record<string, unknown>;\r\n        if (typeof clientAny.getUserGroupInstancesForGroup === 'function') {\r\n          logger.info('[INSTANCES] Trying SDK method: getUserGroupInstancesForGroup');\r\n          const response = await (clientAny.getUserGroupInstancesForGroup as CallableFunction)({ \r\n            path: { userId, groupId } \r\n          });\r\n          const data = (response as { data?: unknown })?.data ?? response;\r\n          logger.info('[INSTANCES] SDK Response:', safeStringify(data));\r\n          instances = extractArray(data);\r\n        } else {\r\n          logger.warn('[INSTANCES] SDK method getUserGroupInstancesForGroup not available');\r\n        }\r\n      } catch (e: unknown) {\r\n        const err = e as { message?: string };\r\n        logger.warn('[INSTANCES] SDK getUserGroupInstancesForGroup failed:', err.message);\r\n      }\r\n\r\n      // Strategy 2: Try getUserGroupInstances (all groups) and filter\r\n      if (instances.length === 0) {\r\n        try {\r\n          const clientAny = client as Record<string, unknown>;\r\n          if (typeof clientAny.getUserGroupInstances === 'function') {\r\n            logger.info('[INSTANCES] Trying SDK method: getUserGroupInstances (all groups)');\r\n            const response = await (clientAny.getUserGroupInstances as CallableFunction)({ \r\n              path: { userId } \r\n            });\r\n            const data = (response as { data?: unknown })?.data ?? response;\r\n            const allInstances = extractArray(data);\r\n            logger.info(`[INSTANCES] getUserGroupInstances returned ${allInstances.length} total instances`);\r\n            \r\n            if (allInstances.length > 0) {\r\n              logger.info('[INSTANCES] First instance keys:', Object.keys(allInstances[0] as object));\r\n              logger.info('[INSTANCES] First instance data:', safeStringify(allInstances[0]));\r\n              \r\n              // Try multiple filter strategies\r\n              instances = allInstances.filter((inst: unknown) => {\r\n                const i = inst as Record<string, unknown>;\r\n                const matchGroupId = i.groupId === groupId;\r\n                const matchGroupObj = (i.group as Record<string, unknown>)?.id === groupId;\r\n                const matchOwnerId = String(i.ownerId || '').includes(groupId);\r\n                return matchGroupId || matchGroupObj || matchOwnerId;\r\n              });\r\n              logger.info(`[INSTANCES] After filtering: ${instances.length} instances for this group`);\r\n            }\r\n          }\r\n        } catch (e: unknown) {\r\n          const err = e as { message?: string };\r\n          logger.warn('[INSTANCES] SDK getUserGroupInstances failed:', err.message);\r\n        }\r\n      }\r\n\r\n      // Strategy 3: Use client.get if available  \r\n      if (instances.length === 0) {\r\n        try {\r\n          const clientAny = client as Record<string, unknown>;\r\n          if (typeof clientAny.get === 'function') {\r\n            logger.info('[INSTANCES] Trying client.get fallback');\r\n            \r\n            // Try specific group endpoint first\r\n            const url = `users/${userId}/instances/groups/${groupId}`;\r\n            logger.info('[INSTANCES] Calling:', url);\r\n            const response = await (clientAny.get as CallableFunction)(url);\r\n            const data = (response as { data?: unknown })?.data ?? response;\r\n            logger.info('[INSTANCES] client.get response:', safeStringify(data));\r\n            instances = extractArray(data);\r\n          }\r\n        } catch (e: unknown) {\r\n          const err = e as { message?: string };\r\n          logger.warn('[INSTANCES] client.get failed:', err.message);\r\n        }\r\n      }\r\n\r\n      // Strategy 4: Try the getGroupInstances method (different from user-specific)\r\n      if (instances.length === 0) {\r\n        try {\r\n          const clientAny = client as Record<string, unknown>;\r\n          if (typeof clientAny.getGroupInstances === 'function') {\r\n            logger.info('[INSTANCES] Trying SDK method: getGroupInstances');\r\n            const response = await (clientAny.getGroupInstances as CallableFunction)({ \r\n              path: { groupId } \r\n            });\r\n            const data = (response as { data?: unknown })?.data ?? response;\r\n            logger.info('[INSTANCES] getGroupInstances response:', safeStringify(data));\r\n            instances = extractArray(data);\r\n          }\r\n        } catch (e: unknown) {\r\n          const err = e as { message?: string };\r\n          logger.warn('[INSTANCES] SDK getGroupInstances failed:', err.message);\r\n        }\r\n      }\r\n\r\n      logger.info(`[INSTANCES] Final result: ${instances.length} instances for group ${groupId}`);\r\n      \r\n      if (instances.length > 0) {\r\n        logger.info('[INSTANCES] Sample instance:', safeStringify(instances[0]));\r\n      }\r\n      \r\n      return { success: true, instances };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string; stack?: string };\r\n      logger.error('[INSTANCES] Fatal error:', err.message);\r\n      logger.error('[INSTANCES] Stack:', err.stack);\r\n      return { success: false, error: err.message || 'Failed to fetch instances' };\r\n    }\r\n  });\r\n\r\n  // Ban a user from a group\r\n  ipcMain.handle('groups:ban-user', async (_event, { groupId, userId }: { groupId: string; userId: string }) => {\r\n    const client = getVRChatClient();\r\n    if (!client) throw new Error(\"Not authenticated\");\r\n\r\n    try {\r\n      logger.info(`[GroupService] Banning user ${userId} from group ${groupId}`);\r\n      \r\n      // Use correct SDK syntax with path and body parameters\r\n      const response = await client.banGroupMember({ \r\n        path: { groupId }, \r\n        body: { userId } \r\n      });\r\n      \r\n      if (response.error) {\r\n        logger.error(`[GroupService] Ban API returned error:`, response.error);\r\n        const errorMessage = (response.error as { message?: string }).message || 'Ban failed';\r\n        return { success: false, error: errorMessage };\r\n      }\r\n      \r\n      logger.info(`[GroupService] Successfully banned user ${userId} from group ${groupId}`);\r\n      return { success: true };\r\n    } catch (e: unknown) {\r\n      const err = e as { message?: string; response?: { data?: { error?: { message?: string } } } };\r\n      logger.error(`[GroupService] Failed to ban user ${userId} from group ${groupId}:`, e);\r\n      const msg = err.response?.data?.error?.message || err.message || 'Unknown error';\r\n      return { success: false, error: msg };\r\n    }\r\n  });\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\InstanceLoggerService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8268,8271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8268,8271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8783,8786],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8783,8786],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\InstanceService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2701,2704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2701,2704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3088,3091],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3088,3091],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8335,8338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8335,8338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10220,10223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10220,10223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11501,11504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11501,11504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13935,13938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13935,13938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":438,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":438,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18200,18203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18200,18203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":506,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":506,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21409,21412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21409,21412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":556,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":556,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23776,23779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23776,23779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\LogWatcherService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":4,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { app, ipcMain, BrowserWindow } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('LogWatcher');\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { EventEmitter } from 'events';\r\n\r\n// ============================================\r\n// TYPES\r\n// ============================================\r\n\r\nexport interface LogEvent {\r\n  type: 'player-joined' | 'player-left' | 'location' | 'world-name' | 'destination';\r\n  timestamp: string;\r\n  data: Record<string, string>;\r\n}\r\n\r\nexport interface PlayerJoinedEvent {\r\n  displayName: string;\r\n  userId?: string; \r\n  timestamp: string;\r\n}\r\n\r\nexport interface LocationEvent {\r\n  worldId: string;\r\n  worldName?: string;\r\n  timestamp: string;\r\n}\r\n\r\n// ============================================\r\n// STATE CACHE\r\n// ============================================\r\n\r\ninterface WatcherState {\r\n  currentWorldId: string | null;\r\n  currentWorldName: string | null;\r\n  currentLocation: string | null; // Full location string for proper tracking\r\n  players: Map<string, PlayerJoinedEvent>; // keyed by displayName\r\n}\r\n\r\n// ============================================\r\n// SERVICE\r\n// ============================================\r\n\r\nclass LogWatcherService extends EventEmitter {\r\n  private currentLogPath: string | null = null;\r\n  private currentFileSize = 0;\r\n  private watcherInterval: NodeJS.Timeout | null = null;\r\n  private isWatching = false;\r\n  \r\n  // State for late joiners\r\n  private state: WatcherState = {\r\n    currentWorldId: null,\r\n    currentWorldName: null,\r\n    currentLocation: null,\r\n    players: new Map()\r\n  };\r\n\r\n  /**\r\n   * Start watching. Validates directory, finds latest log, and starts trailing.\r\n   * If callerWindow is provided, syncs current state to it immediately.\r\n   */\r\n  start(callerWindow?: BrowserWindow) {\r\n    // If requested by a specific window, send it the current state immediately\r\n    if (callerWindow && !callerWindow.isDestroyed()) {\r\n        this.emitStateToWindow(callerWindow);\r\n    }\r\n\r\n    if (this.isWatching) {\r\n        log.info('[LogWatcher] Service already running, synced state to requestor.');\r\n        return;\r\n    }\r\n\r\n    this.isWatching = true;\r\n    log.info('[LogWatcher] Starting service...');\r\n    \r\n    this.findLatestLog();\r\n    \r\n    this.watcherInterval = setInterval(() => {\r\n      this.checkLogPath();\r\n      this.readNewContent();\r\n    }, 1000);\r\n  }\r\n\r\n  stop() {\r\n    this.isWatching = false;\r\n    if (this.watcherInterval) {\r\n      clearInterval(this.watcherInterval);\r\n      this.watcherInterval = null;\r\n    }\r\n    log.info('[LogWatcher] Service stopped');\r\n  }\r\n\r\n  private emitStateToWindow(window: BrowserWindow) {\r\n     log.info('[LogWatcher] Syncing state to renderer...');\r\n     const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19).replace(/-/g, '.');\r\n\r\n     if (this.state.currentWorldName) {\r\n         window.webContents.send('log:world-name', { name: this.state.currentWorldName, timestamp });\r\n     }\r\n     if (this.state.currentWorldId) {\r\n         window.webContents.send('log:location', { worldId: this.state.currentWorldId, timestamp });\r\n     }\r\n     \r\n     // Send all known players\r\n     for (const player of this.state.players.values()) {\r\n         window.webContents.send('log:player-joined', player);\r\n     }\r\n  }\r\n\r\n  private getLogDirectory(): string {\r\n    const appData = app.getPath('appData');\r\n    const localLow = path.join(appData, '..', 'LocalLow');\r\n    return path.join(localLow, 'VRChat', 'VRChat');\r\n  }\r\n\r\n  private findLatestLog() {\r\n    try {\r\n      const logDir = this.getLogDirectory();\r\n      if (!fs.existsSync(logDir)) {\r\n        log.warn(`[LogWatcher] VRChat log directory not found: ${logDir}`);\r\n        return;\r\n      }\r\n\r\n      const files = fs.readdirSync(logDir)\r\n        .filter(f => f.startsWith('output_log_') && f.endsWith('.txt'))\r\n        .map(f => {\r\n          const fullPath = path.join(logDir, f);\r\n          return {\r\n            name: f,\r\n            path: fullPath,\r\n            stat: fs.statSync(fullPath)\r\n          };\r\n        })\r\n        .sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());\r\n\r\n      if (files.length > 0) {\r\n        const latest = files[0];\r\n        if (latest.path !== this.currentLogPath) {\r\n          log.info(`[LogWatcher] Found new log file: ${latest.name}`);\r\n          this.currentLogPath = latest.path;\r\n          // Always read from 0 on new file detection to build state\r\n          this.currentFileSize = 0; \r\n          // Reset state for new log (new session)\r\n          this.state = { currentWorldId: null, currentWorldName: null, currentLocation: null, players: new Map() };\r\n        }\r\n      }\r\n    } catch (error) {\r\n      log.error('[LogWatcher] Error searching for logs:', error);\r\n    }\r\n  }\r\n\r\n  private checkLogPath() {\r\n    this.findLatestLog();\r\n  }\r\n\r\n  private readNewContent() {\r\n    if (!this.currentLogPath) return;\r\n\r\n    try {\r\n      if (!fs.existsSync(this.currentLogPath)) return;\r\n\r\n      const stat = fs.statSync(this.currentLogPath);\r\n      if (stat.size > this.currentFileSize) {\r\n        const stream = fs.createReadStream(this.currentLogPath, {\r\n          start: this.currentFileSize,\r\n          end: stat.size\r\n        });\r\n\r\n        let buffer = '';\r\n        stream.on('data', (chunk) => { buffer += chunk.toString(); });\r\n\r\n        stream.on('end', () => {\r\n          this.currentFileSize = stat.size;\r\n          const lines = buffer.split('\\n');\r\n          for (const line of lines) {\r\n            if (line.trim()) this.parseLine(line.trim());\r\n          }\r\n        });\r\n      }\r\n    } catch (err) {\r\n      log.error('[LogWatcher] Error reading log:', err);\r\n    }\r\n  }\r\n\r\n  private parseLine(line: string) {\r\n    // Timestamp check: yyyy.MM.dd HH:mm:ss\r\n    const timestamp = line.substring(0, 19);\r\n    \r\n    // Regex Definitions (based on FCH / VRCX)\r\n    // 1. Joining World: \"Joining wrld_...\"\r\n    // Matches \"Joining wrld_ID:instanceId~tag(val)...\"\r\n    // Use non-greedy for instance ID until next space or end of line?\r\n    // Actually, VRChat log lines look like: \"[Always] Joining wrld_xxx:12345~group(grp_xxx)\"\r\n    const reJoining = /Joining\\s+(wrld_[a-zA-Z0-9-]+):([^\\s]+)/;\r\n\r\n    // 2. Player Joined: \"OnPlayerJoined Name (usr_...)\" - handles prefixes\r\n    const rePlayerJoined = /OnPlayerJoined\\s+(?:\\[[^\\]]+\\]\\s*)?([^\\r\\n(]+?)\\s*\\((usr_[a-f0-9-]{36})\\)/;\r\n    // 3. Player Left: \"OnPlayerLeft Name (usr_...)\"\r\n    const rePlayerLeft = /OnPlayerLeft\\s+([^\\r\\n(]+?)\\s*\\((usr_[a-f0-9-]{36})\\)/;\r\n    // 4. Entering Room (World Name) - usually has [Behaviour]\r\n    const reEntering = /\\[Behaviour\\] Entering Room: (.+)/;\r\n\r\n    // 5. Avatar Change\r\n    const reAvatar = /\\[Avatar\\] Loading Avatar:\\s+(avtr_[a-f0-9-]{36})/;\r\n\r\n    // ...\r\n\r\n    // 1. World Location (Joining wrld_...)\r\n    const joinMatch = line.match(reJoining);\r\n    if (joinMatch) {\r\n         const worldId = joinMatch[1];\r\n        const fullInstanceString = joinMatch[2]; // Includes tags like 12345~group(...)\r\n        // IMPORTANT: Use the FULL instance string for API calls (includes ~group, ~region, etc.)\r\n        // The API needs this to identify group instances for permissions\r\n        const instanceId = fullInstanceString; // Keep the full string!\r\n        const location = `${worldId}:${fullInstanceString}`;\r\n        \r\n        log.info(`[LogWatcher] MATCH Joining: ${location}`);\r\n        \r\n        // CRITICAL: Check if FULL LOCATION changed (not just worldId!)\r\n        // This ensures we track instance changes even within the same world\r\n        if (this.state.currentLocation !== location) {\r\n            log.info(`[LogWatcher] Location CHANGED from ${this.state.currentLocation} to ${location}`);\r\n            \r\n            // Clear players only if world changed (same world, different instance = keep players briefly)\r\n            if (this.state.currentWorldId !== worldId) {\r\n                this.state.players.clear();\r\n            }\r\n            \r\n            this.state.currentWorldId = worldId;\r\n            this.state.currentLocation = location;\r\n            \r\n            // Emit full location info - instanceId now includes all tags\r\n            this.emitToRenderer('log:location', { worldId, instanceId, location, timestamp });\r\n            this.emit('location', { worldId, instanceId, location, timestamp });\r\n        }\r\n    }\r\n\r\n    // 5. Avatar Change\r\n    const avatarMatch = line.match(reAvatar);\r\n    if (avatarMatch) {\r\n       const avatarId = avatarMatch[1];\r\n       log.info(`[LogWatcher] MATCH Avatar: ${avatarId}`);\r\n       this.emitToRenderer('log:avatar', { avatarId, timestamp });\r\n       this.emit('avatar', { avatarId, timestamp });\r\n    }\r\n\r\n    // 2. World Name (Entering Room: ...)\r\n    const enterMatch = line.match(reEntering);\r\n    if (enterMatch) {\r\n        const worldName = enterMatch[1].trim();\r\n        log.info(`[LogWatcher] MATCH Entering Room: ${worldName}`);\r\n        this.state.currentWorldName = worldName;\r\n        this.emitToRenderer('log:world-name', { name: worldName, timestamp });\r\n        this.emit('world-name', { name: worldName, timestamp });\r\n    }\r\n\r\n    // 3. Player Joined\r\n    const playerJoinMatch = line.match(rePlayerJoined);\r\n    if (playerJoinMatch) {\r\n        const displayName = playerJoinMatch[1].trim();\r\n        const userId = playerJoinMatch[2];\r\n        \r\n        log.info(`[LogWatcher] MATCH Player Joined: ${displayName} (${userId})`);\r\n        \r\n        const playerEvent: PlayerJoinedEvent = { displayName, userId, timestamp };\r\n        this.state.players.set(displayName, playerEvent);\r\n        this.emitToRenderer('log:player-joined', playerEvent);\r\n        this.emit('player-joined', playerEvent);\r\n    }\r\n\r\n    // 4. Player Left\r\n    const playerLeftMatch = line.match(rePlayerLeft);\r\n    if (playerLeftMatch) {\r\n        const displayName = playerLeftMatch[1].trim();\r\n        const userId = playerLeftMatch[2];\r\n        \r\n        log.info(`[LogWatcher] MATCH Player Left: ${displayName} (${userId})`);\r\n        \r\n        this.state.players.delete(displayName);\r\n        this.emitToRenderer('log:player-left', { displayName, userId, timestamp });\r\n        this.emit('player-left', { displayName, userId, timestamp });\r\n    }\r\n  }\r\n\r\n  private emitToRenderer(channel: string, data: unknown) {\r\n    const windows = BrowserWindow.getAllWindows();\r\n    for (const win of windows) {\r\n      if (!win.isDestroyed()) {\r\n        win.webContents.send(channel, data);\r\n      }\r\n    }\r\n  }\r\n  public getPlayers(): PlayerJoinedEvent[] {\r\n      return Array.from(this.state.players.values());\r\n  }\r\n}\r\n\r\nexport const logWatcherService = new LogWatcherService();\r\n\r\nexport function setupLogWatcherHandlers() {\r\n  ipcMain.handle('log-watcher:start', (event) => {\r\n    // Pass the sender window so we can sync state specifically to it\r\n    const win = BrowserWindow.fromWebContents(event.sender);\r\n    logWatcherService.start(win || undefined);\r\n    return { success: true };\r\n  });\r\n\r\n  ipcMain.handle('log-watcher:stop', () => {\r\n    logWatcherService.stop();\r\n    return { success: true };\r\n  });\r\n  \r\n  // Removed global auto-start to ensure we sync on request\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\PipelineService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":17,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * VRChat Pipeline WebSocket Service\r\n * \r\n * Connects to VRChat's real-time WebSocket API for live event streaming.\r\n * Based on: https://vrchat.community/websocket\r\n * Reference: VRCX implementation (reference repos/VRCX/src/service/websocket.js)\r\n * \r\n * Events supported:\r\n * - Notifications (invites, friend requests)\r\n * - Friend status changes (online, offline, location)\r\n * - User updates (current user profile changes)\r\n * - Group events (member updates, role changes, join/leave)\r\n */\r\n\r\nimport { ipcMain, BrowserWindow } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('PipelineService');\r\nimport WebSocket from 'ws';\r\nimport { getVRChatClient, isAuthenticated } from './AuthService';\r\n\r\n// ============================================\r\n// CONSTANTS\r\n// ============================================\r\n\r\nconst PIPELINE_URL = 'wss://pipeline.vrchat.cloud';\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst MAX_RECONNECT_ATTEMPTS = 10;\r\n\r\n// ============================================\r\n// STATE\r\n// ============================================\r\n\r\nlet webSocket: WebSocket | null = null;\r\nlet reconnectAttempts = 0;\r\nlet reconnectTimeout: ReturnType<typeof setTimeout> | null = null;\r\nlet lastMessageData = '';\r\nlet isConnecting = false;\r\nlet isManualDisconnect = false;\r\n\r\n// ============================================\r\n// TYPES\r\n// ============================================\r\n\r\n/** Pipeline event types from VRChat WebSocket API */\r\nexport type PipelineEventType =\r\n  // Notification Events\r\n  | 'notification'\r\n  | 'notification-v2'\r\n  | 'notification-v2-update'\r\n  | 'notification-v2-delete'\r\n  | 'see-notification'\r\n  | 'hide-notification'\r\n  | 'response-notification'\r\n  | 'clear-notification'\r\n  // Friend Events\r\n  | 'friend-add'\r\n  | 'friend-delete'\r\n  | 'friend-online'\r\n  | 'friend-active'\r\n  | 'friend-offline'\r\n  | 'friend-update'\r\n  | 'friend-location'\r\n  // User Events\r\n  | 'user-update'\r\n  | 'user-location'\r\n  | 'user-badge-assigned'\r\n  | 'user-badge-unassigned'\r\n  | 'content-refresh'\r\n  // Group Events\r\n  | 'group-joined'\r\n  | 'group-left'\r\n  | 'group-member-updated'\r\n  | 'group-role-updated';\r\n\r\ninterface PipelineMessage {\r\n  type: PipelineEventType;\r\n  content: unknown;\r\n  err?: string;\r\n}\r\n\r\ninterface PipelineEvent {\r\n  type: PipelineEventType;\r\n  content: Record<string, unknown>;\r\n  timestamp: string;\r\n}\r\n\r\n// ============================================\r\n// AUTH TOKEN FETCHING\r\n// ============================================\r\n\r\n/**\r\n * Fetches the auth token required for WebSocket connection.\r\n * VRChat requires a call to GET /auth to retrieve the WebSocket token.\r\n */\r\nasync function fetchAuthToken(): Promise<string | null> {\r\n  try {\r\n    const client = getVRChatClient();\r\n    if (!client) {\r\n      log.warn('[Pipeline] No VRChat client available for auth token fetch');\r\n      return null;\r\n    }\r\n\r\n    // The VRChat SDK should have a method to get auth info\r\n    // Looking at VRCX, they call: request('auth', { method: 'GET' })\r\n    // which returns { ok: true, token: \"authcookie_...\" }\r\n    \r\n    // Try using the SDK's internal methods\r\n    const clientAny = client as Record<string, unknown>;\r\n    \r\n    // Strategy 1: Try getAuth if available\r\n    if (typeof clientAny.getAuth === 'function') {\r\n      log.debug('[Pipeline] Using getAuth method');\r\n      const response = await (clientAny.getAuth as () => Promise<{ data?: { ok?: boolean; token?: string } }>)();\r\n      const data = response?.data;\r\n      if (data?.ok && data?.token) {\r\n        log.info('[Pipeline] Got auth token via getAuth');\r\n        return data.token;\r\n      }\r\n    }\r\n\r\n    // Strategy 2: Try direct API call if client supports it\r\n    if (typeof clientAny.get === 'function') {\r\n      log.debug('[Pipeline] Using client.get for auth endpoint');\r\n      const response = await (clientAny.get as (path: string) => Promise<{ data?: { ok?: boolean; token?: string } }>)('auth');\r\n      const data = response?.data;\r\n      if (data?.ok && data?.token) {\r\n        log.info('[Pipeline] Got auth token via client.get');\r\n        return data.token;\r\n      }\r\n    }\r\n\r\n    // Strategy 3: Try to extract from the client's cookie jar\r\n    // The auth token for WebSocket is the same as the auth cookie value\r\n    if (clientAny.jar || clientAny.cookieJar) {\r\n      log.debug('[Pipeline] Attempting to extract token from cookie jar');\r\n      const jar = (clientAny.jar || clientAny.cookieJar) as { \r\n        getCookiesSync?: (url: string) => Array<{ key?: string; name?: string; value?: string }>;\r\n        _jar?: { getCookiesSync?: (url: string) => Array<{ key?: string; name?: string; value?: string }> };\r\n      };\r\n      \r\n      let cookies: Array<{ key?: string; name?: string; value?: string }> = [];\r\n      \r\n      if (typeof jar.getCookiesSync === 'function') {\r\n        cookies = jar.getCookiesSync('https://api.vrchat.cloud');\r\n      } else if (jar._jar && typeof jar._jar.getCookiesSync === 'function') {\r\n        cookies = jar._jar.getCookiesSync('https://api.vrchat.cloud');\r\n      }\r\n      \r\n      const authCookie = cookies.find(c => (c.key || c.name) === 'auth');\r\n      if (authCookie?.value) {\r\n        // The token format is \"authcookie_...\" which is the cookie value\r\n        log.info('[Pipeline] Got auth token from cookie jar');\r\n        return `authcookie_${authCookie.value}`;\r\n      }\r\n    }\r\n\r\n    // Strategy 4: Manual fetch using node-fetch or similar\r\n    // This is a fallback - we make a direct HTTP request to the auth endpoint\r\n    log.debug('[Pipeline] Fallback: Making direct HTTP request to /auth');\r\n    \r\n    // Get cookies from the client to include in the request\r\n    // This requires the client to expose its cookie handling\r\n    \r\n    log.warn('[Pipeline] Could not obtain auth token - all strategies exhausted');\r\n    return null;\r\n\r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string };\r\n    log.error('[Pipeline] Failed to fetch auth token:', err.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// WEBSOCKET CONNECTION\r\n// ============================================\r\n\r\n/**\r\n * Connects to the VRChat Pipeline WebSocket.\r\n */\r\nasync function connectWebSocket(): Promise<boolean> {\r\n  if (webSocket !== null || isConnecting) {\r\n    log.debug('[Pipeline] Already connected or connecting');\r\n    return false;\r\n  }\r\n\r\n  if (!isAuthenticated()) {\r\n    log.warn('[Pipeline] Cannot connect - not authenticated');\r\n    return false;\r\n  }\r\n\r\n  isConnecting = true;\r\n  isManualDisconnect = false;\r\n\r\n  try {\r\n    const token = await fetchAuthToken();\r\n    \r\n    if (!token) {\r\n      log.error('[Pipeline] Cannot connect - no auth token available');\r\n      isConnecting = false;\r\n      return false;\r\n    }\r\n\r\n    const url = `${PIPELINE_URL}/?authToken=${token}`;\r\n    log.info('[Pipeline] Connecting to VRChat Pipeline WebSocket...');\r\n\r\n    const socket = new WebSocket(url, {\r\n      headers: {\r\n        'User-Agent': 'VRChatGroupGuard/1.0.0 (admin@groupguard.app)'\r\n      }\r\n    });\r\n\r\n    socket.onopen = () => {\r\n      log.info('[Pipeline] WebSocket connected successfully');\r\n      isConnecting = false;\r\n      reconnectAttempts = 0;\r\n      webSocket = socket;\r\n      \r\n      // Notify renderer that pipeline is connected\r\n      emitToRenderer('pipeline:connected', { connected: true });\r\n    };\r\n\r\n    socket.onclose = (event: WebSocket.CloseEvent) => {\r\n      log.info(`[Pipeline] WebSocket closed: code=${event.code}, reason=${event.reason}`);\r\n      \r\n      if (webSocket === socket) {\r\n        webSocket = null;\r\n      }\r\n      \r\n      isConnecting = false;\r\n      \r\n      // Notify renderer\r\n      emitToRenderer('pipeline:disconnected', { \r\n        code: event.code, \r\n        reason: event.reason,\r\n        willReconnect: !isManualDisconnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS\r\n      });\r\n\r\n      // Auto-reconnect if not manually disconnected\r\n      if (!isManualDisconnect && isAuthenticated()) {\r\n        scheduleReconnect();\r\n      }\r\n    };\r\n\r\n    socket.onerror = (error: WebSocket.ErrorEvent) => {\r\n      log.error('[Pipeline] WebSocket error:', error.message || 'Unknown error');\r\n      emitToRenderer('pipeline:error', { message: error.message || 'WebSocket error' });\r\n    };\r\n\r\n    socket.onmessage = (event: WebSocket.MessageEvent) => {\r\n      try {\r\n        handleMessage(event.data.toString());\r\n      } catch (err: unknown) {\r\n        const error = err as { message?: string };\r\n        log.error('[Pipeline] Error handling message:', error.message);\r\n      }\r\n    };\r\n\r\n    return true;\r\n\r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string };\r\n    log.error('[Pipeline] Connection error:', err.message);\r\n    isConnecting = false;\r\n    scheduleReconnect();\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Schedules a reconnection attempt with exponential backoff.\r\n */\r\nfunction scheduleReconnect(): void {\r\n  if (reconnectTimeout !== null) {\r\n    clearTimeout(reconnectTimeout);\r\n  }\r\n\r\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\r\n    log.warn('[Pipeline] Max reconnect attempts reached, giving up');\r\n    emitToRenderer('pipeline:reconnect-failed', { \r\n      attempts: reconnectAttempts \r\n    });\r\n    return;\r\n  }\r\n\r\n  reconnectAttempts++;\r\n  const delay = RECONNECT_DELAY_MS * Math.min(reconnectAttempts, 5); // Cap at 25s\r\n  \r\n  log.info(`[Pipeline] Scheduling reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\r\n  \r\n  reconnectTimeout = setTimeout(() => {\r\n    reconnectTimeout = null;\r\n    if (isAuthenticated() && !webSocket && !isConnecting && !isManualDisconnect) {\r\n      connectWebSocket();\r\n    }\r\n  }, delay);\r\n}\r\n\r\n/**\r\n * Disconnects the WebSocket.\r\n */\r\nfunction disconnectWebSocket(): void {\r\n  isManualDisconnect = true;\r\n  \r\n  if (reconnectTimeout !== null) {\r\n    clearTimeout(reconnectTimeout);\r\n    reconnectTimeout = null;\r\n  }\r\n\r\n  if (webSocket !== null) {\r\n    log.info('[Pipeline] Disconnecting WebSocket...');\r\n    try {\r\n      webSocket.close(1000, 'Manual disconnect');\r\n    } catch (err) {\r\n      log.warn('[Pipeline] Error closing WebSocket:', err);\r\n    }\r\n    webSocket = null;\r\n  }\r\n  \r\n  reconnectAttempts = 0;\r\n  isConnecting = false;\r\n}\r\n\r\n// ============================================\r\n// MESSAGE HANDLING\r\n// ============================================\r\n\r\n/**\r\n * Handles incoming WebSocket messages.\r\n */\r\nfunction handleMessage(data: string): void {\r\n  // Dedupe identical messages (VRChat sometimes sends duplicates)\r\n  if (lastMessageData === data) {\r\n    return;\r\n  }\r\n  lastMessageData = data;\r\n\r\n  let message: PipelineMessage;\r\n  \r\n  try {\r\n    message = JSON.parse(data);\r\n    \r\n    // VRChat double-encodes content as a JSON string\r\n    if (typeof message.content === 'string') {\r\n      try {\r\n        message.content = JSON.parse(message.content);\r\n      } catch {\r\n        // Content is not JSON, keep as string\r\n      }\r\n    }\r\n  } catch {\r\n    log.warn('[Pipeline] Failed to parse message:', data.substring(0, 100));\r\n    return;\r\n  }\r\n\r\n  // Handle errors from the pipeline\r\n  if (message.err) {\r\n    log.error('[Pipeline] Server error:', message.err);\r\n    emitToRenderer('pipeline:server-error', { error: message.err });\r\n    return;\r\n  }\r\n\r\n  // Log the event\r\n  log.debug(`[Pipeline] Event: ${message.type}`, JSON.stringify(message.content).substring(0, 200));\r\n\r\n  // Create a standardized event\r\n  const event: PipelineEvent = {\r\n    type: message.type,\r\n    content: message.content as Record<string, unknown>,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Emit to renderer\r\n  emitToRenderer('pipeline:event', event);\r\n\r\n  // Handle specific event types that may need additional processing\r\n  handleSpecificEvent(event);\r\n}\r\n\r\n/**\r\n * Handles specific event types that may need server-side processing.\r\n */\r\nfunction handleSpecificEvent(event: PipelineEvent): void {\r\n  switch (event.type) {\r\n    case 'group-member-updated':\r\n      log.info('[Pipeline] Group member updated:', event.content);\r\n      break;\r\n      \r\n    case 'group-role-updated':\r\n      log.info('[Pipeline] Group role updated:', event.content);\r\n      break;\r\n      \r\n    case 'group-joined':\r\n    case 'group-left':\r\n      log.info(`[Pipeline] Group ${event.type}:`, event.content);\r\n      break;\r\n\r\n    case 'notification':\r\n    case 'notification-v2':\r\n      log.info('[Pipeline] Notification received:', event.content);\r\n      break;\r\n\r\n    case 'friend-online':\r\n    case 'friend-offline':\r\n    case 'friend-location':\r\n      log.debug(`[Pipeline] Friend ${event.type}:`, event.content);\r\n      break;\r\n\r\n    case 'user-update':\r\n      log.info('[Pipeline] Current user updated:', event.content);\r\n      break;\r\n\r\n    default:\r\n      // Other events are just forwarded to renderer\r\n      break;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// IPC BRIDGE\r\n// ============================================\r\n\r\n/**\r\n * Emits an event to all renderer windows.\r\n */\r\nfunction emitToRenderer(channel: string, data: unknown): void {\r\n  const windows = BrowserWindow.getAllWindows();\r\n  for (const window of windows) {\r\n    if (!window.isDestroyed()) {\r\n      window.webContents.send(channel, data);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sets up IPC handlers for the Pipeline service.\r\n */\r\nexport function setupPipelineHandlers(): void {\r\n  // Connect to pipeline\r\n  ipcMain.handle('pipeline:connect', async () => {\r\n    log.info('[Pipeline] Connect requested');\r\n    const success = await connectWebSocket();\r\n    return { success, connected: webSocket !== null };\r\n  });\r\n\r\n  // Disconnect from pipeline\r\n  ipcMain.handle('pipeline:disconnect', () => {\r\n    log.info('[Pipeline] Disconnect requested');\r\n    disconnectWebSocket();\r\n    return { success: true };\r\n  });\r\n\r\n  // Get connection status\r\n  ipcMain.handle('pipeline:status', () => {\r\n    return {\r\n      connected: webSocket !== null && webSocket.readyState === WebSocket.OPEN,\r\n      connecting: isConnecting,\r\n      reconnectAttempts\r\n    };\r\n  });\r\n\r\n  // Force reconnect\r\n  ipcMain.handle('pipeline:reconnect', async () => {\r\n    log.info('[Pipeline] Reconnect requested');\r\n    disconnectWebSocket();\r\n    isManualDisconnect = false;\r\n    reconnectAttempts = 0;\r\n    const success = await connectWebSocket();\r\n    return { success };\r\n  });\r\n}\r\n\r\n// ============================================\r\n// LIFECYCLE\r\n// ============================================\r\n\r\n/**\r\n * Call this when the user logs in to auto-connect to the pipeline.\r\n */\r\nexport function onUserLoggedIn(): void {\r\n  log.info('[Pipeline] User logged in, connecting to pipeline...');\r\n  // Small delay to ensure auth is fully set up\r\n  setTimeout(() => {\r\n    connectWebSocket();\r\n  }, 1000);\r\n}\r\n\r\n/**\r\n * Call this when the user logs out to disconnect from the pipeline.\r\n */\r\nexport function onUserLoggedOut(): void {\r\n  log.info('[Pipeline] User logged out, disconnecting from pipeline');\r\n  disconnectWebSocket();\r\n}\r\n\r\n/**\r\n * Check if the pipeline is currently connected.\r\n */\r\nexport function isPipelineConnected(): boolean {\r\n  return webSocket !== null && webSocket.readyState === WebSocket.OPEN;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\StorageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\UserService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\App.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nF:\\Group Guard scratch\\src\\App.tsx:121:24\n  119 |     // Check roaming mode first\n  120 |     if (isRoamingMode) {\n> 121 |       if (!isLiveMode) setIsLiveMode(true);\n      |                        ^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  122 |       return;\n  123 |     }\n  124 |","line":121,"column":24,"nodeType":null,"endLine":121,"endColumn":37},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nF:\\Group Guard scratch\\src\\App.tsx:210:35\n  208 |   useEffect(() => {\n  209 |     if (isRoamingMode) {\n> 210 |       if (currentView !== 'live') setCurrentView('live');\n      |                                   ^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  211 |     } else if (currentView === 'live' && !selectedGroup) {\n  212 |         // If we exited roaming mode and have no group, go back to main\n  213 |         setCurrentView('main');","line":210,"column":35,"nodeType":null,"endLine":210,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useMemo, useCallback, lazy, Suspense } from 'react';\nimport { AppLayout } from './components/layout/AppLayout';\nimport { TitleBar } from './components/layout/TitleBar';\nimport { GlobalModals } from './components/layout/GlobalModals';\nimport { LoginView } from './features/auth/LoginView';\nimport { useAuthStore } from './stores/authStore';\nimport { useGroupStore } from './stores/groupStore';\nimport { GlassPanel } from './components/ui/GlassPanel';\nimport { motion } from 'framer-motion';\nimport { NeonDock, type DockView } from './components/layout/NeonDock';\nimport { usePipelineInit } from './hooks/usePipelineInit';\nimport { useInstanceMonitorInit } from './hooks/useInstanceMonitorInit';\nimport { SetupView } from './features/setup/SetupView';\n\nimport { AnimatePresence } from 'framer-motion';\nimport { PageTransition } from './components/layout/PageTransition';\n\n// Lazy load heavy views for better performance\nconst DashboardView = lazy(() => import('./features/dashboard/DashboardView').then(m => ({ default: m.DashboardView })));\n\nconst GroupSelectionView = lazy(() => import('./features/groups/GroupSelectionView').then(m => ({ default: m.GroupSelectionView })));\nconst SettingsView = lazy(() => import('./features/settings/SettingsView').then(m => ({ default: m.SettingsView })));\nconst DatabaseView = lazy(() => import('./features/database/DatabaseView').then(m => ({ default: m.DatabaseView })));\nconst AutoModView = lazy(() => import('./features/automod/AutoModView').then(m => ({ default: m.AutoModView })));\nconst LiveView = lazy(() => import('./features/live/LiveView').then(m => ({ default: m.LiveView })));\n\n// Simple loading fallback\nconst ViewLoader = () => (\n  <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%', minHeight: '200px' }}>\n    <div style={{ width: 32, height: 32, border: '3px solid var(--border-color)', borderTopColor: 'var(--color-primary)', borderRadius: '50%', animation: 'spin 1s linear infinite' }} />\n    <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>\n  </div>\n);\n\n// Loading screen component for auto-login\nconst AutoLoginLoadingScreen: React.FC = () => (\n  <div style={{ \n    display: 'flex', \n    justifyContent: 'center', \n    alignItems: 'center', \n    height: '100vh',\n    background: 'radial-gradient(circle at center, hsla(var(--primary-hue), 50%, 10%, 0.4) 0%, var(--color-bg-app) 100%)'\n  }}>\n    <GlassPanel style={{ \n      width: '400px', \n      display: 'flex', \n      flexDirection: 'column', \n      gap: '1.5rem',\n      alignItems: 'center',\n      padding: '3rem'\n    }}>\n      <div style={{ textAlign: 'center' }}>\n        <div style={{ fontSize: '1rem', color: 'var(--color-primary)', letterSpacing: '0.2em', fontWeight: 600, marginBottom: '-0.3rem' }}>VRCHAT</div>\n        <h1 className=\"text-gradient\" style={{ fontSize: '2rem', fontWeight: 800, margin: 0 }}>\n          GROUP GUARD\n        </h1>\n      </div>\n      \n      {/* Animated loading spinner */}\n      <motion.div\n        animate={{ rotate: 360 }}\n        transition={{ duration: 1.5, repeat: Infinity, ease: 'linear' }}\n        style={{\n          width: '48px',\n          height: '48px',\n          borderRadius: '50%',\n          border: '3px solid var(--border-color)',\n          borderTopColor: 'var(--color-primary)',\n        }}\n      />\n      \n      <p style={{ color: 'var(--color-text-dim)', textAlign: 'center' }}>\n        Signing you in automatically...\n      </p>\n    </GlassPanel>\n  </div>\n);\n\nfunction App() {\n  const { isAuthenticated, autoLogin, status, logout } = useAuthStore();\n  const { selectedGroup, selectGroup, isRoamingMode } = useGroupStore();\n  const [isCheckingAutoLogin, setIsCheckingAutoLogin] = useState(true);\n  const [isStorageConfigured, setIsStorageConfigured] = useState<boolean | null>(null);\n  const [currentView, setCurrentView] = useState<DockView>('main');\n  const [isLogoutConfirmOpen, setIsLogoutConfirmOpen] = useState(false);\n  const [isLiveMode, setIsLiveMode] = useState(false); // Track if VRC is running basically\n\n  // Initialize Pipeline WebSocket connection and event subscriptions\n  usePipelineInit();\n  \n  // Initialize Live Log Watcher\n  useInstanceMonitorInit(isAuthenticated);\n\n  const [isUpdateReady, setIsUpdateReady] = useState(false);\n\n  // Listen for updates\n  useEffect(() => {\n    // Return unsubscribe function\n    // Listen for updates if updater API is available\n    if (window.electron?.updater) {\n      // Check initial status (in case we missed the event)\n      window.electron.updater.checkStatus().then(downloaded => {\n          if (downloaded) {\n              console.log('Update already downloaded (found via status check)');\n              setIsUpdateReady(true);\n          }\n      });\n\n      const unsubscribe = window.electron.updater.onUpdateDownloaded(() => {\n        console.log('Update downloaded event received');\n        setIsUpdateReady(true);\n      });\n      return unsubscribe;\n    }\n  }, []);\n\n  // Monitor Live Log state to toggle Live Mode UI\n  useEffect(() => {\n    // Check roaming mode first\n    if (isRoamingMode) {\n      if (!isLiveMode) setIsLiveMode(true);\n      return;\n    }\n\n    // 1. Initial check\n    const checkStatus = async () => {\n        if (!selectedGroup) {\n            setIsLiveMode(false);\n            return;\n        }\n        \n        try {\n            const currentInstanceGroupId = await window.electron.instance.getCurrentGroup();\n            setIsLiveMode(currentInstanceGroupId === selectedGroup.id);\n        } catch (e) {\n            console.error(\"Failed to check live status:\", e);\n        }\n    };\n    checkStatus();\n\n    // 2. Listen for changes\n    if (!window.electron?.instance?.onGroupChanged) return;\n\n    const unsubscribe = window.electron.instance.onGroupChanged((groupId) => {\n        if (!selectedGroup) {\n            setIsLiveMode(false);\n        } else {\n            setIsLiveMode(groupId === selectedGroup.id);\n        }\n    });\n\n    return () => {\n        unsubscribe();\n    };\n  }, [selectedGroup, isRoamingMode, isLiveMode]);\n\n  // Check storage configuration first\n  useEffect(() => {\n    const checkStorage = async () => {\n      try {\n        const status = await window.electron.storage.getStatus();\n        setIsStorageConfigured(status.configured);\n      } catch (err) {\n        console.error('Failed to check storage status:', err);\n        // Fallback to true to avoid blocking app if something weird happens, \n        // though this ideally shouldn't happen with the new service.\n        setIsStorageConfigured(true); \n      }\n    };\n    checkStorage();\n  }, []);\n\n  // Attempt auto-login only after storage is confirmed\n  useEffect(() => {\n    if (isStorageConfigured === false || isStorageConfigured === null) {\n        return;\n    }\n\n    const attemptAutoLogin = async () => {\n      setIsCheckingAutoLogin(true);\n      try {\n        // Check if we have saved credentials and attempt auto-login\n        const hasSaved = await window.electron.hasSavedCredentials();\n        if (hasSaved) {\n          console.log('Found saved credentials, attempting auto-login...');\n          const result = await autoLogin();\n          if (result.success) {\n            console.log('Auto-login successful!');\n          } else if (result.requires2FA) {\n            console.log('Auto-login requires 2FA verification');\n            // User will need to enter 2FA code - this is expected behavior\n          } else {\n            console.log('Auto-login failed, showing login screen');\n          }\n        } else {\n          console.log('No saved credentials found');\n        }\n      } catch (err) {\n        console.error('Auto-login error:', err);\n      }\n      setIsCheckingAutoLogin(false);\n    };\n    \n    attemptAutoLogin();\n  }, [autoLogin, isStorageConfigured]);\n\n  // Auto-switch to Live View when entering Roaming Mode\n  useEffect(() => {\n    if (isRoamingMode) {\n      if (currentView !== 'live') setCurrentView('live');\n    } else if (currentView === 'live' && !selectedGroup) {\n        // If we exited roaming mode and have no group, go back to main\n        setCurrentView('main');\n    }\n  }, [isRoamingMode, selectedGroup, currentView]);\n\n  // Handle View Switching - memoized to prevent re-renders\n  const handleViewChange = useCallback((view: DockView) => {\n    // Exceptions for Live view in Roaming Mode\n    if (view === 'live' && (isRoamingMode || selectedGroup)) {\n        setCurrentView('live');\n        return;\n    }\n\n    if ((view === 'moderation' || view === 'audit' || view === 'database' || view === 'live') && !selectedGroup) {\n      // If trying to access group features without a group, go to group selection\n      selectGroup(null);\n      setCurrentView('main');\n      return;\n    }\n    setCurrentView(view);\n  }, [selectedGroup, selectGroup, isRoamingMode]);\n\n  // Memoize content to prevent re-renders during transitions\n  const content = useMemo(() => {\n    switch (currentView) {\n      case 'settings':\n        return <SettingsView />;\n      case 'moderation':\n        return <AutoModView />;\n      case 'live':\n        return <LiveView />;\n      case 'audit':\n        return (\n            <GlassPanel style={{ padding: '2rem', textAlign: 'center' }}>\n                <h2>Audit Logs</h2>\n                <p style={{ color: 'var(--color-text-dim)' }}>Coming Soon</p>\n            </GlassPanel>\n        );\n      case 'database':\n        return <DatabaseView />;\n      case 'main':\n      default:\n        return selectedGroup ? <DashboardView /> : <GroupSelectionView />;\n    }\n  }, [currentView, selectedGroup]);\n\n  // --- Unified Render Logic for Epic Transitions ---\n  let currentScreen: React.ReactNode;\n  let screenKey: string;\n\n  if (isStorageConfigured === null) {\n      currentScreen = <AutoLoginLoadingScreen />;\n      screenKey = 'loading-storage';\n  } else if (isStorageConfigured === false) {\n      currentScreen = <SetupView onComplete={() => setIsStorageConfigured(true)} />;\n      screenKey = 'setup';\n  } else if ((isCheckingAutoLogin && status === 'logging-in')) {\n      currentScreen = <AutoLoginLoadingScreen />;\n      screenKey = 'loading-autologin';\n  } else if (!isAuthenticated) {\n      currentScreen = <LoginView />;\n      screenKey = 'login';\n  } else {\n      // Main Authenticated App\n      currentScreen = (\n        <AppLayout>\n          <TitleBar \n            onSettingsClick={() => setCurrentView('settings')}\n            onLogoutClick={() => setIsLogoutConfirmOpen(true)}\n          />\n\n          {/* Main Content Render - Epic Transition */}\n          <AnimatePresence mode=\"wait\">\n            <PageTransition key={currentView + (selectedGroup ? selectedGroup.id : 'home')}>\n              <Suspense fallback={<ViewLoader />}>\n                {content}\n              </Suspense>\n            </PageTransition>\n          </AnimatePresence>\n\n          {/* Neon Dock Navigation */}\n          <NeonDock \n            currentView={currentView}\n            onViewChange={handleViewChange}\n            selectedGroup={selectedGroup}\n            onGroupClick={() => {\n                selectGroup(null);\n                setCurrentView('main');\n            }}\n            isLiveMode={isLiveMode}\n          />\n          \n          <GlobalModals \n            isLogoutConfirmOpen={isLogoutConfirmOpen}\n            setIsLogoutConfirmOpen={setIsLogoutConfirmOpen}\n            onLogoutConfirm={() => {\n                logout(false);\n                setIsLogoutConfirmOpen(false);\n            }}\n            isUpdateReady={isUpdateReady}\n          />\n        </AppLayout>\n      );\n      screenKey = 'app-layout';\n  }\n\n  return (\n    <AnimatePresence mode=\"wait\">\n        <PageTransition key={screenKey}>\n            {currentScreen}\n        </PageTransition>\n    </AnimatePresence>\n  );\n}\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\AppLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\GlobalModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\NeonDock.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\PageTransition.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\ParticleBackground.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\TitleBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\GlassPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\LiveBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\Modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\NeonButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\PipelineStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\RefreshTimer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\constants\\app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\context\\ThemeContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":59,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":59,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useEffect, useState } from 'react';\r\n\r\n// Define the shape of our Theme State\r\ninterface ThemeState {\r\n  primaryHue: number;\r\n  setPrimaryHue: (hue: number) => void;\r\n  accentHue: number;\r\n  setAccentHue: (hue: number) => void;\r\n  glassBlur: number;\r\n  setGlassBlur: (px: number) => void;\r\n  resetTheme: () => void;\r\n}\r\n\r\nconst ThemeContext = createContext<ThemeState | undefined>(undefined);\r\n\r\nexport const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  // Initialize from LocalStorage or Default\r\n  const [primaryHue, setPrimaryHue] = useState<number>(() => parseInt(localStorage.getItem('primaryHue') || '270'));\r\n  const [accentHue, setAccentHue] = useState<number>(() => parseInt(localStorage.getItem('accentHue') || '180'));\r\n  const [glassBlur, setGlassBlur] = useState<number>(() => parseInt(localStorage.getItem('glassBlur') || '20'));\r\n\r\n  // Sync state to CSS Variables\r\n  useEffect(() => {\r\n    const root = document.documentElement;\r\n    root.style.setProperty('--primary-hue', primaryHue.toString());\r\n    localStorage.setItem('primaryHue', primaryHue.toString());\r\n  }, [primaryHue]);\r\n\r\n  useEffect(() => {\r\n    const root = document.documentElement;\r\n    root.style.setProperty('--accent-hue', accentHue.toString());\r\n    localStorage.setItem('accentHue', accentHue.toString());\r\n  }, [accentHue]);\r\n\r\n  useEffect(() => {\r\n    const root = document.documentElement;\r\n    root.style.setProperty('--glass-blur', `${glassBlur}px`);\r\n    localStorage.setItem('glassBlur', glassBlur.toString());\r\n  }, [glassBlur]);\r\n\r\n  const resetTheme = () => {\r\n    setPrimaryHue(270);\r\n    setAccentHue(180);\r\n    setGlassBlur(20);\r\n  };\r\n\r\n  return (\r\n    <ThemeContext.Provider value={{ \r\n      primaryHue, setPrimaryHue, \r\n      accentHue, setAccentHue,\r\n      glassBlur, setGlassBlur,\r\n      resetTheme \r\n    }}>\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useTheme = () => {\r\n  const context = useContext(ThemeContext);\r\n  if (!context) {\r\n    throw new Error('useTheme must be used within a ThemeProvider');\r\n  }\r\n  return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\auth\\LoginView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\auth\\UserProfileWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\automod\\AutoModView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\automod\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\DashboardView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\components\\StatTile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\BansListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\InstancesListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\MembersListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\RequestsListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\UserProfileDialog.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nF:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\UserProfileDialog.tsx:15:13\n  13 |     useEffect(() => {\n  14 |         if (isOpen && userId) {\n> 15 |             setLoading(true);\n     |             ^^^^^^^^^^ Avoid calling setState() directly within an effect\n  16 |             setError(null);\n  17 |             setUser(null);\n  18 |             ","line":15,"column":13,"nodeType":null,"endLine":15,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\nimport { Modal } from '../../../components/ui/Modal';\r\nimport { GlassPanel } from '../../../components/ui/GlassPanel';\r\nimport { useUserProfileStore } from '../../../stores/userProfileStore';\r\nimport type { VRChatUser } from '../../../types/electron';\r\n\r\nexport const UserProfileDialog: React.FC = () => {\r\n    const { isOpen, userId, closeProfile } = useUserProfileStore();\r\n    const [user, setUser] = useState<VRChatUser | null>(null);\r\n    const [loading, setLoading] = useState(false);\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    useEffect(() => {\r\n        if (isOpen && userId) {\r\n            setLoading(true);\r\n            setError(null);\r\n            setUser(null);\r\n            \r\n            window.electron.getUser(userId)\r\n                .then(res => {\r\n                    if (res.success && res.user) {\r\n                        setUser(res.user);\r\n                    } else {\r\n                        setError(res.error || 'Failed to load user');\r\n                    }\r\n                })\r\n                .catch(err => setError(String(err)))\r\n                .finally(() => setLoading(false));\r\n        }\r\n    }, [isOpen, userId]);\r\n\r\n    if (!isOpen) return null;\r\n\r\n    const getStatusColor = (status?: string) => {\r\n        switch (status) {\r\n            case 'active': return '#5cc9f5'; // Blue\r\n            case 'join me': return '#42b983'; // Blue-ish\r\n            case 'busy': return '#ab1a1a'; // Red\r\n            default: return '#888';\r\n        }\r\n    };\r\n    \r\n    // Status text (VRChat \"status\" is often \"active\", \"join me\", etc. \"state\" is offline/online?)\r\n    // Actually VRChat API is a bit complex here. statusDescription is the custom text.\r\n    // status is \"active\", \"join me\", \"ask me\", \"busy\", \"offline\".\r\n\r\n    return (\r\n        <Modal \r\n            isOpen={isOpen} \r\n            onClose={closeProfile} \r\n            title={user?.displayName || 'User Profile'}\r\n            width=\"600px\"\r\n        >\r\n            {loading ? (\r\n                <div style={{ padding: '40px', textAlign: 'center', color: '#888' }}>\r\n                    Loading profile...\r\n                </div>\r\n            ) : error ? (\r\n                <div style={{ padding: '20px', textAlign: 'center', color: '#ff4444' }}>\r\n                    {error}\r\n                </div>\r\n            ) : user ? (\r\n                <div style={{ padding: '10px' }}>\r\n                    {/* Header: Avatar & Basic Info */}\r\n                    <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>\r\n                        <div style={{ position: 'relative' }}>\r\n                            <img \r\n                                src={user.profilePicOverride || user.currentAvatarImageUrl || user.userIcon} \r\n                                alt={user.displayName}\r\n                                style={{ \r\n                                    width: '120px', \r\n                                    height: '120px', \r\n                                    borderRadius: '12px', \r\n                                    objectFit: 'cover',\r\n                                    border: `2px solid ${getStatusColor(user.status)}`\r\n                                }} \r\n                            />\r\n                            <div style={{ position: 'absolute', bottom: '-10px', right: '-10px', display: 'flex', alignItems: 'center', gap: '5px' }}>\r\n                                {/* Age Verified Badge */}\r\n                                {(user.ageVerified || user.tags?.includes('system_age_verified')) && (\r\n                                    <div style={{\r\n                                        background: '#fbbf24', // Amber/Gold\r\n                                        color: '#000',\r\n                                        padding: '2px 6px',\r\n                                        borderRadius: '8px',\r\n                                        fontSize: '0.75rem',\r\n                                        fontWeight: '800',\r\n                                        border: '2px solid rgba(0,0,0,0.5)'\r\n                                    }}>\r\n                                        18+\r\n                                    </div>\r\n                                )}\r\n                                \r\n                                <div style={{\r\n                                    background: getStatusColor(user.status),\r\n                                    color: 'white',\r\n                                    padding: '2px 8px',\r\n                                    borderRadius: '10px',\r\n                                    fontSize: '0.8rem',\r\n                                    fontWeight: 'bold',\r\n                                    border: '2px solid #1a1b1e' // Match background? Or dark border\r\n                                }}>\r\n                                    {user.status || 'Offline'}\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        \r\n                        <div style={{ flex: 1 }}>\r\n                            <h2 style={{ margin: '0 0 5px 0', fontSize: '1.8rem', color: '#fff' }}>\r\n                                {user.displayName}\r\n                            </h2>\r\n                            <div style={{ color: '#aaa', fontSize: '0.9rem', marginBottom: '10px' }}>\r\n                                {user.statusDescription}\r\n                            </div>\r\n                            \r\n                            <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                                {user.tags?.map(tag => (\r\n                                    <span key={tag} style={{ \r\n                                        background: 'rgba(255,255,255,0.1)', \r\n                                        padding: '2px 8px', \r\n                                        borderRadius: '4px',\r\n                                        fontSize: '0.8rem',\r\n                                        color: '#ccc'\r\n                                    }}>\r\n                                        {tag.replace('system_', '').replace(/_/g, ' ')}\r\n                                    </span>\r\n                                ))}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                    {/* Bio */}\r\n                    <GlassPanel style={{ padding: '15px', marginBottom: '15px' }}>\r\n                        <h4 style={{ marginTop: 0, color: '#888', textTransform: 'uppercase', fontSize: '0.8rem' }}>Bio</h4>\r\n                        <div style={{ whiteSpace: 'pre-wrap', lineHeight: '1.5', color: '#eee' }}>\r\n                            {user.bio || 'No bio available.'}\r\n                        </div>\r\n                        \r\n                        {user.bioLinks && user.bioLinks.length > 0 && (\r\n                            <div style={{ marginTop: '10px', display: 'flex', flexWrap: 'wrap', gap: '10px' }}>\r\n                                {user.bioLinks.map(link => (\r\n                                    <a  key={link} \r\n                                        href={link} \r\n                                        target=\"_blank\" \r\n                                        rel=\"noopener noreferrer\"\r\n                                        style={{ color: '#5cc9f5', textDecoration: 'none', fontSize: '0.9rem' }}\r\n                                    >\r\n                                        {link}\r\n                                    </a>\r\n                                ))}\r\n                            </div>\r\n                        )}\r\n                    </GlassPanel>\r\n\r\n                    {/* Details Grid */}\r\n                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>\r\n                        <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Last Login</div>\r\n                            <div>{user.last_login ? new Date(user.last_login).toLocaleDateString() : 'Unknown'}</div>\r\n                        </GlassPanel>\r\n                        <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Date Joined</div>\r\n                            <div>{user.date_joined ? new Date(user.date_joined).toLocaleDateString() : 'Unknown'}</div>\r\n                        </GlassPanel>\r\n                        <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Trust Rank</div>\r\n                            <div>{getTrustRank(user.tags)}</div>\r\n                        </GlassPanel>\r\n                         <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Location</div>\r\n                            <div>{user.location || user.state || 'Unknown'}</div>\r\n                        </GlassPanel>\r\n                    </div>\r\n\r\n                </div>\r\n            ) : null}\r\n        </Modal>\r\n    );\r\n};\r\n\r\n// Helper to deduce rank from tags because VRChat API doesn't send \"trustRank\" field directly typically, \r\n// unless we inspect tags like 'system_trust_veteran'.\r\nfunction getTrustRank(tags: string[] = []): string {\r\n    if (tags.includes('system_trust_legend')) return 'Legendary';\r\n    if (tags.includes('system_trust_veteran')) return 'Veteran';\r\n    if (tags.includes('system_trust_trusted')) return 'Trusted';\r\n    if (tags.includes('system_trust_known')) return 'Known';\r\n    if (tags.includes('system_trust_basic')) return 'User';\r\n    if (tags.includes('system_probation')) return 'Visitor (Probation)'; // or similar\r\n    // Default fallback\r\n    return 'Visitor'; \r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\widgets\\InstanceMonitorWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\database\\DatabaseView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\groups\\GroupSelectionView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\live\\LiveView.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6260,6263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6260,6263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\live\\dialogs\\BanUserDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\settings\\SettingsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\setup\\SetupView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\useDataRefresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\useInstanceAutoRefresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\useInstanceMonitorInit.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1667,1670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1667,1670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2168,2171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2168,2171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2202,2205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2202,2205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { useEffect, useRef } from 'react';\r\nimport { useInstanceMonitorStore, type LivePlayerInfo } from '../stores/instanceMonitorStore';\r\nimport { useGroupStore } from '../stores/groupStore';\r\n\r\nexport function useInstanceMonitorInit(isAuthenticated: boolean) {\r\n  const { addPlayer, removePlayer, setWorldId, setInstanceInfo, setWorldName, setInstanceImage, clearInstance, clearLiveScan } = useInstanceMonitorStore();\r\n  const { isRoamingMode } = useGroupStore();\r\n\r\n  // Clear live scan history when exiting roaming mode\r\n  const prevRoamingRef = useRef(isRoamingMode);\r\n  useEffect(() => {\r\n    if (prevRoamingRef.current && !isRoamingMode) {\r\n        clearLiveScan();\r\n    }\r\n    prevRoamingRef.current = isRoamingMode;\r\n  }, [isRoamingMode, clearLiveScan]);\r\n\r\n  useEffect(() => {\r\n    if (!isAuthenticated) return;\r\n\r\n    console.log('[InstanceMonitor] Initializing Log Watcher...');\r\n    // Start watching logs\r\n    window.electron.logWatcher.start();\r\n\r\n    // Setup event listeners\r\n    const cleanupJoined = window.electron.logWatcher.onPlayerJoined((event) => {\r\n      const player: LivePlayerInfo = {\r\n        displayName: event.displayName,\r\n        userId: event.userId,\r\n        joinTime: new Date(event.timestamp).getTime()\r\n      };\r\n      addPlayer(player);\r\n    });\r\n\r\n    const cleanupLeft = window.electron.logWatcher.onPlayerLeft((event) => {\r\n      removePlayer(event.displayName);\r\n    });\r\n\r\n    const cleanupLocation = window.electron.logWatcher.onLocation(async (event) => {\r\n      // New location detected, clear previous instance data\r\n      clearInstance();\r\n      setWorldId(event.worldId);\r\n      \r\n      const eventAny = event as any;\r\n      if (eventAny.instanceId && eventAny.location) {\r\n          setInstanceInfo(eventAny.instanceId, eventAny.location);\r\n      }\r\n      \r\n      // Fetch world details if we can (to fix \"Unknown World\")\r\n      try {\r\n        const result = await window.electron.getWorld(event.worldId);\r\n        if (result.success && result.world) {\r\n            setWorldName(result.world.name);\r\n            // Assuming world object has imageUrl or thumbnailImageUrl\r\n            const img = (result.world as any).imageUrl || (result.world as any).thumbnailImageUrl;\r\n            if (img) setInstanceImage(img);\r\n        }\r\n      } catch (e) {\r\n        console.error('Failed to fetch world name', e);\r\n      }\r\n    });\r\n\r\n    const cleanupWorldName = window.electron.logWatcher.onWorldName((event) => {\r\n      setWorldName(event.name);\r\n    });\r\n\r\n    return () => {\r\n      cleanupJoined();\r\n      cleanupLeft();\r\n      cleanupLocation();\r\n      cleanupWorldName();\r\n      window.electron.logWatcher.stop();\r\n    };\r\n\r\n  }, [isAuthenticated, addPlayer, removePlayer, setWorldId, setWorldName, clearInstance, setInstanceInfo, setInstanceImage]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\usePipelineInit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\auditStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\authStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\groupStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\instanceMonitorStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\pipelineStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\uiStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\userProfileStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\types\\electron.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
