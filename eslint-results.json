[{"filePath":"F:\\Group Guard scratch\\debug-vrchat-lib-2.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\debug-vrchat-lib.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\debug-vrchat-lib.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\debug-vrchat.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\debug_lib.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\dist-electron\\main.cjs","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":3548,"column":7,"severity":1,"nodeType":null,"fix":{"range":[118589,118616],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'max-len').","line":6462,"column":9,"severity":1,"nodeType":null,"fix":{"range":[218391,218419],"text":" "}},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":13763,"column":7,"endLine":13763,"endColumn":68,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":13766,"column":7,"endLine":13766,"endColumn":68,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":13769,"column":7,"endLine":13769,"endColumn":68,"severity":2,"nodeType":null},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-unused-vars').","line":15767,"column":9,"severity":1,"nodeType":null,"fix":{"range":[578756,578793],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-unused-vars').","line":15769,"column":9,"severity":1,"nodeType":null,"fix":{"range":[578839,578876],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-unused-vars').","line":15771,"column":9,"severity":1,"nodeType":null,"fix":{"range":[578916,578953],"text":" "}},{"ruleId":"@typescript-eslint/unbound-method","message":"Definition for rule '@typescript-eslint/unbound-method' was not found.","line":19967,"column":9,"endLine":19967,"endColumn":70,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/unbound-method","message":"Definition for rule '@typescript-eslint/unbound-method' was not found.","line":26577,"column":9,"endLine":26577,"endColumn":70,"severity":2,"nodeType":null},{"ruleId":"@stylistic/max-len","message":"Definition for rule '@stylistic/max-len' was not found.","line":37490,"column":7,"endLine":37490,"endColumn":53,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":39119,"column":7,"endLine":39119,"endColumn":69,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":39131,"column":7,"endLine":39131,"endColumn":69,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// node_modules/electron-updater/node_modules/universalify/index.js\nvar require_universalify = __commonJS({\n  \"node_modules/electron-updater/node_modules/universalify/index.js\"(exports2) {\n    \"use strict\";\n    exports2.fromCallback = function(fn) {\n      return Object.defineProperty(function(...args) {\n        if (typeof args[args.length - 1] === \"function\") fn.apply(this, args);\n        else {\n          return new Promise((resolve, reject) => {\n            args.push((err, res) => err != null ? reject(err) : resolve(res));\n            fn.apply(this, args);\n          });\n        }\n      }, \"name\", { value: fn.name });\n    };\n    exports2.fromPromise = function(fn) {\n      return Object.defineProperty(function(...args) {\n        const cb = args[args.length - 1];\n        if (typeof cb !== \"function\") return fn.apply(this, args);\n        else {\n          args.pop();\n          fn.apply(this, args).then((r) => cb(null, r), cb);\n        }\n      }, \"name\", { value: fn.name });\n    };\n  }\n});\n\n// node_modules/graceful-fs/polyfills.js\nvar require_polyfills = __commonJS({\n  \"node_modules/graceful-fs/polyfills.js\"(exports2, module2) {\n    var constants = require(\"constants\");\n    var origCwd = process.cwd;\n    var cwd = null;\n    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;\n    process.cwd = function() {\n      if (!cwd)\n        cwd = origCwd.call(process);\n      return cwd;\n    };\n    try {\n      process.cwd();\n    } catch (er) {\n    }\n    if (typeof process.chdir === \"function\") {\n      chdir = process.chdir;\n      process.chdir = function(d) {\n        cwd = null;\n        chdir.call(process, d);\n      };\n      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);\n    }\n    var chdir;\n    module2.exports = patch;\n    function patch(fs4) {\n      if (constants.hasOwnProperty(\"O_SYMLINK\") && process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n        patchLchmod(fs4);\n      }\n      if (!fs4.lutimes) {\n        patchLutimes(fs4);\n      }\n      fs4.chown = chownFix(fs4.chown);\n      fs4.fchown = chownFix(fs4.fchown);\n      fs4.lchown = chownFix(fs4.lchown);\n      fs4.chmod = chmodFix(fs4.chmod);\n      fs4.fchmod = chmodFix(fs4.fchmod);\n      fs4.lchmod = chmodFix(fs4.lchmod);\n      fs4.chownSync = chownFixSync(fs4.chownSync);\n      fs4.fchownSync = chownFixSync(fs4.fchownSync);\n      fs4.lchownSync = chownFixSync(fs4.lchownSync);\n      fs4.chmodSync = chmodFixSync(fs4.chmodSync);\n      fs4.fchmodSync = chmodFixSync(fs4.fchmodSync);\n      fs4.lchmodSync = chmodFixSync(fs4.lchmodSync);\n      fs4.stat = statFix(fs4.stat);\n      fs4.fstat = statFix(fs4.fstat);\n      fs4.lstat = statFix(fs4.lstat);\n      fs4.statSync = statFixSync(fs4.statSync);\n      fs4.fstatSync = statFixSync(fs4.fstatSync);\n      fs4.lstatSync = statFixSync(fs4.lstatSync);\n      if (fs4.chmod && !fs4.lchmod) {\n        fs4.lchmod = function(path6, mode, cb) {\n          if (cb) process.nextTick(cb);\n        };\n        fs4.lchmodSync = function() {\n        };\n      }\n      if (fs4.chown && !fs4.lchown) {\n        fs4.lchown = function(path6, uid, gid, cb) {\n          if (cb) process.nextTick(cb);\n        };\n        fs4.lchownSync = function() {\n        };\n      }\n      if (platform === \"win32\") {\n        fs4.rename = typeof fs4.rename !== \"function\" ? fs4.rename : (function(fs$rename) {\n          function rename(from, to, cb) {\n            var start = Date.now();\n            var backoff = 0;\n            fs$rename(from, to, function CB(er) {\n              if (er && (er.code === \"EACCES\" || er.code === \"EPERM\" || er.code === \"EBUSY\") && Date.now() - start < 6e4) {\n                setTimeout(function() {\n                  fs4.stat(to, function(stater, st) {\n                    if (stater && stater.code === \"ENOENT\")\n                      fs$rename(from, to, CB);\n                    else\n                      cb(er);\n                  });\n                }, backoff);\n                if (backoff < 100)\n                  backoff += 10;\n                return;\n              }\n              if (cb) cb(er);\n            });\n          }\n          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);\n          return rename;\n        })(fs4.rename);\n      }\n      fs4.read = typeof fs4.read !== \"function\" ? fs4.read : (function(fs$read) {\n        function read(fd, buffer, offset, length, position, callback_) {\n          var callback;\n          if (callback_ && typeof callback_ === \"function\") {\n            var eagCounter = 0;\n            callback = function(er, _, __) {\n              if (er && er.code === \"EAGAIN\" && eagCounter < 10) {\n                eagCounter++;\n                return fs$read.call(fs4, fd, buffer, offset, length, position, callback);\n              }\n              callback_.apply(this, arguments);\n            };\n          }\n          return fs$read.call(fs4, fd, buffer, offset, length, position, callback);\n        }\n        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);\n        return read;\n      })(fs4.read);\n      fs4.readSync = typeof fs4.readSync !== \"function\" ? fs4.readSync : /* @__PURE__ */ (function(fs$readSync) {\n        return function(fd, buffer, offset, length, position) {\n          var eagCounter = 0;\n          while (true) {\n            try {\n              return fs$readSync.call(fs4, fd, buffer, offset, length, position);\n            } catch (er) {\n              if (er.code === \"EAGAIN\" && eagCounter < 10) {\n                eagCounter++;\n                continue;\n              }\n              throw er;\n            }\n          }\n        };\n      })(fs4.readSync);\n      function patchLchmod(fs5) {\n        fs5.lchmod = function(path6, mode, callback) {\n          fs5.open(\n            path6,\n            constants.O_WRONLY | constants.O_SYMLINK,\n            mode,\n            function(err, fd) {\n              if (err) {\n                if (callback) callback(err);\n                return;\n              }\n              fs5.fchmod(fd, mode, function(err2) {\n                fs5.close(fd, function(err22) {\n                  if (callback) callback(err2 || err22);\n                });\n              });\n            }\n          );\n        };\n        fs5.lchmodSync = function(path6, mode) {\n          var fd = fs5.openSync(path6, constants.O_WRONLY | constants.O_SYMLINK, mode);\n          var threw = true;\n          var ret;\n          try {\n            ret = fs5.fchmodSync(fd, mode);\n            threw = false;\n          } finally {\n            if (threw) {\n              try {\n                fs5.closeSync(fd);\n              } catch (er) {\n              }\n            } else {\n              fs5.closeSync(fd);\n            }\n          }\n          return ret;\n        };\n      }\n      function patchLutimes(fs5) {\n        if (constants.hasOwnProperty(\"O_SYMLINK\") && fs5.futimes) {\n          fs5.lutimes = function(path6, at, mt, cb) {\n            fs5.open(path6, constants.O_SYMLINK, function(er, fd) {\n              if (er) {\n                if (cb) cb(er);\n                return;\n              }\n              fs5.futimes(fd, at, mt, function(er2) {\n                fs5.close(fd, function(er22) {\n                  if (cb) cb(er2 || er22);\n                });\n              });\n            });\n          };\n          fs5.lutimesSync = function(path6, at, mt) {\n            var fd = fs5.openSync(path6, constants.O_SYMLINK);\n            var ret;\n            var threw = true;\n            try {\n              ret = fs5.futimesSync(fd, at, mt);\n              threw = false;\n            } finally {\n              if (threw) {\n                try {\n                  fs5.closeSync(fd);\n                } catch (er) {\n                }\n              } else {\n                fs5.closeSync(fd);\n              }\n            }\n            return ret;\n          };\n        } else if (fs5.futimes) {\n          fs5.lutimes = function(_a, _b, _c, cb) {\n            if (cb) process.nextTick(cb);\n          };\n          fs5.lutimesSync = function() {\n          };\n        }\n      }\n      function chmodFix(orig) {\n        if (!orig) return orig;\n        return function(target, mode, cb) {\n          return orig.call(fs4, target, mode, function(er) {\n            if (chownErOk(er)) er = null;\n            if (cb) cb.apply(this, arguments);\n          });\n        };\n      }\n      function chmodFixSync(orig) {\n        if (!orig) return orig;\n        return function(target, mode) {\n          try {\n            return orig.call(fs4, target, mode);\n          } catch (er) {\n            if (!chownErOk(er)) throw er;\n          }\n        };\n      }\n      function chownFix(orig) {\n        if (!orig) return orig;\n        return function(target, uid, gid, cb) {\n          return orig.call(fs4, target, uid, gid, function(er) {\n            if (chownErOk(er)) er = null;\n            if (cb) cb.apply(this, arguments);\n          });\n        };\n      }\n      function chownFixSync(orig) {\n        if (!orig) return orig;\n        return function(target, uid, gid) {\n          try {\n            return orig.call(fs4, target, uid, gid);\n          } catch (er) {\n            if (!chownErOk(er)) throw er;\n          }\n        };\n      }\n      function statFix(orig) {\n        if (!orig) return orig;\n        return function(target, options, cb) {\n          if (typeof options === \"function\") {\n            cb = options;\n            options = null;\n          }\n          function callback(er, stats) {\n            if (stats) {\n              if (stats.uid < 0) stats.uid += 4294967296;\n              if (stats.gid < 0) stats.gid += 4294967296;\n            }\n            if (cb) cb.apply(this, arguments);\n          }\n          return options ? orig.call(fs4, target, options, callback) : orig.call(fs4, target, callback);\n        };\n      }\n      function statFixSync(orig) {\n        if (!orig) return orig;\n        return function(target, options) {\n          var stats = options ? orig.call(fs4, target, options) : orig.call(fs4, target);\n          if (stats) {\n            if (stats.uid < 0) stats.uid += 4294967296;\n            if (stats.gid < 0) stats.gid += 4294967296;\n          }\n          return stats;\n        };\n      }\n      function chownErOk(er) {\n        if (!er)\n          return true;\n        if (er.code === \"ENOSYS\")\n          return true;\n        var nonroot = !process.getuid || process.getuid() !== 0;\n        if (nonroot) {\n          if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n            return true;\n        }\n        return false;\n      }\n    }\n  }\n});\n\n// node_modules/graceful-fs/legacy-streams.js\nvar require_legacy_streams = __commonJS({\n  \"node_modules/graceful-fs/legacy-streams.js\"(exports2, module2) {\n    var Stream = require(\"stream\").Stream;\n    module2.exports = legacy;\n    function legacy(fs4) {\n      return {\n        ReadStream,\n        WriteStream\n      };\n      function ReadStream(path6, options) {\n        if (!(this instanceof ReadStream)) return new ReadStream(path6, options);\n        Stream.call(this);\n        var self2 = this;\n        this.path = path6;\n        this.fd = null;\n        this.readable = true;\n        this.paused = false;\n        this.flags = \"r\";\n        this.mode = 438;\n        this.bufferSize = 64 * 1024;\n        options = options || {};\n        var keys = Object.keys(options);\n        for (var index = 0, length = keys.length; index < length; index++) {\n          var key = keys[index];\n          this[key] = options[key];\n        }\n        if (this.encoding) this.setEncoding(this.encoding);\n        if (this.start !== void 0) {\n          if (\"number\" !== typeof this.start) {\n            throw TypeError(\"start must be a Number\");\n          }\n          if (this.end === void 0) {\n            this.end = Infinity;\n          } else if (\"number\" !== typeof this.end) {\n            throw TypeError(\"end must be a Number\");\n          }\n          if (this.start > this.end) {\n            throw new Error(\"start must be <= end\");\n          }\n          this.pos = this.start;\n        }\n        if (this.fd !== null) {\n          process.nextTick(function() {\n            self2._read();\n          });\n          return;\n        }\n        fs4.open(this.path, this.flags, this.mode, function(err, fd) {\n          if (err) {\n            self2.emit(\"error\", err);\n            self2.readable = false;\n            return;\n          }\n          self2.fd = fd;\n          self2.emit(\"open\", fd);\n          self2._read();\n        });\n      }\n      function WriteStream(path6, options) {\n        if (!(this instanceof WriteStream)) return new WriteStream(path6, options);\n        Stream.call(this);\n        this.path = path6;\n        this.fd = null;\n        this.writable = true;\n        this.flags = \"w\";\n        this.encoding = \"binary\";\n        this.mode = 438;\n        this.bytesWritten = 0;\n        options = options || {};\n        var keys = Object.keys(options);\n        for (var index = 0, length = keys.length; index < length; index++) {\n          var key = keys[index];\n          this[key] = options[key];\n        }\n        if (this.start !== void 0) {\n          if (\"number\" !== typeof this.start) {\n            throw TypeError(\"start must be a Number\");\n          }\n          if (this.start < 0) {\n            throw new Error(\"start must be >= zero\");\n          }\n          this.pos = this.start;\n        }\n        this.busy = false;\n        this._queue = [];\n        if (this.fd === null) {\n          this._open = fs4.open;\n          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);\n          this.flush();\n        }\n      }\n    }\n  }\n});\n\n// node_modules/graceful-fs/clone.js\nvar require_clone = __commonJS({\n  \"node_modules/graceful-fs/clone.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = clone;\n    var getPrototypeOf = Object.getPrototypeOf || function(obj) {\n      return obj.__proto__;\n    };\n    function clone(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return obj;\n      if (obj instanceof Object)\n        var copy = { __proto__: getPrototypeOf(obj) };\n      else\n        var copy = /* @__PURE__ */ Object.create(null);\n      Object.getOwnPropertyNames(obj).forEach(function(key) {\n        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));\n      });\n      return copy;\n    }\n  }\n});\n\n// node_modules/graceful-fs/graceful-fs.js\nvar require_graceful_fs = __commonJS({\n  \"node_modules/graceful-fs/graceful-fs.js\"(exports2, module2) {\n    var fs4 = require(\"fs\");\n    var polyfills = require_polyfills();\n    var legacy = require_legacy_streams();\n    var clone = require_clone();\n    var util = require(\"util\");\n    var gracefulQueue;\n    var previousSymbol;\n    if (typeof Symbol === \"function\" && typeof Symbol.for === \"function\") {\n      gracefulQueue = /* @__PURE__ */ Symbol.for(\"graceful-fs.queue\");\n      previousSymbol = /* @__PURE__ */ Symbol.for(\"graceful-fs.previous\");\n    } else {\n      gracefulQueue = \"___graceful-fs.queue\";\n      previousSymbol = \"___graceful-fs.previous\";\n    }\n    function noop() {\n    }\n    function publishQueue(context, queue2) {\n      Object.defineProperty(context, gracefulQueue, {\n        get: function() {\n          return queue2;\n        }\n      });\n    }\n    var debug = noop;\n    if (util.debuglog)\n      debug = util.debuglog(\"gfs4\");\n    else if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || \"\"))\n      debug = function() {\n        var m = util.format.apply(util, arguments);\n        m = \"GFS4: \" + m.split(/\\n/).join(\"\\nGFS4: \");\n        console.error(m);\n      };\n    if (!fs4[gracefulQueue]) {\n      queue = global[gracefulQueue] || [];\n      publishQueue(fs4, queue);\n      fs4.close = (function(fs$close) {\n        function close(fd, cb) {\n          return fs$close.call(fs4, fd, function(err) {\n            if (!err) {\n              resetQueue();\n            }\n            if (typeof cb === \"function\")\n              cb.apply(this, arguments);\n          });\n        }\n        Object.defineProperty(close, previousSymbol, {\n          value: fs$close\n        });\n        return close;\n      })(fs4.close);\n      fs4.closeSync = (function(fs$closeSync) {\n        function closeSync(fd) {\n          fs$closeSync.apply(fs4, arguments);\n          resetQueue();\n        }\n        Object.defineProperty(closeSync, previousSymbol, {\n          value: fs$closeSync\n        });\n        return closeSync;\n      })(fs4.closeSync);\n      if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || \"\")) {\n        process.on(\"exit\", function() {\n          debug(fs4[gracefulQueue]);\n          require(\"assert\").equal(fs4[gracefulQueue].length, 0);\n        });\n      }\n    }\n    var queue;\n    if (!global[gracefulQueue]) {\n      publishQueue(global, fs4[gracefulQueue]);\n    }\n    module2.exports = patch(clone(fs4));\n    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs4.__patched) {\n      module2.exports = patch(fs4);\n      fs4.__patched = true;\n    }\n    function patch(fs5) {\n      polyfills(fs5);\n      fs5.gracefulify = patch;\n      fs5.createReadStream = createReadStream;\n      fs5.createWriteStream = createWriteStream;\n      var fs$readFile = fs5.readFile;\n      fs5.readFile = readFile;\n      function readFile(path6, options, cb) {\n        if (typeof options === \"function\")\n          cb = options, options = null;\n        return go$readFile(path6, options, cb);\n        function go$readFile(path7, options2, cb2, startTime) {\n          return fs$readFile(path7, options2, function(err) {\n            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))\n              enqueue([go$readFile, [path7, options2, cb2], err, startTime || Date.now(), Date.now()]);\n            else {\n              if (typeof cb2 === \"function\")\n                cb2.apply(this, arguments);\n            }\n          });\n        }\n      }\n      var fs$writeFile = fs5.writeFile;\n      fs5.writeFile = writeFile;\n      function writeFile(path6, data, options, cb) {\n        if (typeof options === \"function\")\n          cb = options, options = null;\n        return go$writeFile(path6, data, options, cb);\n        function go$writeFile(path7, data2, options2, cb2, startTime) {\n          return fs$writeFile(path7, data2, options2, function(err) {\n            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))\n              enqueue([go$writeFile, [path7, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);\n            else {\n              if (typeof cb2 === \"function\")\n                cb2.apply(this, arguments);\n            }\n          });\n        }\n      }\n      var fs$appendFile = fs5.appendFile;\n      if (fs$appendFile)\n        fs5.appendFile = appendFile;\n      function appendFile(path6, data, options, cb) {\n        if (typeof options === \"function\")\n          cb = options, options = null;\n        return go$appendFile(path6, data, options, cb);\n        function go$appendFile(path7, data2, options2, cb2, startTime) {\n          return fs$appendFile(path7, data2, options2, function(err) {\n            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))\n              enqueue([go$appendFile, [path7, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);\n            else {\n              if (typeof cb2 === \"function\")\n                cb2.apply(this, arguments);\n            }\n          });\n        }\n      }\n      var fs$copyFile = fs5.copyFile;\n      if (fs$copyFile)\n        fs5.copyFile = copyFile;\n      function copyFile(src, dest, flags, cb) {\n        if (typeof flags === \"function\") {\n          cb = flags;\n          flags = 0;\n        }\n        return go$copyFile(src, dest, flags, cb);\n        function go$copyFile(src2, dest2, flags2, cb2, startTime) {\n          return fs$copyFile(src2, dest2, flags2, function(err) {\n            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))\n              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);\n            else {\n              if (typeof cb2 === \"function\")\n                cb2.apply(this, arguments);\n            }\n          });\n        }\n      }\n      var fs$readdir = fs5.readdir;\n      fs5.readdir = readdir;\n      var noReaddirOptionVersions = /^v[0-5]\\./;\n      function readdir(path6, options, cb) {\n        if (typeof options === \"function\")\n          cb = options, options = null;\n        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path7, options2, cb2, startTime) {\n          return fs$readdir(path7, fs$readdirCallback(\n            path7,\n            options2,\n            cb2,\n            startTime\n          ));\n        } : function go$readdir2(path7, options2, cb2, startTime) {\n          return fs$readdir(path7, options2, fs$readdirCallback(\n            path7,\n            options2,\n            cb2,\n            startTime\n          ));\n        };\n        return go$readdir(path6, options, cb);\n        function fs$readdirCallback(path7, options2, cb2, startTime) {\n          return function(err, files) {\n            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))\n              enqueue([\n                go$readdir,\n                [path7, options2, cb2],\n                err,\n                startTime || Date.now(),\n                Date.now()\n              ]);\n            else {\n              if (files && files.sort)\n                files.sort();\n              if (typeof cb2 === \"function\")\n                cb2.call(this, err, files);\n            }\n          };\n        }\n      }\n      if (process.version.substr(0, 4) === \"v0.8\") {\n        var legStreams = legacy(fs5);\n        ReadStream = legStreams.ReadStream;\n        WriteStream = legStreams.WriteStream;\n      }\n      var fs$ReadStream = fs5.ReadStream;\n      if (fs$ReadStream) {\n        ReadStream.prototype = Object.create(fs$ReadStream.prototype);\n        ReadStream.prototype.open = ReadStream$open;\n      }\n      var fs$WriteStream = fs5.WriteStream;\n      if (fs$WriteStream) {\n        WriteStream.prototype = Object.create(fs$WriteStream.prototype);\n        WriteStream.prototype.open = WriteStream$open;\n      }\n      Object.defineProperty(fs5, \"ReadStream\", {\n        get: function() {\n          return ReadStream;\n        },\n        set: function(val) {\n          ReadStream = val;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(fs5, \"WriteStream\", {\n        get: function() {\n          return WriteStream;\n        },\n        set: function(val) {\n          WriteStream = val;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      var FileReadStream = ReadStream;\n      Object.defineProperty(fs5, \"FileReadStream\", {\n        get: function() {\n          return FileReadStream;\n        },\n        set: function(val) {\n          FileReadStream = val;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      var FileWriteStream = WriteStream;\n      Object.defineProperty(fs5, \"FileWriteStream\", {\n        get: function() {\n          return FileWriteStream;\n        },\n        set: function(val) {\n          FileWriteStream = val;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      function ReadStream(path6, options) {\n        if (this instanceof ReadStream)\n          return fs$ReadStream.apply(this, arguments), this;\n        else\n          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);\n      }\n      function ReadStream$open() {\n        var that = this;\n        open(that.path, that.flags, that.mode, function(err, fd) {\n          if (err) {\n            if (that.autoClose)\n              that.destroy();\n            that.emit(\"error\", err);\n          } else {\n            that.fd = fd;\n            that.emit(\"open\", fd);\n            that.read();\n          }\n        });\n      }\n      function WriteStream(path6, options) {\n        if (this instanceof WriteStream)\n          return fs$WriteStream.apply(this, arguments), this;\n        else\n          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);\n      }\n      function WriteStream$open() {\n        var that = this;\n        open(that.path, that.flags, that.mode, function(err, fd) {\n          if (err) {\n            that.destroy();\n            that.emit(\"error\", err);\n          } else {\n            that.fd = fd;\n            that.emit(\"open\", fd);\n          }\n        });\n      }\n      function createReadStream(path6, options) {\n        return new fs5.ReadStream(path6, options);\n      }\n      function createWriteStream(path6, options) {\n        return new fs5.WriteStream(path6, options);\n      }\n      var fs$open = fs5.open;\n      fs5.open = open;\n      function open(path6, flags, mode, cb) {\n        if (typeof mode === \"function\")\n          cb = mode, mode = null;\n        return go$open(path6, flags, mode, cb);\n        function go$open(path7, flags2, mode2, cb2, startTime) {\n          return fs$open(path7, flags2, mode2, function(err, fd) {\n            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))\n              enqueue([go$open, [path7, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);\n            else {\n              if (typeof cb2 === \"function\")\n                cb2.apply(this, arguments);\n            }\n          });\n        }\n      }\n      return fs5;\n    }\n    function enqueue(elem) {\n      debug(\"ENQUEUE\", elem[0].name, elem[1]);\n      fs4[gracefulQueue].push(elem);\n      retry();\n    }\n    var retryTimer;\n    function resetQueue() {\n      var now = Date.now();\n      for (var i = 0; i < fs4[gracefulQueue].length; ++i) {\n        if (fs4[gracefulQueue][i].length > 2) {\n          fs4[gracefulQueue][i][3] = now;\n          fs4[gracefulQueue][i][4] = now;\n        }\n      }\n      retry();\n    }\n    function retry() {\n      clearTimeout(retryTimer);\n      retryTimer = void 0;\n      if (fs4[gracefulQueue].length === 0)\n        return;\n      var elem = fs4[gracefulQueue].shift();\n      var fn = elem[0];\n      var args = elem[1];\n      var err = elem[2];\n      var startTime = elem[3];\n      var lastTime = elem[4];\n      if (startTime === void 0) {\n        debug(\"RETRY\", fn.name, args);\n        fn.apply(null, args);\n      } else if (Date.now() - startTime >= 6e4) {\n        debug(\"TIMEOUT\", fn.name, args);\n        var cb = args.pop();\n        if (typeof cb === \"function\")\n          cb.call(null, err);\n      } else {\n        var sinceAttempt = Date.now() - lastTime;\n        var sinceStart = Math.max(lastTime - startTime, 1);\n        var desiredDelay = Math.min(sinceStart * 1.2, 100);\n        if (sinceAttempt >= desiredDelay) {\n          debug(\"RETRY\", fn.name, args);\n          fn.apply(null, args.concat([startTime]));\n        } else {\n          fs4[gracefulQueue].push(elem);\n        }\n      }\n      if (retryTimer === void 0) {\n        retryTimer = setTimeout(retry, 0);\n      }\n    }\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/fs/index.js\nvar require_fs = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/fs/index.js\"(exports2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    var fs4 = require_graceful_fs();\n    var api = [\n      \"access\",\n      \"appendFile\",\n      \"chmod\",\n      \"chown\",\n      \"close\",\n      \"copyFile\",\n      \"fchmod\",\n      \"fchown\",\n      \"fdatasync\",\n      \"fstat\",\n      \"fsync\",\n      \"ftruncate\",\n      \"futimes\",\n      \"lchmod\",\n      \"lchown\",\n      \"link\",\n      \"lstat\",\n      \"mkdir\",\n      \"mkdtemp\",\n      \"open\",\n      \"opendir\",\n      \"readdir\",\n      \"readFile\",\n      \"readlink\",\n      \"realpath\",\n      \"rename\",\n      \"rm\",\n      \"rmdir\",\n      \"stat\",\n      \"symlink\",\n      \"truncate\",\n      \"unlink\",\n      \"utimes\",\n      \"writeFile\"\n    ].filter((key) => {\n      return typeof fs4[key] === \"function\";\n    });\n    Object.assign(exports2, fs4);\n    api.forEach((method) => {\n      exports2[method] = u(fs4[method]);\n    });\n    exports2.exists = function(filename, callback) {\n      if (typeof callback === \"function\") {\n        return fs4.exists(filename, callback);\n      }\n      return new Promise((resolve) => {\n        return fs4.exists(filename, resolve);\n      });\n    };\n    exports2.read = function(fd, buffer, offset, length, position, callback) {\n      if (typeof callback === \"function\") {\n        return fs4.read(fd, buffer, offset, length, position, callback);\n      }\n      return new Promise((resolve, reject) => {\n        fs4.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {\n          if (err) return reject(err);\n          resolve({ bytesRead, buffer: buffer2 });\n        });\n      });\n    };\n    exports2.write = function(fd, buffer, ...args) {\n      if (typeof args[args.length - 1] === \"function\") {\n        return fs4.write(fd, buffer, ...args);\n      }\n      return new Promise((resolve, reject) => {\n        fs4.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {\n          if (err) return reject(err);\n          resolve({ bytesWritten, buffer: buffer2 });\n        });\n      });\n    };\n    if (typeof fs4.writev === \"function\") {\n      exports2.writev = function(fd, buffers, ...args) {\n        if (typeof args[args.length - 1] === \"function\") {\n          return fs4.writev(fd, buffers, ...args);\n        }\n        return new Promise((resolve, reject) => {\n          fs4.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {\n            if (err) return reject(err);\n            resolve({ bytesWritten, buffers: buffers2 });\n          });\n        });\n      };\n    }\n    if (typeof fs4.realpath.native === \"function\") {\n      exports2.realpath.native = u(fs4.realpath.native);\n    } else {\n      process.emitWarning(\n        \"fs.realpath.native is not a function. Is fs being monkey-patched?\",\n        \"Warning\",\n        \"fs-extra-WARN0003\"\n      );\n    }\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/utils.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    module2.exports.checkPath = function checkPath(pth) {\n      if (process.platform === \"win32\") {\n        const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path6.parse(pth).root, \"\"));\n        if (pathHasInvalidWinCharacters) {\n          const error = new Error(`Path contains invalid characters: ${pth}`);\n          error.code = \"EINVAL\";\n          throw error;\n        }\n      }\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/make-dir.js\nvar require_make_dir = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/make-dir.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_fs();\n    var { checkPath } = require_utils();\n    var getMode = (options) => {\n      const defaults = { mode: 511 };\n      if (typeof options === \"number\") return options;\n      return { ...defaults, ...options }.mode;\n    };\n    module2.exports.makeDir = async (dir, options) => {\n      checkPath(dir);\n      return fs4.mkdir(dir, {\n        mode: getMode(options),\n        recursive: true\n      });\n    };\n    module2.exports.makeDirSync = (dir, options) => {\n      checkPath(dir);\n      return fs4.mkdirSync(dir, {\n        mode: getMode(options),\n        recursive: true\n      });\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/index.js\nvar require_mkdirs = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromPromise;\n    var { makeDir: _makeDir, makeDirSync } = require_make_dir();\n    var makeDir = u(_makeDir);\n    module2.exports = {\n      mkdirs: makeDir,\n      mkdirsSync: makeDirSync,\n      // alias\n      mkdirp: makeDir,\n      mkdirpSync: makeDirSync,\n      ensureDir: makeDir,\n      ensureDirSync: makeDirSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/path-exists/index.js\nvar require_path_exists = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/path-exists/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromPromise;\n    var fs4 = require_fs();\n    function pathExists(path6) {\n      return fs4.access(path6).then(() => true).catch(() => false);\n    }\n    module2.exports = {\n      pathExists: u(pathExists),\n      pathExistsSync: fs4.existsSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/util/utimes.js\nvar require_utimes = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/util/utimes.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    function utimesMillis(path6, atime, mtime, callback) {\n      fs4.open(path6, \"r+\", (err, fd) => {\n        if (err) return callback(err);\n        fs4.futimes(fd, atime, mtime, (futimesErr) => {\n          fs4.close(fd, (closeErr) => {\n            if (callback) callback(futimesErr || closeErr);\n          });\n        });\n      });\n    }\n    function utimesMillisSync(path6, atime, mtime) {\n      const fd = fs4.openSync(path6, \"r+\");\n      fs4.futimesSync(fd, atime, mtime);\n      return fs4.closeSync(fd);\n    }\n    module2.exports = {\n      utimesMillis,\n      utimesMillisSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/util/stat.js\nvar require_stat = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/util/stat.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_fs();\n    var path6 = require(\"path\");\n    var util = require(\"util\");\n    function getStats(src, dest, opts) {\n      const statFunc = opts.dereference ? (file) => fs4.stat(file, { bigint: true }) : (file) => fs4.lstat(file, { bigint: true });\n      return Promise.all([\n        statFunc(src),\n        statFunc(dest).catch((err) => {\n          if (err.code === \"ENOENT\") return null;\n          throw err;\n        })\n      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));\n    }\n    function getStatsSync(src, dest, opts) {\n      let destStat;\n      const statFunc = opts.dereference ? (file) => fs4.statSync(file, { bigint: true }) : (file) => fs4.lstatSync(file, { bigint: true });\n      const srcStat = statFunc(src);\n      try {\n        destStat = statFunc(dest);\n      } catch (err) {\n        if (err.code === \"ENOENT\") return { srcStat, destStat: null };\n        throw err;\n      }\n      return { srcStat, destStat };\n    }\n    function checkPaths(src, dest, funcName, opts, cb) {\n      util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n        if (err) return cb(err);\n        const { srcStat, destStat } = stats;\n        if (destStat) {\n          if (areIdentical(srcStat, destStat)) {\n            const srcBaseName = path6.basename(src);\n            const destBaseName = path6.basename(dest);\n            if (funcName === \"move\" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n              return cb(null, { srcStat, destStat, isChangingCase: true });\n            }\n            return cb(new Error(\"Source and destination must not be the same.\"));\n          }\n          if (srcStat.isDirectory() && !destStat.isDirectory()) {\n            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));\n          }\n          if (!srcStat.isDirectory() && destStat.isDirectory()) {\n            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));\n          }\n        }\n        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n          return cb(new Error(errMsg(src, dest, funcName)));\n        }\n        return cb(null, { srcStat, destStat });\n      });\n    }\n    function checkPathsSync(src, dest, funcName, opts) {\n      const { srcStat, destStat } = getStatsSync(src, dest, opts);\n      if (destStat) {\n        if (areIdentical(srcStat, destStat)) {\n          const srcBaseName = path6.basename(src);\n          const destBaseName = path6.basename(dest);\n          if (funcName === \"move\" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n            return { srcStat, destStat, isChangingCase: true };\n          }\n          throw new Error(\"Source and destination must not be the same.\");\n        }\n        if (srcStat.isDirectory() && !destStat.isDirectory()) {\n          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n        }\n        if (!srcStat.isDirectory() && destStat.isDirectory()) {\n          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);\n        }\n      }\n      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n        throw new Error(errMsg(src, dest, funcName));\n      }\n      return { srcStat, destStat };\n    }\n    function checkParentPaths(src, srcStat, dest, funcName, cb) {\n      const srcParent = path6.resolve(path6.dirname(src));\n      const destParent = path6.resolve(path6.dirname(dest));\n      if (destParent === srcParent || destParent === path6.parse(destParent).root) return cb();\n      fs4.stat(destParent, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === \"ENOENT\") return cb();\n          return cb(err);\n        }\n        if (areIdentical(srcStat, destStat)) {\n          return cb(new Error(errMsg(src, dest, funcName)));\n        }\n        return checkParentPaths(src, srcStat, destParent, funcName, cb);\n      });\n    }\n    function checkParentPathsSync(src, srcStat, dest, funcName) {\n      const srcParent = path6.resolve(path6.dirname(src));\n      const destParent = path6.resolve(path6.dirname(dest));\n      if (destParent === srcParent || destParent === path6.parse(destParent).root) return;\n      let destStat;\n      try {\n        destStat = fs4.statSync(destParent, { bigint: true });\n      } catch (err) {\n        if (err.code === \"ENOENT\") return;\n        throw err;\n      }\n      if (areIdentical(srcStat, destStat)) {\n        throw new Error(errMsg(src, dest, funcName));\n      }\n      return checkParentPathsSync(src, srcStat, destParent, funcName);\n    }\n    function areIdentical(srcStat, destStat) {\n      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n    }\n    function isSrcSubdir(src, dest) {\n      const srcArr = path6.resolve(src).split(path6.sep).filter((i) => i);\n      const destArr = path6.resolve(dest).split(path6.sep).filter((i) => i);\n      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);\n    }\n    function errMsg(src, dest, funcName) {\n      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;\n    }\n    module2.exports = {\n      checkPaths,\n      checkPathsSync,\n      checkParentPaths,\n      checkParentPathsSync,\n      isSrcSubdir,\n      areIdentical\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/copy/copy.js\nvar require_copy = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/copy/copy.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    var path6 = require(\"path\");\n    var mkdirs = require_mkdirs().mkdirs;\n    var pathExists = require_path_exists().pathExists;\n    var utimesMillis = require_utimes().utimesMillis;\n    var stat = require_stat();\n    function copy(src, dest, opts, cb) {\n      if (typeof opts === \"function\" && !cb) {\n        cb = opts;\n        opts = {};\n      } else if (typeof opts === \"function\") {\n        opts = { filter: opts };\n      }\n      cb = cb || function() {\n      };\n      opts = opts || {};\n      opts.clobber = \"clobber\" in opts ? !!opts.clobber : true;\n      opts.overwrite = \"overwrite\" in opts ? !!opts.overwrite : opts.clobber;\n      if (opts.preserveTimestamps && process.arch === \"ia32\") {\n        process.emitWarning(\n          \"Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269\",\n          \"Warning\",\n          \"fs-extra-WARN0001\"\n        );\n      }\n      stat.checkPaths(src, dest, \"copy\", opts, (err, stats) => {\n        if (err) return cb(err);\n        const { srcStat, destStat } = stats;\n        stat.checkParentPaths(src, srcStat, dest, \"copy\", (err2) => {\n          if (err2) return cb(err2);\n          if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);\n          return checkParentDir(destStat, src, dest, opts, cb);\n        });\n      });\n    }\n    function checkParentDir(destStat, src, dest, opts, cb) {\n      const destParent = path6.dirname(dest);\n      pathExists(destParent, (err, dirExists) => {\n        if (err) return cb(err);\n        if (dirExists) return getStats(destStat, src, dest, opts, cb);\n        mkdirs(destParent, (err2) => {\n          if (err2) return cb(err2);\n          return getStats(destStat, src, dest, opts, cb);\n        });\n      });\n    }\n    function handleFilter(onInclude, destStat, src, dest, opts, cb) {\n      Promise.resolve(opts.filter(src, dest)).then((include) => {\n        if (include) return onInclude(destStat, src, dest, opts, cb);\n        return cb();\n      }, (error) => cb(error));\n    }\n    function startCopy(destStat, src, dest, opts, cb) {\n      if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);\n      return getStats(destStat, src, dest, opts, cb);\n    }\n    function getStats(destStat, src, dest, opts, cb) {\n      const stat2 = opts.dereference ? fs4.stat : fs4.lstat;\n      stat2(src, (err, srcStat) => {\n        if (err) return cb(err);\n        if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);\n        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);\n        else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);\n        else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`));\n        else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));\n        return cb(new Error(`Unknown file: ${src}`));\n      });\n    }\n    function onFile(srcStat, destStat, src, dest, opts, cb) {\n      if (!destStat) return copyFile(srcStat, src, dest, opts, cb);\n      return mayCopyFile(srcStat, src, dest, opts, cb);\n    }\n    function mayCopyFile(srcStat, src, dest, opts, cb) {\n      if (opts.overwrite) {\n        fs4.unlink(dest, (err) => {\n          if (err) return cb(err);\n          return copyFile(srcStat, src, dest, opts, cb);\n        });\n      } else if (opts.errorOnExist) {\n        return cb(new Error(`'${dest}' already exists`));\n      } else return cb();\n    }\n    function copyFile(srcStat, src, dest, opts, cb) {\n      fs4.copyFile(src, dest, (err) => {\n        if (err) return cb(err);\n        if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb);\n        return setDestMode(dest, srcStat.mode, cb);\n      });\n    }\n    function handleTimestampsAndMode(srcMode, src, dest, cb) {\n      if (fileIsNotWritable(srcMode)) {\n        return makeFileWritable(dest, srcMode, (err) => {\n          if (err) return cb(err);\n          return setDestTimestampsAndMode(srcMode, src, dest, cb);\n        });\n      }\n      return setDestTimestampsAndMode(srcMode, src, dest, cb);\n    }\n    function fileIsNotWritable(srcMode) {\n      return (srcMode & 128) === 0;\n    }\n    function makeFileWritable(dest, srcMode, cb) {\n      return setDestMode(dest, srcMode | 128, cb);\n    }\n    function setDestTimestampsAndMode(srcMode, src, dest, cb) {\n      setDestTimestamps(src, dest, (err) => {\n        if (err) return cb(err);\n        return setDestMode(dest, srcMode, cb);\n      });\n    }\n    function setDestMode(dest, srcMode, cb) {\n      return fs4.chmod(dest, srcMode, cb);\n    }\n    function setDestTimestamps(src, dest, cb) {\n      fs4.stat(src, (err, updatedSrcStat) => {\n        if (err) return cb(err);\n        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);\n      });\n    }\n    function onDir(srcStat, destStat, src, dest, opts, cb) {\n      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);\n      return copyDir(src, dest, opts, cb);\n    }\n    function mkDirAndCopy(srcMode, src, dest, opts, cb) {\n      fs4.mkdir(dest, (err) => {\n        if (err) return cb(err);\n        copyDir(src, dest, opts, (err2) => {\n          if (err2) return cb(err2);\n          return setDestMode(dest, srcMode, cb);\n        });\n      });\n    }\n    function copyDir(src, dest, opts, cb) {\n      fs4.readdir(src, (err, items) => {\n        if (err) return cb(err);\n        return copyDirItems(items, src, dest, opts, cb);\n      });\n    }\n    function copyDirItems(items, src, dest, opts, cb) {\n      const item = items.pop();\n      if (!item) return cb();\n      return copyDirItem(items, item, src, dest, opts, cb);\n    }\n    function copyDirItem(items, item, src, dest, opts, cb) {\n      const srcItem = path6.join(src, item);\n      const destItem = path6.join(dest, item);\n      stat.checkPaths(srcItem, destItem, \"copy\", opts, (err, stats) => {\n        if (err) return cb(err);\n        const { destStat } = stats;\n        startCopy(destStat, srcItem, destItem, opts, (err2) => {\n          if (err2) return cb(err2);\n          return copyDirItems(items, src, dest, opts, cb);\n        });\n      });\n    }\n    function onLink(destStat, src, dest, opts, cb) {\n      fs4.readlink(src, (err, resolvedSrc) => {\n        if (err) return cb(err);\n        if (opts.dereference) {\n          resolvedSrc = path6.resolve(process.cwd(), resolvedSrc);\n        }\n        if (!destStat) {\n          return fs4.symlink(resolvedSrc, dest, cb);\n        } else {\n          fs4.readlink(dest, (err2, resolvedDest) => {\n            if (err2) {\n              if (err2.code === \"EINVAL\" || err2.code === \"UNKNOWN\") return fs4.symlink(resolvedSrc, dest, cb);\n              return cb(err2);\n            }\n            if (opts.dereference) {\n              resolvedDest = path6.resolve(process.cwd(), resolvedDest);\n            }\n            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));\n            }\n            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));\n            }\n            return copyLink(resolvedSrc, dest, cb);\n          });\n        }\n      });\n    }\n    function copyLink(resolvedSrc, dest, cb) {\n      fs4.unlink(dest, (err) => {\n        if (err) return cb(err);\n        return fs4.symlink(resolvedSrc, dest, cb);\n      });\n    }\n    module2.exports = copy;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/copy/copy-sync.js\nvar require_copy_sync = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/copy/copy-sync.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    var path6 = require(\"path\");\n    var mkdirsSync = require_mkdirs().mkdirsSync;\n    var utimesMillisSync = require_utimes().utimesMillisSync;\n    var stat = require_stat();\n    function copySync(src, dest, opts) {\n      if (typeof opts === \"function\") {\n        opts = { filter: opts };\n      }\n      opts = opts || {};\n      opts.clobber = \"clobber\" in opts ? !!opts.clobber : true;\n      opts.overwrite = \"overwrite\" in opts ? !!opts.overwrite : opts.clobber;\n      if (opts.preserveTimestamps && process.arch === \"ia32\") {\n        process.emitWarning(\n          \"Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269\",\n          \"Warning\",\n          \"fs-extra-WARN0002\"\n        );\n      }\n      const { srcStat, destStat } = stat.checkPathsSync(src, dest, \"copy\", opts);\n      stat.checkParentPathsSync(src, srcStat, dest, \"copy\");\n      return handleFilterAndCopy(destStat, src, dest, opts);\n    }\n    function handleFilterAndCopy(destStat, src, dest, opts) {\n      if (opts.filter && !opts.filter(src, dest)) return;\n      const destParent = path6.dirname(dest);\n      if (!fs4.existsSync(destParent)) mkdirsSync(destParent);\n      return getStats(destStat, src, dest, opts);\n    }\n    function startCopy(destStat, src, dest, opts) {\n      if (opts.filter && !opts.filter(src, dest)) return;\n      return getStats(destStat, src, dest, opts);\n    }\n    function getStats(destStat, src, dest, opts) {\n      const statSync = opts.dereference ? fs4.statSync : fs4.lstatSync;\n      const srcStat = statSync(src);\n      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);\n      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);\n      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);\n      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);\n      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n      throw new Error(`Unknown file: ${src}`);\n    }\n    function onFile(srcStat, destStat, src, dest, opts) {\n      if (!destStat) return copyFile(srcStat, src, dest, opts);\n      return mayCopyFile(srcStat, src, dest, opts);\n    }\n    function mayCopyFile(srcStat, src, dest, opts) {\n      if (opts.overwrite) {\n        fs4.unlinkSync(dest);\n        return copyFile(srcStat, src, dest, opts);\n      } else if (opts.errorOnExist) {\n        throw new Error(`'${dest}' already exists`);\n      }\n    }\n    function copyFile(srcStat, src, dest, opts) {\n      fs4.copyFileSync(src, dest);\n      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);\n      return setDestMode(dest, srcStat.mode);\n    }\n    function handleTimestamps(srcMode, src, dest) {\n      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);\n      return setDestTimestamps(src, dest);\n    }\n    function fileIsNotWritable(srcMode) {\n      return (srcMode & 128) === 0;\n    }\n    function makeFileWritable(dest, srcMode) {\n      return setDestMode(dest, srcMode | 128);\n    }\n    function setDestMode(dest, srcMode) {\n      return fs4.chmodSync(dest, srcMode);\n    }\n    function setDestTimestamps(src, dest) {\n      const updatedSrcStat = fs4.statSync(src);\n      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n    }\n    function onDir(srcStat, destStat, src, dest, opts) {\n      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);\n      return copyDir(src, dest, opts);\n    }\n    function mkDirAndCopy(srcMode, src, dest, opts) {\n      fs4.mkdirSync(dest);\n      copyDir(src, dest, opts);\n      return setDestMode(dest, srcMode);\n    }\n    function copyDir(src, dest, opts) {\n      fs4.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));\n    }\n    function copyDirItem(item, src, dest, opts) {\n      const srcItem = path6.join(src, item);\n      const destItem = path6.join(dest, item);\n      const { destStat } = stat.checkPathsSync(srcItem, destItem, \"copy\", opts);\n      return startCopy(destStat, srcItem, destItem, opts);\n    }\n    function onLink(destStat, src, dest, opts) {\n      let resolvedSrc = fs4.readlinkSync(src);\n      if (opts.dereference) {\n        resolvedSrc = path6.resolve(process.cwd(), resolvedSrc);\n      }\n      if (!destStat) {\n        return fs4.symlinkSync(resolvedSrc, dest);\n      } else {\n        let resolvedDest;\n        try {\n          resolvedDest = fs4.readlinkSync(dest);\n        } catch (err) {\n          if (err.code === \"EINVAL\" || err.code === \"UNKNOWN\") return fs4.symlinkSync(resolvedSrc, dest);\n          throw err;\n        }\n        if (opts.dereference) {\n          resolvedDest = path6.resolve(process.cwd(), resolvedDest);\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n        }\n        if (fs4.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n        }\n        return copyLink(resolvedSrc, dest);\n      }\n    }\n    function copyLink(resolvedSrc, dest) {\n      fs4.unlinkSync(dest);\n      return fs4.symlinkSync(resolvedSrc, dest);\n    }\n    module2.exports = copySync;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/copy/index.js\nvar require_copy2 = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/copy/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    module2.exports = {\n      copy: u(require_copy()),\n      copySync: require_copy_sync()\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/remove/rimraf.js\nvar require_rimraf = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/remove/rimraf.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    var path6 = require(\"path\");\n    var assert = require(\"assert\");\n    var isWindows = process.platform === \"win32\";\n    function defaults(options) {\n      const methods = [\n        \"unlink\",\n        \"chmod\",\n        \"stat\",\n        \"lstat\",\n        \"rmdir\",\n        \"readdir\"\n      ];\n      methods.forEach((m) => {\n        options[m] = options[m] || fs4[m];\n        m = m + \"Sync\";\n        options[m] = options[m] || fs4[m];\n      });\n      options.maxBusyTries = options.maxBusyTries || 3;\n    }\n    function rimraf(p, options, cb) {\n      let busyTries = 0;\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n      assert(p, \"rimraf: missing path\");\n      assert.strictEqual(typeof p, \"string\", \"rimraf: path should be a string\");\n      assert.strictEqual(typeof cb, \"function\", \"rimraf: callback function required\");\n      assert(options, \"rimraf: invalid options argument provided\");\n      assert.strictEqual(typeof options, \"object\", \"rimraf: options should be object\");\n      defaults(options);\n      rimraf_(p, options, function CB(er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") && busyTries < options.maxBusyTries) {\n            busyTries++;\n            const time = busyTries * 100;\n            return setTimeout(() => rimraf_(p, options, CB), time);\n          }\n          if (er.code === \"ENOENT\") er = null;\n        }\n        cb(er);\n      });\n    }\n    function rimraf_(p, options, cb) {\n      assert(p);\n      assert(options);\n      assert(typeof cb === \"function\");\n      options.lstat(p, (er, st) => {\n        if (er && er.code === \"ENOENT\") {\n          return cb(null);\n        }\n        if (er && er.code === \"EPERM\" && isWindows) {\n          return fixWinEPERM(p, options, er, cb);\n        }\n        if (st && st.isDirectory()) {\n          return rmdir(p, options, er, cb);\n        }\n        options.unlink(p, (er2) => {\n          if (er2) {\n            if (er2.code === \"ENOENT\") {\n              return cb(null);\n            }\n            if (er2.code === \"EPERM\") {\n              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);\n            }\n            if (er2.code === \"EISDIR\") {\n              return rmdir(p, options, er2, cb);\n            }\n          }\n          return cb(er2);\n        });\n      });\n    }\n    function fixWinEPERM(p, options, er, cb) {\n      assert(p);\n      assert(options);\n      assert(typeof cb === \"function\");\n      options.chmod(p, 438, (er2) => {\n        if (er2) {\n          cb(er2.code === \"ENOENT\" ? null : er);\n        } else {\n          options.stat(p, (er3, stats) => {\n            if (er3) {\n              cb(er3.code === \"ENOENT\" ? null : er);\n            } else if (stats.isDirectory()) {\n              rmdir(p, options, er, cb);\n            } else {\n              options.unlink(p, cb);\n            }\n          });\n        }\n      });\n    }\n    function fixWinEPERMSync(p, options, er) {\n      let stats;\n      assert(p);\n      assert(options);\n      try {\n        options.chmodSync(p, 438);\n      } catch (er2) {\n        if (er2.code === \"ENOENT\") {\n          return;\n        } else {\n          throw er;\n        }\n      }\n      try {\n        stats = options.statSync(p);\n      } catch (er3) {\n        if (er3.code === \"ENOENT\") {\n          return;\n        } else {\n          throw er;\n        }\n      }\n      if (stats.isDirectory()) {\n        rmdirSync(p, options, er);\n      } else {\n        options.unlinkSync(p);\n      }\n    }\n    function rmdir(p, options, originalEr, cb) {\n      assert(p);\n      assert(options);\n      assert(typeof cb === \"function\");\n      options.rmdir(p, (er) => {\n        if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")) {\n          rmkids(p, options, cb);\n        } else if (er && er.code === \"ENOTDIR\") {\n          cb(originalEr);\n        } else {\n          cb(er);\n        }\n      });\n    }\n    function rmkids(p, options, cb) {\n      assert(p);\n      assert(options);\n      assert(typeof cb === \"function\");\n      options.readdir(p, (er, files) => {\n        if (er) return cb(er);\n        let n = files.length;\n        let errState;\n        if (n === 0) return options.rmdir(p, cb);\n        files.forEach((f) => {\n          rimraf(path6.join(p, f), options, (er2) => {\n            if (errState) {\n              return;\n            }\n            if (er2) return cb(errState = er2);\n            if (--n === 0) {\n              options.rmdir(p, cb);\n            }\n          });\n        });\n      });\n    }\n    function rimrafSync(p, options) {\n      let st;\n      options = options || {};\n      defaults(options);\n      assert(p, \"rimraf: missing path\");\n      assert.strictEqual(typeof p, \"string\", \"rimraf: path should be a string\");\n      assert(options, \"rimraf: missing options\");\n      assert.strictEqual(typeof options, \"object\", \"rimraf: options should be object\");\n      try {\n        st = options.lstatSync(p);\n      } catch (er) {\n        if (er.code === \"ENOENT\") {\n          return;\n        }\n        if (er.code === \"EPERM\" && isWindows) {\n          fixWinEPERMSync(p, options, er);\n        }\n      }\n      try {\n        if (st && st.isDirectory()) {\n          rmdirSync(p, options, null);\n        } else {\n          options.unlinkSync(p);\n        }\n      } catch (er) {\n        if (er.code === \"ENOENT\") {\n          return;\n        } else if (er.code === \"EPERM\") {\n          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);\n        } else if (er.code !== \"EISDIR\") {\n          throw er;\n        }\n        rmdirSync(p, options, er);\n      }\n    }\n    function rmdirSync(p, options, originalEr) {\n      assert(p);\n      assert(options);\n      try {\n        options.rmdirSync(p);\n      } catch (er) {\n        if (er.code === \"ENOTDIR\") {\n          throw originalEr;\n        } else if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\") {\n          rmkidsSync(p, options);\n        } else if (er.code !== \"ENOENT\") {\n          throw er;\n        }\n      }\n    }\n    function rmkidsSync(p, options) {\n      assert(p);\n      assert(options);\n      options.readdirSync(p).forEach((f) => rimrafSync(path6.join(p, f), options));\n      if (isWindows) {\n        const startTime = Date.now();\n        do {\n          try {\n            const ret = options.rmdirSync(p, options);\n            return ret;\n          } catch {\n          }\n        } while (Date.now() - startTime < 500);\n      } else {\n        const ret = options.rmdirSync(p, options);\n        return ret;\n      }\n    }\n    module2.exports = rimraf;\n    rimraf.sync = rimrafSync;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/remove/index.js\nvar require_remove = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/remove/index.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    var u = require_universalify().fromCallback;\n    var rimraf = require_rimraf();\n    function remove(path6, callback) {\n      if (fs4.rm) return fs4.rm(path6, { recursive: true, force: true }, callback);\n      rimraf(path6, callback);\n    }\n    function removeSync(path6) {\n      if (fs4.rmSync) return fs4.rmSync(path6, { recursive: true, force: true });\n      rimraf.sync(path6);\n    }\n    module2.exports = {\n      remove: u(remove),\n      removeSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/empty/index.js\nvar require_empty = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/empty/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromPromise;\n    var fs4 = require_fs();\n    var path6 = require(\"path\");\n    var mkdir = require_mkdirs();\n    var remove = require_remove();\n    var emptyDir = u(async function emptyDir2(dir) {\n      let items;\n      try {\n        items = await fs4.readdir(dir);\n      } catch {\n        return mkdir.mkdirs(dir);\n      }\n      return Promise.all(items.map((item) => remove.remove(path6.join(dir, item))));\n    });\n    function emptyDirSync(dir) {\n      let items;\n      try {\n        items = fs4.readdirSync(dir);\n      } catch {\n        return mkdir.mkdirsSync(dir);\n      }\n      items.forEach((item) => {\n        item = path6.join(dir, item);\n        remove.removeSync(item);\n      });\n    }\n    module2.exports = {\n      emptyDirSync,\n      emptydirSync: emptyDirSync,\n      emptyDir,\n      emptydir: emptyDir\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/ensure/file.js\nvar require_file = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/ensure/file.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    var path6 = require(\"path\");\n    var fs4 = require_graceful_fs();\n    var mkdir = require_mkdirs();\n    function createFile(file, callback) {\n      function makeFile() {\n        fs4.writeFile(file, \"\", (err) => {\n          if (err) return callback(err);\n          callback();\n        });\n      }\n      fs4.stat(file, (err, stats) => {\n        if (!err && stats.isFile()) return callback();\n        const dir = path6.dirname(file);\n        fs4.stat(dir, (err2, stats2) => {\n          if (err2) {\n            if (err2.code === \"ENOENT\") {\n              return mkdir.mkdirs(dir, (err3) => {\n                if (err3) return callback(err3);\n                makeFile();\n              });\n            }\n            return callback(err2);\n          }\n          if (stats2.isDirectory()) makeFile();\n          else {\n            fs4.readdir(dir, (err3) => {\n              if (err3) return callback(err3);\n            });\n          }\n        });\n      });\n    }\n    function createFileSync(file) {\n      let stats;\n      try {\n        stats = fs4.statSync(file);\n      } catch {\n      }\n      if (stats && stats.isFile()) return;\n      const dir = path6.dirname(file);\n      try {\n        if (!fs4.statSync(dir).isDirectory()) {\n          fs4.readdirSync(dir);\n        }\n      } catch (err) {\n        if (err && err.code === \"ENOENT\") mkdir.mkdirsSync(dir);\n        else throw err;\n      }\n      fs4.writeFileSync(file, \"\");\n    }\n    module2.exports = {\n      createFile: u(createFile),\n      createFileSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/ensure/link.js\nvar require_link = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/ensure/link.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    var path6 = require(\"path\");\n    var fs4 = require_graceful_fs();\n    var mkdir = require_mkdirs();\n    var pathExists = require_path_exists().pathExists;\n    var { areIdentical } = require_stat();\n    function createLink(srcpath, dstpath, callback) {\n      function makeLink(srcpath2, dstpath2) {\n        fs4.link(srcpath2, dstpath2, (err) => {\n          if (err) return callback(err);\n          callback(null);\n        });\n      }\n      fs4.lstat(dstpath, (_, dstStat) => {\n        fs4.lstat(srcpath, (err, srcStat) => {\n          if (err) {\n            err.message = err.message.replace(\"lstat\", \"ensureLink\");\n            return callback(err);\n          }\n          if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);\n          const dir = path6.dirname(dstpath);\n          pathExists(dir, (err2, dirExists) => {\n            if (err2) return callback(err2);\n            if (dirExists) return makeLink(srcpath, dstpath);\n            mkdir.mkdirs(dir, (err3) => {\n              if (err3) return callback(err3);\n              makeLink(srcpath, dstpath);\n            });\n          });\n        });\n      });\n    }\n    function createLinkSync(srcpath, dstpath) {\n      let dstStat;\n      try {\n        dstStat = fs4.lstatSync(dstpath);\n      } catch {\n      }\n      try {\n        const srcStat = fs4.lstatSync(srcpath);\n        if (dstStat && areIdentical(srcStat, dstStat)) return;\n      } catch (err) {\n        err.message = err.message.replace(\"lstat\", \"ensureLink\");\n        throw err;\n      }\n      const dir = path6.dirname(dstpath);\n      const dirExists = fs4.existsSync(dir);\n      if (dirExists) return fs4.linkSync(srcpath, dstpath);\n      mkdir.mkdirsSync(dir);\n      return fs4.linkSync(srcpath, dstpath);\n    }\n    module2.exports = {\n      createLink: u(createLink),\n      createLinkSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink-paths.js\nvar require_symlink_paths = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink-paths.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    var fs4 = require_graceful_fs();\n    var pathExists = require_path_exists().pathExists;\n    function symlinkPaths(srcpath, dstpath, callback) {\n      if (path6.isAbsolute(srcpath)) {\n        return fs4.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace(\"lstat\", \"ensureSymlink\");\n            return callback(err);\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: srcpath\n          });\n        });\n      } else {\n        const dstdir = path6.dirname(dstpath);\n        const relativeToDst = path6.join(dstdir, srcpath);\n        return pathExists(relativeToDst, (err, exists) => {\n          if (err) return callback(err);\n          if (exists) {\n            return callback(null, {\n              toCwd: relativeToDst,\n              toDst: srcpath\n            });\n          } else {\n            return fs4.lstat(srcpath, (err2) => {\n              if (err2) {\n                err2.message = err2.message.replace(\"lstat\", \"ensureSymlink\");\n                return callback(err2);\n              }\n              return callback(null, {\n                toCwd: srcpath,\n                toDst: path6.relative(dstdir, srcpath)\n              });\n            });\n          }\n        });\n      }\n    }\n    function symlinkPathsSync(srcpath, dstpath) {\n      let exists;\n      if (path6.isAbsolute(srcpath)) {\n        exists = fs4.existsSync(srcpath);\n        if (!exists) throw new Error(\"absolute srcpath does not exist\");\n        return {\n          toCwd: srcpath,\n          toDst: srcpath\n        };\n      } else {\n        const dstdir = path6.dirname(dstpath);\n        const relativeToDst = path6.join(dstdir, srcpath);\n        exists = fs4.existsSync(relativeToDst);\n        if (exists) {\n          return {\n            toCwd: relativeToDst,\n            toDst: srcpath\n          };\n        } else {\n          exists = fs4.existsSync(srcpath);\n          if (!exists) throw new Error(\"relative srcpath does not exist\");\n          return {\n            toCwd: srcpath,\n            toDst: path6.relative(dstdir, srcpath)\n          };\n        }\n      }\n    }\n    module2.exports = {\n      symlinkPaths,\n      symlinkPathsSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink-type.js\nvar require_symlink_type = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink-type.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    function symlinkType(srcpath, type, callback) {\n      callback = typeof type === \"function\" ? type : callback;\n      type = typeof type === \"function\" ? false : type;\n      if (type) return callback(null, type);\n      fs4.lstat(srcpath, (err, stats) => {\n        if (err) return callback(null, \"file\");\n        type = stats && stats.isDirectory() ? \"dir\" : \"file\";\n        callback(null, type);\n      });\n    }\n    function symlinkTypeSync(srcpath, type) {\n      let stats;\n      if (type) return type;\n      try {\n        stats = fs4.lstatSync(srcpath);\n      } catch {\n        return \"file\";\n      }\n      return stats && stats.isDirectory() ? \"dir\" : \"file\";\n    }\n    module2.exports = {\n      symlinkType,\n      symlinkTypeSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink.js\nvar require_symlink = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    var path6 = require(\"path\");\n    var fs4 = require_fs();\n    var _mkdirs = require_mkdirs();\n    var mkdirs = _mkdirs.mkdirs;\n    var mkdirsSync = _mkdirs.mkdirsSync;\n    var _symlinkPaths = require_symlink_paths();\n    var symlinkPaths = _symlinkPaths.symlinkPaths;\n    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;\n    var _symlinkType = require_symlink_type();\n    var symlinkType = _symlinkType.symlinkType;\n    var symlinkTypeSync = _symlinkType.symlinkTypeSync;\n    var pathExists = require_path_exists().pathExists;\n    var { areIdentical } = require_stat();\n    function createSymlink(srcpath, dstpath, type, callback) {\n      callback = typeof type === \"function\" ? type : callback;\n      type = typeof type === \"function\" ? false : type;\n      fs4.lstat(dstpath, (err, stats) => {\n        if (!err && stats.isSymbolicLink()) {\n          Promise.all([\n            fs4.stat(srcpath),\n            fs4.stat(dstpath)\n          ]).then(([srcStat, dstStat]) => {\n            if (areIdentical(srcStat, dstStat)) return callback(null);\n            _createSymlink(srcpath, dstpath, type, callback);\n          });\n        } else _createSymlink(srcpath, dstpath, type, callback);\n      });\n    }\n    function _createSymlink(srcpath, dstpath, type, callback) {\n      symlinkPaths(srcpath, dstpath, (err, relative) => {\n        if (err) return callback(err);\n        srcpath = relative.toDst;\n        symlinkType(relative.toCwd, type, (err2, type2) => {\n          if (err2) return callback(err2);\n          const dir = path6.dirname(dstpath);\n          pathExists(dir, (err3, dirExists) => {\n            if (err3) return callback(err3);\n            if (dirExists) return fs4.symlink(srcpath, dstpath, type2, callback);\n            mkdirs(dir, (err4) => {\n              if (err4) return callback(err4);\n              fs4.symlink(srcpath, dstpath, type2, callback);\n            });\n          });\n        });\n      });\n    }\n    function createSymlinkSync(srcpath, dstpath, type) {\n      let stats;\n      try {\n        stats = fs4.lstatSync(dstpath);\n      } catch {\n      }\n      if (stats && stats.isSymbolicLink()) {\n        const srcStat = fs4.statSync(srcpath);\n        const dstStat = fs4.statSync(dstpath);\n        if (areIdentical(srcStat, dstStat)) return;\n      }\n      const relative = symlinkPathsSync(srcpath, dstpath);\n      srcpath = relative.toDst;\n      type = symlinkTypeSync(relative.toCwd, type);\n      const dir = path6.dirname(dstpath);\n      const exists = fs4.existsSync(dir);\n      if (exists) return fs4.symlinkSync(srcpath, dstpath, type);\n      mkdirsSync(dir);\n      return fs4.symlinkSync(srcpath, dstpath, type);\n    }\n    module2.exports = {\n      createSymlink: u(createSymlink),\n      createSymlinkSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/ensure/index.js\nvar require_ensure = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/ensure/index.js\"(exports2, module2) {\n    \"use strict\";\n    var { createFile, createFileSync } = require_file();\n    var { createLink, createLinkSync } = require_link();\n    var { createSymlink, createSymlinkSync } = require_symlink();\n    module2.exports = {\n      // file\n      createFile,\n      createFileSync,\n      ensureFile: createFile,\n      ensureFileSync: createFileSync,\n      // link\n      createLink,\n      createLinkSync,\n      ensureLink: createLink,\n      ensureLinkSync: createLinkSync,\n      // symlink\n      createSymlink,\n      createSymlinkSync,\n      ensureSymlink: createSymlink,\n      ensureSymlinkSync: createSymlinkSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/jsonfile/utils.js\nvar require_utils2 = __commonJS({\n  \"node_modules/electron-updater/node_modules/jsonfile/utils.js\"(exports2, module2) {\n    function stringify(obj, { EOL = \"\\n\", finalEOL = true, replacer = null, spaces } = {}) {\n      const EOF = finalEOL ? EOL : \"\";\n      const str = JSON.stringify(obj, replacer, spaces);\n      return str.replace(/\\n/g, EOL) + EOF;\n    }\n    function stripBom(content) {\n      if (Buffer.isBuffer(content)) content = content.toString(\"utf8\");\n      return content.replace(/^\\uFEFF/, \"\");\n    }\n    module2.exports = { stringify, stripBom };\n  }\n});\n\n// node_modules/electron-updater/node_modules/jsonfile/index.js\nvar require_jsonfile = __commonJS({\n  \"node_modules/electron-updater/node_modules/jsonfile/index.js\"(exports2, module2) {\n    var _fs;\n    try {\n      _fs = require_graceful_fs();\n    } catch (_) {\n      _fs = require(\"fs\");\n    }\n    var universalify = require_universalify();\n    var { stringify, stripBom } = require_utils2();\n    async function _readFile(file, options = {}) {\n      if (typeof options === \"string\") {\n        options = { encoding: options };\n      }\n      const fs4 = options.fs || _fs;\n      const shouldThrow = \"throws\" in options ? options.throws : true;\n      let data = await universalify.fromCallback(fs4.readFile)(file, options);\n      data = stripBom(data);\n      let obj;\n      try {\n        obj = JSON.parse(data, options ? options.reviver : null);\n      } catch (err) {\n        if (shouldThrow) {\n          err.message = `${file}: ${err.message}`;\n          throw err;\n        } else {\n          return null;\n        }\n      }\n      return obj;\n    }\n    var readFile = universalify.fromPromise(_readFile);\n    function readFileSync(file, options = {}) {\n      if (typeof options === \"string\") {\n        options = { encoding: options };\n      }\n      const fs4 = options.fs || _fs;\n      const shouldThrow = \"throws\" in options ? options.throws : true;\n      try {\n        let content = fs4.readFileSync(file, options);\n        content = stripBom(content);\n        return JSON.parse(content, options.reviver);\n      } catch (err) {\n        if (shouldThrow) {\n          err.message = `${file}: ${err.message}`;\n          throw err;\n        } else {\n          return null;\n        }\n      }\n    }\n    async function _writeFile(file, obj, options = {}) {\n      const fs4 = options.fs || _fs;\n      const str = stringify(obj, options);\n      await universalify.fromCallback(fs4.writeFile)(file, str, options);\n    }\n    var writeFile = universalify.fromPromise(_writeFile);\n    function writeFileSync(file, obj, options = {}) {\n      const fs4 = options.fs || _fs;\n      const str = stringify(obj, options);\n      return fs4.writeFileSync(file, str, options);\n    }\n    module2.exports = {\n      readFile,\n      readFileSync,\n      writeFile,\n      writeFileSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/json/jsonfile.js\nvar require_jsonfile2 = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/json/jsonfile.js\"(exports2, module2) {\n    \"use strict\";\n    var jsonFile = require_jsonfile();\n    module2.exports = {\n      // jsonfile exports\n      readJson: jsonFile.readFile,\n      readJsonSync: jsonFile.readFileSync,\n      writeJson: jsonFile.writeFile,\n      writeJsonSync: jsonFile.writeFileSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/output-file/index.js\nvar require_output_file = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/output-file/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    var fs4 = require_graceful_fs();\n    var path6 = require(\"path\");\n    var mkdir = require_mkdirs();\n    var pathExists = require_path_exists().pathExists;\n    function outputFile(file, data, encoding, callback) {\n      if (typeof encoding === \"function\") {\n        callback = encoding;\n        encoding = \"utf8\";\n      }\n      const dir = path6.dirname(file);\n      pathExists(dir, (err, itDoes) => {\n        if (err) return callback(err);\n        if (itDoes) return fs4.writeFile(file, data, encoding, callback);\n        mkdir.mkdirs(dir, (err2) => {\n          if (err2) return callback(err2);\n          fs4.writeFile(file, data, encoding, callback);\n        });\n      });\n    }\n    function outputFileSync(file, ...args) {\n      const dir = path6.dirname(file);\n      if (fs4.existsSync(dir)) {\n        return fs4.writeFileSync(file, ...args);\n      }\n      mkdir.mkdirsSync(dir);\n      fs4.writeFileSync(file, ...args);\n    }\n    module2.exports = {\n      outputFile: u(outputFile),\n      outputFileSync\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/json/output-json.js\nvar require_output_json = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/json/output-json.js\"(exports2, module2) {\n    \"use strict\";\n    var { stringify } = require_utils2();\n    var { outputFile } = require_output_file();\n    async function outputJson(file, data, options = {}) {\n      const str = stringify(data, options);\n      await outputFile(file, str, options);\n    }\n    module2.exports = outputJson;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/json/output-json-sync.js\nvar require_output_json_sync = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/json/output-json-sync.js\"(exports2, module2) {\n    \"use strict\";\n    var { stringify } = require_utils2();\n    var { outputFileSync } = require_output_file();\n    function outputJsonSync(file, data, options) {\n      const str = stringify(data, options);\n      outputFileSync(file, str, options);\n    }\n    module2.exports = outputJsonSync;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/json/index.js\nvar require_json = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/json/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromPromise;\n    var jsonFile = require_jsonfile2();\n    jsonFile.outputJson = u(require_output_json());\n    jsonFile.outputJsonSync = require_output_json_sync();\n    jsonFile.outputJSON = jsonFile.outputJson;\n    jsonFile.outputJSONSync = jsonFile.outputJsonSync;\n    jsonFile.writeJSON = jsonFile.writeJson;\n    jsonFile.writeJSONSync = jsonFile.writeJsonSync;\n    jsonFile.readJSON = jsonFile.readJson;\n    jsonFile.readJSONSync = jsonFile.readJsonSync;\n    module2.exports = jsonFile;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/move/move.js\nvar require_move = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/move/move.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    var path6 = require(\"path\");\n    var copy = require_copy2().copy;\n    var remove = require_remove().remove;\n    var mkdirp = require_mkdirs().mkdirp;\n    var pathExists = require_path_exists().pathExists;\n    var stat = require_stat();\n    function move(src, dest, opts, cb) {\n      if (typeof opts === \"function\") {\n        cb = opts;\n        opts = {};\n      }\n      opts = opts || {};\n      const overwrite = opts.overwrite || opts.clobber || false;\n      stat.checkPaths(src, dest, \"move\", opts, (err, stats) => {\n        if (err) return cb(err);\n        const { srcStat, isChangingCase = false } = stats;\n        stat.checkParentPaths(src, srcStat, dest, \"move\", (err2) => {\n          if (err2) return cb(err2);\n          if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb);\n          mkdirp(path6.dirname(dest), (err3) => {\n            if (err3) return cb(err3);\n            return doRename(src, dest, overwrite, isChangingCase, cb);\n          });\n        });\n      });\n    }\n    function isParentRoot(dest) {\n      const parent = path6.dirname(dest);\n      const parsedPath = path6.parse(parent);\n      return parsedPath.root === parent;\n    }\n    function doRename(src, dest, overwrite, isChangingCase, cb) {\n      if (isChangingCase) return rename(src, dest, overwrite, cb);\n      if (overwrite) {\n        return remove(dest, (err) => {\n          if (err) return cb(err);\n          return rename(src, dest, overwrite, cb);\n        });\n      }\n      pathExists(dest, (err, destExists) => {\n        if (err) return cb(err);\n        if (destExists) return cb(new Error(\"dest already exists.\"));\n        return rename(src, dest, overwrite, cb);\n      });\n    }\n    function rename(src, dest, overwrite, cb) {\n      fs4.rename(src, dest, (err) => {\n        if (!err) return cb();\n        if (err.code !== \"EXDEV\") return cb(err);\n        return moveAcrossDevice(src, dest, overwrite, cb);\n      });\n    }\n    function moveAcrossDevice(src, dest, overwrite, cb) {\n      const opts = {\n        overwrite,\n        errorOnExist: true\n      };\n      copy(src, dest, opts, (err) => {\n        if (err) return cb(err);\n        return remove(src, cb);\n      });\n    }\n    module2.exports = move;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/move/move-sync.js\nvar require_move_sync = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/move/move-sync.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require_graceful_fs();\n    var path6 = require(\"path\");\n    var copySync = require_copy2().copySync;\n    var removeSync = require_remove().removeSync;\n    var mkdirpSync = require_mkdirs().mkdirpSync;\n    var stat = require_stat();\n    function moveSync(src, dest, opts) {\n      opts = opts || {};\n      const overwrite = opts.overwrite || opts.clobber || false;\n      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, \"move\", opts);\n      stat.checkParentPathsSync(src, srcStat, dest, \"move\");\n      if (!isParentRoot(dest)) mkdirpSync(path6.dirname(dest));\n      return doRename(src, dest, overwrite, isChangingCase);\n    }\n    function isParentRoot(dest) {\n      const parent = path6.dirname(dest);\n      const parsedPath = path6.parse(parent);\n      return parsedPath.root === parent;\n    }\n    function doRename(src, dest, overwrite, isChangingCase) {\n      if (isChangingCase) return rename(src, dest, overwrite);\n      if (overwrite) {\n        removeSync(dest);\n        return rename(src, dest, overwrite);\n      }\n      if (fs4.existsSync(dest)) throw new Error(\"dest already exists.\");\n      return rename(src, dest, overwrite);\n    }\n    function rename(src, dest, overwrite) {\n      try {\n        fs4.renameSync(src, dest);\n      } catch (err) {\n        if (err.code !== \"EXDEV\") throw err;\n        return moveAcrossDevice(src, dest, overwrite);\n      }\n    }\n    function moveAcrossDevice(src, dest, overwrite) {\n      const opts = {\n        overwrite,\n        errorOnExist: true\n      };\n      copySync(src, dest, opts);\n      return removeSync(src);\n    }\n    module2.exports = moveSync;\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/move/index.js\nvar require_move2 = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/move/index.js\"(exports2, module2) {\n    \"use strict\";\n    var u = require_universalify().fromCallback;\n    module2.exports = {\n      move: u(require_move()),\n      moveSync: require_move_sync()\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/fs-extra/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/electron-updater/node_modules/fs-extra/lib/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {\n      // Export promiseified graceful-fs:\n      ...require_fs(),\n      // Export extra methods:\n      ...require_copy2(),\n      ...require_empty(),\n      ...require_ensure(),\n      ...require_json(),\n      ...require_mkdirs(),\n      ...require_move2(),\n      ...require_output_file(),\n      ...require_path_exists(),\n      ...require_remove()\n    };\n  }\n});\n\n// node_modules/builder-util-runtime/out/CancellationToken.js\nvar require_CancellationToken = __commonJS({\n  \"node_modules/builder-util-runtime/out/CancellationToken.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.CancellationError = exports2.CancellationToken = void 0;\n    var events_1 = require(\"events\");\n    var CancellationToken = class extends events_1.EventEmitter {\n      get cancelled() {\n        return this._cancelled || this._parent != null && this._parent.cancelled;\n      }\n      set parent(value) {\n        this.removeParentCancelHandler();\n        this._parent = value;\n        this.parentCancelHandler = () => this.cancel();\n        this._parent.onCancel(this.parentCancelHandler);\n      }\n      // babel cannot compile ... correctly for super calls\n      constructor(parent) {\n        super();\n        this.parentCancelHandler = null;\n        this._parent = null;\n        this._cancelled = false;\n        if (parent != null) {\n          this.parent = parent;\n        }\n      }\n      cancel() {\n        this._cancelled = true;\n        this.emit(\"cancel\");\n      }\n      onCancel(handler) {\n        if (this.cancelled) {\n          handler();\n        } else {\n          this.once(\"cancel\", handler);\n        }\n      }\n      createPromise(callback) {\n        if (this.cancelled) {\n          return Promise.reject(new CancellationError());\n        }\n        const finallyHandler = () => {\n          if (cancelHandler != null) {\n            try {\n              this.removeListener(\"cancel\", cancelHandler);\n              cancelHandler = null;\n            } catch (_ignore) {\n            }\n          }\n        };\n        let cancelHandler = null;\n        return new Promise((resolve, reject) => {\n          let addedCancelHandler = null;\n          cancelHandler = () => {\n            try {\n              if (addedCancelHandler != null) {\n                addedCancelHandler();\n                addedCancelHandler = null;\n              }\n            } finally {\n              reject(new CancellationError());\n            }\n          };\n          if (this.cancelled) {\n            cancelHandler();\n            return;\n          }\n          this.onCancel(cancelHandler);\n          callback(resolve, reject, (callback2) => {\n            addedCancelHandler = callback2;\n          });\n        }).then((it) => {\n          finallyHandler();\n          return it;\n        }).catch((e) => {\n          finallyHandler();\n          throw e;\n        });\n      }\n      removeParentCancelHandler() {\n        const parent = this._parent;\n        if (parent != null && this.parentCancelHandler != null) {\n          parent.removeListener(\"cancel\", this.parentCancelHandler);\n          this.parentCancelHandler = null;\n        }\n      }\n      dispose() {\n        try {\n          this.removeParentCancelHandler();\n        } finally {\n          this.removeAllListeners();\n          this._parent = null;\n        }\n      }\n    };\n    exports2.CancellationToken = CancellationToken;\n    var CancellationError = class extends Error {\n      constructor() {\n        super(\"cancelled\");\n      }\n    };\n    exports2.CancellationError = CancellationError;\n  }\n});\n\n// node_modules/builder-util-runtime/out/error.js\nvar require_error = __commonJS({\n  \"node_modules/builder-util-runtime/out/error.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.newError = newError;\n    function newError(message, code) {\n      const error = new Error(message);\n      error.code = code;\n      return error;\n    }\n  }\n});\n\n// node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"node_modules/ms/index.js\"(exports2, module2) {\n    var s = 1e3;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    module2.exports = function(val, options) {\n      options = options || {};\n      var type = typeof val;\n      if (type === \"string\" && val.length > 0) {\n        return parse(val);\n      } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n      );\n    };\n    function parse(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type = (match[2] || \"ms\").toLowerCase();\n      switch (type) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    function fmtShort(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n      }\n      if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n      }\n      if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n      }\n      return ms + \"ms\";\n    }\n    function fmtLong(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n      }\n      if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n      }\n      if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n      }\n      return ms + \" ms\";\n    }\n    function plural(ms, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n  }\n});\n\n// node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"node_modules/debug/src/common.js\"(exports2, module2) {\n    function setup(env) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env).forEach((key) => {\n        createDebug[key] = env[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n          if (!debug.enabled) {\n            return;\n          }\n          const self2 = debug;\n          const curr = Number(/* @__PURE__ */ new Date());\n          const ms = curr - (prevTime || curr);\n          self2.diff = ms;\n          self2.prev = prevTime;\n          self2.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format];\n            if (typeof formatter === \"function\") {\n              const val = args[index];\n              match = formatter.call(self2, val);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self2, args);\n          const logFn = self2.log || createDebug.log;\n          logFn.apply(self2, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy;\n        Object.defineProperty(debug, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v) => {\n            enableOverride = v;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug);\n        }\n        return debug;\n      }\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").trim().replace(/\\s+/g, \",\").split(\",\").filter(Boolean);\n        for (const ns of split) {\n          if (ns[0] === \"-\") {\n            createDebug.skips.push(ns.slice(1));\n          } else {\n            createDebug.names.push(ns);\n          }\n        }\n      }\n      function matchesTemplate(search, template) {\n        let searchIndex = 0;\n        let templateIndex = 0;\n        let starIndex = -1;\n        let matchIndex = 0;\n        while (searchIndex < search.length) {\n          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === \"*\")) {\n            if (template[templateIndex] === \"*\") {\n              starIndex = templateIndex;\n              matchIndex = searchIndex;\n              templateIndex++;\n            } else {\n              searchIndex++;\n              templateIndex++;\n            }\n          } else if (starIndex !== -1) {\n            templateIndex = starIndex + 1;\n            matchIndex++;\n            searchIndex = matchIndex;\n          } else {\n            return false;\n          }\n        }\n        while (templateIndex < template.length && template[templateIndex] === \"*\") {\n          templateIndex++;\n        }\n        return templateIndex === template.length;\n      }\n      function disable() {\n        const namespaces = [\n          ...createDebug.names,\n          ...createDebug.skips.map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      function enabled(name) {\n        for (const skip of createDebug.skips) {\n          if (matchesTemplate(name, skip)) {\n            return false;\n          }\n        }\n        for (const ns of createDebug.names) {\n          if (matchesTemplate(name, ns)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function coerce(val) {\n        if (val instanceof Error) {\n          return val.stack || val.message;\n        }\n        return val;\n      }\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    module2.exports = setup;\n  }\n});\n\n// node_modules/debug/src/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/debug/src/browser.js\"(exports2, module2) {\n    exports2.formatArgs = formatArgs;\n    exports2.save = save;\n    exports2.load = load;\n    exports2.useColors = useColors;\n    exports2.storage = localstorage();\n    exports2.destroy = /* @__PURE__ */ (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports2.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      let m;\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module2.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c = \"color: \" + this.color;\n      args.splice(1, 0, c, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c);\n    }\n    exports2.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports2.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports2.storage.removeItem(\"debug\");\n        }\n      } catch (error) {\n      }\n    }\n    function load() {\n      let r;\n      try {\n        r = exports2.storage.getItem(\"debug\") || exports2.storage.getItem(\"DEBUG\");\n      } catch (error) {\n      }\n      if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n      }\n      return r;\n    }\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error) {\n      }\n    }\n    module2.exports = require_common()(exports2);\n    var { formatters } = module2.exports;\n    formatters.j = function(v) {\n      try {\n        return JSON.stringify(v);\n      } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n      }\n    };\n  }\n});\n\n// node_modules/has-flag/index.js\nvar require_has_flag = __commonJS({\n  \"node_modules/has-flag/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = (flag, argv = process.argv) => {\n      const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";\n      const position = argv.indexOf(prefix + flag);\n      const terminatorPosition = argv.indexOf(\"--\");\n      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n    };\n  }\n});\n\n// node_modules/supports-color/index.js\nvar require_supports_color = __commonJS({\n  \"node_modules/supports-color/index.js\"(exports2, module2) {\n    \"use strict\";\n    var os = require(\"os\");\n    var tty = require(\"tty\");\n    var hasFlag = require_has_flag();\n    var { env } = process;\n    var forceColor;\n    if (hasFlag(\"no-color\") || hasFlag(\"no-colors\") || hasFlag(\"color=false\") || hasFlag(\"color=never\")) {\n      forceColor = 0;\n    } else if (hasFlag(\"color\") || hasFlag(\"colors\") || hasFlag(\"color=true\") || hasFlag(\"color=always\")) {\n      forceColor = 1;\n    }\n    if (\"FORCE_COLOR\" in env) {\n      if (env.FORCE_COLOR === \"true\") {\n        forceColor = 1;\n      } else if (env.FORCE_COLOR === \"false\") {\n        forceColor = 0;\n      } else {\n        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n      }\n    }\n    function translateLevel(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    function supportsColor(haveStream, streamIsTTY) {\n      if (forceColor === 0) {\n        return 0;\n      }\n      if (hasFlag(\"color=16m\") || hasFlag(\"color=full\") || hasFlag(\"color=truecolor\")) {\n        return 3;\n      }\n      if (hasFlag(\"color=256\")) {\n        return 2;\n      }\n      if (haveStream && !streamIsTTY && forceColor === void 0) {\n        return 0;\n      }\n      const min = forceColor || 0;\n      if (env.TERM === \"dumb\") {\n        return min;\n      }\n      if (process.platform === \"win32\") {\n        const osRelease = os.release().split(\".\");\n        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if (\"CI\" in env) {\n        if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\", \"BUILDKITE\"].some((sign) => sign in env) || env.CI_NAME === \"codeship\") {\n          return 1;\n        }\n        return min;\n      }\n      if (\"TEAMCITY_VERSION\" in env) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env.COLORTERM === \"truecolor\") {\n        return 3;\n      }\n      if (\"TERM_PROGRAM\" in env) {\n        const version = parseInt((env.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n        switch (env.TERM_PROGRAM) {\n          case \"iTerm.app\":\n            return version >= 3 ? 3 : 2;\n          case \"Apple_Terminal\":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n        return 1;\n      }\n      if (\"COLORTERM\" in env) {\n        return 1;\n      }\n      return min;\n    }\n    function getSupportLevel(stream) {\n      const level = supportsColor(stream, stream && stream.isTTY);\n      return translateLevel(level);\n    }\n    module2.exports = {\n      supportsColor: getSupportLevel,\n      stdout: translateLevel(supportsColor(true, tty.isatty(1))),\n      stderr: translateLevel(supportsColor(true, tty.isatty(2)))\n    };\n  }\n});\n\n// node_modules/debug/src/node.js\nvar require_node = __commonJS({\n  \"node_modules/debug/src/node.js\"(exports2, module2) {\n    var tty = require(\"tty\");\n    var util = require(\"util\");\n    exports2.init = init;\n    exports2.log = log12;\n    exports2.formatArgs = formatArgs;\n    exports2.save = save;\n    exports2.load = load;\n    exports2.useColors = useColors;\n    exports2.destroy = util.deprecate(\n      () => {\n      },\n      \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n    );\n    exports2.colors = [6, 2, 3, 4, 5, 1];\n    try {\n      const supportsColor = require_supports_color();\n      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports2.colors = [\n          20,\n          21,\n          26,\n          27,\n          32,\n          33,\n          38,\n          39,\n          40,\n          41,\n          42,\n          43,\n          44,\n          45,\n          56,\n          57,\n          62,\n          63,\n          68,\n          69,\n          74,\n          75,\n          76,\n          77,\n          78,\n          79,\n          80,\n          81,\n          92,\n          93,\n          98,\n          99,\n          112,\n          113,\n          128,\n          129,\n          134,\n          135,\n          148,\n          149,\n          160,\n          161,\n          162,\n          163,\n          164,\n          165,\n          166,\n          167,\n          168,\n          169,\n          170,\n          171,\n          172,\n          173,\n          178,\n          179,\n          184,\n          185,\n          196,\n          197,\n          198,\n          199,\n          200,\n          201,\n          202,\n          203,\n          204,\n          205,\n          206,\n          207,\n          208,\n          209,\n          214,\n          215,\n          220,\n          221\n        ];\n      }\n    } catch (error) {\n    }\n    exports2.inspectOpts = Object.keys(process.env).filter((key) => {\n      return /^debug_/i.test(key);\n    }).reduce((obj, key) => {\n      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {\n        return k.toUpperCase();\n      });\n      let val = process.env[key];\n      if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n      } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n      } else if (val === \"null\") {\n        val = null;\n      } else {\n        val = Number(val);\n      }\n      obj[prop] = val;\n      return obj;\n    }, {});\n    function useColors() {\n      return \"colors\" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n    }\n    function formatArgs(args) {\n      const { namespace: name, useColors: useColors2 } = this;\n      if (useColors2) {\n        const c = this.color;\n        const colorCode = \"\\x1B[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\x1B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module2.exports.humanize(this.diff) + \"\\x1B[0m\");\n      } else {\n        args[0] = getDate() + name + \" \" + args[0];\n      }\n    }\n    function getDate() {\n      if (exports2.inspectOpts.hideDate) {\n        return \"\";\n      }\n      return (/* @__PURE__ */ new Date()).toISOString() + \" \";\n    }\n    function log12(...args) {\n      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + \"\\n\");\n    }\n    function save(namespaces) {\n      if (namespaces) {\n        process.env.DEBUG = namespaces;\n      } else {\n        delete process.env.DEBUG;\n      }\n    }\n    function load() {\n      return process.env.DEBUG;\n    }\n    function init(debug) {\n      debug.inspectOpts = {};\n      const keys = Object.keys(exports2.inspectOpts);\n      for (let i = 0; i < keys.length; i++) {\n        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];\n      }\n    }\n    module2.exports = require_common()(exports2);\n    var { formatters } = module2.exports;\n    formatters.o = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str) => str.trim()).join(\" \");\n    };\n    formatters.O = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util.inspect(v, this.inspectOpts);\n    };\n  }\n});\n\n// node_modules/debug/src/index.js\nvar require_src = __commonJS({\n  \"node_modules/debug/src/index.js\"(exports2, module2) {\n    if (typeof process === \"undefined\" || process.type === \"renderer\" || process.browser === true || process.__nwjs) {\n      module2.exports = require_browser();\n    } else {\n      module2.exports = require_node();\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/ProgressCallbackTransform.js\nvar require_ProgressCallbackTransform = __commonJS({\n  \"node_modules/builder-util-runtime/out/ProgressCallbackTransform.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.ProgressCallbackTransform = void 0;\n    var stream_1 = require(\"stream\");\n    var ProgressCallbackTransform = class extends stream_1.Transform {\n      constructor(total, cancellationToken, onProgress) {\n        super();\n        this.total = total;\n        this.cancellationToken = cancellationToken;\n        this.onProgress = onProgress;\n        this.start = Date.now();\n        this.transferred = 0;\n        this.delta = 0;\n        this.nextUpdate = this.start + 1e3;\n      }\n      _transform(chunk, encoding, callback) {\n        if (this.cancellationToken.cancelled) {\n          callback(new Error(\"cancelled\"), null);\n          return;\n        }\n        this.transferred += chunk.length;\n        this.delta += chunk.length;\n        const now = Date.now();\n        if (now >= this.nextUpdate && this.transferred !== this.total) {\n          this.nextUpdate = now + 1e3;\n          this.onProgress({\n            total: this.total,\n            delta: this.delta,\n            transferred: this.transferred,\n            percent: this.transferred / this.total * 100,\n            bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))\n          });\n          this.delta = 0;\n        }\n        callback(null, chunk);\n      }\n      _flush(callback) {\n        if (this.cancellationToken.cancelled) {\n          callback(new Error(\"cancelled\"));\n          return;\n        }\n        this.onProgress({\n          total: this.total,\n          delta: this.delta,\n          transferred: this.total,\n          percent: 100,\n          bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))\n        });\n        this.delta = 0;\n        callback(null);\n      }\n    };\n    exports2.ProgressCallbackTransform = ProgressCallbackTransform;\n  }\n});\n\n// node_modules/builder-util-runtime/out/httpExecutor.js\nvar require_httpExecutor = __commonJS({\n  \"node_modules/builder-util-runtime/out/httpExecutor.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DigestTransform = exports2.HttpExecutor = exports2.HttpError = void 0;\n    exports2.createHttpError = createHttpError;\n    exports2.parseJson = parseJson;\n    exports2.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;\n    exports2.configureRequestUrl = configureRequestUrl;\n    exports2.safeGetHeader = safeGetHeader;\n    exports2.configureRequestOptions = configureRequestOptions;\n    exports2.safeStringifyJson = safeStringifyJson;\n    var crypto_1 = require(\"crypto\");\n    var debug_1 = require_src();\n    var fs_1 = require(\"fs\");\n    var stream_1 = require(\"stream\");\n    var url_1 = require(\"url\");\n    var CancellationToken_1 = require_CancellationToken();\n    var error_1 = require_error();\n    var ProgressCallbackTransform_1 = require_ProgressCallbackTransform();\n    var debug = (0, debug_1.default)(\"electron-builder\");\n    function createHttpError(response, description = null) {\n      return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? \"\" : \"\\n\" + JSON.stringify(description, null, \"  \")) + \"\\nHeaders: \" + safeStringifyJson(response.headers), description);\n    }\n    var HTTP_STATUS_CODES = /* @__PURE__ */ new Map([\n      [429, \"Too many requests\"],\n      [400, \"Bad request\"],\n      [403, \"Forbidden\"],\n      [404, \"Not found\"],\n      [405, \"Method not allowed\"],\n      [406, \"Not acceptable\"],\n      [408, \"Request timeout\"],\n      [413, \"Request entity too large\"],\n      [500, \"Internal server error\"],\n      [502, \"Bad gateway\"],\n      [503, \"Service unavailable\"],\n      [504, \"Gateway timeout\"],\n      [505, \"HTTP version not supported\"]\n    ]);\n    var HttpError = class extends Error {\n      constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {\n        super(message);\n        this.statusCode = statusCode;\n        this.description = description;\n        this.name = \"HttpError\";\n        this.code = `HTTP_ERROR_${statusCode}`;\n      }\n      isServerError() {\n        return this.statusCode >= 500 && this.statusCode <= 599;\n      }\n    };\n    exports2.HttpError = HttpError;\n    function parseJson(result) {\n      return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));\n    }\n    var HttpExecutor = class _HttpExecutor {\n      constructor() {\n        this.maxRedirects = 10;\n      }\n      request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {\n        configureRequestOptions(options);\n        const json = data == null ? void 0 : JSON.stringify(data);\n        const encodedData = json ? Buffer.from(json) : void 0;\n        if (encodedData != null) {\n          debug(json);\n          const { headers, ...opts } = options;\n          options = {\n            method: \"post\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Content-Length\": encodedData.length,\n              ...headers\n            },\n            ...opts\n          };\n        }\n        return this.doApiRequest(options, cancellationToken, (it) => it.end(encodedData));\n      }\n      doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {\n        if (debug.enabled) {\n          debug(`Request: ${safeStringifyJson(options)}`);\n        }\n        return cancellationToken.createPromise((resolve, reject, onCancel) => {\n          const request = this.createRequest(options, (response) => {\n            try {\n              this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);\n            } catch (e) {\n              reject(e);\n            }\n          });\n          this.addErrorAndTimeoutHandlers(request, reject, options.timeout);\n          this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {\n            this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);\n          });\n          requestProcessor(request, reject);\n          onCancel(() => request.abort());\n        });\n      }\n      // noinspection JSUnusedLocalSymbols\n      // eslint-disable-next-line\n      addRedirectHandlers(request, options, reject, redirectCount, handler) {\n      }\n      addErrorAndTimeoutHandlers(request, reject, timeout = 60 * 1e3) {\n        this.addTimeOutHandler(request, reject, timeout);\n        request.on(\"error\", reject);\n        request.on(\"aborted\", () => {\n          reject(new Error(\"Request has been aborted by the server\"));\n        });\n      }\n      handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {\n        var _a;\n        if (debug.enabled) {\n          debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);\n        }\n        if (response.statusCode === 404) {\n          reject(createHttpError(response, `method: ${options.method || \"GET\"} url: ${options.protocol || \"https:\"}//${options.hostname}${options.port ? `:${options.port}` : \"\"}${options.path}\n\nPlease double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.\n`));\n          return;\n        } else if (response.statusCode === 204) {\n          resolve();\n          return;\n        }\n        const code = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;\n        const shouldRedirect = code >= 300 && code < 400;\n        const redirectUrl = safeGetHeader(response, \"location\");\n        if (shouldRedirect && redirectUrl != null) {\n          if (redirectCount > this.maxRedirects) {\n            reject(this.createMaxRedirectError());\n            return;\n          }\n          this.doApiRequest(_HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);\n          return;\n        }\n        response.setEncoding(\"utf8\");\n        let data = \"\";\n        response.on(\"error\", reject);\n        response.on(\"data\", (chunk) => data += chunk);\n        response.on(\"end\", () => {\n          try {\n            if (response.statusCode != null && response.statusCode >= 400) {\n              const contentType = safeGetHeader(response, \"content-type\");\n              const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes(\"json\")) != null : contentType.includes(\"json\"));\n              reject(createHttpError(response, `method: ${options.method || \"GET\"} url: ${options.protocol || \"https:\"}//${options.hostname}${options.port ? `:${options.port}` : \"\"}${options.path}\n\n          Data:\n          ${isJson ? JSON.stringify(JSON.parse(data)) : data}\n          `));\n            } else {\n              resolve(data.length === 0 ? null : data);\n            }\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }\n      async downloadToBuffer(url, options) {\n        return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {\n          const responseChunks = [];\n          const requestOptions = {\n            headers: options.headers || void 0,\n            // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually\n            redirect: \"manual\"\n          };\n          configureRequestUrl(url, requestOptions);\n          configureRequestOptions(requestOptions);\n          this.doDownload(requestOptions, {\n            destination: null,\n            options,\n            onCancel,\n            callback: (error) => {\n              if (error == null) {\n                resolve(Buffer.concat(responseChunks));\n              } else {\n                reject(error);\n              }\n            },\n            responseHandler: (response, callback) => {\n              let receivedLength = 0;\n              response.on(\"data\", (chunk) => {\n                receivedLength += chunk.length;\n                if (receivedLength > 524288e3) {\n                  callback(new Error(\"Maximum allowed size is 500 MB\"));\n                  return;\n                }\n                responseChunks.push(chunk);\n              });\n              response.on(\"end\", () => {\n                callback(null);\n              });\n            }\n          }, 0);\n        });\n      }\n      doDownload(requestOptions, options, redirectCount) {\n        const request = this.createRequest(requestOptions, (response) => {\n          if (response.statusCode >= 400) {\n            options.callback(new Error(`Cannot download \"${requestOptions.protocol || \"https:\"}//${requestOptions.hostname}${requestOptions.path}\", status ${response.statusCode}: ${response.statusMessage}`));\n            return;\n          }\n          response.on(\"error\", options.callback);\n          const redirectUrl = safeGetHeader(response, \"location\");\n          if (redirectUrl != null) {\n            if (redirectCount < this.maxRedirects) {\n              this.doDownload(_HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);\n            } else {\n              options.callback(this.createMaxRedirectError());\n            }\n            return;\n          }\n          if (options.responseHandler == null) {\n            configurePipes(options, response);\n          } else {\n            options.responseHandler(response, options.callback);\n          }\n        });\n        this.addErrorAndTimeoutHandlers(request, options.callback, requestOptions.timeout);\n        this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {\n          this.doDownload(requestOptions2, options, redirectCount++);\n        });\n        request.end();\n      }\n      createMaxRedirectError() {\n        return new Error(`Too many redirects (> ${this.maxRedirects})`);\n      }\n      addTimeOutHandler(request, callback, timeout) {\n        request.on(\"socket\", (socket) => {\n          socket.setTimeout(timeout, () => {\n            request.abort();\n            callback(new Error(\"Request timed out\"));\n          });\n        });\n      }\n      static prepareRedirectUrlOptions(redirectUrl, options) {\n        const newOptions = configureRequestOptionsFromUrl(redirectUrl, { ...options });\n        const headers = newOptions.headers;\n        if (headers === null || headers === void 0 ? void 0 : headers.authorization) {\n          const parsedNewUrl = new url_1.URL(redirectUrl);\n          if (parsedNewUrl.hostname.endsWith(\".amazonaws.com\") || parsedNewUrl.searchParams.has(\"X-Amz-Credential\")) {\n            delete headers.authorization;\n          }\n        }\n        return newOptions;\n      }\n      static retryOnServerError(task, maxRetries = 3) {\n        for (let attemptNumber = 0; ; attemptNumber++) {\n          try {\n            return task();\n          } catch (e) {\n            if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === \"EPIPE\")) {\n              continue;\n            }\n            throw e;\n          }\n        }\n      }\n    };\n    exports2.HttpExecutor = HttpExecutor;\n    function configureRequestOptionsFromUrl(url, options) {\n      const result = configureRequestOptions(options);\n      configureRequestUrl(new url_1.URL(url), result);\n      return result;\n    }\n    function configureRequestUrl(url, options) {\n      options.protocol = url.protocol;\n      options.hostname = url.hostname;\n      if (url.port) {\n        options.port = url.port;\n      } else if (options.port) {\n        delete options.port;\n      }\n      options.path = url.pathname + url.search;\n    }\n    var DigestTransform = class extends stream_1.Transform {\n      // noinspection JSUnusedGlobalSymbols\n      get actual() {\n        return this._actual;\n      }\n      constructor(expected, algorithm = \"sha512\", encoding = \"base64\") {\n        super();\n        this.expected = expected;\n        this.algorithm = algorithm;\n        this.encoding = encoding;\n        this._actual = null;\n        this.isValidateOnEnd = true;\n        this.digester = (0, crypto_1.createHash)(algorithm);\n      }\n      // noinspection JSUnusedGlobalSymbols\n      _transform(chunk, encoding, callback) {\n        this.digester.update(chunk);\n        callback(null, chunk);\n      }\n      // noinspection JSUnusedGlobalSymbols\n      _flush(callback) {\n        this._actual = this.digester.digest(this.encoding);\n        if (this.isValidateOnEnd) {\n          try {\n            this.validate();\n          } catch (e) {\n            callback(e);\n            return;\n          }\n        }\n        callback(null);\n      }\n      validate() {\n        if (this._actual == null) {\n          throw (0, error_1.newError)(\"Not finished yet\", \"ERR_STREAM_NOT_FINISHED\");\n        }\n        if (this._actual !== this.expected) {\n          throw (0, error_1.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, \"ERR_CHECKSUM_MISMATCH\");\n        }\n        return null;\n      }\n    };\n    exports2.DigestTransform = DigestTransform;\n    function checkSha2(sha2Header, sha2, callback) {\n      if (sha2Header != null && sha2 != null && sha2Header !== sha2) {\n        callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));\n        return false;\n      }\n      return true;\n    }\n    function safeGetHeader(response, headerKey) {\n      const value = response.headers[headerKey];\n      if (value == null) {\n        return null;\n      } else if (Array.isArray(value)) {\n        return value.length === 0 ? null : value[value.length - 1];\n      } else {\n        return value;\n      }\n    }\n    function configurePipes(options, response) {\n      if (!checkSha2(safeGetHeader(response, \"X-Checksum-Sha2\"), options.options.sha2, options.callback)) {\n        return;\n      }\n      const streams = [];\n      if (options.options.onProgress != null) {\n        const contentLength = safeGetHeader(response, \"content-length\");\n        if (contentLength != null) {\n          streams.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));\n        }\n      }\n      const sha512 = options.options.sha512;\n      if (sha512 != null) {\n        streams.push(new DigestTransform(sha512, \"sha512\", sha512.length === 128 && !sha512.includes(\"+\") && !sha512.includes(\"Z\") && !sha512.includes(\"=\") ? \"hex\" : \"base64\"));\n      } else if (options.options.sha2 != null) {\n        streams.push(new DigestTransform(options.options.sha2, \"sha256\", \"hex\"));\n      }\n      const fileOut = (0, fs_1.createWriteStream)(options.destination);\n      streams.push(fileOut);\n      let lastStream = response;\n      for (const stream of streams) {\n        stream.on(\"error\", (error) => {\n          fileOut.close();\n          if (!options.options.cancellationToken.cancelled) {\n            options.callback(error);\n          }\n        });\n        lastStream = lastStream.pipe(stream);\n      }\n      fileOut.on(\"finish\", () => {\n        ;\n        fileOut.close(options.callback);\n      });\n    }\n    function configureRequestOptions(options, token, method) {\n      if (method != null) {\n        options.method = method;\n      }\n      options.headers = { ...options.headers };\n      const headers = options.headers;\n      if (token != null) {\n        ;\n        headers.authorization = token.startsWith(\"Basic\") || token.startsWith(\"Bearer\") ? token : `token ${token}`;\n      }\n      if (headers[\"User-Agent\"] == null) {\n        headers[\"User-Agent\"] = \"electron-builder\";\n      }\n      if (method == null || method === \"GET\" || headers[\"Cache-Control\"] == null) {\n        headers[\"Cache-Control\"] = \"no-cache\";\n      }\n      if (options.protocol == null && process.versions.electron != null) {\n        options.protocol = \"https:\";\n      }\n      return options;\n    }\n    function safeStringifyJson(data, skippedNames) {\n      return JSON.stringify(data, (name, value) => {\n        if (name.endsWith(\"Authorization\") || name.endsWith(\"authorization\") || name.endsWith(\"Password\") || name.endsWith(\"PASSWORD\") || name.endsWith(\"Token\") || name.includes(\"password\") || name.includes(\"token\") || skippedNames != null && skippedNames.has(name)) {\n          return \"<stripped sensitive data>\";\n        }\n        return value;\n      }, 2);\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/MemoLazy.js\nvar require_MemoLazy = __commonJS({\n  \"node_modules/builder-util-runtime/out/MemoLazy.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.MemoLazy = void 0;\n    var MemoLazy = class {\n      constructor(selector, creator) {\n        this.selector = selector;\n        this.creator = creator;\n        this.selected = void 0;\n        this._value = void 0;\n      }\n      get hasValue() {\n        return this._value !== void 0;\n      }\n      get value() {\n        const selected = this.selector();\n        if (this._value !== void 0 && equals(this.selected, selected)) {\n          return this._value;\n        }\n        this.selected = selected;\n        const result = this.creator(selected);\n        this.value = result;\n        return result;\n      }\n      set value(value) {\n        this._value = value;\n      }\n    };\n    exports2.MemoLazy = MemoLazy;\n    function equals(firstValue, secondValue) {\n      const isFirstObject = typeof firstValue === \"object\" && firstValue !== null;\n      const isSecondObject = typeof secondValue === \"object\" && secondValue !== null;\n      if (isFirstObject && isSecondObject) {\n        const keys1 = Object.keys(firstValue);\n        const keys2 = Object.keys(secondValue);\n        return keys1.length === keys2.length && keys1.every((key) => equals(firstValue[key], secondValue[key]));\n      }\n      return firstValue === secondValue;\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/publishOptions.js\nvar require_publishOptions = __commonJS({\n  \"node_modules/builder-util-runtime/out/publishOptions.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.githubUrl = githubUrl;\n    exports2.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;\n    function githubUrl(options, defaultHost = \"github.com\") {\n      return `${options.protocol || \"https\"}://${options.host || defaultHost}`;\n    }\n    function getS3LikeProviderBaseUrl(configuration) {\n      const provider = configuration.provider;\n      if (provider === \"s3\") {\n        return s3Url(configuration);\n      }\n      if (provider === \"spaces\") {\n        return spacesUrl(configuration);\n      }\n      throw new Error(`Not supported provider: ${provider}`);\n    }\n    function s3Url(options) {\n      let url;\n      if (options.accelerate == true) {\n        url = `https://${options.bucket}.s3-accelerate.amazonaws.com`;\n      } else if (options.endpoint != null) {\n        url = `${options.endpoint}/${options.bucket}`;\n      } else if (options.bucket.includes(\".\")) {\n        if (options.region == null) {\n          throw new Error(`Bucket name \"${options.bucket}\" includes a dot, but S3 region is missing`);\n        }\n        if (options.region === \"us-east-1\") {\n          url = `https://s3.amazonaws.com/${options.bucket}`;\n        } else {\n          url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;\n        }\n      } else if (options.region === \"cn-north-1\") {\n        url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;\n      } else {\n        url = `https://${options.bucket}.s3.amazonaws.com`;\n      }\n      return appendPath(url, options.path);\n    }\n    function appendPath(url, p) {\n      if (p != null && p.length > 0) {\n        if (!p.startsWith(\"/\")) {\n          url += \"/\";\n        }\n        url += p;\n      }\n      return url;\n    }\n    function spacesUrl(options) {\n      if (options.name == null) {\n        throw new Error(`name is missing`);\n      }\n      if (options.region == null) {\n        throw new Error(`region is missing`);\n      }\n      return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/retry.js\nvar require_retry = __commonJS({\n  \"node_modules/builder-util-runtime/out/retry.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.retry = retry;\n    var CancellationToken_1 = require_CancellationToken();\n    async function retry(task, retryCount, interval, backoff = 0, attempt = 0, shouldRetry) {\n      var _a;\n      const cancellationToken = new CancellationToken_1.CancellationToken();\n      try {\n        return await task();\n      } catch (error) {\n        if (((_a = shouldRetry === null || shouldRetry === void 0 ? void 0 : shouldRetry(error)) !== null && _a !== void 0 ? _a : true) && retryCount > 0 && !cancellationToken.cancelled) {\n          await new Promise((resolve) => setTimeout(resolve, interval + backoff * attempt));\n          return await retry(task, retryCount - 1, interval, backoff, attempt + 1, shouldRetry);\n        } else {\n          throw error;\n        }\n      }\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/rfc2253Parser.js\nvar require_rfc2253Parser = __commonJS({\n  \"node_modules/builder-util-runtime/out/rfc2253Parser.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.parseDn = parseDn;\n    function parseDn(seq) {\n      let quoted = false;\n      let key = null;\n      let token = \"\";\n      let nextNonSpace = 0;\n      seq = seq.trim();\n      const result = /* @__PURE__ */ new Map();\n      for (let i = 0; i <= seq.length; i++) {\n        if (i === seq.length) {\n          if (key !== null) {\n            result.set(key, token);\n          }\n          break;\n        }\n        const ch = seq[i];\n        if (quoted) {\n          if (ch === '\"') {\n            quoted = false;\n            continue;\n          }\n        } else {\n          if (ch === '\"') {\n            quoted = true;\n            continue;\n          }\n          if (ch === \"\\\\\") {\n            i++;\n            const ord = parseInt(seq.slice(i, i + 2), 16);\n            if (Number.isNaN(ord)) {\n              token += seq[i];\n            } else {\n              i++;\n              token += String.fromCharCode(ord);\n            }\n            continue;\n          }\n          if (key === null && ch === \"=\") {\n            key = token;\n            token = \"\";\n            continue;\n          }\n          if (ch === \",\" || ch === \";\" || ch === \"+\") {\n            if (key !== null) {\n              result.set(key, token);\n            }\n            key = null;\n            token = \"\";\n            continue;\n          }\n        }\n        if (ch === \" \" && !quoted) {\n          if (token.length === 0) {\n            continue;\n          }\n          if (i > nextNonSpace) {\n            let j = i;\n            while (seq[j] === \" \") {\n              j++;\n            }\n            nextNonSpace = j;\n          }\n          if (nextNonSpace >= seq.length || seq[nextNonSpace] === \",\" || seq[nextNonSpace] === \";\" || key === null && seq[nextNonSpace] === \"=\" || key !== null && seq[nextNonSpace] === \"+\") {\n            i = nextNonSpace - 1;\n            continue;\n          }\n        }\n        token += ch;\n      }\n      return result;\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/uuid.js\nvar require_uuid = __commonJS({\n  \"node_modules/builder-util-runtime/out/uuid.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.nil = exports2.UUID = void 0;\n    var crypto_1 = require(\"crypto\");\n    var error_1 = require_error();\n    var invalidName = \"options.name must be either a string or a Buffer\";\n    var randomHost = (0, crypto_1.randomBytes)(16);\n    randomHost[0] = randomHost[0] | 1;\n    var hex2byte = {};\n    var byte2hex = [];\n    for (let i = 0; i < 256; i++) {\n      const hex = (i + 256).toString(16).substr(1);\n      hex2byte[hex] = i;\n      byte2hex[i] = hex;\n    }\n    var UUID = class _UUID {\n      constructor(uuid) {\n        this.ascii = null;\n        this.binary = null;\n        const check = _UUID.check(uuid);\n        if (!check) {\n          throw new Error(\"not a UUID\");\n        }\n        this.version = check.version;\n        if (check.format === \"ascii\") {\n          this.ascii = uuid;\n        } else {\n          this.binary = uuid;\n        }\n      }\n      static v5(name, namespace) {\n        return uuidNamed(name, \"sha1\", 80, namespace);\n      }\n      toString() {\n        if (this.ascii == null) {\n          this.ascii = stringify(this.binary);\n        }\n        return this.ascii;\n      }\n      inspect() {\n        return `UUID v${this.version} ${this.toString()}`;\n      }\n      static check(uuid, offset = 0) {\n        if (typeof uuid === \"string\") {\n          uuid = uuid.toLowerCase();\n          if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid)) {\n            return false;\n          }\n          if (uuid === \"00000000-0000-0000-0000-000000000000\") {\n            return { version: void 0, variant: \"nil\", format: \"ascii\" };\n          }\n          return {\n            version: (hex2byte[uuid[14] + uuid[15]] & 240) >> 4,\n            variant: getVariant((hex2byte[uuid[19] + uuid[20]] & 224) >> 5),\n            format: \"ascii\"\n          };\n        }\n        if (Buffer.isBuffer(uuid)) {\n          if (uuid.length < offset + 16) {\n            return false;\n          }\n          let i = 0;\n          for (; i < 16; i++) {\n            if (uuid[offset + i] !== 0) {\n              break;\n            }\n          }\n          if (i === 16) {\n            return { version: void 0, variant: \"nil\", format: \"binary\" };\n          }\n          return {\n            version: (uuid[offset + 6] & 240) >> 4,\n            variant: getVariant((uuid[offset + 8] & 224) >> 5),\n            format: \"binary\"\n          };\n        }\n        throw (0, error_1.newError)(\"Unknown type of uuid\", \"ERR_UNKNOWN_UUID_TYPE\");\n      }\n      // read stringified uuid into a Buffer\n      static parse(input) {\n        const buffer = Buffer.allocUnsafe(16);\n        let j = 0;\n        for (let i = 0; i < 16; i++) {\n          buffer[i] = hex2byte[input[j++] + input[j++]];\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            j += 1;\n          }\n        }\n        return buffer;\n      }\n    };\n    exports2.UUID = UUID;\n    UUID.OID = UUID.parse(\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\");\n    function getVariant(bits) {\n      switch (bits) {\n        case 0:\n        case 1:\n        case 3:\n          return \"ncs\";\n        case 4:\n        case 5:\n          return \"rfc4122\";\n        case 6:\n          return \"microsoft\";\n        default:\n          return \"future\";\n      }\n    }\n    var UuidEncoding;\n    (function(UuidEncoding2) {\n      UuidEncoding2[UuidEncoding2[\"ASCII\"] = 0] = \"ASCII\";\n      UuidEncoding2[UuidEncoding2[\"BINARY\"] = 1] = \"BINARY\";\n      UuidEncoding2[UuidEncoding2[\"OBJECT\"] = 2] = \"OBJECT\";\n    })(UuidEncoding || (UuidEncoding = {}));\n    function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {\n      const hash = (0, crypto_1.createHash)(hashMethod);\n      const nameIsNotAString = typeof name !== \"string\";\n      if (nameIsNotAString && !Buffer.isBuffer(name)) {\n        throw (0, error_1.newError)(invalidName, \"ERR_INVALID_UUID_NAME\");\n      }\n      hash.update(namespace);\n      hash.update(name);\n      const buffer = hash.digest();\n      let result;\n      switch (encoding) {\n        case UuidEncoding.BINARY:\n          buffer[6] = buffer[6] & 15 | version;\n          buffer[8] = buffer[8] & 63 | 128;\n          result = buffer;\n          break;\n        case UuidEncoding.OBJECT:\n          buffer[6] = buffer[6] & 15 | version;\n          buffer[8] = buffer[8] & 63 | 128;\n          result = new UUID(buffer);\n          break;\n        default:\n          result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + \"-\" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + \"-\" + byte2hex[buffer[6] & 15 | version] + byte2hex[buffer[7]] + \"-\" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + \"-\" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];\n          break;\n      }\n      return result;\n    }\n    function stringify(buffer) {\n      return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + \"-\" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + \"-\" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + \"-\" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + \"-\" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];\n    }\n    exports2.nil = new UUID(\"00000000-0000-0000-0000-000000000000\");\n  }\n});\n\n// node_modules/sax/lib/sax.js\nvar require_sax = __commonJS({\n  \"node_modules/sax/lib/sax.js\"(exports2) {\n    (function(sax) {\n      sax.parser = function(strict, opt) {\n        return new SAXParser(strict, opt);\n      };\n      sax.SAXParser = SAXParser;\n      sax.SAXStream = SAXStream;\n      sax.createStream = createStream;\n      sax.MAX_BUFFER_LENGTH = 64 * 1024;\n      var buffers = [\n        \"comment\",\n        \"sgmlDecl\",\n        \"textNode\",\n        \"tagName\",\n        \"doctype\",\n        \"procInstName\",\n        \"procInstBody\",\n        \"entity\",\n        \"attribName\",\n        \"attribValue\",\n        \"cdata\",\n        \"script\"\n      ];\n      sax.EVENTS = [\n        \"text\",\n        \"processinginstruction\",\n        \"sgmldeclaration\",\n        \"doctype\",\n        \"comment\",\n        \"opentagstart\",\n        \"attribute\",\n        \"opentag\",\n        \"closetag\",\n        \"opencdata\",\n        \"cdata\",\n        \"closecdata\",\n        \"error\",\n        \"end\",\n        \"ready\",\n        \"script\",\n        \"opennamespace\",\n        \"closenamespace\"\n      ];\n      function SAXParser(strict, opt) {\n        if (!(this instanceof SAXParser)) {\n          return new SAXParser(strict, opt);\n        }\n        var parser = this;\n        clearBuffers(parser);\n        parser.q = parser.c = \"\";\n        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n        parser.opt = opt || {};\n        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n        parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n        parser.tags = [];\n        parser.closed = parser.closedRoot = parser.sawRoot = false;\n        parser.tag = parser.error = null;\n        parser.strict = !!strict;\n        parser.noscript = !!(strict || parser.opt.noscript);\n        parser.state = S.BEGIN;\n        parser.strictEntities = parser.opt.strictEntities;\n        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n        parser.attribList = [];\n        if (parser.opt.xmlns) {\n          parser.ns = Object.create(rootNS);\n        }\n        if (parser.opt.unquotedAttributeValues === void 0) {\n          parser.opt.unquotedAttributeValues = !strict;\n        }\n        parser.trackPosition = parser.opt.position !== false;\n        if (parser.trackPosition) {\n          parser.position = parser.line = parser.column = 0;\n        }\n        emit(parser, \"onready\");\n      }\n      if (!Object.create) {\n        Object.create = function(o) {\n          function F() {\n          }\n          F.prototype = o;\n          var newf = new F();\n          return newf;\n        };\n      }\n      if (!Object.keys) {\n        Object.keys = function(o) {\n          var a = [];\n          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n          return a;\n        };\n      }\n      function checkBufferLength(parser) {\n        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n        var maxActual = 0;\n        for (var i = 0, l = buffers.length; i < l; i++) {\n          var len = parser[buffers[i]].length;\n          if (len > maxAllowed) {\n            switch (buffers[i]) {\n              case \"textNode\":\n                closeText(parser);\n                break;\n              case \"cdata\":\n                emitNode(parser, \"oncdata\", parser.cdata);\n                parser.cdata = \"\";\n                break;\n              case \"script\":\n                emitNode(parser, \"onscript\", parser.script);\n                parser.script = \"\";\n                break;\n              default:\n                error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n            }\n          }\n          maxActual = Math.max(maxActual, len);\n        }\n        var m = sax.MAX_BUFFER_LENGTH - maxActual;\n        parser.bufferCheckPosition = m + parser.position;\n      }\n      function clearBuffers(parser) {\n        for (var i = 0, l = buffers.length; i < l; i++) {\n          parser[buffers[i]] = \"\";\n        }\n      }\n      function flushBuffers(parser) {\n        closeText(parser);\n        if (parser.cdata !== \"\") {\n          emitNode(parser, \"oncdata\", parser.cdata);\n          parser.cdata = \"\";\n        }\n        if (parser.script !== \"\") {\n          emitNode(parser, \"onscript\", parser.script);\n          parser.script = \"\";\n        }\n      }\n      SAXParser.prototype = {\n        end: function() {\n          end(this);\n        },\n        write,\n        resume: function() {\n          this.error = null;\n          return this;\n        },\n        close: function() {\n          return this.write(null);\n        },\n        flush: function() {\n          flushBuffers(this);\n        }\n      };\n      var Stream;\n      try {\n        Stream = require(\"stream\").Stream;\n      } catch (ex) {\n        Stream = function() {\n        };\n      }\n      if (!Stream) Stream = function() {\n      };\n      var streamWraps = sax.EVENTS.filter(function(ev) {\n        return ev !== \"error\" && ev !== \"end\";\n      });\n      function createStream(strict, opt) {\n        return new SAXStream(strict, opt);\n      }\n      function SAXStream(strict, opt) {\n        if (!(this instanceof SAXStream)) {\n          return new SAXStream(strict, opt);\n        }\n        Stream.apply(this);\n        this._parser = new SAXParser(strict, opt);\n        this.writable = true;\n        this.readable = true;\n        var me = this;\n        this._parser.onend = function() {\n          me.emit(\"end\");\n        };\n        this._parser.onerror = function(er) {\n          me.emit(\"error\", er);\n          me._parser.error = null;\n        };\n        this._decoder = null;\n        streamWraps.forEach(function(ev) {\n          Object.defineProperty(me, \"on\" + ev, {\n            get: function() {\n              return me._parser[\"on\" + ev];\n            },\n            set: function(h) {\n              if (!h) {\n                me.removeAllListeners(ev);\n                me._parser[\"on\" + ev] = h;\n                return h;\n              }\n              me.on(ev, h);\n            },\n            enumerable: true,\n            configurable: false\n          });\n        });\n      }\n      SAXStream.prototype = Object.create(Stream.prototype, {\n        constructor: {\n          value: SAXStream\n        }\n      });\n      SAXStream.prototype.write = function(data) {\n        if (typeof Buffer === \"function\" && typeof Buffer.isBuffer === \"function\" && Buffer.isBuffer(data)) {\n          if (!this._decoder) {\n            var SD = require(\"string_decoder\").StringDecoder;\n            this._decoder = new SD(\"utf8\");\n          }\n          data = this._decoder.write(data);\n        }\n        this._parser.write(data.toString());\n        this.emit(\"data\", data);\n        return true;\n      };\n      SAXStream.prototype.end = function(chunk) {\n        if (chunk && chunk.length) {\n          this.write(chunk);\n        }\n        this._parser.end();\n        return true;\n      };\n      SAXStream.prototype.on = function(ev, handler) {\n        var me = this;\n        if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n          me._parser[\"on\" + ev] = function() {\n            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n            args.splice(0, 0, ev);\n            me.emit.apply(me, args);\n          };\n        }\n        return Stream.prototype.on.call(me, ev, handler);\n      };\n      var CDATA = \"[CDATA[\";\n      var DOCTYPE = \"DOCTYPE\";\n      var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n      var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n      var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n      var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n      var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n      var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n      function isWhitespace(c) {\n        return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\t\";\n      }\n      function isQuote(c) {\n        return c === '\"' || c === \"'\";\n      }\n      function isAttribEnd(c) {\n        return c === \">\" || isWhitespace(c);\n      }\n      function isMatch(regex, c) {\n        return regex.test(c);\n      }\n      function notMatch(regex, c) {\n        return !isMatch(regex, c);\n      }\n      var S = 0;\n      sax.STATE = {\n        BEGIN: S++,\n        // leading byte order mark or whitespace\n        BEGIN_WHITESPACE: S++,\n        // leading whitespace\n        TEXT: S++,\n        // general stuff\n        TEXT_ENTITY: S++,\n        // &amp and such.\n        OPEN_WAKA: S++,\n        // <\n        SGML_DECL: S++,\n        // <!BLARG\n        SGML_DECL_QUOTED: S++,\n        // <!BLARG foo \"bar\n        DOCTYPE: S++,\n        // <!DOCTYPE\n        DOCTYPE_QUOTED: S++,\n        // <!DOCTYPE \"//blah\n        DOCTYPE_DTD: S++,\n        // <!DOCTYPE \"//blah\" [ ...\n        DOCTYPE_DTD_QUOTED: S++,\n        // <!DOCTYPE \"//blah\" [ \"foo\n        COMMENT_STARTING: S++,\n        // <!-\n        COMMENT: S++,\n        // <!--\n        COMMENT_ENDING: S++,\n        // <!-- blah -\n        COMMENT_ENDED: S++,\n        // <!-- blah --\n        CDATA: S++,\n        // <![CDATA[ something\n        CDATA_ENDING: S++,\n        // ]\n        CDATA_ENDING_2: S++,\n        // ]]\n        PROC_INST: S++,\n        // <?hi\n        PROC_INST_BODY: S++,\n        // <?hi there\n        PROC_INST_ENDING: S++,\n        // <?hi \"there\" ?\n        OPEN_TAG: S++,\n        // <strong\n        OPEN_TAG_SLASH: S++,\n        // <strong /\n        ATTRIB: S++,\n        // <a\n        ATTRIB_NAME: S++,\n        // <a foo\n        ATTRIB_NAME_SAW_WHITE: S++,\n        // <a foo _\n        ATTRIB_VALUE: S++,\n        // <a foo=\n        ATTRIB_VALUE_QUOTED: S++,\n        // <a foo=\"bar\n        ATTRIB_VALUE_CLOSED: S++,\n        // <a foo=\"bar\"\n        ATTRIB_VALUE_UNQUOTED: S++,\n        // <a foo=bar\n        ATTRIB_VALUE_ENTITY_Q: S++,\n        // <foo bar=\"&quot;\"\n        ATTRIB_VALUE_ENTITY_U: S++,\n        // <foo bar=&quot\n        CLOSE_TAG: S++,\n        // </a\n        CLOSE_TAG_SAW_WHITE: S++,\n        // </a   >\n        SCRIPT: S++,\n        // <script> ...\n        SCRIPT_ENDING: S++\n        // <script> ... <\n      };\n      sax.XML_ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\"\n      };\n      sax.ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n        AElig: 198,\n        Aacute: 193,\n        Acirc: 194,\n        Agrave: 192,\n        Aring: 197,\n        Atilde: 195,\n        Auml: 196,\n        Ccedil: 199,\n        ETH: 208,\n        Eacute: 201,\n        Ecirc: 202,\n        Egrave: 200,\n        Euml: 203,\n        Iacute: 205,\n        Icirc: 206,\n        Igrave: 204,\n        Iuml: 207,\n        Ntilde: 209,\n        Oacute: 211,\n        Ocirc: 212,\n        Ograve: 210,\n        Oslash: 216,\n        Otilde: 213,\n        Ouml: 214,\n        THORN: 222,\n        Uacute: 218,\n        Ucirc: 219,\n        Ugrave: 217,\n        Uuml: 220,\n        Yacute: 221,\n        aacute: 225,\n        acirc: 226,\n        aelig: 230,\n        agrave: 224,\n        aring: 229,\n        atilde: 227,\n        auml: 228,\n        ccedil: 231,\n        eacute: 233,\n        ecirc: 234,\n        egrave: 232,\n        eth: 240,\n        euml: 235,\n        iacute: 237,\n        icirc: 238,\n        igrave: 236,\n        iuml: 239,\n        ntilde: 241,\n        oacute: 243,\n        ocirc: 244,\n        ograve: 242,\n        oslash: 248,\n        otilde: 245,\n        ouml: 246,\n        szlig: 223,\n        thorn: 254,\n        uacute: 250,\n        ucirc: 251,\n        ugrave: 249,\n        uuml: 252,\n        yacute: 253,\n        yuml: 255,\n        copy: 169,\n        reg: 174,\n        nbsp: 160,\n        iexcl: 161,\n        cent: 162,\n        pound: 163,\n        curren: 164,\n        yen: 165,\n        brvbar: 166,\n        sect: 167,\n        uml: 168,\n        ordf: 170,\n        laquo: 171,\n        not: 172,\n        shy: 173,\n        macr: 175,\n        deg: 176,\n        plusmn: 177,\n        sup1: 185,\n        sup2: 178,\n        sup3: 179,\n        acute: 180,\n        micro: 181,\n        para: 182,\n        middot: 183,\n        cedil: 184,\n        ordm: 186,\n        raquo: 187,\n        frac14: 188,\n        frac12: 189,\n        frac34: 190,\n        iquest: 191,\n        times: 215,\n        divide: 247,\n        OElig: 338,\n        oelig: 339,\n        Scaron: 352,\n        scaron: 353,\n        Yuml: 376,\n        fnof: 402,\n        circ: 710,\n        tilde: 732,\n        Alpha: 913,\n        Beta: 914,\n        Gamma: 915,\n        Delta: 916,\n        Epsilon: 917,\n        Zeta: 918,\n        Eta: 919,\n        Theta: 920,\n        Iota: 921,\n        Kappa: 922,\n        Lambda: 923,\n        Mu: 924,\n        Nu: 925,\n        Xi: 926,\n        Omicron: 927,\n        Pi: 928,\n        Rho: 929,\n        Sigma: 931,\n        Tau: 932,\n        Upsilon: 933,\n        Phi: 934,\n        Chi: 935,\n        Psi: 936,\n        Omega: 937,\n        alpha: 945,\n        beta: 946,\n        gamma: 947,\n        delta: 948,\n        epsilon: 949,\n        zeta: 950,\n        eta: 951,\n        theta: 952,\n        iota: 953,\n        kappa: 954,\n        lambda: 955,\n        mu: 956,\n        nu: 957,\n        xi: 958,\n        omicron: 959,\n        pi: 960,\n        rho: 961,\n        sigmaf: 962,\n        sigma: 963,\n        tau: 964,\n        upsilon: 965,\n        phi: 966,\n        chi: 967,\n        psi: 968,\n        omega: 969,\n        thetasym: 977,\n        upsih: 978,\n        piv: 982,\n        ensp: 8194,\n        emsp: 8195,\n        thinsp: 8201,\n        zwnj: 8204,\n        zwj: 8205,\n        lrm: 8206,\n        rlm: 8207,\n        ndash: 8211,\n        mdash: 8212,\n        lsquo: 8216,\n        rsquo: 8217,\n        sbquo: 8218,\n        ldquo: 8220,\n        rdquo: 8221,\n        bdquo: 8222,\n        dagger: 8224,\n        Dagger: 8225,\n        bull: 8226,\n        hellip: 8230,\n        permil: 8240,\n        prime: 8242,\n        Prime: 8243,\n        lsaquo: 8249,\n        rsaquo: 8250,\n        oline: 8254,\n        frasl: 8260,\n        euro: 8364,\n        image: 8465,\n        weierp: 8472,\n        real: 8476,\n        trade: 8482,\n        alefsym: 8501,\n        larr: 8592,\n        uarr: 8593,\n        rarr: 8594,\n        darr: 8595,\n        harr: 8596,\n        crarr: 8629,\n        lArr: 8656,\n        uArr: 8657,\n        rArr: 8658,\n        dArr: 8659,\n        hArr: 8660,\n        forall: 8704,\n        part: 8706,\n        exist: 8707,\n        empty: 8709,\n        nabla: 8711,\n        isin: 8712,\n        notin: 8713,\n        ni: 8715,\n        prod: 8719,\n        sum: 8721,\n        minus: 8722,\n        lowast: 8727,\n        radic: 8730,\n        prop: 8733,\n        infin: 8734,\n        ang: 8736,\n        and: 8743,\n        or: 8744,\n        cap: 8745,\n        cup: 8746,\n        int: 8747,\n        there4: 8756,\n        sim: 8764,\n        cong: 8773,\n        asymp: 8776,\n        ne: 8800,\n        equiv: 8801,\n        le: 8804,\n        ge: 8805,\n        sub: 8834,\n        sup: 8835,\n        nsub: 8836,\n        sube: 8838,\n        supe: 8839,\n        oplus: 8853,\n        otimes: 8855,\n        perp: 8869,\n        sdot: 8901,\n        lceil: 8968,\n        rceil: 8969,\n        lfloor: 8970,\n        rfloor: 8971,\n        lang: 9001,\n        rang: 9002,\n        loz: 9674,\n        spades: 9824,\n        clubs: 9827,\n        hearts: 9829,\n        diams: 9830\n      };\n      Object.keys(sax.ENTITIES).forEach(function(key) {\n        var e = sax.ENTITIES[key];\n        var s2 = typeof e === \"number\" ? String.fromCharCode(e) : e;\n        sax.ENTITIES[key] = s2;\n      });\n      for (var s in sax.STATE) {\n        sax.STATE[sax.STATE[s]] = s;\n      }\n      S = sax.STATE;\n      function emit(parser, event, data) {\n        parser[event] && parser[event](data);\n      }\n      function emitNode(parser, nodeType, data) {\n        if (parser.textNode) closeText(parser);\n        emit(parser, nodeType, data);\n      }\n      function closeText(parser) {\n        parser.textNode = textopts(parser.opt, parser.textNode);\n        if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n        parser.textNode = \"\";\n      }\n      function textopts(opt, text) {\n        if (opt.trim) text = text.trim();\n        if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n        return text;\n      }\n      function error(parser, er) {\n        closeText(parser);\n        if (parser.trackPosition) {\n          er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n        }\n        er = new Error(er);\n        parser.error = er;\n        emit(parser, \"onerror\", er);\n        return parser;\n      }\n      function end(parser) {\n        if (parser.sawRoot && !parser.closedRoot)\n          strictFail(parser, \"Unclosed root tag\");\n        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n          error(parser, \"Unexpected end\");\n        }\n        closeText(parser);\n        parser.c = \"\";\n        parser.closed = true;\n        emit(parser, \"onend\");\n        SAXParser.call(parser, parser.strict, parser.opt);\n        return parser;\n      }\n      function strictFail(parser, message) {\n        if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n          throw new Error(\"bad call to strictFail\");\n        }\n        if (parser.strict) {\n          error(parser, message);\n        }\n      }\n      function newTag(parser) {\n        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        var tag = parser.tag = { name: parser.tagName, attributes: {} };\n        if (parser.opt.xmlns) {\n          tag.ns = parent.ns;\n        }\n        parser.attribList.length = 0;\n        emitNode(parser, \"onopentagstart\", tag);\n      }\n      function qname(name, attribute) {\n        var i = name.indexOf(\":\");\n        var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n        var prefix = qualName[0];\n        var local = qualName[1];\n        if (attribute && name === \"xmlns\") {\n          prefix = \"xmlns\";\n          local = \"\";\n        }\n        return { prefix, local };\n      }\n      function attrib(parser) {\n        if (!parser.strict) {\n          parser.attribName = parser.attribName[parser.looseCase]();\n        }\n        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n          parser.attribName = parser.attribValue = \"\";\n          return;\n        }\n        if (parser.opt.xmlns) {\n          var qn = qname(parser.attribName, true);\n          var prefix = qn.prefix;\n          var local = qn.local;\n          if (prefix === \"xmlns\") {\n            if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n              strictFail(\n                parser,\n                \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\nActual: \" + parser.attribValue\n              );\n            } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n              strictFail(\n                parser,\n                \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\nActual: \" + parser.attribValue\n              );\n            } else {\n              var tag = parser.tag;\n              var parent = parser.tags[parser.tags.length - 1] || parser;\n              if (tag.ns === parent.ns) {\n                tag.ns = Object.create(parent.ns);\n              }\n              tag.ns[local] = parser.attribValue;\n            }\n          }\n          parser.attribList.push([parser.attribName, parser.attribValue]);\n        } else {\n          parser.tag.attributes[parser.attribName] = parser.attribValue;\n          emitNode(parser, \"onattribute\", {\n            name: parser.attribName,\n            value: parser.attribValue\n          });\n        }\n        parser.attribName = parser.attribValue = \"\";\n      }\n      function openTag(parser, selfClosing) {\n        if (parser.opt.xmlns) {\n          var tag = parser.tag;\n          var qn = qname(parser.tagName);\n          tag.prefix = qn.prefix;\n          tag.local = qn.local;\n          tag.uri = tag.ns[qn.prefix] || \"\";\n          if (tag.prefix && !tag.uri) {\n            strictFail(\n              parser,\n              \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName)\n            );\n            tag.uri = qn.prefix;\n          }\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns && parent.ns !== tag.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n              emitNode(parser, \"onopennamespace\", {\n                prefix: p,\n                uri: tag.ns[p]\n              });\n            });\n          }\n          for (var i = 0, l = parser.attribList.length; i < l; i++) {\n            var nv = parser.attribList[i];\n            var name = nv[0];\n            var value = nv[1];\n            var qualName = qname(name, true);\n            var prefix = qualName.prefix;\n            var local = qualName.local;\n            var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n            var a = {\n              name,\n              value,\n              prefix,\n              local,\n              uri\n            };\n            if (prefix && prefix !== \"xmlns\" && !uri) {\n              strictFail(\n                parser,\n                \"Unbound namespace prefix: \" + JSON.stringify(prefix)\n              );\n              a.uri = prefix;\n            }\n            parser.tag.attributes[name] = a;\n            emitNode(parser, \"onattribute\", a);\n          }\n          parser.attribList.length = 0;\n        }\n        parser.tag.isSelfClosing = !!selfClosing;\n        parser.sawRoot = true;\n        parser.tags.push(parser.tag);\n        emitNode(parser, \"onopentag\", parser.tag);\n        if (!selfClosing) {\n          if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n            parser.state = S.SCRIPT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          parser.tag = null;\n          parser.tagName = \"\";\n        }\n        parser.attribName = parser.attribValue = \"\";\n        parser.attribList.length = 0;\n      }\n      function closeTag(parser) {\n        if (!parser.tagName) {\n          strictFail(parser, \"Weird empty close tag.\");\n          parser.textNode += \"</>\";\n          parser.state = S.TEXT;\n          return;\n        }\n        if (parser.script) {\n          if (parser.tagName !== \"script\") {\n            parser.script += \"</\" + parser.tagName + \">\";\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n            return;\n          }\n          emitNode(parser, \"onscript\", parser.script);\n          parser.script = \"\";\n        }\n        var t = parser.tags.length;\n        var tagName = parser.tagName;\n        if (!parser.strict) {\n          tagName = tagName[parser.looseCase]();\n        }\n        var closeTo = tagName;\n        while (t--) {\n          var close = parser.tags[t];\n          if (close.name !== closeTo) {\n            strictFail(parser, \"Unexpected close tag\");\n          } else {\n            break;\n          }\n        }\n        if (t < 0) {\n          strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n          parser.textNode += \"</\" + parser.tagName + \">\";\n          parser.state = S.TEXT;\n          return;\n        }\n        parser.tagName = tagName;\n        var s2 = parser.tags.length;\n        while (s2-- > t) {\n          var tag = parser.tag = parser.tags.pop();\n          parser.tagName = parser.tag.name;\n          emitNode(parser, \"onclosetag\", parser.tagName);\n          var x = {};\n          for (var i in tag.ns) {\n            x[i] = tag.ns[i];\n          }\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (parser.opt.xmlns && tag.ns !== parent.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n              var n = tag.ns[p];\n              emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n            });\n          }\n        }\n        if (t === 0) parser.closedRoot = true;\n        parser.tagName = parser.attribValue = parser.attribName = \"\";\n        parser.attribList.length = 0;\n        parser.state = S.TEXT;\n      }\n      function parseEntity(parser) {\n        var entity = parser.entity;\n        var entityLC = entity.toLowerCase();\n        var num;\n        var numStr = \"\";\n        if (parser.ENTITIES[entity]) {\n          return parser.ENTITIES[entity];\n        }\n        if (parser.ENTITIES[entityLC]) {\n          return parser.ENTITIES[entityLC];\n        }\n        entity = entityLC;\n        if (entity.charAt(0) === \"#\") {\n          if (entity.charAt(1) === \"x\") {\n            entity = entity.slice(2);\n            num = parseInt(entity, 16);\n            numStr = num.toString(16);\n          } else {\n            entity = entity.slice(1);\n            num = parseInt(entity, 10);\n            numStr = num.toString(10);\n          }\n        }\n        entity = entity.replace(/^0+/, \"\");\n        if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 1114111) {\n          strictFail(parser, \"Invalid character entity\");\n          return \"&\" + parser.entity + \";\";\n        }\n        return String.fromCodePoint(num);\n      }\n      function beginWhiteSpace(parser, c) {\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA;\n          parser.startTagPosition = parser.position;\n        } else if (!isWhitespace(c)) {\n          strictFail(parser, \"Non-whitespace before first tag.\");\n          parser.textNode = c;\n          parser.state = S.TEXT;\n        }\n      }\n      function charAt(chunk, i) {\n        var result = \"\";\n        if (i < chunk.length) {\n          result = chunk.charAt(i);\n        }\n        return result;\n      }\n      function write(chunk) {\n        var parser = this;\n        if (this.error) {\n          throw this.error;\n        }\n        if (parser.closed) {\n          return error(\n            parser,\n            \"Cannot write after close. Assign an onready handler.\"\n          );\n        }\n        if (chunk === null) {\n          return end(parser);\n        }\n        if (typeof chunk === \"object\") {\n          chunk = chunk.toString();\n        }\n        var i = 0;\n        var c = \"\";\n        while (true) {\n          c = charAt(chunk, i++);\n          parser.c = c;\n          if (!c) {\n            break;\n          }\n          if (parser.trackPosition) {\n            parser.position++;\n            if (c === \"\\n\") {\n              parser.line++;\n              parser.column = 0;\n            } else {\n              parser.column++;\n            }\n          }\n          switch (parser.state) {\n            case S.BEGIN:\n              parser.state = S.BEGIN_WHITESPACE;\n              if (c === \"\\uFEFF\") {\n                continue;\n              }\n              beginWhiteSpace(parser, c);\n              continue;\n            case S.BEGIN_WHITESPACE:\n              beginWhiteSpace(parser, c);\n              continue;\n            case S.TEXT:\n              if (parser.sawRoot && !parser.closedRoot) {\n                var starti = i - 1;\n                while (c && c !== \"<\" && c !== \"&\") {\n                  c = charAt(chunk, i++);\n                  if (c && parser.trackPosition) {\n                    parser.position++;\n                    if (c === \"\\n\") {\n                      parser.line++;\n                      parser.column = 0;\n                    } else {\n                      parser.column++;\n                    }\n                  }\n                }\n                parser.textNode += chunk.substring(starti, i - 1);\n              }\n              if (c === \"<\" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                parser.state = S.OPEN_WAKA;\n                parser.startTagPosition = parser.position;\n              } else {\n                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                  strictFail(parser, \"Text data outside of root node.\");\n                }\n                if (c === \"&\") {\n                  parser.state = S.TEXT_ENTITY;\n                } else {\n                  parser.textNode += c;\n                }\n              }\n              continue;\n            case S.SCRIPT:\n              if (c === \"<\") {\n                parser.state = S.SCRIPT_ENDING;\n              } else {\n                parser.script += c;\n              }\n              continue;\n            case S.SCRIPT_ENDING:\n              if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n              } else {\n                parser.script += \"<\" + c;\n                parser.state = S.SCRIPT;\n              }\n              continue;\n            case S.OPEN_WAKA:\n              if (c === \"!\") {\n                parser.state = S.SGML_DECL;\n                parser.sgmlDecl = \"\";\n              } else if (isWhitespace(c)) {\n              } else if (isMatch(nameStart, c)) {\n                parser.state = S.OPEN_TAG;\n                parser.tagName = c;\n              } else if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n                parser.tagName = \"\";\n              } else if (c === \"?\") {\n                parser.state = S.PROC_INST;\n                parser.procInstName = parser.procInstBody = \"\";\n              } else {\n                strictFail(parser, \"Unencoded <\");\n                if (parser.startTagPosition + 1 < parser.position) {\n                  var pad = parser.position - parser.startTagPosition;\n                  c = new Array(pad).join(\" \") + c;\n                }\n                parser.textNode += \"<\" + c;\n                parser.state = S.TEXT;\n              }\n              continue;\n            case S.SGML_DECL:\n              if (parser.sgmlDecl + c === \"--\") {\n                parser.state = S.COMMENT;\n                parser.comment = \"\";\n                parser.sgmlDecl = \"\";\n                continue;\n              }\n              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {\n                parser.state = S.DOCTYPE_DTD;\n                parser.doctype += \"<!\" + parser.sgmlDecl + c;\n                parser.sgmlDecl = \"\";\n              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                emitNode(parser, \"onopencdata\");\n                parser.state = S.CDATA;\n                parser.sgmlDecl = \"\";\n                parser.cdata = \"\";\n              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                parser.state = S.DOCTYPE;\n                if (parser.doctype || parser.sawRoot) {\n                  strictFail(\n                    parser,\n                    \"Inappropriately located doctype declaration\"\n                  );\n                }\n                parser.doctype = \"\";\n                parser.sgmlDecl = \"\";\n              } else if (c === \">\") {\n                emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                parser.sgmlDecl = \"\";\n                parser.state = S.TEXT;\n              } else if (isQuote(c)) {\n                parser.state = S.SGML_DECL_QUOTED;\n                parser.sgmlDecl += c;\n              } else {\n                parser.sgmlDecl += c;\n              }\n              continue;\n            case S.SGML_DECL_QUOTED:\n              if (c === parser.q) {\n                parser.state = S.SGML_DECL;\n                parser.q = \"\";\n              }\n              parser.sgmlDecl += c;\n              continue;\n            case S.DOCTYPE:\n              if (c === \">\") {\n                parser.state = S.TEXT;\n                emitNode(parser, \"ondoctype\", parser.doctype);\n                parser.doctype = true;\n              } else {\n                parser.doctype += c;\n                if (c === \"[\") {\n                  parser.state = S.DOCTYPE_DTD;\n                } else if (isQuote(c)) {\n                  parser.state = S.DOCTYPE_QUOTED;\n                  parser.q = c;\n                }\n              }\n              continue;\n            case S.DOCTYPE_QUOTED:\n              parser.doctype += c;\n              if (c === parser.q) {\n                parser.q = \"\";\n                parser.state = S.DOCTYPE;\n              }\n              continue;\n            case S.DOCTYPE_DTD:\n              if (c === \"]\") {\n                parser.doctype += c;\n                parser.state = S.DOCTYPE;\n              } else if (c === \"<\") {\n                parser.state = S.OPEN_WAKA;\n                parser.startTagPosition = parser.position;\n              } else if (isQuote(c)) {\n                parser.doctype += c;\n                parser.state = S.DOCTYPE_DTD_QUOTED;\n                parser.q = c;\n              } else {\n                parser.doctype += c;\n              }\n              continue;\n            case S.DOCTYPE_DTD_QUOTED:\n              parser.doctype += c;\n              if (c === parser.q) {\n                parser.state = S.DOCTYPE_DTD;\n                parser.q = \"\";\n              }\n              continue;\n            case S.COMMENT:\n              if (c === \"-\") {\n                parser.state = S.COMMENT_ENDING;\n              } else {\n                parser.comment += c;\n              }\n              continue;\n            case S.COMMENT_ENDING:\n              if (c === \"-\") {\n                parser.state = S.COMMENT_ENDED;\n                parser.comment = textopts(parser.opt, parser.comment);\n                if (parser.comment) {\n                  emitNode(parser, \"oncomment\", parser.comment);\n                }\n                parser.comment = \"\";\n              } else {\n                parser.comment += \"-\" + c;\n                parser.state = S.COMMENT;\n              }\n              continue;\n            case S.COMMENT_ENDED:\n              if (c !== \">\") {\n                strictFail(parser, \"Malformed comment\");\n                parser.comment += \"--\" + c;\n                parser.state = S.COMMENT;\n              } else if (parser.doctype && parser.doctype !== true) {\n                parser.state = S.DOCTYPE_DTD;\n              } else {\n                parser.state = S.TEXT;\n              }\n              continue;\n            case S.CDATA:\n              var starti = i - 1;\n              while (c && c !== \"]\") {\n                c = charAt(chunk, i++);\n                if (c && parser.trackPosition) {\n                  parser.position++;\n                  if (c === \"\\n\") {\n                    parser.line++;\n                    parser.column = 0;\n                  } else {\n                    parser.column++;\n                  }\n                }\n              }\n              parser.cdata += chunk.substring(starti, i - 1);\n              if (c === \"]\") {\n                parser.state = S.CDATA_ENDING;\n              }\n              continue;\n            case S.CDATA_ENDING:\n              if (c === \"]\") {\n                parser.state = S.CDATA_ENDING_2;\n              } else {\n                parser.cdata += \"]\" + c;\n                parser.state = S.CDATA;\n              }\n              continue;\n            case S.CDATA_ENDING_2:\n              if (c === \">\") {\n                if (parser.cdata) {\n                  emitNode(parser, \"oncdata\", parser.cdata);\n                }\n                emitNode(parser, \"onclosecdata\");\n                parser.cdata = \"\";\n                parser.state = S.TEXT;\n              } else if (c === \"]\") {\n                parser.cdata += \"]\";\n              } else {\n                parser.cdata += \"]]\" + c;\n                parser.state = S.CDATA;\n              }\n              continue;\n            case S.PROC_INST:\n              if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n              } else if (isWhitespace(c)) {\n                parser.state = S.PROC_INST_BODY;\n              } else {\n                parser.procInstName += c;\n              }\n              continue;\n            case S.PROC_INST_BODY:\n              if (!parser.procInstBody && isWhitespace(c)) {\n                continue;\n              } else if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n              } else {\n                parser.procInstBody += c;\n              }\n              continue;\n            case S.PROC_INST_ENDING:\n              if (c === \">\") {\n                emitNode(parser, \"onprocessinginstruction\", {\n                  name: parser.procInstName,\n                  body: parser.procInstBody\n                });\n                parser.procInstName = parser.procInstBody = \"\";\n                parser.state = S.TEXT;\n              } else {\n                parser.procInstBody += \"?\" + c;\n                parser.state = S.PROC_INST_BODY;\n              }\n              continue;\n            case S.OPEN_TAG:\n              if (isMatch(nameBody, c)) {\n                parser.tagName += c;\n              } else {\n                newTag(parser);\n                if (c === \">\") {\n                  openTag(parser);\n                } else if (c === \"/\") {\n                  parser.state = S.OPEN_TAG_SLASH;\n                } else {\n                  if (!isWhitespace(c)) {\n                    strictFail(parser, \"Invalid character in tag name\");\n                  }\n                  parser.state = S.ATTRIB;\n                }\n              }\n              continue;\n            case S.OPEN_TAG_SLASH:\n              if (c === \">\") {\n                openTag(parser, true);\n                closeTag(parser);\n              } else {\n                strictFail(\n                  parser,\n                  \"Forward-slash in opening tag not followed by >\"\n                );\n                parser.state = S.ATTRIB;\n              }\n              continue;\n            case S.ATTRIB:\n              if (isWhitespace(c)) {\n                continue;\n              } else if (c === \">\") {\n                openTag(parser);\n              } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n              } else if (isMatch(nameStart, c)) {\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n              } else {\n                strictFail(parser, \"Invalid attribute name\");\n              }\n              continue;\n            case S.ATTRIB_NAME:\n              if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n              } else if (c === \">\") {\n                strictFail(parser, \"Attribute without value\");\n                parser.attribValue = parser.attribName;\n                attrib(parser);\n                openTag(parser);\n              } else if (isWhitespace(c)) {\n                parser.state = S.ATTRIB_NAME_SAW_WHITE;\n              } else if (isMatch(nameBody, c)) {\n                parser.attribName += c;\n              } else {\n                strictFail(parser, \"Invalid attribute name\");\n              }\n              continue;\n            case S.ATTRIB_NAME_SAW_WHITE:\n              if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n              } else if (isWhitespace(c)) {\n                continue;\n              } else {\n                strictFail(parser, \"Attribute without value\");\n                parser.tag.attributes[parser.attribName] = \"\";\n                parser.attribValue = \"\";\n                emitNode(parser, \"onattribute\", {\n                  name: parser.attribName,\n                  value: \"\"\n                });\n                parser.attribName = \"\";\n                if (c === \">\") {\n                  openTag(parser);\n                } else if (isMatch(nameStart, c)) {\n                  parser.attribName = c;\n                  parser.state = S.ATTRIB_NAME;\n                } else {\n                  strictFail(parser, \"Invalid attribute name\");\n                  parser.state = S.ATTRIB;\n                }\n              }\n              continue;\n            case S.ATTRIB_VALUE:\n              if (isWhitespace(c)) {\n                continue;\n              } else if (isQuote(c)) {\n                parser.q = c;\n                parser.state = S.ATTRIB_VALUE_QUOTED;\n              } else {\n                if (!parser.opt.unquotedAttributeValues) {\n                  error(parser, \"Unquoted attribute value\");\n                }\n                parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                parser.attribValue = c;\n              }\n              continue;\n            case S.ATTRIB_VALUE_QUOTED:\n              if (c !== parser.q) {\n                if (c === \"&\") {\n                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                } else {\n                  parser.attribValue += c;\n                }\n                continue;\n              }\n              attrib(parser);\n              parser.q = \"\";\n              parser.state = S.ATTRIB_VALUE_CLOSED;\n              continue;\n            case S.ATTRIB_VALUE_CLOSED:\n              if (isWhitespace(c)) {\n                parser.state = S.ATTRIB;\n              } else if (c === \">\") {\n                openTag(parser);\n              } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n              } else if (isMatch(nameStart, c)) {\n                strictFail(parser, \"No whitespace between attributes\");\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n              } else {\n                strictFail(parser, \"Invalid attribute name\");\n              }\n              continue;\n            case S.ATTRIB_VALUE_UNQUOTED:\n              if (!isAttribEnd(c)) {\n                if (c === \"&\") {\n                  parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                } else {\n                  parser.attribValue += c;\n                }\n                continue;\n              }\n              attrib(parser);\n              if (c === \">\") {\n                openTag(parser);\n              } else {\n                parser.state = S.ATTRIB;\n              }\n              continue;\n            case S.CLOSE_TAG:\n              if (!parser.tagName) {\n                if (isWhitespace(c)) {\n                  continue;\n                } else if (notMatch(nameStart, c)) {\n                  if (parser.script) {\n                    parser.script += \"</\" + c;\n                    parser.state = S.SCRIPT;\n                  } else {\n                    strictFail(parser, \"Invalid tagname in closing tag.\");\n                  }\n                } else {\n                  parser.tagName = c;\n                }\n              } else if (c === \">\") {\n                closeTag(parser);\n              } else if (isMatch(nameBody, c)) {\n                parser.tagName += c;\n              } else if (parser.script) {\n                parser.script += \"</\" + parser.tagName;\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n              } else {\n                if (!isWhitespace(c)) {\n                  strictFail(parser, \"Invalid tagname in closing tag\");\n                }\n                parser.state = S.CLOSE_TAG_SAW_WHITE;\n              }\n              continue;\n            case S.CLOSE_TAG_SAW_WHITE:\n              if (isWhitespace(c)) {\n                continue;\n              }\n              if (c === \">\") {\n                closeTag(parser);\n              } else {\n                strictFail(parser, \"Invalid characters in closing tag\");\n              }\n              continue;\n            case S.TEXT_ENTITY:\n            case S.ATTRIB_VALUE_ENTITY_Q:\n            case S.ATTRIB_VALUE_ENTITY_U:\n              var returnState;\n              var buffer;\n              switch (parser.state) {\n                case S.TEXT_ENTITY:\n                  returnState = S.TEXT;\n                  buffer = \"textNode\";\n                  break;\n                case S.ATTRIB_VALUE_ENTITY_Q:\n                  returnState = S.ATTRIB_VALUE_QUOTED;\n                  buffer = \"attribValue\";\n                  break;\n                case S.ATTRIB_VALUE_ENTITY_U:\n                  returnState = S.ATTRIB_VALUE_UNQUOTED;\n                  buffer = \"attribValue\";\n                  break;\n              }\n              if (c === \";\") {\n                var parsedEntity = parseEntity(parser);\n                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {\n                  parser.entity = \"\";\n                  parser.state = returnState;\n                  parser.write(parsedEntity);\n                } else {\n                  parser[buffer] += parsedEntity;\n                  parser.entity = \"\";\n                  parser.state = returnState;\n                }\n              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                parser.entity += c;\n              } else {\n                strictFail(parser, \"Invalid character in entity name\");\n                parser[buffer] += \"&\" + parser.entity + c;\n                parser.entity = \"\";\n                parser.state = returnState;\n              }\n              continue;\n            default: {\n              throw new Error(parser, \"Unknown state: \" + parser.state);\n            }\n          }\n        }\n        if (parser.position >= parser.bufferCheckPosition) {\n          checkBufferLength(parser);\n        }\n        return parser;\n      }\n      if (!String.fromCodePoint) {\n        ;\n        (function() {\n          var stringFromCharCode = String.fromCharCode;\n          var floor = Math.floor;\n          var fromCodePoint = function() {\n            var MAX_SIZE = 16384;\n            var codeUnits = [];\n            var highSurrogate;\n            var lowSurrogate;\n            var index = -1;\n            var length = arguments.length;\n            if (!length) {\n              return \"\";\n            }\n            var result = \"\";\n            while (++index < length) {\n              var codePoint = Number(arguments[index]);\n              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n              codePoint < 0 || // not a valid Unicode code point\n              codePoint > 1114111 || // not a valid Unicode code point\n              floor(codePoint) !== codePoint) {\n                throw RangeError(\"Invalid code point: \" + codePoint);\n              }\n              if (codePoint <= 65535) {\n                codeUnits.push(codePoint);\n              } else {\n                codePoint -= 65536;\n                highSurrogate = (codePoint >> 10) + 55296;\n                lowSurrogate = codePoint % 1024 + 56320;\n                codeUnits.push(highSurrogate, lowSurrogate);\n              }\n              if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode.apply(null, codeUnits);\n                codeUnits.length = 0;\n              }\n            }\n            return result;\n          };\n          if (Object.defineProperty) {\n            Object.defineProperty(String, \"fromCodePoint\", {\n              value: fromCodePoint,\n              configurable: true,\n              writable: true\n            });\n          } else {\n            String.fromCodePoint = fromCodePoint;\n          }\n        })();\n      }\n    })(typeof exports2 === \"undefined\" ? exports2.sax = {} : exports2);\n  }\n});\n\n// node_modules/builder-util-runtime/out/xml.js\nvar require_xml = __commonJS({\n  \"node_modules/builder-util-runtime/out/xml.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.XElement = void 0;\n    exports2.parseXml = parseXml;\n    var sax = require_sax();\n    var error_1 = require_error();\n    var XElement = class {\n      constructor(name) {\n        this.name = name;\n        this.value = \"\";\n        this.attributes = null;\n        this.isCData = false;\n        this.elements = null;\n        if (!name) {\n          throw (0, error_1.newError)(\"Element name cannot be empty\", \"ERR_XML_ELEMENT_NAME_EMPTY\");\n        }\n        if (!isValidName(name)) {\n          throw (0, error_1.newError)(`Invalid element name: ${name}`, \"ERR_XML_ELEMENT_INVALID_NAME\");\n        }\n      }\n      attribute(name) {\n        const result = this.attributes === null ? null : this.attributes[name];\n        if (result == null) {\n          throw (0, error_1.newError)(`No attribute \"${name}\"`, \"ERR_XML_MISSED_ATTRIBUTE\");\n        }\n        return result;\n      }\n      removeAttribute(name) {\n        if (this.attributes !== null) {\n          delete this.attributes[name];\n        }\n      }\n      element(name, ignoreCase = false, errorIfMissed = null) {\n        const result = this.elementOrNull(name, ignoreCase);\n        if (result === null) {\n          throw (0, error_1.newError)(errorIfMissed || `No element \"${name}\"`, \"ERR_XML_MISSED_ELEMENT\");\n        }\n        return result;\n      }\n      elementOrNull(name, ignoreCase = false) {\n        if (this.elements === null) {\n          return null;\n        }\n        for (const element of this.elements) {\n          if (isNameEquals(element, name, ignoreCase)) {\n            return element;\n          }\n        }\n        return null;\n      }\n      getElements(name, ignoreCase = false) {\n        if (this.elements === null) {\n          return [];\n        }\n        return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));\n      }\n      elementValueOrEmpty(name, ignoreCase = false) {\n        const element = this.elementOrNull(name, ignoreCase);\n        return element === null ? \"\" : element.value;\n      }\n    };\n    exports2.XElement = XElement;\n    var NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);\n    function isValidName(name) {\n      return NAME_REG_EXP.test(name);\n    }\n    function isNameEquals(element, name, ignoreCase) {\n      const elementName = element.name;\n      return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();\n    }\n    function parseXml(data) {\n      let rootElement = null;\n      const parser = sax.parser(true, {});\n      const elements = [];\n      parser.onopentag = (saxElement) => {\n        const element = new XElement(saxElement.name);\n        element.attributes = saxElement.attributes;\n        if (rootElement === null) {\n          rootElement = element;\n        } else {\n          const parent = elements[elements.length - 1];\n          if (parent.elements == null) {\n            parent.elements = [];\n          }\n          parent.elements.push(element);\n        }\n        elements.push(element);\n      };\n      parser.onclosetag = () => {\n        elements.pop();\n      };\n      parser.ontext = (text) => {\n        if (elements.length > 0) {\n          elements[elements.length - 1].value = text;\n        }\n      };\n      parser.oncdata = (cdata) => {\n        const element = elements[elements.length - 1];\n        element.value = cdata;\n        element.isCData = true;\n      };\n      parser.onerror = (err) => {\n        throw err;\n      };\n      parser.write(data);\n      return rootElement;\n    }\n  }\n});\n\n// node_modules/builder-util-runtime/out/index.js\nvar require_out = __commonJS({\n  \"node_modules/builder-util-runtime/out/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.CURRENT_APP_PACKAGE_FILE_NAME = exports2.CURRENT_APP_INSTALLER_FILE_NAME = exports2.XElement = exports2.parseXml = exports2.UUID = exports2.parseDn = exports2.retry = exports2.githubUrl = exports2.getS3LikeProviderBaseUrl = exports2.ProgressCallbackTransform = exports2.MemoLazy = exports2.safeStringifyJson = exports2.safeGetHeader = exports2.parseJson = exports2.HttpExecutor = exports2.HttpError = exports2.DigestTransform = exports2.createHttpError = exports2.configureRequestUrl = exports2.configureRequestOptionsFromUrl = exports2.configureRequestOptions = exports2.newError = exports2.CancellationToken = exports2.CancellationError = void 0;\n    exports2.asArray = asArray;\n    var CancellationToken_1 = require_CancellationToken();\n    Object.defineProperty(exports2, \"CancellationError\", { enumerable: true, get: function() {\n      return CancellationToken_1.CancellationError;\n    } });\n    Object.defineProperty(exports2, \"CancellationToken\", { enumerable: true, get: function() {\n      return CancellationToken_1.CancellationToken;\n    } });\n    var error_1 = require_error();\n    Object.defineProperty(exports2, \"newError\", { enumerable: true, get: function() {\n      return error_1.newError;\n    } });\n    var httpExecutor_1 = require_httpExecutor();\n    Object.defineProperty(exports2, \"configureRequestOptions\", { enumerable: true, get: function() {\n      return httpExecutor_1.configureRequestOptions;\n    } });\n    Object.defineProperty(exports2, \"configureRequestOptionsFromUrl\", { enumerable: true, get: function() {\n      return httpExecutor_1.configureRequestOptionsFromUrl;\n    } });\n    Object.defineProperty(exports2, \"configureRequestUrl\", { enumerable: true, get: function() {\n      return httpExecutor_1.configureRequestUrl;\n    } });\n    Object.defineProperty(exports2, \"createHttpError\", { enumerable: true, get: function() {\n      return httpExecutor_1.createHttpError;\n    } });\n    Object.defineProperty(exports2, \"DigestTransform\", { enumerable: true, get: function() {\n      return httpExecutor_1.DigestTransform;\n    } });\n    Object.defineProperty(exports2, \"HttpError\", { enumerable: true, get: function() {\n      return httpExecutor_1.HttpError;\n    } });\n    Object.defineProperty(exports2, \"HttpExecutor\", { enumerable: true, get: function() {\n      return httpExecutor_1.HttpExecutor;\n    } });\n    Object.defineProperty(exports2, \"parseJson\", { enumerable: true, get: function() {\n      return httpExecutor_1.parseJson;\n    } });\n    Object.defineProperty(exports2, \"safeGetHeader\", { enumerable: true, get: function() {\n      return httpExecutor_1.safeGetHeader;\n    } });\n    Object.defineProperty(exports2, \"safeStringifyJson\", { enumerable: true, get: function() {\n      return httpExecutor_1.safeStringifyJson;\n    } });\n    var MemoLazy_1 = require_MemoLazy();\n    Object.defineProperty(exports2, \"MemoLazy\", { enumerable: true, get: function() {\n      return MemoLazy_1.MemoLazy;\n    } });\n    var ProgressCallbackTransform_1 = require_ProgressCallbackTransform();\n    Object.defineProperty(exports2, \"ProgressCallbackTransform\", { enumerable: true, get: function() {\n      return ProgressCallbackTransform_1.ProgressCallbackTransform;\n    } });\n    var publishOptions_1 = require_publishOptions();\n    Object.defineProperty(exports2, \"getS3LikeProviderBaseUrl\", { enumerable: true, get: function() {\n      return publishOptions_1.getS3LikeProviderBaseUrl;\n    } });\n    Object.defineProperty(exports2, \"githubUrl\", { enumerable: true, get: function() {\n      return publishOptions_1.githubUrl;\n    } });\n    var retry_1 = require_retry();\n    Object.defineProperty(exports2, \"retry\", { enumerable: true, get: function() {\n      return retry_1.retry;\n    } });\n    var rfc2253Parser_1 = require_rfc2253Parser();\n    Object.defineProperty(exports2, \"parseDn\", { enumerable: true, get: function() {\n      return rfc2253Parser_1.parseDn;\n    } });\n    var uuid_1 = require_uuid();\n    Object.defineProperty(exports2, \"UUID\", { enumerable: true, get: function() {\n      return uuid_1.UUID;\n    } });\n    var xml_1 = require_xml();\n    Object.defineProperty(exports2, \"parseXml\", { enumerable: true, get: function() {\n      return xml_1.parseXml;\n    } });\n    Object.defineProperty(exports2, \"XElement\", { enumerable: true, get: function() {\n      return xml_1.XElement;\n    } });\n    exports2.CURRENT_APP_INSTALLER_FILE_NAME = \"installer.exe\";\n    exports2.CURRENT_APP_PACKAGE_FILE_NAME = \"package.7z\";\n    function asArray(v) {\n      if (v == null) {\n        return [];\n      } else if (Array.isArray(v)) {\n        return v;\n      } else {\n        return [v];\n      }\n    }\n  }\n});\n\n// node_modules/js-yaml/lib/common.js\nvar require_common2 = __commonJS({\n  \"node_modules/js-yaml/lib/common.js\"(exports2, module2) {\n    \"use strict\";\n    function isNothing(subject) {\n      return typeof subject === \"undefined\" || subject === null;\n    }\n    function isObject(subject) {\n      return typeof subject === \"object\" && subject !== null;\n    }\n    function toArray(sequence) {\n      if (Array.isArray(sequence)) return sequence;\n      else if (isNothing(sequence)) return [];\n      return [sequence];\n    }\n    function extend(target, source) {\n      var index, length, key, sourceKeys;\n      if (source) {\n        sourceKeys = Object.keys(source);\n        for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n          key = sourceKeys[index];\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function repeat(string, count) {\n      var result = \"\", cycle;\n      for (cycle = 0; cycle < count; cycle += 1) {\n        result += string;\n      }\n      return result;\n    }\n    function isNegativeZero(number) {\n      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n    }\n    module2.exports.isNothing = isNothing;\n    module2.exports.isObject = isObject;\n    module2.exports.toArray = toArray;\n    module2.exports.repeat = repeat;\n    module2.exports.isNegativeZero = isNegativeZero;\n    module2.exports.extend = extend;\n  }\n});\n\n// node_modules/js-yaml/lib/exception.js\nvar require_exception = __commonJS({\n  \"node_modules/js-yaml/lib/exception.js\"(exports2, module2) {\n    \"use strict\";\n    function formatError(exception, compact) {\n      var where = \"\", message = exception.reason || \"(unknown reason)\";\n      if (!exception.mark) return message;\n      if (exception.mark.name) {\n        where += 'in \"' + exception.mark.name + '\" ';\n      }\n      where += \"(\" + (exception.mark.line + 1) + \":\" + (exception.mark.column + 1) + \")\";\n      if (!compact && exception.mark.snippet) {\n        where += \"\\n\\n\" + exception.mark.snippet;\n      }\n      return message + \" \" + where;\n    }\n    function YAMLException(reason, mark) {\n      Error.call(this);\n      this.name = \"YAMLException\";\n      this.reason = reason;\n      this.mark = mark;\n      this.message = formatError(this, false);\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        this.stack = new Error().stack || \"\";\n      }\n    }\n    YAMLException.prototype = Object.create(Error.prototype);\n    YAMLException.prototype.constructor = YAMLException;\n    YAMLException.prototype.toString = function toString(compact) {\n      return this.name + \": \" + formatError(this, compact);\n    };\n    module2.exports = YAMLException;\n  }\n});\n\n// node_modules/js-yaml/lib/snippet.js\nvar require_snippet = __commonJS({\n  \"node_modules/js-yaml/lib/snippet.js\"(exports2, module2) {\n    \"use strict\";\n    var common = require_common2();\n    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n      var head = \"\";\n      var tail = \"\";\n      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n      if (position - lineStart > maxHalfLength) {\n        head = \" ... \";\n        lineStart = position - maxHalfLength + head.length;\n      }\n      if (lineEnd - position > maxHalfLength) {\n        tail = \" ...\";\n        lineEnd = position + maxHalfLength - tail.length;\n      }\n      return {\n        str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, \"\\u2192\") + tail,\n        pos: position - lineStart + head.length\n        // relative position\n      };\n    }\n    function padStart(string, max) {\n      return common.repeat(\" \", max - string.length) + string;\n    }\n    function makeSnippet(mark, options) {\n      options = Object.create(options || null);\n      if (!mark.buffer) return null;\n      if (!options.maxLength) options.maxLength = 79;\n      if (typeof options.indent !== \"number\") options.indent = 1;\n      if (typeof options.linesBefore !== \"number\") options.linesBefore = 3;\n      if (typeof options.linesAfter !== \"number\") options.linesAfter = 2;\n      var re = /\\r?\\n|\\r|\\0/g;\n      var lineStarts = [0];\n      var lineEnds = [];\n      var match;\n      var foundLineNo = -1;\n      while (match = re.exec(mark.buffer)) {\n        lineEnds.push(match.index);\n        lineStarts.push(match.index + match[0].length);\n        if (mark.position <= match.index && foundLineNo < 0) {\n          foundLineNo = lineStarts.length - 2;\n        }\n      }\n      if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n      var result = \"\", i, line;\n      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n      for (i = 1; i <= options.linesBefore; i++) {\n        if (foundLineNo - i < 0) break;\n        line = getLine(\n          mark.buffer,\n          lineStarts[foundLineNo - i],\n          lineEnds[foundLineNo - i],\n          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n          maxLineLength\n        );\n        result = common.repeat(\" \", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\" + result;\n      }\n      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n      result += common.repeat(\" \", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\";\n      result += common.repeat(\"-\", options.indent + lineNoLength + 3 + line.pos) + \"^\\n\";\n      for (i = 1; i <= options.linesAfter; i++) {\n        if (foundLineNo + i >= lineEnds.length) break;\n        line = getLine(\n          mark.buffer,\n          lineStarts[foundLineNo + i],\n          lineEnds[foundLineNo + i],\n          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n          maxLineLength\n        );\n        result += common.repeat(\" \", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\";\n      }\n      return result.replace(/\\n$/, \"\");\n    }\n    module2.exports = makeSnippet;\n  }\n});\n\n// node_modules/js-yaml/lib/type.js\nvar require_type = __commonJS({\n  \"node_modules/js-yaml/lib/type.js\"(exports2, module2) {\n    \"use strict\";\n    var YAMLException = require_exception();\n    var TYPE_CONSTRUCTOR_OPTIONS = [\n      \"kind\",\n      \"multi\",\n      \"resolve\",\n      \"construct\",\n      \"instanceOf\",\n      \"predicate\",\n      \"represent\",\n      \"representName\",\n      \"defaultStyle\",\n      \"styleAliases\"\n    ];\n    var YAML_NODE_KINDS = [\n      \"scalar\",\n      \"sequence\",\n      \"mapping\"\n    ];\n    function compileStyleAliases(map) {\n      var result = {};\n      if (map !== null) {\n        Object.keys(map).forEach(function(style) {\n          map[style].forEach(function(alias) {\n            result[String(alias)] = style;\n          });\n        });\n      }\n      return result;\n    }\n    function Type(tag, options) {\n      options = options || {};\n      Object.keys(options).forEach(function(name) {\n        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n          throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n        }\n      });\n      this.options = options;\n      this.tag = tag;\n      this.kind = options[\"kind\"] || null;\n      this.resolve = options[\"resolve\"] || function() {\n        return true;\n      };\n      this.construct = options[\"construct\"] || function(data) {\n        return data;\n      };\n      this.instanceOf = options[\"instanceOf\"] || null;\n      this.predicate = options[\"predicate\"] || null;\n      this.represent = options[\"represent\"] || null;\n      this.representName = options[\"representName\"] || null;\n      this.defaultStyle = options[\"defaultStyle\"] || null;\n      this.multi = options[\"multi\"] || false;\n      this.styleAliases = compileStyleAliases(options[\"styleAliases\"] || null);\n      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n        throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n      }\n    }\n    module2.exports = Type;\n  }\n});\n\n// node_modules/js-yaml/lib/schema.js\nvar require_schema = __commonJS({\n  \"node_modules/js-yaml/lib/schema.js\"(exports2, module2) {\n    \"use strict\";\n    var YAMLException = require_exception();\n    var Type = require_type();\n    function compileList(schema, name) {\n      var result = [];\n      schema[name].forEach(function(currentType) {\n        var newIndex = result.length;\n        result.forEach(function(previousType, previousIndex) {\n          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n            newIndex = previousIndex;\n          }\n        });\n        result[newIndex] = currentType;\n      });\n      return result;\n    }\n    function compileMap() {\n      var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n      function collectType(type) {\n        if (type.multi) {\n          result.multi[type.kind].push(type);\n          result.multi[\"fallback\"].push(type);\n        } else {\n          result[type.kind][type.tag] = result[\"fallback\"][type.tag] = type;\n        }\n      }\n      for (index = 0, length = arguments.length; index < length; index += 1) {\n        arguments[index].forEach(collectType);\n      }\n      return result;\n    }\n    function Schema(definition) {\n      return this.extend(definition);\n    }\n    Schema.prototype.extend = function extend(definition) {\n      var implicit = [];\n      var explicit = [];\n      if (definition instanceof Type) {\n        explicit.push(definition);\n      } else if (Array.isArray(definition)) {\n        explicit = explicit.concat(definition);\n      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n        if (definition.implicit) implicit = implicit.concat(definition.implicit);\n        if (definition.explicit) explicit = explicit.concat(definition.explicit);\n      } else {\n        throw new YAMLException(\"Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })\");\n      }\n      implicit.forEach(function(type) {\n        if (!(type instanceof Type)) {\n          throw new YAMLException(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n        }\n        if (type.loadKind && type.loadKind !== \"scalar\") {\n          throw new YAMLException(\"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.\");\n        }\n        if (type.multi) {\n          throw new YAMLException(\"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.\");\n        }\n      });\n      explicit.forEach(function(type) {\n        if (!(type instanceof Type)) {\n          throw new YAMLException(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n        }\n      });\n      var result = Object.create(Schema.prototype);\n      result.implicit = (this.implicit || []).concat(implicit);\n      result.explicit = (this.explicit || []).concat(explicit);\n      result.compiledImplicit = compileList(result, \"implicit\");\n      result.compiledExplicit = compileList(result, \"explicit\");\n      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n      return result;\n    };\n    module2.exports = Schema;\n  }\n});\n\n// node_modules/js-yaml/lib/type/str.js\nvar require_str = __commonJS({\n  \"node_modules/js-yaml/lib/type/str.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    module2.exports = new Type(\"tag:yaml.org,2002:str\", {\n      kind: \"scalar\",\n      construct: function(data) {\n        return data !== null ? data : \"\";\n      }\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/seq.js\nvar require_seq = __commonJS({\n  \"node_modules/js-yaml/lib/type/seq.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    module2.exports = new Type(\"tag:yaml.org,2002:seq\", {\n      kind: \"sequence\",\n      construct: function(data) {\n        return data !== null ? data : [];\n      }\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/map.js\nvar require_map = __commonJS({\n  \"node_modules/js-yaml/lib/type/map.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    module2.exports = new Type(\"tag:yaml.org,2002:map\", {\n      kind: \"mapping\",\n      construct: function(data) {\n        return data !== null ? data : {};\n      }\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/schema/failsafe.js\nvar require_failsafe = __commonJS({\n  \"node_modules/js-yaml/lib/schema/failsafe.js\"(exports2, module2) {\n    \"use strict\";\n    var Schema = require_schema();\n    module2.exports = new Schema({\n      explicit: [\n        require_str(),\n        require_seq(),\n        require_map()\n      ]\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/null.js\nvar require_null = __commonJS({\n  \"node_modules/js-yaml/lib/type/null.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    function resolveYamlNull(data) {\n      if (data === null) return true;\n      var max = data.length;\n      return max === 1 && data === \"~\" || max === 4 && (data === \"null\" || data === \"Null\" || data === \"NULL\");\n    }\n    function constructYamlNull() {\n      return null;\n    }\n    function isNull(object) {\n      return object === null;\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:null\", {\n      kind: \"scalar\",\n      resolve: resolveYamlNull,\n      construct: constructYamlNull,\n      predicate: isNull,\n      represent: {\n        canonical: function() {\n          return \"~\";\n        },\n        lowercase: function() {\n          return \"null\";\n        },\n        uppercase: function() {\n          return \"NULL\";\n        },\n        camelcase: function() {\n          return \"Null\";\n        },\n        empty: function() {\n          return \"\";\n        }\n      },\n      defaultStyle: \"lowercase\"\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/bool.js\nvar require_bool = __commonJS({\n  \"node_modules/js-yaml/lib/type/bool.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    function resolveYamlBoolean(data) {\n      if (data === null) return false;\n      var max = data.length;\n      return max === 4 && (data === \"true\" || data === \"True\" || data === \"TRUE\") || max === 5 && (data === \"false\" || data === \"False\" || data === \"FALSE\");\n    }\n    function constructYamlBoolean(data) {\n      return data === \"true\" || data === \"True\" || data === \"TRUE\";\n    }\n    function isBoolean(object) {\n      return Object.prototype.toString.call(object) === \"[object Boolean]\";\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:bool\", {\n      kind: \"scalar\",\n      resolve: resolveYamlBoolean,\n      construct: constructYamlBoolean,\n      predicate: isBoolean,\n      represent: {\n        lowercase: function(object) {\n          return object ? \"true\" : \"false\";\n        },\n        uppercase: function(object) {\n          return object ? \"TRUE\" : \"FALSE\";\n        },\n        camelcase: function(object) {\n          return object ? \"True\" : \"False\";\n        }\n      },\n      defaultStyle: \"lowercase\"\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/int.js\nvar require_int = __commonJS({\n  \"node_modules/js-yaml/lib/type/int.js\"(exports2, module2) {\n    \"use strict\";\n    var common = require_common2();\n    var Type = require_type();\n    function isHexCode(c) {\n      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;\n    }\n    function isOctCode(c) {\n      return 48 <= c && c <= 55;\n    }\n    function isDecCode(c) {\n      return 48 <= c && c <= 57;\n    }\n    function resolveYamlInteger(data) {\n      if (data === null) return false;\n      var max = data.length, index = 0, hasDigits = false, ch;\n      if (!max) return false;\n      ch = data[index];\n      if (ch === \"-\" || ch === \"+\") {\n        ch = data[++index];\n      }\n      if (ch === \"0\") {\n        if (index + 1 === max) return true;\n        ch = data[++index];\n        if (ch === \"b\") {\n          index++;\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === \"_\") continue;\n            if (ch !== \"0\" && ch !== \"1\") return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== \"_\";\n        }\n        if (ch === \"x\") {\n          index++;\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === \"_\") continue;\n            if (!isHexCode(data.charCodeAt(index))) return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== \"_\";\n        }\n        if (ch === \"o\") {\n          index++;\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === \"_\") continue;\n            if (!isOctCode(data.charCodeAt(index))) return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== \"_\";\n        }\n      }\n      if (ch === \"_\") return false;\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === \"_\") continue;\n        if (!isDecCode(data.charCodeAt(index))) {\n          return false;\n        }\n        hasDigits = true;\n      }\n      if (!hasDigits || ch === \"_\") return false;\n      return true;\n    }\n    function constructYamlInteger(data) {\n      var value = data, sign = 1, ch;\n      if (value.indexOf(\"_\") !== -1) {\n        value = value.replace(/_/g, \"\");\n      }\n      ch = value[0];\n      if (ch === \"-\" || ch === \"+\") {\n        if (ch === \"-\") sign = -1;\n        value = value.slice(1);\n        ch = value[0];\n      }\n      if (value === \"0\") return 0;\n      if (ch === \"0\") {\n        if (value[1] === \"b\") return sign * parseInt(value.slice(2), 2);\n        if (value[1] === \"x\") return sign * parseInt(value.slice(2), 16);\n        if (value[1] === \"o\") return sign * parseInt(value.slice(2), 8);\n      }\n      return sign * parseInt(value, 10);\n    }\n    function isInteger(object) {\n      return Object.prototype.toString.call(object) === \"[object Number]\" && (object % 1 === 0 && !common.isNegativeZero(object));\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:int\", {\n      kind: \"scalar\",\n      resolve: resolveYamlInteger,\n      construct: constructYamlInteger,\n      predicate: isInteger,\n      represent: {\n        binary: function(obj) {\n          return obj >= 0 ? \"0b\" + obj.toString(2) : \"-0b\" + obj.toString(2).slice(1);\n        },\n        octal: function(obj) {\n          return obj >= 0 ? \"0o\" + obj.toString(8) : \"-0o\" + obj.toString(8).slice(1);\n        },\n        decimal: function(obj) {\n          return obj.toString(10);\n        },\n        /* eslint-disable max-len */\n        hexadecimal: function(obj) {\n          return obj >= 0 ? \"0x\" + obj.toString(16).toUpperCase() : \"-0x\" + obj.toString(16).toUpperCase().slice(1);\n        }\n      },\n      defaultStyle: \"decimal\",\n      styleAliases: {\n        binary: [2, \"bin\"],\n        octal: [8, \"oct\"],\n        decimal: [10, \"dec\"],\n        hexadecimal: [16, \"hex\"]\n      }\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/float.js\nvar require_float = __commonJS({\n  \"node_modules/js-yaml/lib/type/float.js\"(exports2, module2) {\n    \"use strict\";\n    var common = require_common2();\n    var Type = require_type();\n    var YAML_FLOAT_PATTERN = new RegExp(\n      // 2.5e4, 2.5 and integers\n      \"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\\\.(?:inf|Inf|INF)|\\\\.(?:nan|NaN|NAN))$\"\n    );\n    function resolveYamlFloat(data) {\n      if (data === null) return false;\n      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === \"_\") {\n        return false;\n      }\n      return true;\n    }\n    function constructYamlFloat(data) {\n      var value, sign;\n      value = data.replace(/_/g, \"\").toLowerCase();\n      sign = value[0] === \"-\" ? -1 : 1;\n      if (\"+-\".indexOf(value[0]) >= 0) {\n        value = value.slice(1);\n      }\n      if (value === \".inf\") {\n        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n      } else if (value === \".nan\") {\n        return NaN;\n      }\n      return sign * parseFloat(value, 10);\n    }\n    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n    function representYamlFloat(object, style) {\n      var res;\n      if (isNaN(object)) {\n        switch (style) {\n          case \"lowercase\":\n            return \".nan\";\n          case \"uppercase\":\n            return \".NAN\";\n          case \"camelcase\":\n            return \".NaN\";\n        }\n      } else if (Number.POSITIVE_INFINITY === object) {\n        switch (style) {\n          case \"lowercase\":\n            return \".inf\";\n          case \"uppercase\":\n            return \".INF\";\n          case \"camelcase\":\n            return \".Inf\";\n        }\n      } else if (Number.NEGATIVE_INFINITY === object) {\n        switch (style) {\n          case \"lowercase\":\n            return \"-.inf\";\n          case \"uppercase\":\n            return \"-.INF\";\n          case \"camelcase\":\n            return \"-.Inf\";\n        }\n      } else if (common.isNegativeZero(object)) {\n        return \"-0.0\";\n      }\n      res = object.toString(10);\n      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(\"e\", \".e\") : res;\n    }\n    function isFloat(object) {\n      return Object.prototype.toString.call(object) === \"[object Number]\" && (object % 1 !== 0 || common.isNegativeZero(object));\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:float\", {\n      kind: \"scalar\",\n      resolve: resolveYamlFloat,\n      construct: constructYamlFloat,\n      predicate: isFloat,\n      represent: representYamlFloat,\n      defaultStyle: \"lowercase\"\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/schema/json.js\nvar require_json2 = __commonJS({\n  \"node_modules/js-yaml/lib/schema/json.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_failsafe().extend({\n      implicit: [\n        require_null(),\n        require_bool(),\n        require_int(),\n        require_float()\n      ]\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/schema/core.js\nvar require_core = __commonJS({\n  \"node_modules/js-yaml/lib/schema/core.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_json2();\n  }\n});\n\n// node_modules/js-yaml/lib/type/timestamp.js\nvar require_timestamp = __commonJS({\n  \"node_modules/js-yaml/lib/type/timestamp.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    var YAML_DATE_REGEXP = new RegExp(\n      \"^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$\"\n    );\n    var YAML_TIMESTAMP_REGEXP = new RegExp(\n      \"^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\\\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\\\.([0-9]*))?(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$\"\n    );\n    function resolveYamlTimestamp(data) {\n      if (data === null) return false;\n      if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n      return false;\n    }\n    function constructYamlTimestamp(data) {\n      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;\n      match = YAML_DATE_REGEXP.exec(data);\n      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n      if (match === null) throw new Error(\"Date resolve error\");\n      year = +match[1];\n      month = +match[2] - 1;\n      day = +match[3];\n      if (!match[4]) {\n        return new Date(Date.UTC(year, month, day));\n      }\n      hour = +match[4];\n      minute = +match[5];\n      second = +match[6];\n      if (match[7]) {\n        fraction = match[7].slice(0, 3);\n        while (fraction.length < 3) {\n          fraction += \"0\";\n        }\n        fraction = +fraction;\n      }\n      if (match[9]) {\n        tz_hour = +match[10];\n        tz_minute = +(match[11] || 0);\n        delta = (tz_hour * 60 + tz_minute) * 6e4;\n        if (match[9] === \"-\") delta = -delta;\n      }\n      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n      if (delta) date.setTime(date.getTime() - delta);\n      return date;\n    }\n    function representYamlTimestamp(object) {\n      return object.toISOString();\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:timestamp\", {\n      kind: \"scalar\",\n      resolve: resolveYamlTimestamp,\n      construct: constructYamlTimestamp,\n      instanceOf: Date,\n      represent: representYamlTimestamp\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/merge.js\nvar require_merge = __commonJS({\n  \"node_modules/js-yaml/lib/type/merge.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    function resolveYamlMerge(data) {\n      return data === \"<<\" || data === null;\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:merge\", {\n      kind: \"scalar\",\n      resolve: resolveYamlMerge\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/binary.js\nvar require_binary = __commonJS({\n  \"node_modules/js-yaml/lib/type/binary.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    var BASE64_MAP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r\";\n    function resolveYamlBinary(data) {\n      if (data === null) return false;\n      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n      for (idx = 0; idx < max; idx++) {\n        code = map.indexOf(data.charAt(idx));\n        if (code > 64) continue;\n        if (code < 0) return false;\n        bitlen += 6;\n      }\n      return bitlen % 8 === 0;\n    }\n    function constructYamlBinary(data) {\n      var idx, tailbits, input = data.replace(/[\\r\\n=]/g, \"\"), max = input.length, map = BASE64_MAP, bits = 0, result = [];\n      for (idx = 0; idx < max; idx++) {\n        if (idx % 4 === 0 && idx) {\n          result.push(bits >> 16 & 255);\n          result.push(bits >> 8 & 255);\n          result.push(bits & 255);\n        }\n        bits = bits << 6 | map.indexOf(input.charAt(idx));\n      }\n      tailbits = max % 4 * 6;\n      if (tailbits === 0) {\n        result.push(bits >> 16 & 255);\n        result.push(bits >> 8 & 255);\n        result.push(bits & 255);\n      } else if (tailbits === 18) {\n        result.push(bits >> 10 & 255);\n        result.push(bits >> 2 & 255);\n      } else if (tailbits === 12) {\n        result.push(bits >> 4 & 255);\n      }\n      return new Uint8Array(result);\n    }\n    function representYamlBinary(object) {\n      var result = \"\", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;\n      for (idx = 0; idx < max; idx++) {\n        if (idx % 3 === 0 && idx) {\n          result += map[bits >> 18 & 63];\n          result += map[bits >> 12 & 63];\n          result += map[bits >> 6 & 63];\n          result += map[bits & 63];\n        }\n        bits = (bits << 8) + object[idx];\n      }\n      tail = max % 3;\n      if (tail === 0) {\n        result += map[bits >> 18 & 63];\n        result += map[bits >> 12 & 63];\n        result += map[bits >> 6 & 63];\n        result += map[bits & 63];\n      } else if (tail === 2) {\n        result += map[bits >> 10 & 63];\n        result += map[bits >> 4 & 63];\n        result += map[bits << 2 & 63];\n        result += map[64];\n      } else if (tail === 1) {\n        result += map[bits >> 2 & 63];\n        result += map[bits << 4 & 63];\n        result += map[64];\n        result += map[64];\n      }\n      return result;\n    }\n    function isBinary(obj) {\n      return Object.prototype.toString.call(obj) === \"[object Uint8Array]\";\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:binary\", {\n      kind: \"scalar\",\n      resolve: resolveYamlBinary,\n      construct: constructYamlBinary,\n      predicate: isBinary,\n      represent: representYamlBinary\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/omap.js\nvar require_omap = __commonJS({\n  \"node_modules/js-yaml/lib/type/omap.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    var _toString = Object.prototype.toString;\n    function resolveYamlOmap(data) {\n      if (data === null) return true;\n      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;\n      for (index = 0, length = object.length; index < length; index += 1) {\n        pair = object[index];\n        pairHasKey = false;\n        if (_toString.call(pair) !== \"[object Object]\") return false;\n        for (pairKey in pair) {\n          if (_hasOwnProperty.call(pair, pairKey)) {\n            if (!pairHasKey) pairHasKey = true;\n            else return false;\n          }\n        }\n        if (!pairHasKey) return false;\n        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n        else return false;\n      }\n      return true;\n    }\n    function constructYamlOmap(data) {\n      return data !== null ? data : [];\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:omap\", {\n      kind: \"sequence\",\n      resolve: resolveYamlOmap,\n      construct: constructYamlOmap\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/pairs.js\nvar require_pairs = __commonJS({\n  \"node_modules/js-yaml/lib/type/pairs.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    var _toString = Object.prototype.toString;\n    function resolveYamlPairs(data) {\n      if (data === null) return true;\n      var index, length, pair, keys, result, object = data;\n      result = new Array(object.length);\n      for (index = 0, length = object.length; index < length; index += 1) {\n        pair = object[index];\n        if (_toString.call(pair) !== \"[object Object]\") return false;\n        keys = Object.keys(pair);\n        if (keys.length !== 1) return false;\n        result[index] = [keys[0], pair[keys[0]]];\n      }\n      return true;\n    }\n    function constructYamlPairs(data) {\n      if (data === null) return [];\n      var index, length, pair, keys, result, object = data;\n      result = new Array(object.length);\n      for (index = 0, length = object.length; index < length; index += 1) {\n        pair = object[index];\n        keys = Object.keys(pair);\n        result[index] = [keys[0], pair[keys[0]]];\n      }\n      return result;\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:pairs\", {\n      kind: \"sequence\",\n      resolve: resolveYamlPairs,\n      construct: constructYamlPairs\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/type/set.js\nvar require_set = __commonJS({\n  \"node_modules/js-yaml/lib/type/set.js\"(exports2, module2) {\n    \"use strict\";\n    var Type = require_type();\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    function resolveYamlSet(data) {\n      if (data === null) return true;\n      var key, object = data;\n      for (key in object) {\n        if (_hasOwnProperty.call(object, key)) {\n          if (object[key] !== null) return false;\n        }\n      }\n      return true;\n    }\n    function constructYamlSet(data) {\n      return data !== null ? data : {};\n    }\n    module2.exports = new Type(\"tag:yaml.org,2002:set\", {\n      kind: \"mapping\",\n      resolve: resolveYamlSet,\n      construct: constructYamlSet\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/schema/default.js\nvar require_default = __commonJS({\n  \"node_modules/js-yaml/lib/schema/default.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_core().extend({\n      implicit: [\n        require_timestamp(),\n        require_merge()\n      ],\n      explicit: [\n        require_binary(),\n        require_omap(),\n        require_pairs(),\n        require_set()\n      ]\n    });\n  }\n});\n\n// node_modules/js-yaml/lib/loader.js\nvar require_loader = __commonJS({\n  \"node_modules/js-yaml/lib/loader.js\"(exports2, module2) {\n    \"use strict\";\n    var common = require_common2();\n    var YAMLException = require_exception();\n    var makeSnippet = require_snippet();\n    var DEFAULT_SCHEMA = require_default();\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    var CONTEXT_FLOW_IN = 1;\n    var CONTEXT_FLOW_OUT = 2;\n    var CONTEXT_BLOCK_IN = 3;\n    var CONTEXT_BLOCK_OUT = 4;\n    var CHOMPING_CLIP = 1;\n    var CHOMPING_STRIP = 2;\n    var CHOMPING_KEEP = 3;\n    var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n    var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n    var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n    var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function is_EOL(c) {\n      return c === 10 || c === 13;\n    }\n    function is_WHITE_SPACE(c) {\n      return c === 9 || c === 32;\n    }\n    function is_WS_OR_EOL(c) {\n      return c === 9 || c === 32 || c === 10 || c === 13;\n    }\n    function is_FLOW_INDICATOR(c) {\n      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;\n    }\n    function fromHexCode(c) {\n      var lc;\n      if (48 <= c && c <= 57) {\n        return c - 48;\n      }\n      lc = c | 32;\n      if (97 <= lc && lc <= 102) {\n        return lc - 97 + 10;\n      }\n      return -1;\n    }\n    function escapedHexLen(c) {\n      if (c === 120) {\n        return 2;\n      }\n      if (c === 117) {\n        return 4;\n      }\n      if (c === 85) {\n        return 8;\n      }\n      return 0;\n    }\n    function fromDecimalCode(c) {\n      if (48 <= c && c <= 57) {\n        return c - 48;\n      }\n      return -1;\n    }\n    function simpleEscapeSequence(c) {\n      return c === 48 ? \"\\0\" : c === 97 ? \"\\x07\" : c === 98 ? \"\\b\" : c === 116 ? \"\t\" : c === 9 ? \"\t\" : c === 110 ? \"\\n\" : c === 118 ? \"\\v\" : c === 102 ? \"\\f\" : c === 114 ? \"\\r\" : c === 101 ? \"\\x1B\" : c === 32 ? \" \" : c === 34 ? '\"' : c === 47 ? \"/\" : c === 92 ? \"\\\\\" : c === 78 ? \"\\x85\" : c === 95 ? \"\\xA0\" : c === 76 ? \"\\u2028\" : c === 80 ? \"\\u2029\" : \"\";\n    }\n    function charFromCodepoint(c) {\n      if (c <= 65535) {\n        return String.fromCharCode(c);\n      }\n      return String.fromCharCode(\n        (c - 65536 >> 10) + 55296,\n        (c - 65536 & 1023) + 56320\n      );\n    }\n    function setProperty(object, key, value) {\n      if (key === \"__proto__\") {\n        Object.defineProperty(object, key, {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n    var simpleEscapeCheck = new Array(256);\n    var simpleEscapeMap = new Array(256);\n    for (i = 0; i < 256; i++) {\n      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n      simpleEscapeMap[i] = simpleEscapeSequence(i);\n    }\n    var i;\n    function State(input, options) {\n      this.input = input;\n      this.filename = options[\"filename\"] || null;\n      this.schema = options[\"schema\"] || DEFAULT_SCHEMA;\n      this.onWarning = options[\"onWarning\"] || null;\n      this.legacy = options[\"legacy\"] || false;\n      this.json = options[\"json\"] || false;\n      this.listener = options[\"listener\"] || null;\n      this.implicitTypes = this.schema.compiledImplicit;\n      this.typeMap = this.schema.compiledTypeMap;\n      this.length = input.length;\n      this.position = 0;\n      this.line = 0;\n      this.lineStart = 0;\n      this.lineIndent = 0;\n      this.firstTabInLine = -1;\n      this.documents = [];\n    }\n    function generateError(state, message) {\n      var mark = {\n        name: state.filename,\n        buffer: state.input.slice(0, -1),\n        // omit trailing \\0\n        position: state.position,\n        line: state.line,\n        column: state.position - state.lineStart\n      };\n      mark.snippet = makeSnippet(mark);\n      return new YAMLException(message, mark);\n    }\n    function throwError(state, message) {\n      throw generateError(state, message);\n    }\n    function throwWarning(state, message) {\n      if (state.onWarning) {\n        state.onWarning.call(null, generateError(state, message));\n      }\n    }\n    var directiveHandlers = {\n      YAML: function handleYamlDirective(state, name, args) {\n        var match, major, minor;\n        if (state.version !== null) {\n          throwError(state, \"duplication of %YAML directive\");\n        }\n        if (args.length !== 1) {\n          throwError(state, \"YAML directive accepts exactly one argument\");\n        }\n        match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n        if (match === null) {\n          throwError(state, \"ill-formed argument of the YAML directive\");\n        }\n        major = parseInt(match[1], 10);\n        minor = parseInt(match[2], 10);\n        if (major !== 1) {\n          throwError(state, \"unacceptable YAML version of the document\");\n        }\n        state.version = args[0];\n        state.checkLineBreaks = minor < 2;\n        if (minor !== 1 && minor !== 2) {\n          throwWarning(state, \"unsupported YAML version of the document\");\n        }\n      },\n      TAG: function handleTagDirective(state, name, args) {\n        var handle, prefix;\n        if (args.length !== 2) {\n          throwError(state, \"TAG directive accepts exactly two arguments\");\n        }\n        handle = args[0];\n        prefix = args[1];\n        if (!PATTERN_TAG_HANDLE.test(handle)) {\n          throwError(state, \"ill-formed tag handle (first argument) of the TAG directive\");\n        }\n        if (_hasOwnProperty.call(state.tagMap, handle)) {\n          throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n        }\n        if (!PATTERN_TAG_URI.test(prefix)) {\n          throwError(state, \"ill-formed tag prefix (second argument) of the TAG directive\");\n        }\n        try {\n          prefix = decodeURIComponent(prefix);\n        } catch (err) {\n          throwError(state, \"tag prefix is malformed: \" + prefix);\n        }\n        state.tagMap[handle] = prefix;\n      }\n    };\n    function captureSegment(state, start, end, checkJson) {\n      var _position, _length, _character, _result;\n      if (start < end) {\n        _result = state.input.slice(start, end);\n        if (checkJson) {\n          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n            _character = _result.charCodeAt(_position);\n            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {\n              throwError(state, \"expected valid JSON character\");\n            }\n          }\n        } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n          throwError(state, \"the stream contains non-printable characters\");\n        }\n        state.result += _result;\n      }\n    }\n    function mergeMappings(state, destination, source, overridableKeys) {\n      var sourceKeys, key, index, quantity;\n      if (!common.isObject(source)) {\n        throwError(state, \"cannot merge mappings; the provided source object is unacceptable\");\n      }\n      sourceKeys = Object.keys(source);\n      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n        key = sourceKeys[index];\n        if (!_hasOwnProperty.call(destination, key)) {\n          setProperty(destination, key, source[key]);\n          overridableKeys[key] = true;\n        }\n      }\n    }\n    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {\n      var index, quantity;\n      if (Array.isArray(keyNode)) {\n        keyNode = Array.prototype.slice.call(keyNode);\n        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n          if (Array.isArray(keyNode[index])) {\n            throwError(state, \"nested arrays are not supported inside keys\");\n          }\n          if (typeof keyNode === \"object\" && _class(keyNode[index]) === \"[object Object]\") {\n            keyNode[index] = \"[object Object]\";\n          }\n        }\n      }\n      if (typeof keyNode === \"object\" && _class(keyNode) === \"[object Object]\") {\n        keyNode = \"[object Object]\";\n      }\n      keyNode = String(keyNode);\n      if (_result === null) {\n        _result = {};\n      }\n      if (keyTag === \"tag:yaml.org,2002:merge\") {\n        if (Array.isArray(valueNode)) {\n          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n            mergeMappings(state, _result, valueNode[index], overridableKeys);\n          }\n        } else {\n          mergeMappings(state, _result, valueNode, overridableKeys);\n        }\n      } else {\n        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {\n          state.line = startLine || state.line;\n          state.lineStart = startLineStart || state.lineStart;\n          state.position = startPos || state.position;\n          throwError(state, \"duplicated mapping key\");\n        }\n        setProperty(_result, keyNode, valueNode);\n        delete overridableKeys[keyNode];\n      }\n      return _result;\n    }\n    function readLineBreak(state) {\n      var ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 10) {\n        state.position++;\n      } else if (ch === 13) {\n        state.position++;\n        if (state.input.charCodeAt(state.position) === 10) {\n          state.position++;\n        }\n      } else {\n        throwError(state, \"a line break is expected\");\n      }\n      state.line += 1;\n      state.lineStart = state.position;\n      state.firstTabInLine = -1;\n    }\n    function skipSeparationSpace(state, allowComments, checkIndent) {\n      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);\n      while (ch !== 0) {\n        while (is_WHITE_SPACE(ch)) {\n          if (ch === 9 && state.firstTabInLine === -1) {\n            state.firstTabInLine = state.position;\n          }\n          ch = state.input.charCodeAt(++state.position);\n        }\n        if (allowComments && ch === 35) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 10 && ch !== 13 && ch !== 0);\n        }\n        if (is_EOL(ch)) {\n          readLineBreak(state);\n          ch = state.input.charCodeAt(state.position);\n          lineBreaks++;\n          state.lineIndent = 0;\n          while (ch === 32) {\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n          }\n        } else {\n          break;\n        }\n      }\n      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n        throwWarning(state, \"deficient indentation\");\n      }\n      return lineBreaks;\n    }\n    function testDocumentSeparator(state) {\n      var _position = state.position, ch;\n      ch = state.input.charCodeAt(_position);\n      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n        _position += 3;\n        ch = state.input.charCodeAt(_position);\n        if (ch === 0 || is_WS_OR_EOL(ch)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function writeFoldedLines(state, count) {\n      if (count === 1) {\n        state.result += \" \";\n      } else if (count > 1) {\n        state.result += common.repeat(\"\\n\", count - 1);\n      }\n    }\n    function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {\n        return false;\n      }\n      if (ch === 63 || ch === 45) {\n        following = state.input.charCodeAt(state.position + 1);\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          return false;\n        }\n      }\n      state.kind = \"scalar\";\n      state.result = \"\";\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n      while (ch !== 0) {\n        if (ch === 58) {\n          following = state.input.charCodeAt(state.position + 1);\n          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            break;\n          }\n        } else if (ch === 35) {\n          preceding = state.input.charCodeAt(state.position - 1);\n          if (is_WS_OR_EOL(preceding)) {\n            break;\n          }\n        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n          break;\n        } else if (is_EOL(ch)) {\n          _line = state.line;\n          _lineStart = state.lineStart;\n          _lineIndent = state.lineIndent;\n          skipSeparationSpace(state, false, -1);\n          if (state.lineIndent >= nodeIndent) {\n            hasPendingContent = true;\n            ch = state.input.charCodeAt(state.position);\n            continue;\n          } else {\n            state.position = captureEnd;\n            state.line = _line;\n            state.lineStart = _lineStart;\n            state.lineIndent = _lineIndent;\n            break;\n          }\n        }\n        if (hasPendingContent) {\n          captureSegment(state, captureStart, captureEnd, false);\n          writeFoldedLines(state, state.line - _line);\n          captureStart = captureEnd = state.position;\n          hasPendingContent = false;\n        }\n        if (!is_WHITE_SPACE(ch)) {\n          captureEnd = state.position + 1;\n        }\n        ch = state.input.charCodeAt(++state.position);\n      }\n      captureSegment(state, captureStart, captureEnd, false);\n      if (state.result) {\n        return true;\n      }\n      state.kind = _kind;\n      state.result = _result;\n      return false;\n    }\n    function readSingleQuotedScalar(state, nodeIndent) {\n      var ch, captureStart, captureEnd;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 39) {\n        return false;\n      }\n      state.kind = \"scalar\";\n      state.result = \"\";\n      state.position++;\n      captureStart = captureEnd = state.position;\n      while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n        if (ch === 39) {\n          captureSegment(state, captureStart, state.position, true);\n          ch = state.input.charCodeAt(++state.position);\n          if (ch === 39) {\n            captureStart = state.position;\n            state.position++;\n            captureEnd = state.position;\n          } else {\n            return true;\n          }\n        } else if (is_EOL(ch)) {\n          captureSegment(state, captureStart, captureEnd, true);\n          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n          captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n          throwError(state, \"unexpected end of the document within a single quoted scalar\");\n        } else {\n          state.position++;\n          captureEnd = state.position;\n        }\n      }\n      throwError(state, \"unexpected end of the stream within a single quoted scalar\");\n    }\n    function readDoubleQuotedScalar(state, nodeIndent) {\n      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 34) {\n        return false;\n      }\n      state.kind = \"scalar\";\n      state.result = \"\";\n      state.position++;\n      captureStart = captureEnd = state.position;\n      while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n        if (ch === 34) {\n          captureSegment(state, captureStart, state.position, true);\n          state.position++;\n          return true;\n        } else if (ch === 92) {\n          captureSegment(state, captureStart, state.position, true);\n          ch = state.input.charCodeAt(++state.position);\n          if (is_EOL(ch)) {\n            skipSeparationSpace(state, false, nodeIndent);\n          } else if (ch < 256 && simpleEscapeCheck[ch]) {\n            state.result += simpleEscapeMap[ch];\n            state.position++;\n          } else if ((tmp = escapedHexLen(ch)) > 0) {\n            hexLength = tmp;\n            hexResult = 0;\n            for (; hexLength > 0; hexLength--) {\n              ch = state.input.charCodeAt(++state.position);\n              if ((tmp = fromHexCode(ch)) >= 0) {\n                hexResult = (hexResult << 4) + tmp;\n              } else {\n                throwError(state, \"expected hexadecimal character\");\n              }\n            }\n            state.result += charFromCodepoint(hexResult);\n            state.position++;\n          } else {\n            throwError(state, \"unknown escape sequence\");\n          }\n          captureStart = captureEnd = state.position;\n        } else if (is_EOL(ch)) {\n          captureSegment(state, captureStart, captureEnd, true);\n          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n          captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n          throwError(state, \"unexpected end of the document within a double quoted scalar\");\n        } else {\n          state.position++;\n          captureEnd = state.position;\n        }\n      }\n      throwError(state, \"unexpected end of the stream within a double quoted scalar\");\n    }\n    function readFlowCollection(state, nodeIndent) {\n      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 91) {\n        terminator = 93;\n        isMapping = false;\n        _result = [];\n      } else if (ch === 123) {\n        terminator = 125;\n        isMapping = true;\n        _result = {};\n      } else {\n        return false;\n      }\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n      }\n      ch = state.input.charCodeAt(++state.position);\n      while (ch !== 0) {\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === terminator) {\n          state.position++;\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = isMapping ? \"mapping\" : \"sequence\";\n          state.result = _result;\n          return true;\n        } else if (!readNext) {\n          throwError(state, \"missed comma between flow collection entries\");\n        } else if (ch === 44) {\n          throwError(state, \"expected the node content, but found ','\");\n        }\n        keyTag = keyNode = valueNode = null;\n        isPair = isExplicitPair = false;\n        if (ch === 63) {\n          following = state.input.charCodeAt(state.position + 1);\n          if (is_WS_OR_EOL(following)) {\n            isPair = isExplicitPair = true;\n            state.position++;\n            skipSeparationSpace(state, true, nodeIndent);\n          }\n        }\n        _line = state.line;\n        _lineStart = state.lineStart;\n        _pos = state.position;\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        keyTag = state.tag;\n        keyNode = state.result;\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if ((isExplicitPair || state.line === _line) && ch === 58) {\n          isPair = true;\n          ch = state.input.charCodeAt(++state.position);\n          skipSeparationSpace(state, true, nodeIndent);\n          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n          valueNode = state.result;\n        }\n        if (isMapping) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n        } else if (isPair) {\n          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n        } else {\n          _result.push(keyNode);\n        }\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === 44) {\n          readNext = true;\n          ch = state.input.charCodeAt(++state.position);\n        } else {\n          readNext = false;\n        }\n      }\n      throwError(state, \"unexpected end of the stream within a flow collection\");\n    }\n    function readBlockScalar(state, nodeIndent) {\n      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 124) {\n        folding = false;\n      } else if (ch === 62) {\n        folding = true;\n      } else {\n        return false;\n      }\n      state.kind = \"scalar\";\n      state.result = \"\";\n      while (ch !== 0) {\n        ch = state.input.charCodeAt(++state.position);\n        if (ch === 43 || ch === 45) {\n          if (CHOMPING_CLIP === chomping) {\n            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;\n          } else {\n            throwError(state, \"repeat of a chomping mode identifier\");\n          }\n        } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n          if (tmp === 0) {\n            throwError(state, \"bad explicit indentation width of a block scalar; it cannot be less than one\");\n          } else if (!detectedIndent) {\n            textIndent = nodeIndent + tmp - 1;\n            detectedIndent = true;\n          } else {\n            throwError(state, \"repeat of an indentation width identifier\");\n          }\n        } else {\n          break;\n        }\n      }\n      if (is_WHITE_SPACE(ch)) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (is_WHITE_SPACE(ch));\n        if (ch === 35) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (!is_EOL(ch) && ch !== 0);\n        }\n      }\n      while (ch !== 0) {\n        readLineBreak(state);\n        state.lineIndent = 0;\n        ch = state.input.charCodeAt(state.position);\n        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {\n          state.lineIndent++;\n          ch = state.input.charCodeAt(++state.position);\n        }\n        if (!detectedIndent && state.lineIndent > textIndent) {\n          textIndent = state.lineIndent;\n        }\n        if (is_EOL(ch)) {\n          emptyLines++;\n          continue;\n        }\n        if (state.lineIndent < textIndent) {\n          if (chomping === CHOMPING_KEEP) {\n            state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n          } else if (chomping === CHOMPING_CLIP) {\n            if (didReadContent) {\n              state.result += \"\\n\";\n            }\n          }\n          break;\n        }\n        if (folding) {\n          if (is_WHITE_SPACE(ch)) {\n            atMoreIndented = true;\n            state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n          } else if (atMoreIndented) {\n            atMoreIndented = false;\n            state.result += common.repeat(\"\\n\", emptyLines + 1);\n          } else if (emptyLines === 0) {\n            if (didReadContent) {\n              state.result += \" \";\n            }\n          } else {\n            state.result += common.repeat(\"\\n\", emptyLines);\n          }\n        } else {\n          state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n        }\n        didReadContent = true;\n        detectedIndent = true;\n        emptyLines = 0;\n        captureStart = state.position;\n        while (!is_EOL(ch) && ch !== 0) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        captureSegment(state, captureStart, state.position, false);\n      }\n      return true;\n    }\n    function readBlockSequence(state, nodeIndent) {\n      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;\n      if (state.firstTabInLine !== -1) return false;\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n      }\n      ch = state.input.charCodeAt(state.position);\n      while (ch !== 0) {\n        if (state.firstTabInLine !== -1) {\n          state.position = state.firstTabInLine;\n          throwError(state, \"tab characters must not be used in indentation\");\n        }\n        if (ch !== 45) {\n          break;\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        if (!is_WS_OR_EOL(following)) {\n          break;\n        }\n        detected = true;\n        state.position++;\n        if (skipSeparationSpace(state, true, -1)) {\n          if (state.lineIndent <= nodeIndent) {\n            _result.push(null);\n            ch = state.input.charCodeAt(state.position);\n            continue;\n          }\n        }\n        _line = state.line;\n        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n        _result.push(state.result);\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n          throwError(state, \"bad indentation of a sequence entry\");\n        } else if (state.lineIndent < nodeIndent) {\n          break;\n        }\n      }\n      if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = \"sequence\";\n        state.result = _result;\n        return true;\n      }\n      return false;\n    }\n    function readBlockMapping(state, nodeIndent, flowIndent) {\n      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;\n      if (state.firstTabInLine !== -1) return false;\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n      }\n      ch = state.input.charCodeAt(state.position);\n      while (ch !== 0) {\n        if (!atExplicitKey && state.firstTabInLine !== -1) {\n          state.position = state.firstTabInLine;\n          throwError(state, \"tab characters must not be used in indentation\");\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        _line = state.line;\n        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {\n          if (ch === 63) {\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n              keyTag = keyNode = valueNode = null;\n            }\n            detected = true;\n            atExplicitKey = true;\n            allowCompact = true;\n          } else if (atExplicitKey) {\n            atExplicitKey = false;\n            allowCompact = true;\n          } else {\n            throwError(state, \"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line\");\n          }\n          state.position += 1;\n          ch = following;\n        } else {\n          _keyLine = state.line;\n          _keyLineStart = state.lineStart;\n          _keyPos = state.position;\n          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n            break;\n          }\n          if (state.line === _line) {\n            ch = state.input.charCodeAt(state.position);\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            if (ch === 58) {\n              ch = state.input.charCodeAt(++state.position);\n              if (!is_WS_OR_EOL(ch)) {\n                throwError(state, \"a whitespace character is expected after the key-value separator within a block mapping\");\n              }\n              if (atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n                keyTag = keyNode = valueNode = null;\n              }\n              detected = true;\n              atExplicitKey = false;\n              allowCompact = false;\n              keyTag = state.tag;\n              keyNode = state.result;\n            } else if (detected) {\n              throwError(state, \"can not read an implicit mapping pair; a colon is missed\");\n            } else {\n              state.tag = _tag;\n              state.anchor = _anchor;\n              return true;\n            }\n          } else if (detected) {\n            throwError(state, \"can not read a block mapping entry; a multiline key may not be an implicit key\");\n          } else {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            return true;\n          }\n        }\n        if (state.line === _line || state.lineIndent > nodeIndent) {\n          if (atExplicitKey) {\n            _keyLine = state.line;\n            _keyLineStart = state.lineStart;\n            _keyPos = state.position;\n          }\n          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n            if (atExplicitKey) {\n              keyNode = state.result;\n            } else {\n              valueNode = state.result;\n            }\n          }\n          if (!atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n          skipSeparationSpace(state, true, -1);\n          ch = state.input.charCodeAt(state.position);\n        }\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n          throwError(state, \"bad indentation of a mapping entry\");\n        } else if (state.lineIndent < nodeIndent) {\n          break;\n        }\n      }\n      if (atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n      }\n      if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = \"mapping\";\n        state.result = _result;\n      }\n      return detected;\n    }\n    function readTagProperty(state) {\n      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 33) return false;\n      if (state.tag !== null) {\n        throwError(state, \"duplication of a tag property\");\n      }\n      ch = state.input.charCodeAt(++state.position);\n      if (ch === 60) {\n        isVerbatim = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else if (ch === 33) {\n        isNamed = true;\n        tagHandle = \"!!\";\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        tagHandle = \"!\";\n      }\n      _position = state.position;\n      if (isVerbatim) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0 && ch !== 62);\n        if (state.position < state.length) {\n          tagName = state.input.slice(_position, state.position);\n          ch = state.input.charCodeAt(++state.position);\n        } else {\n          throwError(state, \"unexpected end of the stream within a verbatim tag\");\n        }\n      } else {\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          if (ch === 33) {\n            if (!isNamed) {\n              tagHandle = state.input.slice(_position - 1, state.position + 1);\n              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                throwError(state, \"named tag handle cannot contain such characters\");\n              }\n              isNamed = true;\n              _position = state.position + 1;\n            } else {\n              throwError(state, \"tag suffix cannot contain exclamation marks\");\n            }\n          }\n          ch = state.input.charCodeAt(++state.position);\n        }\n        tagName = state.input.slice(_position, state.position);\n        if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n          throwError(state, \"tag suffix cannot contain flow indicator characters\");\n        }\n      }\n      if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n        throwError(state, \"tag name cannot contain such characters: \" + tagName);\n      }\n      try {\n        tagName = decodeURIComponent(tagName);\n      } catch (err) {\n        throwError(state, \"tag name is malformed: \" + tagName);\n      }\n      if (isVerbatim) {\n        state.tag = tagName;\n      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n        state.tag = state.tagMap[tagHandle] + tagName;\n      } else if (tagHandle === \"!\") {\n        state.tag = \"!\" + tagName;\n      } else if (tagHandle === \"!!\") {\n        state.tag = \"tag:yaml.org,2002:\" + tagName;\n      } else {\n        throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n      }\n      return true;\n    }\n    function readAnchorProperty(state) {\n      var _position, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 38) return false;\n      if (state.anchor !== null) {\n        throwError(state, \"duplication of an anchor property\");\n      }\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (state.position === _position) {\n        throwError(state, \"name of an anchor node must contain at least one character\");\n      }\n      state.anchor = state.input.slice(_position, state.position);\n      return true;\n    }\n    function readAlias(state) {\n      var _position, alias, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 42) return false;\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (state.position === _position) {\n        throwError(state, \"name of an alias node must contain at least one character\");\n      }\n      alias = state.input.slice(_position, state.position);\n      if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n        throwError(state, 'unidentified alias \"' + alias + '\"');\n      }\n      state.result = state.anchorMap[alias];\n      skipSeparationSpace(state, true, -1);\n      return true;\n    }\n    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;\n      if (state.listener !== null) {\n        state.listener(\"open\", state);\n      }\n      state.tag = null;\n      state.anchor = null;\n      state.kind = null;\n      state.result = null;\n      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n      if (allowToSeek) {\n        if (skipSeparationSpace(state, true, -1)) {\n          atNewLine = true;\n          if (state.lineIndent > parentIndent) {\n            indentStatus = 1;\n          } else if (state.lineIndent === parentIndent) {\n            indentStatus = 0;\n          } else if (state.lineIndent < parentIndent) {\n            indentStatus = -1;\n          }\n        }\n      }\n      if (indentStatus === 1) {\n        while (readTagProperty(state) || readAnchorProperty(state)) {\n          if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n            allowBlockCollections = allowBlockStyles;\n            if (state.lineIndent > parentIndent) {\n              indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n              indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n              indentStatus = -1;\n            }\n          } else {\n            allowBlockCollections = false;\n          }\n        }\n      }\n      if (allowBlockCollections) {\n        allowBlockCollections = atNewLine || allowCompact;\n      }\n      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n          flowIndent = parentIndent;\n        } else {\n          flowIndent = parentIndent + 1;\n        }\n        blockIndent = state.position - state.lineStart;\n        if (indentStatus === 1) {\n          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n            hasContent = true;\n          } else {\n            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n              hasContent = true;\n            } else if (readAlias(state)) {\n              hasContent = true;\n              if (state.tag !== null || state.anchor !== null) {\n                throwError(state, \"alias node should not have any properties\");\n              }\n            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n              hasContent = true;\n              if (state.tag === null) {\n                state.tag = \"?\";\n              }\n            }\n            if (state.anchor !== null) {\n              state.anchorMap[state.anchor] = state.result;\n            }\n          }\n        } else if (indentStatus === 0) {\n          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n        }\n      }\n      if (state.tag === null) {\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      } else if (state.tag === \"?\") {\n        if (state.result !== null && state.kind !== \"scalar\") {\n          throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n        }\n        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n          type = state.implicitTypes[typeIndex];\n          if (type.resolve(state.result)) {\n            state.result = type.construct(state.result);\n            state.tag = type.tag;\n            if (state.anchor !== null) {\n              state.anchorMap[state.anchor] = state.result;\n            }\n            break;\n          }\n        }\n      } else if (state.tag !== \"!\") {\n        if (_hasOwnProperty.call(state.typeMap[state.kind || \"fallback\"], state.tag)) {\n          type = state.typeMap[state.kind || \"fallback\"][state.tag];\n        } else {\n          type = null;\n          typeList = state.typeMap.multi[state.kind || \"fallback\"];\n          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n              type = typeList[typeIndex];\n              break;\n            }\n          }\n        }\n        if (!type) {\n          throwError(state, \"unknown tag !<\" + state.tag + \">\");\n        }\n        if (state.result !== null && type.kind !== state.kind) {\n          throwError(state, \"unacceptable node kind for !<\" + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n        }\n        if (!type.resolve(state.result, state.tag)) {\n          throwError(state, \"cannot resolve a node with !<\" + state.tag + \"> explicit tag\");\n        } else {\n          state.result = type.construct(state.result, state.tag);\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n        }\n      }\n      if (state.listener !== null) {\n        state.listener(\"close\", state);\n      }\n      return state.tag !== null || state.anchor !== null || hasContent;\n    }\n    function readDocument(state) {\n      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;\n      state.version = null;\n      state.checkLineBreaks = state.legacy;\n      state.tagMap = /* @__PURE__ */ Object.create(null);\n      state.anchorMap = /* @__PURE__ */ Object.create(null);\n      while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if (state.lineIndent > 0 || ch !== 37) {\n          break;\n        }\n        hasDirectives = true;\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        directiveName = state.input.slice(_position, state.position);\n        directiveArgs = [];\n        if (directiveName.length < 1) {\n          throwError(state, \"directive name must not be less than one character in length\");\n        }\n        while (ch !== 0) {\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (ch === 35) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0 && !is_EOL(ch));\n            break;\n          }\n          if (is_EOL(ch)) break;\n          _position = state.position;\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          directiveArgs.push(state.input.slice(_position, state.position));\n        }\n        if (ch !== 0) readLineBreak(state);\n        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n          directiveHandlers[directiveName](state, directiveName, directiveArgs);\n        } else {\n          throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n        }\n      }\n      skipSeparationSpace(state, true, -1);\n      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      } else if (hasDirectives) {\n        throwError(state, \"directives end mark is expected\");\n      }\n      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n      skipSeparationSpace(state, true, -1);\n      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n        throwWarning(state, \"non-ASCII line breaks are interpreted as content\");\n      }\n      state.documents.push(state.result);\n      if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        if (state.input.charCodeAt(state.position) === 46) {\n          state.position += 3;\n          skipSeparationSpace(state, true, -1);\n        }\n        return;\n      }\n      if (state.position < state.length - 1) {\n        throwError(state, \"end of the stream or a document separator is expected\");\n      } else {\n        return;\n      }\n    }\n    function loadDocuments(input, options) {\n      input = String(input);\n      options = options || {};\n      if (input.length !== 0) {\n        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {\n          input += \"\\n\";\n        }\n        if (input.charCodeAt(0) === 65279) {\n          input = input.slice(1);\n        }\n      }\n      var state = new State(input, options);\n      var nullpos = input.indexOf(\"\\0\");\n      if (nullpos !== -1) {\n        state.position = nullpos;\n        throwError(state, \"null byte is not allowed in input\");\n      }\n      state.input += \"\\0\";\n      while (state.input.charCodeAt(state.position) === 32) {\n        state.lineIndent += 1;\n        state.position += 1;\n      }\n      while (state.position < state.length - 1) {\n        readDocument(state);\n      }\n      return state.documents;\n    }\n    function loadAll(input, iterator, options) {\n      if (iterator !== null && typeof iterator === \"object\" && typeof options === \"undefined\") {\n        options = iterator;\n        iterator = null;\n      }\n      var documents = loadDocuments(input, options);\n      if (typeof iterator !== \"function\") {\n        return documents;\n      }\n      for (var index = 0, length = documents.length; index < length; index += 1) {\n        iterator(documents[index]);\n      }\n    }\n    function load(input, options) {\n      var documents = loadDocuments(input, options);\n      if (documents.length === 0) {\n        return void 0;\n      } else if (documents.length === 1) {\n        return documents[0];\n      }\n      throw new YAMLException(\"expected a single document in the stream, but found more\");\n    }\n    module2.exports.loadAll = loadAll;\n    module2.exports.load = load;\n  }\n});\n\n// node_modules/js-yaml/lib/dumper.js\nvar require_dumper = __commonJS({\n  \"node_modules/js-yaml/lib/dumper.js\"(exports2, module2) {\n    \"use strict\";\n    var common = require_common2();\n    var YAMLException = require_exception();\n    var DEFAULT_SCHEMA = require_default();\n    var _toString = Object.prototype.toString;\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    var CHAR_BOM = 65279;\n    var CHAR_TAB = 9;\n    var CHAR_LINE_FEED = 10;\n    var CHAR_CARRIAGE_RETURN = 13;\n    var CHAR_SPACE = 32;\n    var CHAR_EXCLAMATION = 33;\n    var CHAR_DOUBLE_QUOTE = 34;\n    var CHAR_SHARP = 35;\n    var CHAR_PERCENT = 37;\n    var CHAR_AMPERSAND = 38;\n    var CHAR_SINGLE_QUOTE = 39;\n    var CHAR_ASTERISK = 42;\n    var CHAR_COMMA = 44;\n    var CHAR_MINUS = 45;\n    var CHAR_COLON = 58;\n    var CHAR_EQUALS = 61;\n    var CHAR_GREATER_THAN = 62;\n    var CHAR_QUESTION = 63;\n    var CHAR_COMMERCIAL_AT = 64;\n    var CHAR_LEFT_SQUARE_BRACKET = 91;\n    var CHAR_RIGHT_SQUARE_BRACKET = 93;\n    var CHAR_GRAVE_ACCENT = 96;\n    var CHAR_LEFT_CURLY_BRACKET = 123;\n    var CHAR_VERTICAL_LINE = 124;\n    var CHAR_RIGHT_CURLY_BRACKET = 125;\n    var ESCAPE_SEQUENCES = {};\n    ESCAPE_SEQUENCES[0] = \"\\\\0\";\n    ESCAPE_SEQUENCES[7] = \"\\\\a\";\n    ESCAPE_SEQUENCES[8] = \"\\\\b\";\n    ESCAPE_SEQUENCES[9] = \"\\\\t\";\n    ESCAPE_SEQUENCES[10] = \"\\\\n\";\n    ESCAPE_SEQUENCES[11] = \"\\\\v\";\n    ESCAPE_SEQUENCES[12] = \"\\\\f\";\n    ESCAPE_SEQUENCES[13] = \"\\\\r\";\n    ESCAPE_SEQUENCES[27] = \"\\\\e\";\n    ESCAPE_SEQUENCES[34] = '\\\\\"';\n    ESCAPE_SEQUENCES[92] = \"\\\\\\\\\";\n    ESCAPE_SEQUENCES[133] = \"\\\\N\";\n    ESCAPE_SEQUENCES[160] = \"\\\\_\";\n    ESCAPE_SEQUENCES[8232] = \"\\\\L\";\n    ESCAPE_SEQUENCES[8233] = \"\\\\P\";\n    var DEPRECATED_BOOLEANS_SYNTAX = [\n      \"y\",\n      \"Y\",\n      \"yes\",\n      \"Yes\",\n      \"YES\",\n      \"on\",\n      \"On\",\n      \"ON\",\n      \"n\",\n      \"N\",\n      \"no\",\n      \"No\",\n      \"NO\",\n      \"off\",\n      \"Off\",\n      \"OFF\"\n    ];\n    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n    function compileStyleMap(schema, map) {\n      var result, keys, index, length, tag, style, type;\n      if (map === null) return {};\n      result = {};\n      keys = Object.keys(map);\n      for (index = 0, length = keys.length; index < length; index += 1) {\n        tag = keys[index];\n        style = String(map[tag]);\n        if (tag.slice(0, 2) === \"!!\") {\n          tag = \"tag:yaml.org,2002:\" + tag.slice(2);\n        }\n        type = schema.compiledTypeMap[\"fallback\"][tag];\n        if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n          style = type.styleAliases[style];\n        }\n        result[tag] = style;\n      }\n      return result;\n    }\n    function encodeHex(character) {\n      var string, handle, length;\n      string = character.toString(16).toUpperCase();\n      if (character <= 255) {\n        handle = \"x\";\n        length = 2;\n      } else if (character <= 65535) {\n        handle = \"u\";\n        length = 4;\n      } else if (character <= 4294967295) {\n        handle = \"U\";\n        length = 8;\n      } else {\n        throw new YAMLException(\"code point within a string may not be greater than 0xFFFFFFFF\");\n      }\n      return \"\\\\\" + handle + common.repeat(\"0\", length - string.length) + string;\n    }\n    var QUOTING_TYPE_SINGLE = 1;\n    var QUOTING_TYPE_DOUBLE = 2;\n    function State(options) {\n      this.schema = options[\"schema\"] || DEFAULT_SCHEMA;\n      this.indent = Math.max(1, options[\"indent\"] || 2);\n      this.noArrayIndent = options[\"noArrayIndent\"] || false;\n      this.skipInvalid = options[\"skipInvalid\"] || false;\n      this.flowLevel = common.isNothing(options[\"flowLevel\"]) ? -1 : options[\"flowLevel\"];\n      this.styleMap = compileStyleMap(this.schema, options[\"styles\"] || null);\n      this.sortKeys = options[\"sortKeys\"] || false;\n      this.lineWidth = options[\"lineWidth\"] || 80;\n      this.noRefs = options[\"noRefs\"] || false;\n      this.noCompatMode = options[\"noCompatMode\"] || false;\n      this.condenseFlow = options[\"condenseFlow\"] || false;\n      this.quotingType = options[\"quotingType\"] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n      this.forceQuotes = options[\"forceQuotes\"] || false;\n      this.replacer = typeof options[\"replacer\"] === \"function\" ? options[\"replacer\"] : null;\n      this.implicitTypes = this.schema.compiledImplicit;\n      this.explicitTypes = this.schema.compiledExplicit;\n      this.tag = null;\n      this.result = \"\";\n      this.duplicates = [];\n      this.usedDuplicates = null;\n    }\n    function indentString(string, spaces) {\n      var ind = common.repeat(\" \", spaces), position = 0, next = -1, result = \"\", line, length = string.length;\n      while (position < length) {\n        next = string.indexOf(\"\\n\", position);\n        if (next === -1) {\n          line = string.slice(position);\n          position = length;\n        } else {\n          line = string.slice(position, next + 1);\n          position = next + 1;\n        }\n        if (line.length && line !== \"\\n\") result += ind;\n        result += line;\n      }\n      return result;\n    }\n    function generateNextLine(state, level) {\n      return \"\\n\" + common.repeat(\" \", state.indent * level);\n    }\n    function testImplicitResolving(state, str) {\n      var index, length, type;\n      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n        type = state.implicitTypes[index];\n        if (type.resolve(str)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function isWhitespace(c) {\n      return c === CHAR_SPACE || c === CHAR_TAB;\n    }\n    function isPrintable(c) {\n      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;\n    }\n    function isNsCharOrWhitespace(c) {\n      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n    }\n    function isPlainSafe(c, prev, inblock) {\n      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n      return (\n        // ns-plain-safe\n        (inblock ? (\n          // c = flow-in\n          cIsNsCharOrWhitespace\n        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar\n      );\n    }\n    function isPlainSafeFirst(c) {\n      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n    }\n    function isPlainSafeLast(c) {\n      return !isWhitespace(c) && c !== CHAR_COLON;\n    }\n    function codePointAt(string, pos) {\n      var first = string.charCodeAt(pos), second;\n      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {\n        second = string.charCodeAt(pos + 1);\n        if (second >= 56320 && second <= 57343) {\n          return (first - 55296) * 1024 + second - 56320 + 65536;\n        }\n      }\n      return first;\n    }\n    function needIndentIndicator(string) {\n      var leadingSpaceRe = /^\\n* /;\n      return leadingSpaceRe.test(string);\n    }\n    var STYLE_PLAIN = 1;\n    var STYLE_SINGLE = 2;\n    var STYLE_LITERAL = 3;\n    var STYLE_FOLDED = 4;\n    var STYLE_DOUBLE = 5;\n    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n      var i;\n      var char = 0;\n      var prevChar = null;\n      var hasLineBreak = false;\n      var hasFoldableLine = false;\n      var shouldTrackWidth = lineWidth !== -1;\n      var previousLineBreak = -1;\n      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n      if (singleLineOnly || forceQuotes) {\n        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {\n          char = codePointAt(string, i);\n          if (!isPrintable(char)) {\n            return STYLE_DOUBLE;\n          }\n          plain = plain && isPlainSafe(char, prevChar, inblock);\n          prevChar = char;\n        }\n      } else {\n        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {\n          char = codePointAt(string, i);\n          if (char === CHAR_LINE_FEED) {\n            hasLineBreak = true;\n            if (shouldTrackWidth) {\n              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== \" \";\n              previousLineBreak = i;\n            }\n          } else if (!isPrintable(char)) {\n            return STYLE_DOUBLE;\n          }\n          plain = plain && isPlainSafe(char, prevChar, inblock);\n          prevChar = char;\n        }\n        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== \" \");\n      }\n      if (!hasLineBreak && !hasFoldableLine) {\n        if (plain && !forceQuotes && !testAmbiguousType(string)) {\n          return STYLE_PLAIN;\n        }\n        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n      }\n      if (indentPerLevel > 9 && needIndentIndicator(string)) {\n        return STYLE_DOUBLE;\n      }\n      if (!forceQuotes) {\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n      }\n      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n    }\n    function writeScalar(state, string, level, iskey, inblock) {\n      state.dump = (function() {\n        if (string.length === 0) {\n          return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n        }\n        if (!state.noCompatMode) {\n          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n            return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n          }\n        }\n        var indent = state.indent * Math.max(1, level);\n        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;\n        function testAmbiguity(string2) {\n          return testImplicitResolving(state, string2);\n        }\n        switch (chooseScalarStyle(\n          string,\n          singleLineOnly,\n          state.indent,\n          lineWidth,\n          testAmbiguity,\n          state.quotingType,\n          state.forceQuotes && !iskey,\n          inblock\n        )) {\n          case STYLE_PLAIN:\n            return string;\n          case STYLE_SINGLE:\n            return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n          case STYLE_LITERAL:\n            return \"|\" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n          case STYLE_FOLDED:\n            return \">\" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n          case STYLE_DOUBLE:\n            return '\"' + escapeString(string, lineWidth) + '\"';\n          default:\n            throw new YAMLException(\"impossible error: invalid scalar style\");\n        }\n      })();\n    }\n    function blockHeader(string, indentPerLevel) {\n      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : \"\";\n      var clip = string[string.length - 1] === \"\\n\";\n      var keep = clip && (string[string.length - 2] === \"\\n\" || string === \"\\n\");\n      var chomp = keep ? \"+\" : clip ? \"\" : \"-\";\n      return indentIndicator + chomp + \"\\n\";\n    }\n    function dropEndingNewline(string) {\n      return string[string.length - 1] === \"\\n\" ? string.slice(0, -1) : string;\n    }\n    function foldString(string, width) {\n      var lineRe = /(\\n+)([^\\n]*)/g;\n      var result = (function() {\n        var nextLF = string.indexOf(\"\\n\");\n        nextLF = nextLF !== -1 ? nextLF : string.length;\n        lineRe.lastIndex = nextLF;\n        return foldLine(string.slice(0, nextLF), width);\n      })();\n      var prevMoreIndented = string[0] === \"\\n\" || string[0] === \" \";\n      var moreIndented;\n      var match;\n      while (match = lineRe.exec(string)) {\n        var prefix = match[1], line = match[2];\n        moreIndented = line[0] === \" \";\n        result += prefix + (!prevMoreIndented && !moreIndented && line !== \"\" ? \"\\n\" : \"\") + foldLine(line, width);\n        prevMoreIndented = moreIndented;\n      }\n      return result;\n    }\n    function foldLine(line, width) {\n      if (line === \"\" || line[0] === \" \") return line;\n      var breakRe = / [^ ]/g;\n      var match;\n      var start = 0, end, curr = 0, next = 0;\n      var result = \"\";\n      while (match = breakRe.exec(line)) {\n        next = match.index;\n        if (next - start > width) {\n          end = curr > start ? curr : next;\n          result += \"\\n\" + line.slice(start, end);\n          start = end + 1;\n        }\n        curr = next;\n      }\n      result += \"\\n\";\n      if (line.length - start > width && curr > start) {\n        result += line.slice(start, curr) + \"\\n\" + line.slice(curr + 1);\n      } else {\n        result += line.slice(start);\n      }\n      return result.slice(1);\n    }\n    function escapeString(string) {\n      var result = \"\";\n      var char = 0;\n      var escapeSeq;\n      for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        escapeSeq = ESCAPE_SEQUENCES[char];\n        if (!escapeSeq && isPrintable(char)) {\n          result += string[i];\n          if (char >= 65536) result += string[i + 1];\n        } else {\n          result += escapeSeq || encodeHex(char);\n        }\n      }\n      return result;\n    }\n    function writeFlowSequence(state, level, object) {\n      var _result = \"\", _tag = state.tag, index, length, value;\n      for (index = 0, length = object.length; index < length; index += 1) {\n        value = object[index];\n        if (state.replacer) {\n          value = state.replacer.call(object, String(index), value);\n        }\n        if (writeNode(state, level, value, false, false) || typeof value === \"undefined\" && writeNode(state, level, null, false, false)) {\n          if (_result !== \"\") _result += \",\" + (!state.condenseFlow ? \" \" : \"\");\n          _result += state.dump;\n        }\n      }\n      state.tag = _tag;\n      state.dump = \"[\" + _result + \"]\";\n    }\n    function writeBlockSequence(state, level, object, compact) {\n      var _result = \"\", _tag = state.tag, index, length, value;\n      for (index = 0, length = object.length; index < length; index += 1) {\n        value = object[index];\n        if (state.replacer) {\n          value = state.replacer.call(object, String(index), value);\n        }\n        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === \"undefined\" && writeNode(state, level + 1, null, true, true, false, true)) {\n          if (!compact || _result !== \"\") {\n            _result += generateNextLine(state, level);\n          }\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            _result += \"-\";\n          } else {\n            _result += \"- \";\n          }\n          _result += state.dump;\n        }\n      }\n      state.tag = _tag;\n      state.dump = _result || \"[]\";\n    }\n    function writeFlowMapping(state, level, object) {\n      var _result = \"\", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;\n      for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n        pairBuffer = \"\";\n        if (_result !== \"\") pairBuffer += \", \";\n        if (state.condenseFlow) pairBuffer += '\"';\n        objectKey = objectKeyList[index];\n        objectValue = object[objectKey];\n        if (state.replacer) {\n          objectValue = state.replacer.call(object, objectKey, objectValue);\n        }\n        if (!writeNode(state, level, objectKey, false, false)) {\n          continue;\n        }\n        if (state.dump.length > 1024) pairBuffer += \"? \";\n        pairBuffer += state.dump + (state.condenseFlow ? '\"' : \"\") + \":\" + (state.condenseFlow ? \"\" : \" \");\n        if (!writeNode(state, level, objectValue, false, false)) {\n          continue;\n        }\n        pairBuffer += state.dump;\n        _result += pairBuffer;\n      }\n      state.tag = _tag;\n      state.dump = \"{\" + _result + \"}\";\n    }\n    function writeBlockMapping(state, level, object, compact) {\n      var _result = \"\", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;\n      if (state.sortKeys === true) {\n        objectKeyList.sort();\n      } else if (typeof state.sortKeys === \"function\") {\n        objectKeyList.sort(state.sortKeys);\n      } else if (state.sortKeys) {\n        throw new YAMLException(\"sortKeys must be a boolean or a function\");\n      }\n      for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n        pairBuffer = \"\";\n        if (!compact || _result !== \"\") {\n          pairBuffer += generateNextLine(state, level);\n        }\n        objectKey = objectKeyList[index];\n        objectValue = object[objectKey];\n        if (state.replacer) {\n          objectValue = state.replacer.call(object, objectKey, objectValue);\n        }\n        if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n          continue;\n        }\n        explicitPair = state.tag !== null && state.tag !== \"?\" || state.dump && state.dump.length > 1024;\n        if (explicitPair) {\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += \"?\";\n          } else {\n            pairBuffer += \"? \";\n          }\n        }\n        pairBuffer += state.dump;\n        if (explicitPair) {\n          pairBuffer += generateNextLine(state, level);\n        }\n        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n          continue;\n        }\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          pairBuffer += \":\";\n        } else {\n          pairBuffer += \": \";\n        }\n        pairBuffer += state.dump;\n        _result += pairBuffer;\n      }\n      state.tag = _tag;\n      state.dump = _result || \"{}\";\n    }\n    function detectType(state, object, explicit) {\n      var _result, typeList, index, length, type, style;\n      typeList = explicit ? state.explicitTypes : state.implicitTypes;\n      for (index = 0, length = typeList.length; index < length; index += 1) {\n        type = typeList[index];\n        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === \"object\" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n          if (explicit) {\n            if (type.multi && type.representName) {\n              state.tag = type.representName(object);\n            } else {\n              state.tag = type.tag;\n            }\n          } else {\n            state.tag = \"?\";\n          }\n          if (type.represent) {\n            style = state.styleMap[type.tag] || type.defaultStyle;\n            if (_toString.call(type.represent) === \"[object Function]\") {\n              _result = type.represent(object, style);\n            } else if (_hasOwnProperty.call(type.represent, style)) {\n              _result = type.represent[style](object, style);\n            } else {\n              throw new YAMLException(\"!<\" + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n            }\n            state.dump = _result;\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n    function writeNode(state, level, object, block, compact, iskey, isblockseq) {\n      state.tag = null;\n      state.dump = object;\n      if (!detectType(state, object, false)) {\n        detectType(state, object, true);\n      }\n      var type = _toString.call(state.dump);\n      var inblock = block;\n      var tagStr;\n      if (block) {\n        block = state.flowLevel < 0 || state.flowLevel > level;\n      }\n      var objectOrArray = type === \"[object Object]\" || type === \"[object Array]\", duplicateIndex, duplicate;\n      if (objectOrArray) {\n        duplicateIndex = state.duplicates.indexOf(object);\n        duplicate = duplicateIndex !== -1;\n      }\n      if (state.tag !== null && state.tag !== \"?\" || duplicate || state.indent !== 2 && level > 0) {\n        compact = false;\n      }\n      if (duplicate && state.usedDuplicates[duplicateIndex]) {\n        state.dump = \"*ref_\" + duplicateIndex;\n      } else {\n        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n          state.usedDuplicates[duplicateIndex] = true;\n        }\n        if (type === \"[object Object]\") {\n          if (block && Object.keys(state.dump).length !== 0) {\n            writeBlockMapping(state, level, state.dump, compact);\n            if (duplicate) {\n              state.dump = \"&ref_\" + duplicateIndex + state.dump;\n            }\n          } else {\n            writeFlowMapping(state, level, state.dump);\n            if (duplicate) {\n              state.dump = \"&ref_\" + duplicateIndex + \" \" + state.dump;\n            }\n          }\n        } else if (type === \"[object Array]\") {\n          if (block && state.dump.length !== 0) {\n            if (state.noArrayIndent && !isblockseq && level > 0) {\n              writeBlockSequence(state, level - 1, state.dump, compact);\n            } else {\n              writeBlockSequence(state, level, state.dump, compact);\n            }\n            if (duplicate) {\n              state.dump = \"&ref_\" + duplicateIndex + state.dump;\n            }\n          } else {\n            writeFlowSequence(state, level, state.dump);\n            if (duplicate) {\n              state.dump = \"&ref_\" + duplicateIndex + \" \" + state.dump;\n            }\n          }\n        } else if (type === \"[object String]\") {\n          if (state.tag !== \"?\") {\n            writeScalar(state, state.dump, level, iskey, inblock);\n          }\n        } else if (type === \"[object Undefined]\") {\n          return false;\n        } else {\n          if (state.skipInvalid) return false;\n          throw new YAMLException(\"unacceptable kind of an object to dump \" + type);\n        }\n        if (state.tag !== null && state.tag !== \"?\") {\n          tagStr = encodeURI(\n            state.tag[0] === \"!\" ? state.tag.slice(1) : state.tag\n          ).replace(/!/g, \"%21\");\n          if (state.tag[0] === \"!\") {\n            tagStr = \"!\" + tagStr;\n          } else if (tagStr.slice(0, 18) === \"tag:yaml.org,2002:\") {\n            tagStr = \"!!\" + tagStr.slice(18);\n          } else {\n            tagStr = \"!<\" + tagStr + \">\";\n          }\n          state.dump = tagStr + \" \" + state.dump;\n        }\n      }\n      return true;\n    }\n    function getDuplicateReferences(object, state) {\n      var objects = [], duplicatesIndexes = [], index, length;\n      inspectNode(object, objects, duplicatesIndexes);\n      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n        state.duplicates.push(objects[duplicatesIndexes[index]]);\n      }\n      state.usedDuplicates = new Array(length);\n    }\n    function inspectNode(object, objects, duplicatesIndexes) {\n      var objectKeyList, index, length;\n      if (object !== null && typeof object === \"object\") {\n        index = objects.indexOf(object);\n        if (index !== -1) {\n          if (duplicatesIndexes.indexOf(index) === -1) {\n            duplicatesIndexes.push(index);\n          }\n        } else {\n          objects.push(object);\n          if (Array.isArray(object)) {\n            for (index = 0, length = object.length; index < length; index += 1) {\n              inspectNode(object[index], objects, duplicatesIndexes);\n            }\n          } else {\n            objectKeyList = Object.keys(object);\n            for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n            }\n          }\n        }\n      }\n    }\n    function dump(input, options) {\n      options = options || {};\n      var state = new State(options);\n      if (!state.noRefs) getDuplicateReferences(input, state);\n      var value = input;\n      if (state.replacer) {\n        value = state.replacer.call({ \"\": value }, \"\", value);\n      }\n      if (writeNode(state, 0, value, true, true)) return state.dump + \"\\n\";\n      return \"\";\n    }\n    module2.exports.dump = dump;\n  }\n});\n\n// node_modules/js-yaml/index.js\nvar require_js_yaml = __commonJS({\n  \"node_modules/js-yaml/index.js\"(exports2, module2) {\n    \"use strict\";\n    var loader = require_loader();\n    var dumper = require_dumper();\n    function renamed(from, to) {\n      return function() {\n        throw new Error(\"Function yaml.\" + from + \" is removed in js-yaml 4. Use yaml.\" + to + \" instead, which is now safe by default.\");\n      };\n    }\n    module2.exports.Type = require_type();\n    module2.exports.Schema = require_schema();\n    module2.exports.FAILSAFE_SCHEMA = require_failsafe();\n    module2.exports.JSON_SCHEMA = require_json2();\n    module2.exports.CORE_SCHEMA = require_core();\n    module2.exports.DEFAULT_SCHEMA = require_default();\n    module2.exports.load = loader.load;\n    module2.exports.loadAll = loader.loadAll;\n    module2.exports.dump = dumper.dump;\n    module2.exports.YAMLException = require_exception();\n    module2.exports.types = {\n      binary: require_binary(),\n      float: require_float(),\n      map: require_map(),\n      null: require_null(),\n      pairs: require_pairs(),\n      set: require_set(),\n      timestamp: require_timestamp(),\n      bool: require_bool(),\n      int: require_int(),\n      merge: require_merge(),\n      omap: require_omap(),\n      seq: require_seq(),\n      str: require_str()\n    };\n    module2.exports.safeLoad = renamed(\"safeLoad\", \"load\");\n    module2.exports.safeLoadAll = renamed(\"safeLoadAll\", \"loadAll\");\n    module2.exports.safeDump = renamed(\"safeDump\", \"dump\");\n  }\n});\n\n// node_modules/lazy-val/out/main.js\nvar require_main = __commonJS({\n  \"node_modules/lazy-val/out/main.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.Lazy = void 0;\n    var Lazy = class {\n      constructor(creator) {\n        this._value = null;\n        this.creator = creator;\n      }\n      get hasValue() {\n        return this.creator == null;\n      }\n      get value() {\n        if (this.creator == null) {\n          return this._value;\n        }\n        const result = this.creator();\n        this.value = result;\n        return result;\n      }\n      set value(value) {\n        this._value = value;\n        this.creator = null;\n      }\n    };\n    exports2.Lazy = Lazy;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/internal/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/internal/constants.js\"(exports2, module2) {\n    \"use strict\";\n    var SEMVER_SPEC_VERSION = \"2.0.0\";\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */\n    9007199254740991;\n    var MAX_SAFE_COMPONENT_LENGTH = 16;\n    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;\n    var RELEASE_TYPES = [\n      \"major\",\n      \"premajor\",\n      \"minor\",\n      \"preminor\",\n      \"patch\",\n      \"prepatch\",\n      \"prerelease\"\n    ];\n    module2.exports = {\n      MAX_LENGTH,\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_SAFE_INTEGER,\n      RELEASE_TYPES,\n      SEMVER_SPEC_VERSION,\n      FLAG_INCLUDE_PRERELEASE: 1,\n      FLAG_LOOSE: 2\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/internal/debug.js\nvar require_debug = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/internal/debug.js\"(exports2, module2) {\n    \"use strict\";\n    var debug = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error(\"SEMVER\", ...args) : () => {\n    };\n    module2.exports = debug;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/internal/re.js\nvar require_re = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/internal/re.js\"(exports2, module2) {\n    \"use strict\";\n    var {\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_LENGTH\n    } = require_constants();\n    var debug = require_debug();\n    exports2 = module2.exports = {};\n    var re = exports2.re = [];\n    var safeRe = exports2.safeRe = [];\n    var src = exports2.src = [];\n    var safeSrc = exports2.safeSrc = [];\n    var t = exports2.t = {};\n    var R = 0;\n    var LETTERDASHNUMBER = \"[a-zA-Z0-9-]\";\n    var safeRegexReplacements = [\n      [\"\\\\s\", 1],\n      [\"\\\\d\", MAX_LENGTH],\n      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]\n    ];\n    var makeSafeRegex = (value) => {\n      for (const [token, max] of safeRegexReplacements) {\n        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);\n      }\n      return value;\n    };\n    var createToken = (name, value, isGlobal) => {\n      const safe = makeSafeRegex(value);\n      const index = R++;\n      debug(name, index, value);\n      t[name] = index;\n      src[index] = value;\n      safeSrc[index] = safe;\n      re[index] = new RegExp(value, isGlobal ? \"g\" : void 0);\n      safeRe[index] = new RegExp(safe, isGlobal ? \"g\" : void 0);\n    };\n    createToken(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n    createToken(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n    createToken(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n    createToken(\"MAINVERSION\", `(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"MAINVERSIONLOOSE\", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASEIDENTIFIER\", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASE\", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n    createToken(\"PRERELEASELOOSE\", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n    createToken(\"BUILDIDENTIFIER\", `${LETTERDASHNUMBER}+`);\n    createToken(\"BUILD\", `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n    createToken(\"FULLPLAIN\", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n    createToken(\"FULL\", `^${src[t.FULLPLAIN]}$`);\n    createToken(\"LOOSEPLAIN\", `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n    createToken(\"LOOSE\", `^${src[t.LOOSEPLAIN]}$`);\n    createToken(\"GTLT\", \"((?:<|>)?=?)\");\n    createToken(\"XRANGEIDENTIFIERLOOSE\", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n    createToken(\"XRANGEIDENTIFIER\", `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n    createToken(\"XRANGEPLAIN\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n    createToken(\"XRANGELOOSE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COERCEPLAIN\", `${\"(^|[^\\\\d])(\\\\d{1,\"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);\n    createToken(\"COERCE\", `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`);\n    createToken(\"COERCEFULL\", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\\\d])`);\n    createToken(\"COERCERTL\", src[t.COERCE], true);\n    createToken(\"COERCERTLFULL\", src[t.COERCEFULL], true);\n    createToken(\"LONETILDE\", \"(?:~>?)\");\n    createToken(\"TILDETRIM\", `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n    exports2.tildeTrimReplace = \"$1~\";\n    createToken(\"TILDE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"TILDELOOSE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"LONECARET\", \"(?:\\\\^)\");\n    createToken(\"CARETTRIM\", `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n    exports2.caretTrimReplace = \"$1^\";\n    createToken(\"CARET\", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"CARETLOOSE\", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COMPARATORLOOSE\", `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n    createToken(\"COMPARATOR\", `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n    createToken(\"COMPARATORTRIM\", `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n    exports2.comparatorTrimReplace = \"$1$2$3\";\n    createToken(\"HYPHENRANGE\", `^\\\\s*(${src[t.XRANGEPLAIN]})\\\\s+-\\\\s+(${src[t.XRANGEPLAIN]})\\\\s*$`);\n    createToken(\"HYPHENRANGELOOSE\", `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${src[t.XRANGEPLAINLOOSE]})\\\\s*$`);\n    createToken(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n    createToken(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n    createToken(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/internal/parse-options.js\nvar require_parse_options = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/internal/parse-options.js\"(exports2, module2) {\n    \"use strict\";\n    var looseOption = Object.freeze({ loose: true });\n    var emptyOpts = Object.freeze({});\n    var parseOptions = (options) => {\n      if (!options) {\n        return emptyOpts;\n      }\n      if (typeof options !== \"object\") {\n        return looseOption;\n      }\n      return options;\n    };\n    module2.exports = parseOptions;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/internal/identifiers.js\nvar require_identifiers = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/internal/identifiers.js\"(exports2, module2) {\n    \"use strict\";\n    var numeric = /^[0-9]+$/;\n    var compareIdentifiers = (a, b) => {\n      if (typeof a === \"number\" && typeof b === \"number\") {\n        return a === b ? 0 : a < b ? -1 : 1;\n      }\n      const anum = numeric.test(a);\n      const bnum = numeric.test(b);\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    };\n    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n    module2.exports = {\n      compareIdentifiers,\n      rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/classes/semver.js\nvar require_semver = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/classes/semver.js\"(exports2, module2) {\n    \"use strict\";\n    var debug = require_debug();\n    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();\n    var { safeRe: re, t } = require_re();\n    var parseOptions = require_parse_options();\n    var { compareIdentifiers } = require_identifiers();\n    var SemVer = class _SemVer {\n      constructor(version, options) {\n        options = parseOptions(options);\n        if (version instanceof _SemVer) {\n          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {\n            return version;\n          } else {\n            version = version.version;\n          }\n        } else if (typeof version !== \"string\") {\n          throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`);\n        }\n        if (version.length > MAX_LENGTH) {\n          throw new TypeError(\n            `version is longer than ${MAX_LENGTH} characters`\n          );\n        }\n        debug(\"SemVer\", version, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n        if (!m) {\n          throw new TypeError(`Invalid Version: ${version}`);\n        }\n        this.raw = version;\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError(\"Invalid major version\");\n        }\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError(\"Invalid minor version\");\n        }\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError(\"Invalid patch version\");\n        }\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split(\".\").map((id) => {\n            if (/^[0-9]+$/.test(id)) {\n              const num = +id;\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n            return id;\n          });\n        }\n        this.build = m[5] ? m[5].split(\".\") : [];\n        this.format();\n      }\n      format() {\n        this.version = `${this.major}.${this.minor}.${this.patch}`;\n        if (this.prerelease.length) {\n          this.version += `-${this.prerelease.join(\".\")}`;\n        }\n        return this.version;\n      }\n      toString() {\n        return this.version;\n      }\n      compare(other) {\n        debug(\"SemVer.compare\", this.version, this.options, other);\n        if (!(other instanceof _SemVer)) {\n          if (typeof other === \"string\" && other === this.version) {\n            return 0;\n          }\n          other = new _SemVer(other, this.options);\n        }\n        if (other.version === this.version) {\n          return 0;\n        }\n        return this.compareMain(other) || this.comparePre(other);\n      }\n      compareMain(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.major < other.major) {\n          return -1;\n        }\n        if (this.major > other.major) {\n          return 1;\n        }\n        if (this.minor < other.minor) {\n          return -1;\n        }\n        if (this.minor > other.minor) {\n          return 1;\n        }\n        if (this.patch < other.patch) {\n          return -1;\n        }\n        if (this.patch > other.patch) {\n          return 1;\n        }\n        return 0;\n      }\n      comparePre(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n        let i = 0;\n        do {\n          const a = this.prerelease[i];\n          const b = other.prerelease[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      compareBuild(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        let i = 0;\n        do {\n          const a = this.build[i];\n          const b = other.build[i];\n          debug(\"build compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      // preminor will bump the version up to the next minor release, and immediately\n      // down to pre-release. premajor and prepatch work the same way.\n      inc(release, identifier, identifierBase) {\n        if (release.startsWith(\"pre\")) {\n          if (!identifier && identifierBase === false) {\n            throw new Error(\"invalid increment argument: identifier is empty\");\n          }\n          if (identifier) {\n            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);\n            if (!match || match[1] !== identifier) {\n              throw new Error(`invalid identifier: ${identifier}`);\n            }\n          }\n        }\n        switch (release) {\n          case \"premajor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"preminor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prepatch\":\n            this.prerelease.length = 0;\n            this.inc(\"patch\", identifier, identifierBase);\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          // If the input is a non-prerelease version, this acts the same as\n          // prepatch.\n          case \"prerelease\":\n            if (this.prerelease.length === 0) {\n              this.inc(\"patch\", identifier, identifierBase);\n            }\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"release\":\n            if (this.prerelease.length === 0) {\n              throw new Error(`version ${this.raw} is not a prerelease`);\n            }\n            this.prerelease.length = 0;\n            break;\n          case \"major\":\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"minor\":\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"patch\":\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n            this.prerelease = [];\n            break;\n          // This probably shouldn't be used publicly.\n          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n          case \"pre\": {\n            const base = Number(identifierBase) ? 1 : 0;\n            if (this.prerelease.length === 0) {\n              this.prerelease = [base];\n            } else {\n              let i = this.prerelease.length;\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === \"number\") {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n              if (i === -1) {\n                if (identifier === this.prerelease.join(\".\") && identifierBase === false) {\n                  throw new Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(base);\n              }\n            }\n            if (identifier) {\n              let prerelease = [identifier, base];\n              if (identifierBase === false) {\n                prerelease = [identifier];\n              }\n              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = prerelease;\n                }\n              } else {\n                this.prerelease = prerelease;\n              }\n            }\n            break;\n          }\n          default:\n            throw new Error(`invalid increment argument: ${release}`);\n        }\n        this.raw = this.format();\n        if (this.build.length) {\n          this.raw += `+${this.build.join(\".\")}`;\n        }\n        return this;\n      }\n    };\n    module2.exports = SemVer;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/parse.js\nvar require_parse = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/parse.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var parse = (version, options, throwErrors = false) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      try {\n        return new SemVer(version, options);\n      } catch (er) {\n        if (!throwErrors) {\n          return null;\n        }\n        throw er;\n      }\n    };\n    module2.exports = parse;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/valid.js\nvar require_valid = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/valid.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse();\n    var valid = (version, options) => {\n      const v = parse(version, options);\n      return v ? v.version : null;\n    };\n    module2.exports = valid;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/clean.js\nvar require_clean = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/clean.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse();\n    var clean = (version, options) => {\n      const s = parse(version.trim().replace(/^[=v]+/, \"\"), options);\n      return s ? s.version : null;\n    };\n    module2.exports = clean;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/inc.js\nvar require_inc = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/inc.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var inc = (version, release, options, identifier, identifierBase) => {\n      if (typeof options === \"string\") {\n        identifierBase = identifier;\n        identifier = options;\n        options = void 0;\n      }\n      try {\n        return new SemVer(\n          version instanceof SemVer ? version.version : version,\n          options\n        ).inc(release, identifier, identifierBase).version;\n      } catch (er) {\n        return null;\n      }\n    };\n    module2.exports = inc;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/diff.js\nvar require_diff = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/diff.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse();\n    var diff = (version1, version2) => {\n      const v1 = parse(version1, null, true);\n      const v2 = parse(version2, null, true);\n      const comparison = v1.compare(v2);\n      if (comparison === 0) {\n        return null;\n      }\n      const v1Higher = comparison > 0;\n      const highVersion = v1Higher ? v1 : v2;\n      const lowVersion = v1Higher ? v2 : v1;\n      const highHasPre = !!highVersion.prerelease.length;\n      const lowHasPre = !!lowVersion.prerelease.length;\n      if (lowHasPre && !highHasPre) {\n        if (!lowVersion.patch && !lowVersion.minor) {\n          return \"major\";\n        }\n        if (lowVersion.compareMain(highVersion) === 0) {\n          if (lowVersion.minor && !lowVersion.patch) {\n            return \"minor\";\n          }\n          return \"patch\";\n        }\n      }\n      const prefix = highHasPre ? \"pre\" : \"\";\n      if (v1.major !== v2.major) {\n        return prefix + \"major\";\n      }\n      if (v1.minor !== v2.minor) {\n        return prefix + \"minor\";\n      }\n      if (v1.patch !== v2.patch) {\n        return prefix + \"patch\";\n      }\n      return \"prerelease\";\n    };\n    module2.exports = diff;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/major.js\nvar require_major = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/major.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var major = (a, loose) => new SemVer(a, loose).major;\n    module2.exports = major;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/minor.js\nvar require_minor = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/minor.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var minor = (a, loose) => new SemVer(a, loose).minor;\n    module2.exports = minor;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/patch.js\nvar require_patch = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/patch.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var patch = (a, loose) => new SemVer(a, loose).patch;\n    module2.exports = patch;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/prerelease.js\nvar require_prerelease = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/prerelease.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse();\n    var prerelease = (version, options) => {\n      const parsed = parse(version, options);\n      return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n    };\n    module2.exports = prerelease;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/compare.js\nvar require_compare = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/compare.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));\n    module2.exports = compare;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/rcompare.js\nvar require_rcompare = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/rcompare.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var rcompare = (a, b, loose) => compare(b, a, loose);\n    module2.exports = rcompare;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/compare-loose.js\nvar require_compare_loose = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/compare-loose.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var compareLoose = (a, b) => compare(a, b, true);\n    module2.exports = compareLoose;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/compare-build.js\nvar require_compare_build = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/compare-build.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var compareBuild = (a, b, loose) => {\n      const versionA = new SemVer(a, loose);\n      const versionB = new SemVer(b, loose);\n      return versionA.compare(versionB) || versionA.compareBuild(versionB);\n    };\n    module2.exports = compareBuild;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/sort.js\nvar require_sort = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/sort.js\"(exports2, module2) {\n    \"use strict\";\n    var compareBuild = require_compare_build();\n    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));\n    module2.exports = sort;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/rsort.js\nvar require_rsort = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/rsort.js\"(exports2, module2) {\n    \"use strict\";\n    var compareBuild = require_compare_build();\n    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));\n    module2.exports = rsort;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/gt.js\nvar require_gt = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/gt.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var gt = (a, b, loose) => compare(a, b, loose) > 0;\n    module2.exports = gt;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/lt.js\nvar require_lt = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/lt.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var lt = (a, b, loose) => compare(a, b, loose) < 0;\n    module2.exports = lt;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/eq.js\nvar require_eq = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/eq.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var eq = (a, b, loose) => compare(a, b, loose) === 0;\n    module2.exports = eq;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/neq.js\nvar require_neq = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/neq.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var neq = (a, b, loose) => compare(a, b, loose) !== 0;\n    module2.exports = neq;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/gte.js\nvar require_gte = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/gte.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var gte = (a, b, loose) => compare(a, b, loose) >= 0;\n    module2.exports = gte;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/lte.js\nvar require_lte = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/lte.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare();\n    var lte = (a, b, loose) => compare(a, b, loose) <= 0;\n    module2.exports = lte;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/cmp.js\nvar require_cmp = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/cmp.js\"(exports2, module2) {\n    \"use strict\";\n    var eq = require_eq();\n    var neq = require_neq();\n    var gt = require_gt();\n    var gte = require_gte();\n    var lt = require_lt();\n    var lte = require_lte();\n    var cmp = (a, op, b, loose) => {\n      switch (op) {\n        case \"===\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a === b;\n        case \"!==\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a !== b;\n        case \"\":\n        case \"=\":\n        case \"==\":\n          return eq(a, b, loose);\n        case \"!=\":\n          return neq(a, b, loose);\n        case \">\":\n          return gt(a, b, loose);\n        case \">=\":\n          return gte(a, b, loose);\n        case \"<\":\n          return lt(a, b, loose);\n        case \"<=\":\n          return lte(a, b, loose);\n        default:\n          throw new TypeError(`Invalid operator: ${op}`);\n      }\n    };\n    module2.exports = cmp;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/coerce.js\nvar require_coerce = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/coerce.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var parse = require_parse();\n    var { safeRe: re, t } = require_re();\n    var coerce = (version, options) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      if (typeof version === \"number\") {\n        version = String(version);\n      }\n      if (typeof version !== \"string\") {\n        return null;\n      }\n      options = options || {};\n      let match = null;\n      if (!options.rtl) {\n        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);\n      } else {\n        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];\n        let next;\n        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n          if (!match || next.index + next[0].length !== match.index + match[0].length) {\n            match = next;\n          }\n          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;\n        }\n        coerceRtlRegex.lastIndex = -1;\n      }\n      if (match === null) {\n        return null;\n      }\n      const major = match[2];\n      const minor = match[3] || \"0\";\n      const patch = match[4] || \"0\";\n      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : \"\";\n      const build = options.includePrerelease && match[6] ? `+${match[6]}` : \"\";\n      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);\n    };\n    module2.exports = coerce;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/internal/lrucache.js\nvar require_lrucache = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/internal/lrucache.js\"(exports2, module2) {\n    \"use strict\";\n    var LRUCache = class {\n      constructor() {\n        this.max = 1e3;\n        this.map = /* @__PURE__ */ new Map();\n      }\n      get(key) {\n        const value = this.map.get(key);\n        if (value === void 0) {\n          return void 0;\n        } else {\n          this.map.delete(key);\n          this.map.set(key, value);\n          return value;\n        }\n      }\n      delete(key) {\n        return this.map.delete(key);\n      }\n      set(key, value) {\n        const deleted = this.delete(key);\n        if (!deleted && value !== void 0) {\n          if (this.map.size >= this.max) {\n            const firstKey = this.map.keys().next().value;\n            this.delete(firstKey);\n          }\n          this.map.set(key, value);\n        }\n        return this;\n      }\n    };\n    module2.exports = LRUCache;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/classes/range.js\nvar require_range = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/classes/range.js\"(exports2, module2) {\n    \"use strict\";\n    var SPACE_CHARACTERS = /\\s+/g;\n    var Range = class _Range {\n      constructor(range, options) {\n        options = parseOptions(options);\n        if (range instanceof _Range) {\n          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n            return range;\n          } else {\n            return new _Range(range.raw, options);\n          }\n        }\n        if (range instanceof Comparator) {\n          this.raw = range.value;\n          this.set = [[range]];\n          this.formatted = void 0;\n          return this;\n        }\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        this.raw = range.trim().replace(SPACE_CHARACTERS, \" \");\n        this.set = this.raw.split(\"||\").map((r) => this.parseRange(r.trim())).filter((c) => c.length);\n        if (!this.set.length) {\n          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);\n        }\n        if (this.set.length > 1) {\n          const first = this.set[0];\n          this.set = this.set.filter((c) => !isNullSet(c[0]));\n          if (this.set.length === 0) {\n            this.set = [first];\n          } else if (this.set.length > 1) {\n            for (const c of this.set) {\n              if (c.length === 1 && isAny(c[0])) {\n                this.set = [c];\n                break;\n              }\n            }\n          }\n        }\n        this.formatted = void 0;\n      }\n      get range() {\n        if (this.formatted === void 0) {\n          this.formatted = \"\";\n          for (let i = 0; i < this.set.length; i++) {\n            if (i > 0) {\n              this.formatted += \"||\";\n            }\n            const comps = this.set[i];\n            for (let k = 0; k < comps.length; k++) {\n              if (k > 0) {\n                this.formatted += \" \";\n              }\n              this.formatted += comps[k].toString().trim();\n            }\n          }\n        }\n        return this.formatted;\n      }\n      format() {\n        return this.range;\n      }\n      toString() {\n        return this.range;\n      }\n      parseRange(range) {\n        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);\n        const memoKey = memoOpts + \":\" + range;\n        const cached = cache.get(memoKey);\n        if (cached) {\n          return cached;\n        }\n        const loose = this.options.loose;\n        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n        debug(\"hyphen replace\", range);\n        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n        debug(\"comparator trim\", range);\n        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);\n        debug(\"tilde trim\", range);\n        range = range.replace(re[t.CARETTRIM], caretTrimReplace);\n        debug(\"caret trim\", range);\n        let rangeList = range.split(\" \").map((comp) => parseComparator(comp, this.options)).join(\" \").split(/\\s+/).map((comp) => replaceGTE0(comp, this.options));\n        if (loose) {\n          rangeList = rangeList.filter((comp) => {\n            debug(\"loose invalid filter\", comp, this.options);\n            return !!comp.match(re[t.COMPARATORLOOSE]);\n          });\n        }\n        debug(\"range list\", rangeList);\n        const rangeMap = /* @__PURE__ */ new Map();\n        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));\n        for (const comp of comparators) {\n          if (isNullSet(comp)) {\n            return [comp];\n          }\n          rangeMap.set(comp.value, comp);\n        }\n        if (rangeMap.size > 1 && rangeMap.has(\"\")) {\n          rangeMap.delete(\"\");\n        }\n        const result = [...rangeMap.values()];\n        cache.set(memoKey, result);\n        return result;\n      }\n      intersects(range, options) {\n        if (!(range instanceof _Range)) {\n          throw new TypeError(\"a Range is required\");\n        }\n        return this.set.some((thisComparators) => {\n          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {\n            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options);\n              });\n            });\n          });\n        });\n      }\n      // if ANY of the sets match ALL of its comparators, then pass\n      test(version) {\n        if (!version) {\n          return false;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        for (let i = 0; i < this.set.length; i++) {\n          if (testSet(this.set[i], version, this.options)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n    module2.exports = Range;\n    var LRU = require_lrucache();\n    var cache = new LRU();\n    var parseOptions = require_parse_options();\n    var Comparator = require_comparator();\n    var debug = require_debug();\n    var SemVer = require_semver();\n    var {\n      safeRe: re,\n      t,\n      comparatorTrimReplace,\n      tildeTrimReplace,\n      caretTrimReplace\n    } = require_re();\n    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();\n    var isNullSet = (c) => c.value === \"<0.0.0-0\";\n    var isAny = (c) => c.value === \"\";\n    var isSatisfiable = (comparators, options) => {\n      let result = true;\n      const remainingComparators = comparators.slice();\n      let testComparator = remainingComparators.pop();\n      while (result && remainingComparators.length) {\n        result = remainingComparators.every((otherComparator) => {\n          return testComparator.intersects(otherComparator, options);\n        });\n        testComparator = remainingComparators.pop();\n      }\n      return result;\n    };\n    var parseComparator = (comp, options) => {\n      comp = comp.replace(re[t.BUILD], \"\");\n      debug(\"comp\", comp, options);\n      comp = replaceCarets(comp, options);\n      debug(\"caret\", comp);\n      comp = replaceTildes(comp, options);\n      debug(\"tildes\", comp);\n      comp = replaceXRanges(comp, options);\n      debug(\"xrange\", comp);\n      comp = replaceStars(comp, options);\n      debug(\"stars\", comp);\n      return comp;\n    };\n    var isX = (id) => !id || id.toLowerCase() === \"x\" || id === \"*\";\n    var replaceTildes = (comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceTilde(c, options)).join(\" \");\n    };\n    var replaceTilde = (comp, options) => {\n      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"tilde\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n        } else if (pr) {\n          debug(\"replaceTilde pr\", pr);\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n        } else {\n          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"tilde return\", ret);\n        return ret;\n      });\n    };\n    var replaceCarets = (comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceCaret(c, options)).join(\" \");\n    };\n    var replaceCaret = (comp, options) => {\n      debug(\"caret\", comp, options);\n      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n      const z = options.includePrerelease ? \"-0\" : \"\";\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"caret\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          if (M === \"0\") {\n            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n          } else {\n            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n          }\n        } else if (pr) {\n          debug(\"replaceCaret pr\", pr);\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;\n          }\n        } else {\n          debug(\"no pr\");\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;\n          }\n        }\n        debug(\"caret return\", ret);\n        return ret;\n      });\n    };\n    var replaceXRanges = (comp, options) => {\n      debug(\"replaceXRanges\", comp, options);\n      return comp.split(/\\s+/).map((c) => replaceXRange(c, options)).join(\" \");\n    };\n    var replaceXRange = (comp, options) => {\n      comp = comp.trim();\n      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n        debug(\"xRange\", comp, ret, gtlt, M, m, p, pr);\n        const xM = isX(M);\n        const xm = xM || isX(m);\n        const xp = xm || isX(p);\n        const anyX = xp;\n        if (gtlt === \"=\" && anyX) {\n          gtlt = \"\";\n        }\n        pr = options.includePrerelease ? \"-0\" : \"\";\n        if (xM) {\n          if (gtlt === \">\" || gtlt === \"<\") {\n            ret = \"<0.0.0-0\";\n          } else {\n            ret = \"*\";\n          }\n        } else if (gtlt && anyX) {\n          if (xm) {\n            m = 0;\n          }\n          p = 0;\n          if (gtlt === \">\") {\n            gtlt = \">=\";\n            if (xm) {\n              M = +M + 1;\n              m = 0;\n              p = 0;\n            } else {\n              m = +m + 1;\n              p = 0;\n            }\n          } else if (gtlt === \"<=\") {\n            gtlt = \"<\";\n            if (xm) {\n              M = +M + 1;\n            } else {\n              m = +m + 1;\n            }\n          }\n          if (gtlt === \"<\") {\n            pr = \"-0\";\n          }\n          ret = `${gtlt + M}.${m}.${p}${pr}`;\n        } else if (xm) {\n          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n        } else if (xp) {\n          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"xRange return\", ret);\n        return ret;\n      });\n    };\n    var replaceStars = (comp, options) => {\n      debug(\"replaceStars\", comp, options);\n      return comp.trim().replace(re[t.STAR], \"\");\n    };\n    var replaceGTE0 = (comp, options) => {\n      debug(\"replaceGTE0\", comp, options);\n      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], \"\");\n    };\n    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {\n      if (isX(fM)) {\n        from = \"\";\n      } else if (isX(fm)) {\n        from = `>=${fM}.0.0${incPr ? \"-0\" : \"\"}`;\n      } else if (isX(fp)) {\n        from = `>=${fM}.${fm}.0${incPr ? \"-0\" : \"\"}`;\n      } else if (fpr) {\n        from = `>=${from}`;\n      } else {\n        from = `>=${from}${incPr ? \"-0\" : \"\"}`;\n      }\n      if (isX(tM)) {\n        to = \"\";\n      } else if (isX(tm)) {\n        to = `<${+tM + 1}.0.0-0`;\n      } else if (isX(tp)) {\n        to = `<${tM}.${+tm + 1}.0-0`;\n      } else if (tpr) {\n        to = `<=${tM}.${tm}.${tp}-${tpr}`;\n      } else if (incPr) {\n        to = `<${tM}.${tm}.${+tp + 1}-0`;\n      } else {\n        to = `<=${to}`;\n      }\n      return `${from} ${to}`.trim();\n    };\n    var testSet = (set, version, options) => {\n      for (let i = 0; i < set.length; i++) {\n        if (!set[i].test(version)) {\n          return false;\n        }\n      }\n      if (version.prerelease.length && !options.includePrerelease) {\n        for (let i = 0; i < set.length; i++) {\n          debug(set[i].semver);\n          if (set[i].semver === Comparator.ANY) {\n            continue;\n          }\n          if (set[i].semver.prerelease.length > 0) {\n            const allowed = set[i].semver;\n            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/classes/comparator.js\nvar require_comparator = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/classes/comparator.js\"(exports2, module2) {\n    \"use strict\";\n    var ANY = /* @__PURE__ */ Symbol(\"SemVer ANY\");\n    var Comparator = class _Comparator {\n      static get ANY() {\n        return ANY;\n      }\n      constructor(comp, options) {\n        options = parseOptions(options);\n        if (comp instanceof _Comparator) {\n          if (comp.loose === !!options.loose) {\n            return comp;\n          } else {\n            comp = comp.value;\n          }\n        }\n        comp = comp.trim().split(/\\s+/).join(\" \");\n        debug(\"comparator\", comp, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.parse(comp);\n        if (this.semver === ANY) {\n          this.value = \"\";\n        } else {\n          this.value = this.operator + this.semver.version;\n        }\n        debug(\"comp\", this);\n      }\n      parse(comp) {\n        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n        const m = comp.match(r);\n        if (!m) {\n          throw new TypeError(`Invalid comparator: ${comp}`);\n        }\n        this.operator = m[1] !== void 0 ? m[1] : \"\";\n        if (this.operator === \"=\") {\n          this.operator = \"\";\n        }\n        if (!m[2]) {\n          this.semver = ANY;\n        } else {\n          this.semver = new SemVer(m[2], this.options.loose);\n        }\n      }\n      toString() {\n        return this.value;\n      }\n      test(version) {\n        debug(\"Comparator.test\", version, this.options.loose);\n        if (this.semver === ANY || version === ANY) {\n          return true;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        return cmp(version, this.operator, this.semver, this.options);\n      }\n      intersects(comp, options) {\n        if (!(comp instanceof _Comparator)) {\n          throw new TypeError(\"a Comparator is required\");\n        }\n        if (this.operator === \"\") {\n          if (this.value === \"\") {\n            return true;\n          }\n          return new Range(comp.value, options).test(this.value);\n        } else if (comp.operator === \"\") {\n          if (comp.value === \"\") {\n            return true;\n          }\n          return new Range(this.value, options).test(comp.semver);\n        }\n        options = parseOptions(options);\n        if (options.includePrerelease && (this.value === \"<0.0.0-0\" || comp.value === \"<0.0.0-0\")) {\n          return false;\n        }\n        if (!options.includePrerelease && (this.value.startsWith(\"<0.0.0\") || comp.value.startsWith(\"<0.0.0\"))) {\n          return false;\n        }\n        if (this.operator.startsWith(\">\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        if (this.operator.startsWith(\"<\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (this.semver.version === comp.semver.version && this.operator.includes(\"=\") && comp.operator.includes(\"=\")) {\n          return true;\n        }\n        if (cmp(this.semver, \"<\", comp.semver, options) && this.operator.startsWith(\">\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (cmp(this.semver, \">\", comp.semver, options) && this.operator.startsWith(\"<\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        return false;\n      }\n    };\n    module2.exports = Comparator;\n    var parseOptions = require_parse_options();\n    var { safeRe: re, t } = require_re();\n    var cmp = require_cmp();\n    var debug = require_debug();\n    var SemVer = require_semver();\n    var Range = require_range();\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/functions/satisfies.js\nvar require_satisfies = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/functions/satisfies.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range();\n    var satisfies = (version, range, options) => {\n      try {\n        range = new Range(range, options);\n      } catch (er) {\n        return false;\n      }\n      return range.test(version);\n    };\n    module2.exports = satisfies;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/to-comparators.js\nvar require_to_comparators = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/to-comparators.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range();\n    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(\" \").trim().split(\" \"));\n    module2.exports = toComparators;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/max-satisfying.js\nvar require_max_satisfying = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/max-satisfying.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var Range = require_range();\n    var maxSatisfying = (versions, range, options) => {\n      let max = null;\n      let maxSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!max || maxSV.compare(v) === -1) {\n            max = v;\n            maxSV = new SemVer(max, options);\n          }\n        }\n      });\n      return max;\n    };\n    module2.exports = maxSatisfying;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/min-satisfying.js\nvar require_min_satisfying = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/min-satisfying.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var Range = require_range();\n    var minSatisfying = (versions, range, options) => {\n      let min = null;\n      let minSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!min || minSV.compare(v) === 1) {\n            min = v;\n            minSV = new SemVer(min, options);\n          }\n        }\n      });\n      return min;\n    };\n    module2.exports = minSatisfying;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/min-version.js\nvar require_min_version = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/min-version.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var Range = require_range();\n    var gt = require_gt();\n    var minVersion = (range, loose) => {\n      range = new Range(range, loose);\n      let minver = new SemVer(\"0.0.0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = new SemVer(\"0.0.0-0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = null;\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let setMin = null;\n        comparators.forEach((comparator) => {\n          const compver = new SemVer(comparator.semver.version);\n          switch (comparator.operator) {\n            case \">\":\n              if (compver.prerelease.length === 0) {\n                compver.patch++;\n              } else {\n                compver.prerelease.push(0);\n              }\n              compver.raw = compver.format();\n            /* fallthrough */\n            case \"\":\n            case \">=\":\n              if (!setMin || gt(compver, setMin)) {\n                setMin = compver;\n              }\n              break;\n            case \"<\":\n            case \"<=\":\n              break;\n            /* istanbul ignore next */\n            default:\n              throw new Error(`Unexpected operation: ${comparator.operator}`);\n          }\n        });\n        if (setMin && (!minver || gt(minver, setMin))) {\n          minver = setMin;\n        }\n      }\n      if (minver && range.test(minver)) {\n        return minver;\n      }\n      return null;\n    };\n    module2.exports = minVersion;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/valid.js\nvar require_valid2 = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/valid.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range();\n    var validRange = (range, options) => {\n      try {\n        return new Range(range, options).range || \"*\";\n      } catch (er) {\n        return null;\n      }\n    };\n    module2.exports = validRange;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/outside.js\nvar require_outside = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/outside.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver();\n    var Comparator = require_comparator();\n    var { ANY } = Comparator;\n    var Range = require_range();\n    var satisfies = require_satisfies();\n    var gt = require_gt();\n    var lt = require_lt();\n    var lte = require_lte();\n    var gte = require_gte();\n    var outside = (version, range, hilo, options) => {\n      version = new SemVer(version, options);\n      range = new Range(range, options);\n      let gtfn, ltefn, ltfn, comp, ecomp;\n      switch (hilo) {\n        case \">\":\n          gtfn = gt;\n          ltefn = lte;\n          ltfn = lt;\n          comp = \">\";\n          ecomp = \">=\";\n          break;\n        case \"<\":\n          gtfn = lt;\n          ltefn = gte;\n          ltfn = gt;\n          comp = \"<\";\n          ecomp = \"<=\";\n          break;\n        default:\n          throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n      }\n      if (satisfies(version, range, options)) {\n        return false;\n      }\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let high = null;\n        let low = null;\n        comparators.forEach((comparator) => {\n          if (comparator.semver === ANY) {\n            comparator = new Comparator(\">=0.0.0\");\n          }\n          high = high || comparator;\n          low = low || comparator;\n          if (gtfn(comparator.semver, high.semver, options)) {\n            high = comparator;\n          } else if (ltfn(comparator.semver, low.semver, options)) {\n            low = comparator;\n          }\n        });\n        if (high.operator === comp || high.operator === ecomp) {\n          return false;\n        }\n        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n          return false;\n        } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    module2.exports = outside;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/gtr.js\nvar require_gtr = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/gtr.js\"(exports2, module2) {\n    \"use strict\";\n    var outside = require_outside();\n    var gtr = (version, range, options) => outside(version, range, \">\", options);\n    module2.exports = gtr;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/ltr.js\nvar require_ltr = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/ltr.js\"(exports2, module2) {\n    \"use strict\";\n    var outside = require_outside();\n    var ltr = (version, range, options) => outside(version, range, \"<\", options);\n    module2.exports = ltr;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/intersects.js\nvar require_intersects = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/intersects.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range();\n    var intersects = (r1, r2, options) => {\n      r1 = new Range(r1, options);\n      r2 = new Range(r2, options);\n      return r1.intersects(r2, options);\n    };\n    module2.exports = intersects;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/simplify.js\nvar require_simplify = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/simplify.js\"(exports2, module2) {\n    \"use strict\";\n    var satisfies = require_satisfies();\n    var compare = require_compare();\n    module2.exports = (versions, range, options) => {\n      const set = [];\n      let first = null;\n      let prev = null;\n      const v = versions.sort((a, b) => compare(a, b, options));\n      for (const version of v) {\n        const included = satisfies(version, range, options);\n        if (included) {\n          prev = version;\n          if (!first) {\n            first = version;\n          }\n        } else {\n          if (prev) {\n            set.push([first, prev]);\n          }\n          prev = null;\n          first = null;\n        }\n      }\n      if (first) {\n        set.push([first, null]);\n      }\n      const ranges = [];\n      for (const [min, max] of set) {\n        if (min === max) {\n          ranges.push(min);\n        } else if (!max && min === v[0]) {\n          ranges.push(\"*\");\n        } else if (!max) {\n          ranges.push(`>=${min}`);\n        } else if (min === v[0]) {\n          ranges.push(`<=${max}`);\n        } else {\n          ranges.push(`${min} - ${max}`);\n        }\n      }\n      const simplified = ranges.join(\" || \");\n      const original = typeof range.raw === \"string\" ? range.raw : String(range);\n      return simplified.length < original.length ? simplified : range;\n    };\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/ranges/subset.js\nvar require_subset = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/ranges/subset.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range();\n    var Comparator = require_comparator();\n    var { ANY } = Comparator;\n    var satisfies = require_satisfies();\n    var compare = require_compare();\n    var subset = (sub, dom, options = {}) => {\n      if (sub === dom) {\n        return true;\n      }\n      sub = new Range(sub, options);\n      dom = new Range(dom, options);\n      let sawNonNull = false;\n      OUTER: for (const simpleSub of sub.set) {\n        for (const simpleDom of dom.set) {\n          const isSub = simpleSubset(simpleSub, simpleDom, options);\n          sawNonNull = sawNonNull || isSub !== null;\n          if (isSub) {\n            continue OUTER;\n          }\n        }\n        if (sawNonNull) {\n          return false;\n        }\n      }\n      return true;\n    };\n    var minimumVersionWithPreRelease = [new Comparator(\">=0.0.0-0\")];\n    var minimumVersion = [new Comparator(\">=0.0.0\")];\n    var simpleSubset = (sub, dom, options) => {\n      if (sub === dom) {\n        return true;\n      }\n      if (sub.length === 1 && sub[0].semver === ANY) {\n        if (dom.length === 1 && dom[0].semver === ANY) {\n          return true;\n        } else if (options.includePrerelease) {\n          sub = minimumVersionWithPreRelease;\n        } else {\n          sub = minimumVersion;\n        }\n      }\n      if (dom.length === 1 && dom[0].semver === ANY) {\n        if (options.includePrerelease) {\n          return true;\n        } else {\n          dom = minimumVersion;\n        }\n      }\n      const eqSet = /* @__PURE__ */ new Set();\n      let gt, lt;\n      for (const c of sub) {\n        if (c.operator === \">\" || c.operator === \">=\") {\n          gt = higherGT(gt, c, options);\n        } else if (c.operator === \"<\" || c.operator === \"<=\") {\n          lt = lowerLT(lt, c, options);\n        } else {\n          eqSet.add(c.semver);\n        }\n      }\n      if (eqSet.size > 1) {\n        return null;\n      }\n      let gtltComp;\n      if (gt && lt) {\n        gtltComp = compare(gt.semver, lt.semver, options);\n        if (gtltComp > 0) {\n          return null;\n        } else if (gtltComp === 0 && (gt.operator !== \">=\" || lt.operator !== \"<=\")) {\n          return null;\n        }\n      }\n      for (const eq of eqSet) {\n        if (gt && !satisfies(eq, String(gt), options)) {\n          return null;\n        }\n        if (lt && !satisfies(eq, String(lt), options)) {\n          return null;\n        }\n        for (const c of dom) {\n          if (!satisfies(eq, String(c), options)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      let higher, lower;\n      let hasDomLT, hasDomGT;\n      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;\n      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;\n      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === \"<\" && needDomLTPre.prerelease[0] === 0) {\n        needDomLTPre = false;\n      }\n      for (const c of dom) {\n        hasDomGT = hasDomGT || c.operator === \">\" || c.operator === \">=\";\n        hasDomLT = hasDomLT || c.operator === \"<\" || c.operator === \"<=\";\n        if (gt) {\n          if (needDomGTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {\n              needDomGTPre = false;\n            }\n          }\n          if (c.operator === \">\" || c.operator === \">=\") {\n            higher = higherGT(gt, c, options);\n            if (higher === c && higher !== gt) {\n              return false;\n            }\n          } else if (gt.operator === \">=\" && !satisfies(gt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (lt) {\n          if (needDomLTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {\n              needDomLTPre = false;\n            }\n          }\n          if (c.operator === \"<\" || c.operator === \"<=\") {\n            lower = lowerLT(lt, c, options);\n            if (lower === c && lower !== lt) {\n              return false;\n            }\n          } else if (lt.operator === \"<=\" && !satisfies(lt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (!c.operator && (lt || gt) && gtltComp !== 0) {\n          return false;\n        }\n      }\n      if (gt && hasDomLT && !lt && gtltComp !== 0) {\n        return false;\n      }\n      if (lt && hasDomGT && !gt && gtltComp !== 0) {\n        return false;\n      }\n      if (needDomGTPre || needDomLTPre) {\n        return false;\n      }\n      return true;\n    };\n    var higherGT = (a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare(a.semver, b.semver, options);\n      return comp > 0 ? a : comp < 0 ? b : b.operator === \">\" && a.operator === \">=\" ? b : a;\n    };\n    var lowerLT = (a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare(a.semver, b.semver, options);\n      return comp < 0 ? a : comp > 0 ? b : b.operator === \"<\" && a.operator === \"<=\" ? b : a;\n    };\n    module2.exports = subset;\n  }\n});\n\n// node_modules/electron-updater/node_modules/semver/index.js\nvar require_semver2 = __commonJS({\n  \"node_modules/electron-updater/node_modules/semver/index.js\"(exports2, module2) {\n    \"use strict\";\n    var internalRe = require_re();\n    var constants = require_constants();\n    var SemVer = require_semver();\n    var identifiers = require_identifiers();\n    var parse = require_parse();\n    var valid = require_valid();\n    var clean = require_clean();\n    var inc = require_inc();\n    var diff = require_diff();\n    var major = require_major();\n    var minor = require_minor();\n    var patch = require_patch();\n    var prerelease = require_prerelease();\n    var compare = require_compare();\n    var rcompare = require_rcompare();\n    var compareLoose = require_compare_loose();\n    var compareBuild = require_compare_build();\n    var sort = require_sort();\n    var rsort = require_rsort();\n    var gt = require_gt();\n    var lt = require_lt();\n    var eq = require_eq();\n    var neq = require_neq();\n    var gte = require_gte();\n    var lte = require_lte();\n    var cmp = require_cmp();\n    var coerce = require_coerce();\n    var Comparator = require_comparator();\n    var Range = require_range();\n    var satisfies = require_satisfies();\n    var toComparators = require_to_comparators();\n    var maxSatisfying = require_max_satisfying();\n    var minSatisfying = require_min_satisfying();\n    var minVersion = require_min_version();\n    var validRange = require_valid2();\n    var outside = require_outside();\n    var gtr = require_gtr();\n    var ltr = require_ltr();\n    var intersects = require_intersects();\n    var simplifyRange = require_simplify();\n    var subset = require_subset();\n    module2.exports = {\n      parse,\n      valid,\n      clean,\n      inc,\n      diff,\n      major,\n      minor,\n      patch,\n      prerelease,\n      compare,\n      rcompare,\n      compareLoose,\n      compareBuild,\n      sort,\n      rsort,\n      gt,\n      lt,\n      eq,\n      neq,\n      gte,\n      lte,\n      cmp,\n      coerce,\n      Comparator,\n      Range,\n      satisfies,\n      toComparators,\n      maxSatisfying,\n      minSatisfying,\n      minVersion,\n      validRange,\n      outside,\n      gtr,\n      ltr,\n      intersects,\n      simplifyRange,\n      subset,\n      SemVer,\n      re: internalRe.re,\n      src: internalRe.src,\n      tokens: internalRe.t,\n      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n      RELEASE_TYPES: constants.RELEASE_TYPES,\n      compareIdentifiers: identifiers.compareIdentifiers,\n      rcompareIdentifiers: identifiers.rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/lodash.isequal/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/lodash.isequal/index.js\"(exports2, module2) {\n    var LARGE_ARRAY_SIZE = 200;\n    var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    var COMPARE_PARTIAL_FLAG = 1;\n    var COMPARE_UNORDERED_FLAG = 2;\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    var argsTag = \"[object Arguments]\";\n    var arrayTag = \"[object Array]\";\n    var asyncTag = \"[object AsyncFunction]\";\n    var boolTag = \"[object Boolean]\";\n    var dateTag = \"[object Date]\";\n    var errorTag = \"[object Error]\";\n    var funcTag = \"[object Function]\";\n    var genTag = \"[object GeneratorFunction]\";\n    var mapTag = \"[object Map]\";\n    var numberTag = \"[object Number]\";\n    var nullTag = \"[object Null]\";\n    var objectTag = \"[object Object]\";\n    var promiseTag = \"[object Promise]\";\n    var proxyTag = \"[object Proxy]\";\n    var regexpTag = \"[object RegExp]\";\n    var setTag = \"[object Set]\";\n    var stringTag = \"[object String]\";\n    var symbolTag = \"[object Symbol]\";\n    var undefinedTag = \"[object Undefined]\";\n    var weakMapTag = \"[object WeakMap]\";\n    var arrayBufferTag = \"[object ArrayBuffer]\";\n    var dataViewTag = \"[object DataView]\";\n    var float32Tag = \"[object Float32Array]\";\n    var float64Tag = \"[object Float64Array]\";\n    var int8Tag = \"[object Int8Array]\";\n    var int16Tag = \"[object Int16Array]\";\n    var int32Tag = \"[object Int32Array]\";\n    var uint8Tag = \"[object Uint8Array]\";\n    var uint8ClampedTag = \"[object Uint8ClampedArray]\";\n    var uint16Tag = \"[object Uint16Array]\";\n    var uint32Tag = \"[object Uint32Array]\";\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var freeExports = typeof exports2 == \"object\" && exports2 && !exports2.nodeType && exports2;\n    var freeModule = freeExports && typeof module2 == \"object\" && module2 && !module2.nodeType && module2;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var freeProcess = moduleExports && freeGlobal.process;\n    var nodeUtil = (function() {\n      try {\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e) {\n      }\n    })();\n    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n    function arrayFilter(array, predicate) {\n      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    function arrayPush(array, values) {\n      var index = -1, length = values.length, offset = array.length;\n      while (++index < length) {\n        array[offset + index] = values[index];\n      }\n      return array;\n    }\n    function arraySome(array, predicate) {\n      var index = -1, length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function baseTimes(n, iteratee) {\n      var index = -1, result = Array(n);\n      while (++index < n) {\n        result[index] = iteratee(index);\n      }\n      return result;\n    }\n    function baseUnary(func) {\n      return function(value) {\n        return func(value);\n      };\n    }\n    function cacheHas(cache, key) {\n      return cache.has(key);\n    }\n    function getValue(object, key) {\n      return object == null ? void 0 : object[key];\n    }\n    function mapToArray(map) {\n      var index = -1, result = Array(map.size);\n      map.forEach(function(value, key) {\n        result[++index] = [key, value];\n      });\n      return result;\n    }\n    function overArg(func, transform) {\n      return function(arg) {\n        return func(transform(arg));\n      };\n    }\n    function setToArray(set) {\n      var index = -1, result = Array(set.size);\n      set.forEach(function(value) {\n        result[++index] = value;\n      });\n      return result;\n    }\n    var arrayProto = Array.prototype;\n    var funcProto = Function.prototype;\n    var objectProto = Object.prototype;\n    var coreJsData = root[\"__core-js_shared__\"];\n    var funcToString = funcProto.toString;\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    })();\n    var nativeObjectToString = objectProto.toString;\n    var reIsNative = RegExp(\n      \"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n    );\n    var Buffer2 = moduleExports ? root.Buffer : void 0;\n    var Symbol2 = root.Symbol;\n    var Uint8Array2 = root.Uint8Array;\n    var propertyIsEnumerable = objectProto.propertyIsEnumerable;\n    var splice = arrayProto.splice;\n    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;\n    var nativeGetSymbols = Object.getOwnPropertySymbols;\n    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n    var nativeKeys = overArg(Object.keys, Object);\n    var DataView = getNative(root, \"DataView\");\n    var Map2 = getNative(root, \"Map\");\n    var Promise2 = getNative(root, \"Promise\");\n    var Set2 = getNative(root, \"Set\");\n    var WeakMap2 = getNative(root, \"WeakMap\");\n    var nativeCreate = getNative(Object, \"create\");\n    var dataViewCtorString = toSource(DataView);\n    var mapCtorString = toSource(Map2);\n    var promiseCtorString = toSource(Promise2);\n    var setCtorString = toSource(Set2);\n    var weakMapCtorString = toSource(WeakMap2);\n    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;\n    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\n    function Hash(entries) {\n      var index = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? void 0 : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : void 0;\n    }\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);\n    }\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;\n      return this;\n    }\n    Hash.prototype.clear = hashClear;\n    Hash.prototype[\"delete\"] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    function ListCache(entries) {\n      var index = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n    function listCacheDelete(key) {\n      var data = this.__data__, index = assocIndexOf(data, key);\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n    function listCacheGet(key) {\n      var data = this.__data__, index = assocIndexOf(data, key);\n      return index < 0 ? void 0 : data[index][1];\n    }\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n    function listCacheSet(key, value) {\n      var data = this.__data__, index = assocIndexOf(data, key);\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype[\"delete\"] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    function MapCache(entries) {\n      var index = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        \"hash\": new Hash(),\n        \"map\": new (Map2 || ListCache)(),\n        \"string\": new Hash()\n      };\n    }\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)[\"delete\"](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key), size = data.size;\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype[\"delete\"] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    function SetCache(values) {\n      var index = -1, length = values == null ? 0 : values.length;\n      this.__data__ = new MapCache();\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n    function stackClear() {\n      this.__data__ = new ListCache();\n      this.size = 0;\n    }\n    function stackDelete(key) {\n      var data = this.__data__, result = data[\"delete\"](key);\n      this.size = data.size;\n      return result;\n    }\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n    Stack.prototype.clear = stackClear;\n    Stack.prototype[\"delete\"] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n        isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n        isIndex(key, length)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === void 0 ? undefinedTag : nullTag;\n      }\n      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack());\n        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack());\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack());\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != \"constructor\") {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;\n      stack.set(array, other);\n      stack.set(other, array);\n      while (++index < arrLength) {\n        var arrValue = array[index], othValue = other[index];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== void 0) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        if (seen) {\n          if (!arraySome(other, function(othValue2, othIndex) {\n            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack[\"delete\"](array);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n        case arrayBufferTag:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {\n            return false;\n          }\n          return true;\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          return eq(+object, +other);\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n          return object == other + \"\";\n        case mapTag:\n          var convert = mapToArray;\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack[\"delete\"](object);\n          return result;\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack[\"delete\"](object);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : void 0;\n    }\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n      try {\n        value[symToStringTag] = void 0;\n        var unmasked = true;\n      } catch (e) {\n      }\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n    var getTag = baseGetTag;\n    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {\n      getTag = function(value) {\n        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag;\n            case mapCtorString:\n              return mapTag;\n            case promiseCtorString:\n              return promiseTag;\n            case setCtorString:\n              return setTag;\n            case weakMapCtorString:\n              return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n    function isIndex(value, length) {\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return !!length && (typeof value == \"number\" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n    }\n    function isKeyable(value) {\n      var type = typeof value;\n      return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n    function isPrototype(value) {\n      var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto;\n      return value === proto;\n    }\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {\n        }\n        try {\n          return func + \"\";\n        } catch (e) {\n        }\n      }\n      return \"\";\n    }\n    function eq(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {\n      return arguments;\n    })()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n    };\n    var isArray = Array.isArray;\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n    var isBuffer = nativeIsBuffer || stubFalse;\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n    function isLength(value) {\n      return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return value != null && typeof value == \"object\";\n    }\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n    function stubArray() {\n      return [];\n    }\n    function stubFalse() {\n      return false;\n    }\n    module2.exports = isEqual;\n  }\n});\n\n// node_modules/electron-updater/out/DownloadedUpdateHelper.js\nvar require_DownloadedUpdateHelper = __commonJS({\n  \"node_modules/electron-updater/out/DownloadedUpdateHelper.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DownloadedUpdateHelper = void 0;\n    exports2.createTempUpdateFile = createTempUpdateFile;\n    var crypto_1 = require(\"crypto\");\n    var fs_1 = require(\"fs\");\n    var isEqual = require_lodash();\n    var fs_extra_1 = require_lib();\n    var path6 = require(\"path\");\n    var DownloadedUpdateHelper = class {\n      constructor(cacheDir) {\n        this.cacheDir = cacheDir;\n        this._file = null;\n        this._packageFile = null;\n        this.versionInfo = null;\n        this.fileInfo = null;\n        this._downloadedFileInfo = null;\n      }\n      get downloadedFileInfo() {\n        return this._downloadedFileInfo;\n      }\n      get file() {\n        return this._file;\n      }\n      get packageFile() {\n        return this._packageFile;\n      }\n      get cacheDirForPendingUpdate() {\n        return path6.join(this.cacheDir, \"pending\");\n      }\n      async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger12) {\n        if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {\n          if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await (0, fs_extra_1.pathExists)(updateFile)) {\n            return updateFile;\n          } else {\n            return null;\n          }\n        }\n        const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger12);\n        if (cachedUpdateFile === null) {\n          return null;\n        }\n        logger12.info(`Update has already been downloaded to ${updateFile}).`);\n        this._file = cachedUpdateFile;\n        return cachedUpdateFile;\n      }\n      async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {\n        this._file = downloadedFile;\n        this._packageFile = packageFile;\n        this.versionInfo = versionInfo;\n        this.fileInfo = fileInfo;\n        this._downloadedFileInfo = {\n          fileName: updateFileName,\n          sha512: fileInfo.info.sha512,\n          isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true\n        };\n        if (isSaveCache) {\n          await (0, fs_extra_1.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);\n        }\n      }\n      async clear() {\n        this._file = null;\n        this._packageFile = null;\n        this.versionInfo = null;\n        this.fileInfo = null;\n        await this.cleanCacheDirForPendingUpdate();\n      }\n      async cleanCacheDirForPendingUpdate() {\n        try {\n          await (0, fs_extra_1.emptyDir)(this.cacheDirForPendingUpdate);\n        } catch (_ignore) {\n        }\n      }\n      /**\n       * Returns \"update-info.json\" which is created in the update cache directory's \"pending\" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.\n       * @param fileInfo\n       * @param logger\n       */\n      async getValidCachedUpdateFile(fileInfo, logger12) {\n        const updateInfoFilePath = this.getUpdateInfoFile();\n        const doesUpdateInfoFileExist = await (0, fs_extra_1.pathExists)(updateInfoFilePath);\n        if (!doesUpdateInfoFileExist) {\n          return null;\n        }\n        let cachedInfo;\n        try {\n          cachedInfo = await (0, fs_extra_1.readJson)(updateInfoFilePath);\n        } catch (error) {\n          let message = `No cached update info available`;\n          if (error.code !== \"ENOENT\") {\n            await this.cleanCacheDirForPendingUpdate();\n            message += ` (error on read: ${error.message})`;\n          }\n          logger12.info(message);\n          return null;\n        }\n        const isCachedInfoFileNameValid = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null;\n        if (!isCachedInfoFileNameValid) {\n          logger12.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);\n          await this.cleanCacheDirForPendingUpdate();\n          return null;\n        }\n        if (fileInfo.info.sha512 !== cachedInfo.sha512) {\n          logger12.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);\n          await this.cleanCacheDirForPendingUpdate();\n          return null;\n        }\n        const updateFile = path6.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);\n        if (!await (0, fs_extra_1.pathExists)(updateFile)) {\n          logger12.info(\"Cached update file doesn't exist\");\n          return null;\n        }\n        const sha512 = await hashFile(updateFile);\n        if (fileInfo.info.sha512 !== sha512) {\n          logger12.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);\n          await this.cleanCacheDirForPendingUpdate();\n          return null;\n        }\n        this._downloadedFileInfo = cachedInfo;\n        return updateFile;\n      }\n      getUpdateInfoFile() {\n        return path6.join(this.cacheDirForPendingUpdate, \"update-info.json\");\n      }\n    };\n    exports2.DownloadedUpdateHelper = DownloadedUpdateHelper;\n    function hashFile(file, algorithm = \"sha512\", encoding = \"base64\", options) {\n      return new Promise((resolve, reject) => {\n        const hash = (0, crypto_1.createHash)(algorithm);\n        hash.on(\"error\", reject).setEncoding(encoding);\n        (0, fs_1.createReadStream)(file, {\n          ...options,\n          highWaterMark: 1024 * 1024\n          /* better to use more memory but hash faster */\n        }).on(\"error\", reject).on(\"end\", () => {\n          hash.end();\n          resolve(hash.read());\n        }).pipe(hash, { end: false });\n      });\n    }\n    async function createTempUpdateFile(name, cacheDir, log12) {\n      let nameCounter = 0;\n      let result = path6.join(cacheDir, name);\n      for (let i = 0; i < 3; i++) {\n        try {\n          await (0, fs_extra_1.unlink)(result);\n          return result;\n        } catch (e) {\n          if (e.code === \"ENOENT\") {\n            return result;\n          }\n          log12.warn(`Error on remove temp update file: ${e}`);\n          result = path6.join(cacheDir, `${nameCounter++}-${name}`);\n        }\n      }\n      return result;\n    }\n  }\n});\n\n// node_modules/electron-updater/out/AppAdapter.js\nvar require_AppAdapter = __commonJS({\n  \"node_modules/electron-updater/out/AppAdapter.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getAppCacheDir = getAppCacheDir;\n    var path6 = require(\"path\");\n    var os_1 = require(\"os\");\n    function getAppCacheDir() {\n      const homedir = (0, os_1.homedir)();\n      let result;\n      if (process.platform === \"win32\") {\n        result = process.env[\"LOCALAPPDATA\"] || path6.join(homedir, \"AppData\", \"Local\");\n      } else if (process.platform === \"darwin\") {\n        result = path6.join(homedir, \"Library\", \"Caches\");\n      } else {\n        result = process.env[\"XDG_CACHE_HOME\"] || path6.join(homedir, \".cache\");\n      }\n      return result;\n    }\n  }\n});\n\n// node_modules/electron-updater/out/ElectronAppAdapter.js\nvar require_ElectronAppAdapter = __commonJS({\n  \"node_modules/electron-updater/out/ElectronAppAdapter.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.ElectronAppAdapter = void 0;\n    var path6 = require(\"path\");\n    var AppAdapter_1 = require_AppAdapter();\n    var ElectronAppAdapter = class {\n      constructor(app6 = require(\"electron\").app) {\n        this.app = app6;\n      }\n      whenReady() {\n        return this.app.whenReady();\n      }\n      get version() {\n        return this.app.getVersion();\n      }\n      get name() {\n        return this.app.getName();\n      }\n      get isPackaged() {\n        return this.app.isPackaged === true;\n      }\n      get appUpdateConfigPath() {\n        return this.isPackaged ? path6.join(process.resourcesPath, \"app-update.yml\") : path6.join(this.app.getAppPath(), \"dev-app-update.yml\");\n      }\n      get userDataPath() {\n        return this.app.getPath(\"userData\");\n      }\n      get baseCachePath() {\n        return (0, AppAdapter_1.getAppCacheDir)();\n      }\n      quit() {\n        this.app.quit();\n      }\n      relaunch() {\n        this.app.relaunch();\n      }\n      onQuit(handler) {\n        this.app.once(\"quit\", (_, exitCode) => handler(exitCode));\n      }\n    };\n    exports2.ElectronAppAdapter = ElectronAppAdapter;\n  }\n});\n\n// node_modules/electron-updater/out/electronHttpExecutor.js\nvar require_electronHttpExecutor = __commonJS({\n  \"node_modules/electron-updater/out/electronHttpExecutor.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.ElectronHttpExecutor = exports2.NET_SESSION_NAME = void 0;\n    exports2.getNetSession = getNetSession;\n    var builder_util_runtime_1 = require_out();\n    exports2.NET_SESSION_NAME = \"electron-updater\";\n    function getNetSession() {\n      return require(\"electron\").session.fromPartition(exports2.NET_SESSION_NAME, {\n        cache: false\n      });\n    }\n    var ElectronHttpExecutor = class extends builder_util_runtime_1.HttpExecutor {\n      constructor(proxyLoginCallback) {\n        super();\n        this.proxyLoginCallback = proxyLoginCallback;\n        this.cachedSession = null;\n      }\n      async download(url, destination, options) {\n        return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {\n          const requestOptions = {\n            headers: options.headers || void 0,\n            redirect: \"manual\"\n          };\n          (0, builder_util_runtime_1.configureRequestUrl)(url, requestOptions);\n          (0, builder_util_runtime_1.configureRequestOptions)(requestOptions);\n          this.doDownload(requestOptions, {\n            destination,\n            options,\n            onCancel,\n            callback: (error) => {\n              if (error == null) {\n                resolve(destination);\n              } else {\n                reject(error);\n              }\n            },\n            responseHandler: null\n          }, 0);\n        });\n      }\n      createRequest(options, callback) {\n        if (options.headers && options.headers.Host) {\n          options.host = options.headers.Host;\n          delete options.headers.Host;\n        }\n        if (this.cachedSession == null) {\n          this.cachedSession = getNetSession();\n        }\n        const request = require(\"electron\").net.request({\n          ...options,\n          session: this.cachedSession\n        });\n        request.on(\"response\", callback);\n        if (this.proxyLoginCallback != null) {\n          request.on(\"login\", this.proxyLoginCallback);\n        }\n        return request;\n      }\n      addRedirectHandlers(request, options, reject, redirectCount, handler) {\n        request.on(\"redirect\", (statusCode, method, redirectUrl) => {\n          request.abort();\n          if (redirectCount > this.maxRedirects) {\n            reject(this.createMaxRedirectError());\n          } else {\n            handler(builder_util_runtime_1.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));\n          }\n        });\n      }\n    };\n    exports2.ElectronHttpExecutor = ElectronHttpExecutor;\n  }\n});\n\n// node_modules/lodash.escaperegexp/index.js\nvar require_lodash2 = __commonJS({\n  \"node_modules/lodash.escaperegexp/index.js\"(exports2, module2) {\n    var INFINITY = 1 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reHasRegExpChar = RegExp(reRegExpChar.source);\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var Symbol2 = root.Symbol;\n    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;\n    var symbolToString = symbolProto ? symbolProto.toString : void 0;\n    function baseToString(value) {\n      if (typeof value == \"string\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : \"\";\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toString(value) {\n      return value == null ? \"\" : baseToString(value);\n    }\n    function escapeRegExp(string) {\n      string = toString(string);\n      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, \"\\\\$&\") : string;\n    }\n    module2.exports = escapeRegExp;\n  }\n});\n\n// node_modules/electron-updater/out/util.js\nvar require_util = __commonJS({\n  \"node_modules/electron-updater/out/util.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.newBaseUrl = newBaseUrl;\n    exports2.newUrlFromBase = newUrlFromBase;\n    exports2.getChannelFilename = getChannelFilename;\n    exports2.blockmapFiles = blockmapFiles;\n    var url_1 = require(\"url\");\n    var escapeRegExp = require_lodash2();\n    function newBaseUrl(url) {\n      const result = new url_1.URL(url);\n      if (!result.pathname.endsWith(\"/\")) {\n        result.pathname += \"/\";\n      }\n      return result;\n    }\n    function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {\n      const result = new url_1.URL(pathname, baseUrl);\n      const search = baseUrl.search;\n      if (search != null && search.length !== 0) {\n        result.search = search;\n      } else if (addRandomQueryToAvoidCaching) {\n        result.search = `noCache=${Date.now().toString(32)}`;\n      }\n      return result;\n    }\n    function getChannelFilename(channel) {\n      return `${channel}.yml`;\n    }\n    function blockmapFiles(baseUrl, oldVersion, newVersion) {\n      const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);\n      const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), \"g\"), oldVersion)}.blockmap`, baseUrl);\n      return [oldBlockMapUrl, newBlockMapUrl];\n    }\n  }\n});\n\n// node_modules/electron-updater/out/providers/Provider.js\nvar require_Provider = __commonJS({\n  \"node_modules/electron-updater/out/providers/Provider.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.Provider = void 0;\n    exports2.findFile = findFile;\n    exports2.parseUpdateInfo = parseUpdateInfo;\n    exports2.getFileList = getFileList;\n    exports2.resolveFiles = resolveFiles;\n    var builder_util_runtime_1 = require_out();\n    var js_yaml_1 = require_js_yaml();\n    var util_1 = require_util();\n    var Provider = class {\n      constructor(runtimeOptions) {\n        this.runtimeOptions = runtimeOptions;\n        this.requestHeaders = null;\n        this.executor = runtimeOptions.executor;\n      }\n      get isUseMultipleRangeRequest() {\n        return this.runtimeOptions.isUseMultipleRangeRequest !== false;\n      }\n      getChannelFilePrefix() {\n        if (this.runtimeOptions.platform === \"linux\") {\n          const arch = process.env[\"TEST_UPDATER_ARCH\"] || process.arch;\n          const archSuffix = arch === \"x64\" ? \"\" : `-${arch}`;\n          return \"-linux\" + archSuffix;\n        } else {\n          return this.runtimeOptions.platform === \"darwin\" ? \"-mac\" : \"\";\n        }\n      }\n      // due to historical reasons for windows we use channel name without platform specifier\n      getDefaultChannelName() {\n        return this.getCustomChannelName(\"latest\");\n      }\n      getCustomChannelName(channel) {\n        return `${channel}${this.getChannelFilePrefix()}`;\n      }\n      get fileExtraDownloadHeaders() {\n        return null;\n      }\n      setRequestHeaders(value) {\n        this.requestHeaders = value;\n      }\n      /**\n       * Method to perform API request only to resolve update info, but not to download update.\n       */\n      httpRequest(url, headers, cancellationToken) {\n        return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);\n      }\n      createRequestOptions(url, headers) {\n        const result = {};\n        if (this.requestHeaders == null) {\n          if (headers != null) {\n            result.headers = headers;\n          }\n        } else {\n          result.headers = headers == null ? this.requestHeaders : { ...this.requestHeaders, ...headers };\n        }\n        (0, builder_util_runtime_1.configureRequestUrl)(url, result);\n        return result;\n      }\n    };\n    exports2.Provider = Provider;\n    function findFile(files, extension, not) {\n      if (files.length === 0) {\n        throw (0, builder_util_runtime_1.newError)(\"No files provided\", \"ERR_UPDATER_NO_FILES_PROVIDED\");\n      }\n      const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));\n      if (result != null) {\n        return result;\n      } else if (not == null) {\n        return files[0];\n      } else {\n        return files.find((fileInfo) => !not.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));\n      }\n    }\n    function parseUpdateInfo(rawData, channelFile, channelFileUrl) {\n      if (rawData == null) {\n        throw (0, builder_util_runtime_1.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, \"ERR_UPDATER_INVALID_UPDATE_INFO\");\n      }\n      let result;\n      try {\n        result = (0, js_yaml_1.load)(rawData);\n      } catch (e) {\n        throw (0, builder_util_runtime_1.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, \"ERR_UPDATER_INVALID_UPDATE_INFO\");\n      }\n      return result;\n    }\n    function getFileList(updateInfo) {\n      const files = updateInfo.files;\n      if (files != null && files.length > 0) {\n        return files;\n      }\n      if (updateInfo.path != null) {\n        return [\n          {\n            url: updateInfo.path,\n            sha2: updateInfo.sha2,\n            sha512: updateInfo.sha512\n          }\n        ];\n      } else {\n        throw (0, builder_util_runtime_1.newError)(`No files provided: ${(0, builder_util_runtime_1.safeStringifyJson)(updateInfo)}`, \"ERR_UPDATER_NO_FILES_PROVIDED\");\n      }\n    }\n    function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {\n      const files = getFileList(updateInfo);\n      const result = files.map((fileInfo) => {\n        if (fileInfo.sha2 == null && fileInfo.sha512 == null) {\n          throw (0, builder_util_runtime_1.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1.safeStringifyJson)(fileInfo)}`, \"ERR_UPDATER_NO_CHECKSUM\");\n        }\n        return {\n          url: (0, util_1.newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),\n          info: fileInfo\n        };\n      });\n      const packages = updateInfo.packages;\n      const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;\n      if (packageInfo != null) {\n        ;\n        result[0].packageInfo = {\n          ...packageInfo,\n          path: (0, util_1.newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href\n        };\n      }\n      return result;\n    }\n  }\n});\n\n// node_modules/electron-updater/out/providers/GenericProvider.js\nvar require_GenericProvider = __commonJS({\n  \"node_modules/electron-updater/out/providers/GenericProvider.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.GenericProvider = void 0;\n    var builder_util_runtime_1 = require_out();\n    var util_1 = require_util();\n    var Provider_1 = require_Provider();\n    var GenericProvider = class extends Provider_1.Provider {\n      constructor(configuration, updater, runtimeOptions) {\n        super(runtimeOptions);\n        this.configuration = configuration;\n        this.updater = updater;\n        this.baseUrl = (0, util_1.newBaseUrl)(this.configuration.url);\n      }\n      get channel() {\n        const result = this.updater.channel || this.configuration.channel;\n        return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);\n      }\n      async getLatestVersion() {\n        const channelFile = (0, util_1.getChannelFilename)(this.channel);\n        const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);\n        for (let attemptNumber = 0; ; attemptNumber++) {\n          try {\n            return (0, Provider_1.parseUpdateInfo)(await this.httpRequest(channelUrl), channelFile, channelUrl);\n          } catch (e) {\n            if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {\n              throw (0, builder_util_runtime_1.newError)(`Cannot find channel \"${channelFile}\" update info: ${e.stack || e.message}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n            } else if (e.code === \"ECONNREFUSED\") {\n              if (attemptNumber < 3) {\n                await new Promise((resolve, reject) => {\n                  try {\n                    setTimeout(resolve, 1e3 * attemptNumber);\n                  } catch (e2) {\n                    reject(e2);\n                  }\n                });\n                continue;\n              }\n            }\n            throw e;\n          }\n        }\n      }\n      resolveFiles(updateInfo) {\n        return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);\n      }\n    };\n    exports2.GenericProvider = GenericProvider;\n  }\n});\n\n// node_modules/electron-updater/out/providers/BitbucketProvider.js\nvar require_BitbucketProvider = __commonJS({\n  \"node_modules/electron-updater/out/providers/BitbucketProvider.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.BitbucketProvider = void 0;\n    var builder_util_runtime_1 = require_out();\n    var util_1 = require_util();\n    var Provider_1 = require_Provider();\n    var BitbucketProvider = class extends Provider_1.Provider {\n      constructor(configuration, updater, runtimeOptions) {\n        super({\n          ...runtimeOptions,\n          isUseMultipleRangeRequest: false\n        });\n        this.configuration = configuration;\n        this.updater = updater;\n        const { owner, slug } = configuration;\n        this.baseUrl = (0, util_1.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);\n      }\n      get channel() {\n        return this.updater.channel || this.configuration.channel || \"latest\";\n      }\n      async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const channelFile = (0, util_1.getChannelFilename)(this.getCustomChannelName(this.channel));\n        const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);\n        try {\n          const updateInfo = await this.httpRequest(channelUrl, void 0, cancellationToken);\n          return (0, Provider_1.parseUpdateInfo)(updateInfo, channelFile, channelUrl);\n        } catch (e) {\n          throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n      }\n      resolveFiles(updateInfo) {\n        return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);\n      }\n      toString() {\n        const { owner, slug } = this.configuration;\n        return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;\n      }\n    };\n    exports2.BitbucketProvider = BitbucketProvider;\n  }\n});\n\n// node_modules/electron-updater/out/providers/GitHubProvider.js\nvar require_GitHubProvider = __commonJS({\n  \"node_modules/electron-updater/out/providers/GitHubProvider.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.GitHubProvider = exports2.BaseGitHubProvider = void 0;\n    exports2.computeReleaseNotes = computeReleaseNotes;\n    var builder_util_runtime_1 = require_out();\n    var semver = require_semver2();\n    var url_1 = require(\"url\");\n    var util_1 = require_util();\n    var Provider_1 = require_Provider();\n    var hrefRegExp = /\\/tag\\/([^/]+)$/;\n    var BaseGitHubProvider = class extends Provider_1.Provider {\n      constructor(options, defaultHost, runtimeOptions) {\n        super({\n          ...runtimeOptions,\n          /* because GitHib uses S3 */\n          isUseMultipleRangeRequest: false\n        });\n        this.options = options;\n        this.baseUrl = (0, util_1.newBaseUrl)((0, builder_util_runtime_1.githubUrl)(options, defaultHost));\n        const apiHost = defaultHost === \"github.com\" ? \"api.github.com\" : defaultHost;\n        this.baseApiUrl = (0, util_1.newBaseUrl)((0, builder_util_runtime_1.githubUrl)(options, apiHost));\n      }\n      computeGithubBasePath(result) {\n        const host = this.options.host;\n        return host && ![\"github.com\", \"api.github.com\"].includes(host) ? `/api/v3${result}` : result;\n      }\n    };\n    exports2.BaseGitHubProvider = BaseGitHubProvider;\n    var GitHubProvider = class extends BaseGitHubProvider {\n      constructor(options, updater, runtimeOptions) {\n        super(options, \"github.com\", runtimeOptions);\n        this.options = options;\n        this.updater = updater;\n      }\n      get channel() {\n        const result = this.updater.channel || this.options.channel;\n        return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);\n      }\n      async getLatestVersion() {\n        var _a, _b, _c, _d, _e;\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const feedXml = await this.httpRequest((0, util_1.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {\n          accept: \"application/xml, application/atom+xml, text/xml, */*\"\n        }, cancellationToken);\n        const feed = (0, builder_util_runtime_1.parseXml)(feedXml);\n        let latestRelease = feed.element(\"entry\", false, `No published versions on GitHub`);\n        let tag = null;\n        try {\n          if (this.updater.allowPrerelease) {\n            const currentChannel = ((_a = this.updater) === null || _a === void 0 ? void 0 : _a.channel) || ((_b = semver.prerelease(this.updater.currentVersion)) === null || _b === void 0 ? void 0 : _b[0]) || null;\n            if (currentChannel === null) {\n              tag = hrefRegExp.exec(latestRelease.element(\"link\").attribute(\"href\"))[1];\n            } else {\n              for (const element of feed.getElements(\"entry\")) {\n                const hrefElement = hrefRegExp.exec(element.element(\"link\").attribute(\"href\"));\n                if (hrefElement === null)\n                  continue;\n                const hrefTag = hrefElement[1];\n                const hrefChannel = ((_c = semver.prerelease(hrefTag)) === null || _c === void 0 ? void 0 : _c[0]) || null;\n                const shouldFetchVersion = !currentChannel || [\"alpha\", \"beta\"].includes(currentChannel);\n                const isCustomChannel = hrefChannel !== null && ![\"alpha\", \"beta\"].includes(String(hrefChannel));\n                const channelMismatch = currentChannel === \"beta\" && hrefChannel === \"alpha\";\n                if (shouldFetchVersion && !isCustomChannel && !channelMismatch) {\n                  tag = hrefTag;\n                  break;\n                }\n                const isNextPreRelease = hrefChannel && hrefChannel === currentChannel;\n                if (isNextPreRelease) {\n                  tag = hrefTag;\n                  break;\n                }\n              }\n            }\n          } else {\n            tag = await this.getLatestTagName(cancellationToken);\n            for (const element of feed.getElements(\"entry\")) {\n              if (hrefRegExp.exec(element.element(\"link\").attribute(\"href\"))[1] === tag) {\n                latestRelease = element;\n                break;\n              }\n            }\n          }\n        } catch (e) {\n          throw (0, builder_util_runtime_1.newError)(`Cannot parse releases feed: ${e.stack || e.message},\nXML:\n${feedXml}`, \"ERR_UPDATER_INVALID_RELEASE_FEED\");\n        }\n        if (tag == null) {\n          throw (0, builder_util_runtime_1.newError)(`No published versions on GitHub`, \"ERR_UPDATER_NO_PUBLISHED_VERSIONS\");\n        }\n        let rawData;\n        let channelFile = \"\";\n        let channelFileUrl = \"\";\n        const fetchData = async (channelName) => {\n          channelFile = (0, util_1.getChannelFilename)(channelName);\n          channelFileUrl = (0, util_1.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);\n          const requestOptions = this.createRequestOptions(channelFileUrl);\n          try {\n            return await this.executor.request(requestOptions, cancellationToken);\n          } catch (e) {\n            if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {\n              throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n            }\n            throw e;\n          }\n        };\n        try {\n          let channel = this.channel;\n          if (this.updater.allowPrerelease && ((_d = semver.prerelease(tag)) === null || _d === void 0 ? void 0 : _d[0])) {\n            channel = this.getCustomChannelName(String((_e = semver.prerelease(tag)) === null || _e === void 0 ? void 0 : _e[0]));\n          }\n          rawData = await fetchData(channel);\n        } catch (e) {\n          if (this.updater.allowPrerelease) {\n            rawData = await fetchData(this.getDefaultChannelName());\n          } else {\n            throw e;\n          }\n        }\n        const result = (0, Provider_1.parseUpdateInfo)(rawData, channelFile, channelFileUrl);\n        if (result.releaseName == null) {\n          result.releaseName = latestRelease.elementValueOrEmpty(\"title\");\n        }\n        if (result.releaseNotes == null) {\n          result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);\n        }\n        return {\n          tag,\n          ...result\n        };\n      }\n      async getLatestTagName(cancellationToken) {\n        const options = this.options;\n        const url = options.host == null || options.host === \"github.com\" ? (0, util_1.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);\n        try {\n          const rawData = await this.httpRequest(url, { Accept: \"application/json\" }, cancellationToken);\n          if (rawData == null) {\n            return null;\n          }\n          const releaseInfo = JSON.parse(rawData);\n          return releaseInfo.tag_name;\n        } catch (e) {\n          throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n      }\n      get basePath() {\n        return `/${this.options.owner}/${this.options.repo}/releases`;\n      }\n      resolveFiles(updateInfo) {\n        return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, \"-\")));\n      }\n      getBaseDownloadPath(tag, fileName) {\n        return `${this.basePath}/download/${tag}/${fileName}`;\n      }\n    };\n    exports2.GitHubProvider = GitHubProvider;\n    function getNoteValue(parent) {\n      const result = parent.elementValueOrEmpty(\"content\");\n      return result === \"No content.\" ? \"\" : result;\n    }\n    function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {\n      if (!isFullChangelog) {\n        return getNoteValue(latestRelease);\n      }\n      const releaseNotes = [];\n      for (const release of feed.getElements(\"entry\")) {\n        const versionRelease = /\\/tag\\/v?([^/]+)$/.exec(release.element(\"link\").attribute(\"href\"))[1];\n        if (semver.lt(currentVersion, versionRelease)) {\n          releaseNotes.push({\n            version: versionRelease,\n            note: getNoteValue(release)\n          });\n        }\n      }\n      return releaseNotes.sort((a, b) => semver.rcompare(a.version, b.version));\n    }\n  }\n});\n\n// node_modules/electron-updater/out/providers/KeygenProvider.js\nvar require_KeygenProvider = __commonJS({\n  \"node_modules/electron-updater/out/providers/KeygenProvider.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.KeygenProvider = void 0;\n    var builder_util_runtime_1 = require_out();\n    var util_1 = require_util();\n    var Provider_1 = require_Provider();\n    var KeygenProvider = class extends Provider_1.Provider {\n      constructor(configuration, updater, runtimeOptions) {\n        super({\n          ...runtimeOptions,\n          isUseMultipleRangeRequest: false\n        });\n        this.configuration = configuration;\n        this.updater = updater;\n        this.defaultHostname = \"api.keygen.sh\";\n        const host = this.configuration.host || this.defaultHostname;\n        this.baseUrl = (0, util_1.newBaseUrl)(`https://${host}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);\n      }\n      get channel() {\n        return this.updater.channel || this.configuration.channel || \"stable\";\n      }\n      async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const channelFile = (0, util_1.getChannelFilename)(this.getCustomChannelName(this.channel));\n        const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);\n        try {\n          const updateInfo = await this.httpRequest(channelUrl, {\n            Accept: \"application/vnd.api+json\",\n            \"Keygen-Version\": \"1.1\"\n          }, cancellationToken);\n          return (0, Provider_1.parseUpdateInfo)(updateInfo, channelFile, channelUrl);\n        } catch (e) {\n          throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n      }\n      resolveFiles(updateInfo) {\n        return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);\n      }\n      toString() {\n        const { account, product, platform } = this.configuration;\n        return `Keygen (account: ${account}, product: ${product}, platform: ${platform}, channel: ${this.channel})`;\n      }\n    };\n    exports2.KeygenProvider = KeygenProvider;\n  }\n});\n\n// node_modules/electron-updater/out/providers/PrivateGitHubProvider.js\nvar require_PrivateGitHubProvider = __commonJS({\n  \"node_modules/electron-updater/out/providers/PrivateGitHubProvider.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.PrivateGitHubProvider = void 0;\n    var builder_util_runtime_1 = require_out();\n    var js_yaml_1 = require_js_yaml();\n    var path6 = require(\"path\");\n    var url_1 = require(\"url\");\n    var util_1 = require_util();\n    var GitHubProvider_1 = require_GitHubProvider();\n    var Provider_1 = require_Provider();\n    var PrivateGitHubProvider = class extends GitHubProvider_1.BaseGitHubProvider {\n      constructor(options, updater, token, runtimeOptions) {\n        super(options, \"api.github.com\", runtimeOptions);\n        this.updater = updater;\n        this.token = token;\n      }\n      createRequestOptions(url, headers) {\n        const result = super.createRequestOptions(url, headers);\n        result.redirect = \"manual\";\n        return result;\n      }\n      async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const channelFile = (0, util_1.getChannelFilename)(this.getDefaultChannelName());\n        const releaseInfo = await this.getLatestVersionInfo(cancellationToken);\n        const asset = releaseInfo.assets.find((it) => it.name === channelFile);\n        if (asset == null) {\n          throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n        }\n        const url = new url_1.URL(asset.url);\n        let result;\n        try {\n          result = (0, js_yaml_1.load)(await this.httpRequest(url, this.configureHeaders(\"application/octet-stream\"), cancellationToken));\n        } catch (e) {\n          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {\n            throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n          }\n          throw e;\n        }\n        ;\n        result.assets = releaseInfo.assets;\n        return result;\n      }\n      get fileExtraDownloadHeaders() {\n        return this.configureHeaders(\"application/octet-stream\");\n      }\n      configureHeaders(accept) {\n        return {\n          accept,\n          authorization: `token ${this.token}`\n        };\n      }\n      async getLatestVersionInfo(cancellationToken) {\n        const allowPrerelease = this.updater.allowPrerelease;\n        let basePath = this.basePath;\n        if (!allowPrerelease) {\n          basePath = `${basePath}/latest`;\n        }\n        const url = (0, util_1.newUrlFromBase)(basePath, this.baseUrl);\n        try {\n          const version = JSON.parse(await this.httpRequest(url, this.configureHeaders(\"application/vnd.github.v3+json\"), cancellationToken));\n          if (allowPrerelease) {\n            return version.find((it) => it.prerelease) || version[0];\n          } else {\n            return version;\n          }\n        } catch (e) {\n          throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n      }\n      get basePath() {\n        return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);\n      }\n      resolveFiles(updateInfo) {\n        return (0, Provider_1.getFileList)(updateInfo).map((it) => {\n          const name = path6.posix.basename(it.url).replace(/ /g, \"-\");\n          const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);\n          if (asset == null) {\n            throw (0, builder_util_runtime_1.newError)(`Cannot find asset \"${name}\" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, \"ERR_UPDATER_ASSET_NOT_FOUND\");\n          }\n          return {\n            url: new url_1.URL(asset.url),\n            info: it\n          };\n        });\n      }\n    };\n    exports2.PrivateGitHubProvider = PrivateGitHubProvider;\n  }\n});\n\n// node_modules/electron-updater/out/providerFactory.js\nvar require_providerFactory = __commonJS({\n  \"node_modules/electron-updater/out/providerFactory.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;\n    exports2.createClient = createClient;\n    var builder_util_runtime_1 = require_out();\n    var BitbucketProvider_1 = require_BitbucketProvider();\n    var GenericProvider_1 = require_GenericProvider();\n    var GitHubProvider_1 = require_GitHubProvider();\n    var KeygenProvider_1 = require_KeygenProvider();\n    var PrivateGitHubProvider_1 = require_PrivateGitHubProvider();\n    function isUrlProbablySupportMultiRangeRequests(url) {\n      return !url.includes(\"s3.amazonaws.com\");\n    }\n    function createClient(data, updater, runtimeOptions) {\n      if (typeof data === \"string\") {\n        throw (0, builder_util_runtime_1.newError)(\"Please pass PublishConfiguration object\", \"ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION\");\n      }\n      const provider = data.provider;\n      switch (provider) {\n        case \"github\": {\n          const githubOptions = data;\n          const token = (githubOptions.private ? process.env[\"GH_TOKEN\"] || process.env[\"GITHUB_TOKEN\"] : null) || githubOptions.token;\n          if (token == null) {\n            return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);\n          } else {\n            return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);\n          }\n        }\n        case \"bitbucket\":\n          return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);\n        case \"keygen\":\n          return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);\n        case \"s3\":\n        case \"spaces\":\n          return new GenericProvider_1.GenericProvider({\n            provider: \"generic\",\n            url: (0, builder_util_runtime_1.getS3LikeProviderBaseUrl)(data),\n            channel: data.channel || null\n          }, updater, {\n            ...runtimeOptions,\n            // https://github.com/minio/minio/issues/5285#issuecomment-350428955\n            isUseMultipleRangeRequest: false\n          });\n        case \"generic\": {\n          const options = data;\n          return new GenericProvider_1.GenericProvider(options, updater, {\n            ...runtimeOptions,\n            isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)\n          });\n        }\n        case \"custom\": {\n          const options = data;\n          const constructor = options.updateProvider;\n          if (!constructor) {\n            throw (0, builder_util_runtime_1.newError)(\"Custom provider not specified\", \"ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION\");\n          }\n          return new constructor(options, updater, runtimeOptions);\n        }\n        default:\n          throw (0, builder_util_runtime_1.newError)(`Unsupported provider: ${provider}`, \"ERR_UPDATER_UNSUPPORTED_PROVIDER\");\n      }\n    }\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/downloadPlanBuilder.js\nvar require_downloadPlanBuilder = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/downloadPlanBuilder.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.OperationKind = void 0;\n    exports2.computeOperations = computeOperations;\n    var OperationKind;\n    (function(OperationKind2) {\n      OperationKind2[OperationKind2[\"COPY\"] = 0] = \"COPY\";\n      OperationKind2[OperationKind2[\"DOWNLOAD\"] = 1] = \"DOWNLOAD\";\n    })(OperationKind || (exports2.OperationKind = OperationKind = {}));\n    function computeOperations(oldBlockMap, newBlockMap, logger12) {\n      const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);\n      const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);\n      let lastOperation = null;\n      const blockMapFile = newBlockMap.files[0];\n      const operations = [];\n      const name = blockMapFile.name;\n      const oldEntry = nameToOldBlocks.get(name);\n      if (oldEntry == null) {\n        throw new Error(`no file ${name} in old blockmap`);\n      }\n      const newFile = nameToNewBlocks.get(name);\n      let changedBlockCount = 0;\n      const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger12);\n      let newOffset = blockMapFile.offset;\n      for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {\n        const blockSize = newFile.sizes[i];\n        const checksum = newFile.checksums[i];\n        let oldOffset = checksumToOldOffset.get(checksum);\n        if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {\n          logger12.warn(`Checksum (\"${checksum}\") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);\n          oldOffset = void 0;\n        }\n        if (oldOffset === void 0) {\n          changedBlockCount++;\n          if (lastOperation != null && lastOperation.kind === OperationKind.DOWNLOAD && lastOperation.end === newOffset) {\n            lastOperation.end += blockSize;\n          } else {\n            lastOperation = {\n              kind: OperationKind.DOWNLOAD,\n              start: newOffset,\n              end: newOffset + blockSize\n              // oldBlocks: null,\n            };\n            validateAndAdd(lastOperation, operations, checksum, i);\n          }\n        } else {\n          if (lastOperation != null && lastOperation.kind === OperationKind.COPY && lastOperation.end === oldOffset) {\n            lastOperation.end += blockSize;\n          } else {\n            lastOperation = {\n              kind: OperationKind.COPY,\n              start: oldOffset,\n              end: oldOffset + blockSize\n              // oldBlocks: [checksum]\n            };\n            validateAndAdd(lastOperation, operations, checksum, i);\n          }\n        }\n      }\n      if (changedBlockCount > 0) {\n        logger12.info(`File${blockMapFile.name === \"file\" ? \"\" : \" \" + blockMapFile.name} has ${changedBlockCount} changed blocks`);\n      }\n      return operations;\n    }\n    var isValidateOperationRange = process.env[\"DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES\"] === \"true\";\n    function validateAndAdd(operation, operations, checksum, index) {\n      if (isValidateOperationRange && operations.length !== 0) {\n        const lastOperation = operations[operations.length - 1];\n        if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {\n          const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);\n          throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind[operation.kind]}) overlaps previous operation (checksum: ${checksum}):\nabs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}\nrel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);\n        }\n      }\n      operations.push(operation);\n    }\n    function buildChecksumMap(file, fileOffset, logger12) {\n      const checksumToOffset = /* @__PURE__ */ new Map();\n      const checksumToSize = /* @__PURE__ */ new Map();\n      let offset = fileOffset;\n      for (let i = 0; i < file.checksums.length; i++) {\n        const checksum = file.checksums[i];\n        const size = file.sizes[i];\n        const existing = checksumToSize.get(checksum);\n        if (existing === void 0) {\n          checksumToOffset.set(checksum, offset);\n          checksumToSize.set(checksum, size);\n        } else if (logger12.debug != null) {\n          const sizeExplanation = existing === size ? \"(same size)\" : `(size: ${existing}, this size: ${size})`;\n          logger12.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);\n        }\n        offset += size;\n      }\n      return { checksumToOffset, checksumToOldSize: checksumToSize };\n    }\n    function buildBlockFileMap(list) {\n      const result = /* @__PURE__ */ new Map();\n      for (const item of list) {\n        result.set(item.name, item);\n      }\n      return result;\n    }\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/DataSplitter.js\nvar require_DataSplitter = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/DataSplitter.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DataSplitter = void 0;\n    exports2.copyData = copyData;\n    var builder_util_runtime_1 = require_out();\n    var fs_1 = require(\"fs\");\n    var stream_1 = require(\"stream\");\n    var downloadPlanBuilder_1 = require_downloadPlanBuilder();\n    var DOUBLE_CRLF = Buffer.from(\"\\r\\n\\r\\n\");\n    var ReadState;\n    (function(ReadState2) {\n      ReadState2[ReadState2[\"INIT\"] = 0] = \"INIT\";\n      ReadState2[ReadState2[\"HEADER\"] = 1] = \"HEADER\";\n      ReadState2[ReadState2[\"BODY\"] = 2] = \"BODY\";\n    })(ReadState || (ReadState = {}));\n    function copyData(task, out, oldFileFd, reject, resolve) {\n      const readStream = (0, fs_1.createReadStream)(\"\", {\n        fd: oldFileFd,\n        autoClose: false,\n        start: task.start,\n        // end is inclusive\n        end: task.end - 1\n      });\n      readStream.on(\"error\", reject);\n      readStream.once(\"end\", resolve);\n      readStream.pipe(out, {\n        end: false\n      });\n    }\n    var DataSplitter = class extends stream_1.Writable {\n      constructor(out, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {\n        super();\n        this.out = out;\n        this.options = options;\n        this.partIndexToTaskIndex = partIndexToTaskIndex;\n        this.partIndexToLength = partIndexToLength;\n        this.finishHandler = finishHandler;\n        this.partIndex = -1;\n        this.headerListBuffer = null;\n        this.readState = ReadState.INIT;\n        this.ignoreByteCount = 0;\n        this.remainingPartDataCount = 0;\n        this.actualPartLength = 0;\n        this.boundaryLength = boundary.length + 4;\n        this.ignoreByteCount = this.boundaryLength - 2;\n      }\n      get isFinished() {\n        return this.partIndex === this.partIndexToLength.length;\n      }\n      // noinspection JSUnusedGlobalSymbols\n      _write(data, encoding, callback) {\n        if (this.isFinished) {\n          console.error(`Trailing ignored data: ${data.length} bytes`);\n          return;\n        }\n        this.handleData(data).then(callback).catch(callback);\n      }\n      async handleData(chunk) {\n        let start = 0;\n        if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {\n          throw (0, builder_util_runtime_1.newError)(\"Internal error\", \"ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH\");\n        }\n        if (this.ignoreByteCount > 0) {\n          const toIgnore = Math.min(this.ignoreByteCount, chunk.length);\n          this.ignoreByteCount -= toIgnore;\n          start = toIgnore;\n        } else if (this.remainingPartDataCount > 0) {\n          const toRead = Math.min(this.remainingPartDataCount, chunk.length);\n          this.remainingPartDataCount -= toRead;\n          await this.processPartData(chunk, 0, toRead);\n          start = toRead;\n        }\n        if (start === chunk.length) {\n          return;\n        }\n        if (this.readState === ReadState.HEADER) {\n          const headerListEnd = this.searchHeaderListEnd(chunk, start);\n          if (headerListEnd === -1) {\n            return;\n          }\n          start = headerListEnd;\n          this.readState = ReadState.BODY;\n          this.headerListBuffer = null;\n        }\n        while (true) {\n          if (this.readState === ReadState.BODY) {\n            this.readState = ReadState.INIT;\n          } else {\n            this.partIndex++;\n            let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);\n            if (taskIndex == null) {\n              if (this.isFinished) {\n                taskIndex = this.options.end;\n              } else {\n                throw (0, builder_util_runtime_1.newError)(\"taskIndex is null\", \"ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL\");\n              }\n            }\n            const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;\n            if (prevTaskIndex < taskIndex) {\n              await this.copyExistingData(prevTaskIndex, taskIndex);\n            } else if (prevTaskIndex > taskIndex) {\n              throw (0, builder_util_runtime_1.newError)(\"prevTaskIndex must be < taskIndex\", \"ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED\");\n            }\n            if (this.isFinished) {\n              this.onPartEnd();\n              this.finishHandler();\n              return;\n            }\n            start = this.searchHeaderListEnd(chunk, start);\n            if (start === -1) {\n              this.readState = ReadState.HEADER;\n              return;\n            }\n          }\n          const partLength = this.partIndexToLength[this.partIndex];\n          const end = start + partLength;\n          const effectiveEnd = Math.min(end, chunk.length);\n          await this.processPartStarted(chunk, start, effectiveEnd);\n          this.remainingPartDataCount = partLength - (effectiveEnd - start);\n          if (this.remainingPartDataCount > 0) {\n            return;\n          }\n          start = end + this.boundaryLength;\n          if (start >= chunk.length) {\n            this.ignoreByteCount = this.boundaryLength - (chunk.length - end);\n            return;\n          }\n        }\n      }\n      copyExistingData(index, end) {\n        return new Promise((resolve, reject) => {\n          const w = () => {\n            if (index === end) {\n              resolve();\n              return;\n            }\n            const task = this.options.tasks[index];\n            if (task.kind !== downloadPlanBuilder_1.OperationKind.COPY) {\n              reject(new Error(\"Task kind must be COPY\"));\n              return;\n            }\n            copyData(task, this.out, this.options.oldFileFd, reject, () => {\n              index++;\n              w();\n            });\n          };\n          w();\n        });\n      }\n      searchHeaderListEnd(chunk, readOffset) {\n        const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);\n        if (headerListEnd !== -1) {\n          return headerListEnd + DOUBLE_CRLF.length;\n        }\n        const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);\n        if (this.headerListBuffer == null) {\n          this.headerListBuffer = partialChunk;\n        } else {\n          this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);\n        }\n        return -1;\n      }\n      onPartEnd() {\n        const expectedLength = this.partIndexToLength[this.partIndex - 1];\n        if (this.actualPartLength !== expectedLength) {\n          throw (0, builder_util_runtime_1.newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, \"ERR_DATA_SPLITTER_LENGTH_MISMATCH\");\n        }\n        this.actualPartLength = 0;\n      }\n      processPartStarted(data, start, end) {\n        if (this.partIndex !== 0) {\n          this.onPartEnd();\n        }\n        return this.processPartData(data, start, end);\n      }\n      processPartData(data, start, end) {\n        this.actualPartLength += end - start;\n        const out = this.out;\n        if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {\n          return Promise.resolve();\n        } else {\n          return new Promise((resolve, reject) => {\n            out.on(\"error\", reject);\n            out.once(\"drain\", () => {\n              out.removeListener(\"error\", reject);\n              resolve();\n            });\n          });\n        }\n      }\n    };\n    exports2.DataSplitter = DataSplitter;\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/multipleRangeDownloader.js\nvar require_multipleRangeDownloader = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/multipleRangeDownloader.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;\n    exports2.checkIsRangesSupported = checkIsRangesSupported;\n    var builder_util_runtime_1 = require_out();\n    var DataSplitter_1 = require_DataSplitter();\n    var downloadPlanBuilder_1 = require_downloadPlanBuilder();\n    function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out, oldFileFd, reject) {\n      const w = (taskOffset) => {\n        if (taskOffset >= tasks.length) {\n          if (differentialDownloader.fileMetadataBuffer != null) {\n            out.write(differentialDownloader.fileMetadataBuffer);\n          }\n          out.end();\n          return;\n        }\n        const nextOffset = taskOffset + 1e3;\n        doExecuteTasks(differentialDownloader, {\n          tasks,\n          start: taskOffset,\n          end: Math.min(tasks.length, nextOffset),\n          oldFileFd\n        }, out, () => w(nextOffset), reject);\n      };\n      return w;\n    }\n    function doExecuteTasks(differentialDownloader, options, out, resolve, reject) {\n      let ranges = \"bytes=\";\n      let partCount = 0;\n      const partIndexToTaskIndex = /* @__PURE__ */ new Map();\n      const partIndexToLength = [];\n      for (let i = options.start; i < options.end; i++) {\n        const task = options.tasks[i];\n        if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {\n          ranges += `${task.start}-${task.end - 1}, `;\n          partIndexToTaskIndex.set(partCount, i);\n          partCount++;\n          partIndexToLength.push(task.end - task.start);\n        }\n      }\n      if (partCount <= 1) {\n        const w = (index) => {\n          if (index >= options.end) {\n            resolve();\n            return;\n          }\n          const task = options.tasks[index++];\n          if (task.kind === downloadPlanBuilder_1.OperationKind.COPY) {\n            (0, DataSplitter_1.copyData)(task, out, options.oldFileFd, reject, () => w(index));\n          } else {\n            const requestOptions2 = differentialDownloader.createRequestOptions();\n            requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;\n            const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {\n              if (!checkIsRangesSupported(response, reject)) {\n                return;\n              }\n              response.pipe(out, {\n                end: false\n              });\n              response.once(\"end\", () => w(index));\n            });\n            differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);\n            request2.end();\n          }\n        };\n        w(options.start);\n        return;\n      }\n      const requestOptions = differentialDownloader.createRequestOptions();\n      requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);\n      const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {\n        if (!checkIsRangesSupported(response, reject)) {\n          return;\n        }\n        const contentType = (0, builder_util_runtime_1.safeGetHeader)(response, \"content-type\");\n        const m = /^multipart\\/.+?(?:; boundary=(?:(?:\"(.+)\")|(?:([^\\s]+))))$/i.exec(contentType);\n        if (m == null) {\n          reject(new Error(`Content-Type \"multipart/byteranges\" is expected, but got \"${contentType}\"`));\n          return;\n        }\n        const dicer = new DataSplitter_1.DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);\n        dicer.on(\"error\", reject);\n        response.pipe(dicer);\n        response.on(\"end\", () => {\n          setTimeout(() => {\n            request.abort();\n            reject(new Error(\"Response ends without calling any handlers\"));\n          }, 1e4);\n        });\n      });\n      differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n      request.end();\n    }\n    function checkIsRangesSupported(response, reject) {\n      if (response.statusCode >= 400) {\n        reject((0, builder_util_runtime_1.createHttpError)(response));\n        return false;\n      }\n      if (response.statusCode !== 206) {\n        const acceptRanges = (0, builder_util_runtime_1.safeGetHeader)(response, \"accept-ranges\");\n        if (acceptRanges == null || acceptRanges === \"none\") {\n          reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/ProgressDifferentialDownloadCallbackTransform.js\nvar require_ProgressDifferentialDownloadCallbackTransform = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/ProgressDifferentialDownloadCallbackTransform.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.ProgressDifferentialDownloadCallbackTransform = void 0;\n    var stream_1 = require(\"stream\");\n    var OperationKind;\n    (function(OperationKind2) {\n      OperationKind2[OperationKind2[\"COPY\"] = 0] = \"COPY\";\n      OperationKind2[OperationKind2[\"DOWNLOAD\"] = 1] = \"DOWNLOAD\";\n    })(OperationKind || (OperationKind = {}));\n    var ProgressDifferentialDownloadCallbackTransform = class extends stream_1.Transform {\n      constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {\n        super();\n        this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;\n        this.cancellationToken = cancellationToken;\n        this.onProgress = onProgress;\n        this.start = Date.now();\n        this.transferred = 0;\n        this.delta = 0;\n        this.expectedBytes = 0;\n        this.index = 0;\n        this.operationType = OperationKind.COPY;\n        this.nextUpdate = this.start + 1e3;\n      }\n      _transform(chunk, encoding, callback) {\n        if (this.cancellationToken.cancelled) {\n          callback(new Error(\"cancelled\"), null);\n          return;\n        }\n        if (this.operationType == OperationKind.COPY) {\n          callback(null, chunk);\n          return;\n        }\n        this.transferred += chunk.length;\n        this.delta += chunk.length;\n        const now = Date.now();\n        if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {\n          this.nextUpdate = now + 1e3;\n          this.onProgress({\n            total: this.progressDifferentialDownloadInfo.grandTotal,\n            delta: this.delta,\n            transferred: this.transferred,\n            percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,\n            bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))\n          });\n          this.delta = 0;\n        }\n        callback(null, chunk);\n      }\n      beginFileCopy() {\n        this.operationType = OperationKind.COPY;\n      }\n      beginRangeDownload() {\n        this.operationType = OperationKind.DOWNLOAD;\n        this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];\n      }\n      endRangeDownload() {\n        if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {\n          this.onProgress({\n            total: this.progressDifferentialDownloadInfo.grandTotal,\n            delta: this.delta,\n            transferred: this.transferred,\n            percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,\n            bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))\n          });\n        }\n      }\n      // Called when we are 100% done with the connection/download\n      _flush(callback) {\n        if (this.cancellationToken.cancelled) {\n          callback(new Error(\"cancelled\"));\n          return;\n        }\n        this.onProgress({\n          total: this.progressDifferentialDownloadInfo.grandTotal,\n          delta: this.delta,\n          transferred: this.transferred,\n          percent: 100,\n          bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))\n        });\n        this.delta = 0;\n        this.transferred = 0;\n        callback(null);\n      }\n    };\n    exports2.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/DifferentialDownloader.js\nvar require_DifferentialDownloader = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/DifferentialDownloader.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DifferentialDownloader = void 0;\n    var builder_util_runtime_1 = require_out();\n    var fs_extra_1 = require_lib();\n    var fs_1 = require(\"fs\");\n    var DataSplitter_1 = require_DataSplitter();\n    var url_1 = require(\"url\");\n    var downloadPlanBuilder_1 = require_downloadPlanBuilder();\n    var multipleRangeDownloader_1 = require_multipleRangeDownloader();\n    var ProgressDifferentialDownloadCallbackTransform_1 = require_ProgressDifferentialDownloadCallbackTransform();\n    var DifferentialDownloader = class {\n      // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n      constructor(blockAwareFileInfo, httpExecutor, options) {\n        this.blockAwareFileInfo = blockAwareFileInfo;\n        this.httpExecutor = httpExecutor;\n        this.options = options;\n        this.fileMetadataBuffer = null;\n        this.logger = options.logger;\n      }\n      createRequestOptions() {\n        const result = {\n          headers: {\n            ...this.options.requestHeaders,\n            accept: \"*/*\"\n          }\n        };\n        (0, builder_util_runtime_1.configureRequestUrl)(this.options.newUrl, result);\n        (0, builder_util_runtime_1.configureRequestOptions)(result);\n        return result;\n      }\n      doDownload(oldBlockMap, newBlockMap) {\n        if (oldBlockMap.version !== newBlockMap.version) {\n          throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);\n        }\n        const logger12 = this.logger;\n        const operations = (0, downloadPlanBuilder_1.computeOperations)(oldBlockMap, newBlockMap, logger12);\n        if (logger12.debug != null) {\n          logger12.debug(JSON.stringify(operations, null, 2));\n        }\n        let downloadSize = 0;\n        let copySize = 0;\n        for (const operation of operations) {\n          const length = operation.end - operation.start;\n          if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {\n            downloadSize += length;\n          } else {\n            copySize += length;\n          }\n        }\n        const newSize = this.blockAwareFileInfo.size;\n        if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {\n          throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);\n        }\n        logger12.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);\n        return this.downloadFile(operations);\n      }\n      downloadFile(tasks) {\n        const fdList = [];\n        const closeFiles = () => {\n          return Promise.all(fdList.map((openedFile) => {\n            return (0, fs_extra_1.close)(openedFile.descriptor).catch((e) => {\n              this.logger.error(`cannot close file \"${openedFile.path}\": ${e}`);\n            });\n          }));\n        };\n        return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {\n          return closeFiles().catch((closeFilesError) => {\n            try {\n              this.logger.error(`cannot close files: ${closeFilesError}`);\n            } catch (errorOnLog) {\n              try {\n                console.error(errorOnLog);\n              } catch (_ignored) {\n              }\n            }\n            throw e;\n          }).then(() => {\n            throw e;\n          });\n        });\n      }\n      async doDownloadFile(tasks, fdList) {\n        const oldFileFd = await (0, fs_extra_1.open)(this.options.oldFile, \"r\");\n        fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });\n        const newFileFd = await (0, fs_extra_1.open)(this.options.newFile, \"w\");\n        fdList.push({ descriptor: newFileFd, path: this.options.newFile });\n        const fileOut = (0, fs_1.createWriteStream)(this.options.newFile, { fd: newFileFd });\n        await new Promise((resolve, reject) => {\n          const streams = [];\n          let downloadInfoTransform = void 0;\n          if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {\n            const expectedByteCounts = [];\n            let grandTotalBytes = 0;\n            for (const task of tasks) {\n              if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {\n                expectedByteCounts.push(task.end - task.start);\n                grandTotalBytes += task.end - task.start;\n              }\n            }\n            const progressDifferentialDownloadInfo = {\n              expectedByteCounts,\n              grandTotal: grandTotalBytes\n            };\n            downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);\n            streams.push(downloadInfoTransform);\n          }\n          const digestTransform = new builder_util_runtime_1.DigestTransform(this.blockAwareFileInfo.sha512);\n          digestTransform.isValidateOnEnd = false;\n          streams.push(digestTransform);\n          fileOut.on(\"finish\", () => {\n            ;\n            fileOut.close(() => {\n              fdList.splice(1, 1);\n              try {\n                digestTransform.validate();\n              } catch (e) {\n                reject(e);\n                return;\n              }\n              resolve(void 0);\n            });\n          });\n          streams.push(fileOut);\n          let lastStream = null;\n          for (const stream of streams) {\n            stream.on(\"error\", reject);\n            if (lastStream == null) {\n              lastStream = stream;\n            } else {\n              lastStream = lastStream.pipe(stream);\n            }\n          }\n          const firstStream = streams[0];\n          let w;\n          if (this.options.isUseMultipleRangeRequest) {\n            w = (0, multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests)(this, tasks, firstStream, oldFileFd, reject);\n            w(0);\n            return;\n          }\n          let downloadOperationCount = 0;\n          let actualUrl = null;\n          this.logger.info(`Differential download: ${this.options.newUrl}`);\n          const requestOptions = this.createRequestOptions();\n          requestOptions.redirect = \"manual\";\n          w = (index) => {\n            var _a, _b;\n            if (index >= tasks.length) {\n              if (this.fileMetadataBuffer != null) {\n                firstStream.write(this.fileMetadataBuffer);\n              }\n              firstStream.end();\n              return;\n            }\n            const operation = tasks[index++];\n            if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {\n              if (downloadInfoTransform) {\n                downloadInfoTransform.beginFileCopy();\n              }\n              (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w(index));\n              return;\n            }\n            const range = `bytes=${operation.start}-${operation.end - 1}`;\n            requestOptions.headers.range = range;\n            (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range}`);\n            if (downloadInfoTransform) {\n              downloadInfoTransform.beginRangeDownload();\n            }\n            const request = this.httpExecutor.createRequest(requestOptions, (response) => {\n              response.on(\"error\", reject);\n              response.on(\"aborted\", () => {\n                reject(new Error(\"response has been aborted by the server\"));\n              });\n              if (response.statusCode >= 400) {\n                reject((0, builder_util_runtime_1.createHttpError)(response));\n              }\n              response.pipe(firstStream, {\n                end: false\n              });\n              response.once(\"end\", () => {\n                if (downloadInfoTransform) {\n                  downloadInfoTransform.endRangeDownload();\n                }\n                if (++downloadOperationCount === 100) {\n                  downloadOperationCount = 0;\n                  setTimeout(() => w(index), 1e3);\n                } else {\n                  w(index);\n                }\n              });\n            });\n            request.on(\"redirect\", (statusCode, method, redirectUrl) => {\n              this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);\n              actualUrl = redirectUrl;\n              (0, builder_util_runtime_1.configureRequestUrl)(new url_1.URL(actualUrl), requestOptions);\n              request.followRedirect();\n            });\n            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n            request.end();\n          };\n          w(0);\n        });\n      }\n      async readRemoteBytes(start, endInclusive) {\n        const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);\n        const requestOptions = this.createRequestOptions();\n        requestOptions.headers.range = `bytes=${start}-${endInclusive}`;\n        let position = 0;\n        await this.request(requestOptions, (chunk) => {\n          chunk.copy(buffer, position);\n          position += chunk.length;\n        });\n        if (position !== buffer.length) {\n          throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);\n        }\n        return buffer;\n      }\n      request(requestOptions, dataHandler) {\n        return new Promise((resolve, reject) => {\n          const request = this.httpExecutor.createRequest(requestOptions, (response) => {\n            if (!(0, multipleRangeDownloader_1.checkIsRangesSupported)(response, reject)) {\n              return;\n            }\n            response.on(\"error\", reject);\n            response.on(\"aborted\", () => {\n              reject(new Error(\"response has been aborted by the server\"));\n            });\n            response.on(\"data\", dataHandler);\n            response.on(\"end\", () => resolve());\n          });\n          this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n          request.end();\n        });\n      }\n    };\n    exports2.DifferentialDownloader = DifferentialDownloader;\n    function formatBytes(value, symbol = \" KB\") {\n      return new Intl.NumberFormat(\"en\").format((value / 1024).toFixed(2)) + symbol;\n    }\n    function removeQuery(url) {\n      const index = url.indexOf(\"?\");\n      return index < 0 ? url : url.substring(0, index);\n    }\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/GenericDifferentialDownloader.js\nvar require_GenericDifferentialDownloader = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/GenericDifferentialDownloader.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.GenericDifferentialDownloader = void 0;\n    var DifferentialDownloader_1 = require_DifferentialDownloader();\n    var GenericDifferentialDownloader = class extends DifferentialDownloader_1.DifferentialDownloader {\n      download(oldBlockMap, newBlockMap) {\n        return this.doDownload(oldBlockMap, newBlockMap);\n      }\n    };\n    exports2.GenericDifferentialDownloader = GenericDifferentialDownloader;\n  }\n});\n\n// node_modules/electron-updater/out/types.js\nvar require_types = __commonJS({\n  \"node_modules/electron-updater/out/types.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.UpdaterSignal = exports2.UPDATE_DOWNLOADED = exports2.DOWNLOAD_PROGRESS = exports2.CancellationToken = void 0;\n    exports2.addHandler = addHandler;\n    var builder_util_runtime_1 = require_out();\n    Object.defineProperty(exports2, \"CancellationToken\", { enumerable: true, get: function() {\n      return builder_util_runtime_1.CancellationToken;\n    } });\n    exports2.DOWNLOAD_PROGRESS = \"download-progress\";\n    exports2.UPDATE_DOWNLOADED = \"update-downloaded\";\n    var UpdaterSignal = class {\n      constructor(emitter) {\n        this.emitter = emitter;\n      }\n      /**\n       * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).\n       */\n      login(handler) {\n        addHandler(this.emitter, \"login\", handler);\n      }\n      progress(handler) {\n        addHandler(this.emitter, exports2.DOWNLOAD_PROGRESS, handler);\n      }\n      updateDownloaded(handler) {\n        addHandler(this.emitter, exports2.UPDATE_DOWNLOADED, handler);\n      }\n      updateCancelled(handler) {\n        addHandler(this.emitter, \"update-cancelled\", handler);\n      }\n    };\n    exports2.UpdaterSignal = UpdaterSignal;\n    var isLogEvent = false;\n    function addHandler(emitter, event, handler) {\n      if (isLogEvent) {\n        emitter.on(event, (...args) => {\n          console.log(\"%s %s\", event, args);\n          handler(...args);\n        });\n      } else {\n        emitter.on(event, handler);\n      }\n    }\n  }\n});\n\n// node_modules/electron-updater/out/AppUpdater.js\nvar require_AppUpdater = __commonJS({\n  \"node_modules/electron-updater/out/AppUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.NoOpLogger = exports2.AppUpdater = void 0;\n    var builder_util_runtime_1 = require_out();\n    var crypto_1 = require(\"crypto\");\n    var os_1 = require(\"os\");\n    var events_1 = require(\"events\");\n    var fs_extra_1 = require_lib();\n    var js_yaml_1 = require_js_yaml();\n    var lazy_val_1 = require_main();\n    var path6 = require(\"path\");\n    var semver_1 = require_semver2();\n    var DownloadedUpdateHelper_1 = require_DownloadedUpdateHelper();\n    var ElectronAppAdapter_1 = require_ElectronAppAdapter();\n    var electronHttpExecutor_1 = require_electronHttpExecutor();\n    var GenericProvider_1 = require_GenericProvider();\n    var providerFactory_1 = require_providerFactory();\n    var zlib_1 = require(\"zlib\");\n    var util_1 = require_util();\n    var GenericDifferentialDownloader_1 = require_GenericDifferentialDownloader();\n    var types_1 = require_types();\n    var AppUpdater = class _AppUpdater extends events_1.EventEmitter {\n      /**\n       * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.\n       */\n      get channel() {\n        return this._channel;\n      }\n      /**\n       * Set the update channel. Overrides `channel` in the update configuration.\n       *\n       * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.\n       */\n      set channel(value) {\n        if (this._channel != null) {\n          if (typeof value !== \"string\") {\n            throw (0, builder_util_runtime_1.newError)(`Channel must be a string, but got: ${value}`, \"ERR_UPDATER_INVALID_CHANNEL\");\n          } else if (value.length === 0) {\n            throw (0, builder_util_runtime_1.newError)(`Channel must be not an empty string`, \"ERR_UPDATER_INVALID_CHANNEL\");\n          }\n        }\n        this._channel = value;\n        this.allowDowngrade = true;\n      }\n      /**\n       *  Shortcut for explicitly adding auth tokens to request headers\n       */\n      addAuthHeader(token) {\n        this.requestHeaders = Object.assign({}, this.requestHeaders, {\n          authorization: token\n        });\n      }\n      // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols\n      get netSession() {\n        return (0, electronHttpExecutor_1.getNetSession)();\n      }\n      /**\n       * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.\n       * Set it to `null` if you would like to disable a logging feature.\n       */\n      get logger() {\n        return this._logger;\n      }\n      set logger(value) {\n        this._logger = value == null ? new NoOpLogger() : value;\n      }\n      // noinspection JSUnusedGlobalSymbols\n      /**\n       * test only\n       * @private\n       */\n      set updateConfigPath(value) {\n        this.clientPromise = null;\n        this._appUpdateConfigPath = value;\n        this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());\n      }\n      /**\n       * Allows developer to override default logic for determining if an update is supported.\n       * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package\n       */\n      get isUpdateSupported() {\n        return this._isUpdateSupported;\n      }\n      set isUpdateSupported(value) {\n        if (value) {\n          this._isUpdateSupported = value;\n        }\n      }\n      constructor(options, app6) {\n        super();\n        this.autoDownload = true;\n        this.autoInstallOnAppQuit = true;\n        this.autoRunAppAfterInstall = true;\n        this.allowPrerelease = false;\n        this.fullChangelog = false;\n        this.allowDowngrade = false;\n        this.disableWebInstaller = false;\n        this.disableDifferentialDownload = false;\n        this.forceDevUpdateConfig = false;\n        this._channel = null;\n        this.downloadedUpdateHelper = null;\n        this.requestHeaders = null;\n        this._logger = console;\n        this.signals = new types_1.UpdaterSignal(this);\n        this._appUpdateConfigPath = null;\n        this._isUpdateSupported = (updateInfo) => this.checkIfUpdateSupported(updateInfo);\n        this.clientPromise = null;\n        this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());\n        this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());\n        this.checkForUpdatesPromise = null;\n        this.downloadPromise = null;\n        this.updateInfoAndProvider = null;\n        this._testOnlyOptions = null;\n        this.on(\"error\", (error) => {\n          this._logger.error(`Error: ${error.stack || error.message}`);\n        });\n        if (app6 == null) {\n          this.app = new ElectronAppAdapter_1.ElectronAppAdapter();\n          this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit(\"login\", authInfo, callback));\n        } else {\n          this.app = app6;\n          this.httpExecutor = null;\n        }\n        const currentVersionString = this.app.version;\n        const currentVersion = (0, semver_1.parse)(currentVersionString);\n        if (currentVersion == null) {\n          throw (0, builder_util_runtime_1.newError)(`App version is not a valid semver version: \"${currentVersionString}\"`, \"ERR_UPDATER_INVALID_VERSION\");\n        }\n        this.currentVersion = currentVersion;\n        this.allowPrerelease = hasPrereleaseComponents(currentVersion);\n        if (options != null) {\n          this.setFeedURL(options);\n          if (typeof options !== \"string\" && options.requestHeaders) {\n            this.requestHeaders = options.requestHeaders;\n          }\n        }\n      }\n      //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols\n      getFeedURL() {\n        return \"Deprecated. Do not use it.\";\n      }\n      /**\n       * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.\n       * @param options If you want to override configuration in the `app-update.yml`.\n       */\n      setFeedURL(options) {\n        const runtimeOptions = this.createProviderRuntimeOptions();\n        let provider;\n        if (typeof options === \"string\") {\n          provider = new GenericProvider_1.GenericProvider({ provider: \"generic\", url: options }, this, {\n            ...runtimeOptions,\n            isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)\n          });\n        } else {\n          provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);\n        }\n        this.clientPromise = Promise.resolve(provider);\n      }\n      /**\n       * Asks the server whether there is an update.\n       * @returns null if the updater is disabled, otherwise info about the latest version\n       */\n      checkForUpdates() {\n        if (!this.isUpdaterActive()) {\n          return Promise.resolve(null);\n        }\n        let checkForUpdatesPromise = this.checkForUpdatesPromise;\n        if (checkForUpdatesPromise != null) {\n          this._logger.info(\"Checking for update (already in progress)\");\n          return checkForUpdatesPromise;\n        }\n        const nullizePromise = () => this.checkForUpdatesPromise = null;\n        this._logger.info(\"Checking for update\");\n        checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {\n          nullizePromise();\n          return it;\n        }).catch((e) => {\n          nullizePromise();\n          this.emit(\"error\", e, `Cannot check for updates: ${(e.stack || e).toString()}`);\n          throw e;\n        });\n        this.checkForUpdatesPromise = checkForUpdatesPromise;\n        return checkForUpdatesPromise;\n      }\n      isUpdaterActive() {\n        const isEnabled = this.app.isPackaged || this.forceDevUpdateConfig;\n        if (!isEnabled) {\n          this._logger.info(\"Skip checkForUpdates because application is not packed and dev update config is not forced\");\n          return false;\n        }\n        return true;\n      }\n      // noinspection JSUnusedGlobalSymbols\n      checkForUpdatesAndNotify(downloadNotification) {\n        return this.checkForUpdates().then((it) => {\n          if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {\n            if (this._logger.debug != null) {\n              this._logger.debug(\"checkForUpdatesAndNotify called, downloadPromise is null\");\n            }\n            return it;\n          }\n          void it.downloadPromise.then(() => {\n            const notificationContent = _AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);\n            new (require(\"electron\")).Notification(notificationContent).show();\n          });\n          return it;\n        });\n      }\n      static formatDownloadNotification(version, appName, downloadNotification) {\n        if (downloadNotification == null) {\n          downloadNotification = {\n            title: \"A new update is ready to install\",\n            body: `{appName} version {version} has been downloaded and will be automatically installed on exit`\n          };\n        }\n        downloadNotification = {\n          title: downloadNotification.title.replace(\"{appName}\", appName).replace(\"{version}\", version),\n          body: downloadNotification.body.replace(\"{appName}\", appName).replace(\"{version}\", version)\n        };\n        return downloadNotification;\n      }\n      async isStagingMatch(updateInfo) {\n        const rawStagingPercentage = updateInfo.stagingPercentage;\n        let stagingPercentage = rawStagingPercentage;\n        if (stagingPercentage == null) {\n          return true;\n        }\n        stagingPercentage = parseInt(stagingPercentage, 10);\n        if (isNaN(stagingPercentage)) {\n          this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);\n          return true;\n        }\n        stagingPercentage = stagingPercentage / 100;\n        const stagingUserId = await this.stagingUserIdPromise.value;\n        const val = builder_util_runtime_1.UUID.parse(stagingUserId).readUInt32BE(12);\n        const percentage = val / 4294967295;\n        this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);\n        return percentage < stagingPercentage;\n      }\n      computeFinalHeaders(headers) {\n        if (this.requestHeaders != null) {\n          Object.assign(headers, this.requestHeaders);\n        }\n        return headers;\n      }\n      async isUpdateAvailable(updateInfo) {\n        const latestVersion = (0, semver_1.parse)(updateInfo.version);\n        if (latestVersion == null) {\n          throw (0, builder_util_runtime_1.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: \"${updateInfo.version}\"`, \"ERR_UPDATER_INVALID_VERSION\");\n        }\n        const currentVersion = this.currentVersion;\n        if ((0, semver_1.eq)(latestVersion, currentVersion)) {\n          return false;\n        }\n        if (!await Promise.resolve(this.isUpdateSupported(updateInfo))) {\n          return false;\n        }\n        const isStagingMatch = await this.isStagingMatch(updateInfo);\n        if (!isStagingMatch) {\n          return false;\n        }\n        const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);\n        const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);\n        if (isLatestVersionNewer) {\n          return true;\n        }\n        return this.allowDowngrade && isLatestVersionOlder;\n      }\n      checkIfUpdateSupported(updateInfo) {\n        const minimumSystemVersion = updateInfo === null || updateInfo === void 0 ? void 0 : updateInfo.minimumSystemVersion;\n        const currentOSVersion = (0, os_1.release)();\n        if (minimumSystemVersion) {\n          try {\n            if ((0, semver_1.lt)(currentOSVersion, minimumSystemVersion)) {\n              this._logger.info(`Current OS version ${currentOSVersion} is less than the minimum OS version required ${minimumSystemVersion} for version ${currentOSVersion}`);\n              return false;\n            }\n          } catch (e) {\n            this._logger.warn(`Failed to compare current OS version(${currentOSVersion}) with minimum OS version(${minimumSystemVersion}): ${(e.message || e).toString()}`);\n          }\n        }\n        return true;\n      }\n      async getUpdateInfoAndProvider() {\n        await this.app.whenReady();\n        if (this.clientPromise == null) {\n          this.clientPromise = this.configOnDisk.value.then((it) => (0, providerFactory_1.createClient)(it, this, this.createProviderRuntimeOptions()));\n        }\n        const client = await this.clientPromise;\n        const stagingUserId = await this.stagingUserIdPromise.value;\n        client.setRequestHeaders(this.computeFinalHeaders({ \"x-user-staging-id\": stagingUserId }));\n        return {\n          info: await client.getLatestVersion(),\n          provider: client\n        };\n      }\n      createProviderRuntimeOptions() {\n        return {\n          isUseMultipleRangeRequest: true,\n          platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,\n          executor: this.httpExecutor\n        };\n      }\n      async doCheckForUpdates() {\n        this.emit(\"checking-for-update\");\n        const result = await this.getUpdateInfoAndProvider();\n        const updateInfo = result.info;\n        if (!await this.isUpdateAvailable(updateInfo)) {\n          this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? \"allowed\" : \"disallowed\"}).`);\n          this.emit(\"update-not-available\", updateInfo);\n          return {\n            isUpdateAvailable: false,\n            versionInfo: updateInfo,\n            updateInfo\n          };\n        }\n        this.updateInfoAndProvider = result;\n        this.onUpdateAvailable(updateInfo);\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        return {\n          isUpdateAvailable: true,\n          versionInfo: updateInfo,\n          updateInfo,\n          cancellationToken,\n          downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null\n        };\n      }\n      onUpdateAvailable(updateInfo) {\n        this._logger.info(`Found version ${updateInfo.version} (url: ${(0, builder_util_runtime_1.asArray)(updateInfo.files).map((it) => it.url).join(\", \")})`);\n        this.emit(\"update-available\", updateInfo);\n      }\n      /**\n       * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.\n       * @returns {Promise<Array<string>>} Paths to downloaded files.\n       */\n      downloadUpdate(cancellationToken = new builder_util_runtime_1.CancellationToken()) {\n        const updateInfoAndProvider = this.updateInfoAndProvider;\n        if (updateInfoAndProvider == null) {\n          const error = new Error(\"Please check update first\");\n          this.dispatchError(error);\n          return Promise.reject(error);\n        }\n        if (this.downloadPromise != null) {\n          this._logger.info(\"Downloading update (already in progress)\");\n          return this.downloadPromise;\n        }\n        this._logger.info(`Downloading update from ${(0, builder_util_runtime_1.asArray)(updateInfoAndProvider.info.files).map((it) => it.url).join(\", \")}`);\n        const errorHandler = (e) => {\n          if (!(e instanceof builder_util_runtime_1.CancellationError)) {\n            try {\n              this.dispatchError(e);\n            } catch (nestedError) {\n              this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);\n            }\n          }\n          return e;\n        };\n        this.downloadPromise = this.doDownloadUpdate({\n          updateInfoAndProvider,\n          requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),\n          cancellationToken,\n          disableWebInstaller: this.disableWebInstaller,\n          disableDifferentialDownload: this.disableDifferentialDownload\n        }).catch((e) => {\n          throw errorHandler(e);\n        }).finally(() => {\n          this.downloadPromise = null;\n        });\n        return this.downloadPromise;\n      }\n      dispatchError(e) {\n        this.emit(\"error\", e, (e.stack || e).toString());\n      }\n      dispatchUpdateDownloaded(event) {\n        this.emit(types_1.UPDATE_DOWNLOADED, event);\n      }\n      async loadUpdateConfig() {\n        if (this._appUpdateConfigPath == null) {\n          this._appUpdateConfigPath = this.app.appUpdateConfigPath;\n        }\n        return (0, js_yaml_1.load)(await (0, fs_extra_1.readFile)(this._appUpdateConfigPath, \"utf-8\"));\n      }\n      computeRequestHeaders(provider) {\n        const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;\n        if (fileExtraDownloadHeaders != null) {\n          const requestHeaders = this.requestHeaders;\n          return requestHeaders == null ? fileExtraDownloadHeaders : {\n            ...fileExtraDownloadHeaders,\n            ...requestHeaders\n          };\n        }\n        return this.computeFinalHeaders({ accept: \"*/*\" });\n      }\n      async getOrCreateStagingUserId() {\n        const file = path6.join(this.app.userDataPath, \".updaterId\");\n        try {\n          const id2 = await (0, fs_extra_1.readFile)(file, \"utf-8\");\n          if (builder_util_runtime_1.UUID.check(id2)) {\n            return id2;\n          } else {\n            this._logger.warn(`Staging user id file exists, but content was invalid: ${id2}`);\n          }\n        } catch (e) {\n          if (e.code !== \"ENOENT\") {\n            this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);\n          }\n        }\n        const id = builder_util_runtime_1.UUID.v5((0, crypto_1.randomBytes)(4096), builder_util_runtime_1.UUID.OID);\n        this._logger.info(`Generated new staging user ID: ${id}`);\n        try {\n          await (0, fs_extra_1.outputFile)(file, id);\n        } catch (e) {\n          this._logger.warn(`Couldn't write out staging user ID: ${e}`);\n        }\n        return id;\n      }\n      /** @internal */\n      get isAddNoCacheQuery() {\n        const headers = this.requestHeaders;\n        if (headers == null) {\n          return true;\n        }\n        for (const headerName of Object.keys(headers)) {\n          const s = headerName.toLowerCase();\n          if (s === \"authorization\" || s === \"private-token\") {\n            return false;\n          }\n        }\n        return true;\n      }\n      async getOrCreateDownloadHelper() {\n        let result = this.downloadedUpdateHelper;\n        if (result == null) {\n          const dirName = (await this.configOnDisk.value).updaterCacheDirName;\n          const logger12 = this._logger;\n          if (dirName == null) {\n            logger12.error(\"updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?\");\n          }\n          const cacheDir = path6.join(this.app.baseCachePath, dirName || this.app.name);\n          if (logger12.debug != null) {\n            logger12.debug(`updater cache dir: ${cacheDir}`);\n          }\n          result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);\n          this.downloadedUpdateHelper = result;\n        }\n        return result;\n      }\n      async executeDownload(taskOptions) {\n        const fileInfo = taskOptions.fileInfo;\n        const downloadOptions = {\n          headers: taskOptions.downloadUpdateOptions.requestHeaders,\n          cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,\n          sha2: fileInfo.info.sha2,\n          sha512: fileInfo.info.sha512\n        };\n        if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n          downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n        }\n        const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;\n        const version = updateInfo.version;\n        const packageInfo = fileInfo.packageInfo;\n        function getCacheUpdateFileName() {\n          const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);\n          if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {\n            return path6.basename(urlPath);\n          } else {\n            return taskOptions.fileInfo.info.url;\n          }\n        }\n        const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();\n        const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;\n        await (0, fs_extra_1.mkdir)(cacheDir, { recursive: true });\n        const updateFileName = getCacheUpdateFileName();\n        let updateFile = path6.join(cacheDir, updateFileName);\n        const packageFile = packageInfo == null ? null : path6.join(cacheDir, `package-${version}${path6.extname(packageInfo.path) || \".7z\"}`);\n        const done = async (isSaveCache) => {\n          await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);\n          await taskOptions.done({\n            ...updateInfo,\n            downloadedFile: updateFile\n          });\n          return packageFile == null ? [updateFile] : [updateFile, packageFile];\n        };\n        const log12 = this._logger;\n        const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log12);\n        if (cachedUpdateFile != null) {\n          updateFile = cachedUpdateFile;\n          return await done(false);\n        }\n        const removeFileIfAny = async () => {\n          await downloadedUpdateHelper.clear().catch(() => {\n          });\n          return await (0, fs_extra_1.unlink)(updateFile).catch(() => {\n          });\n        };\n        const tempUpdateFile = await (0, DownloadedUpdateHelper_1.createTempUpdateFile)(`temp-${updateFileName}`, cacheDir, log12);\n        try {\n          await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);\n          await (0, builder_util_runtime_1.retry)(() => (0, fs_extra_1.rename)(tempUpdateFile, updateFile), 60, 500, 0, 0, (error) => error instanceof Error && /^EBUSY:/.test(error.message));\n        } catch (e) {\n          await removeFileIfAny();\n          if (e instanceof builder_util_runtime_1.CancellationError) {\n            log12.info(\"cancelled\");\n            this.emit(\"update-cancelled\", updateInfo);\n          }\n          throw e;\n        }\n        log12.info(`New version ${version} has been downloaded to ${updateFile}`);\n        return await done(true);\n      }\n      async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider, oldInstallerFileName) {\n        try {\n          if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {\n            return true;\n          }\n          const blockmapFileUrls = (0, util_1.blockmapFiles)(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);\n          this._logger.info(`Download block maps (old: \"${blockmapFileUrls[0]}\", new: ${blockmapFileUrls[1]})`);\n          const downloadBlockMap = async (url) => {\n            const data = await this.httpExecutor.downloadToBuffer(url, {\n              headers: downloadUpdateOptions.requestHeaders,\n              cancellationToken: downloadUpdateOptions.cancellationToken\n            });\n            if (data == null || data.length === 0) {\n              throw new Error(`Blockmap \"${url.href}\" is empty`);\n            }\n            try {\n              return JSON.parse((0, zlib_1.gunzipSync)(data).toString());\n            } catch (e) {\n              throw new Error(`Cannot parse blockmap \"${url.href}\", error: ${e}`);\n            }\n          };\n          const downloadOptions = {\n            newUrl: fileInfo.url,\n            oldFile: path6.join(this.downloadedUpdateHelper.cacheDir, oldInstallerFileName),\n            logger: this._logger,\n            newFile: installerPath,\n            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n            cancellationToken: downloadUpdateOptions.cancellationToken\n          };\n          if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n            downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n          }\n          const blockMapDataList = await Promise.all(blockmapFileUrls.map((u) => downloadBlockMap(u)));\n          await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);\n          return false;\n        } catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);\n          if (this._testOnlyOptions != null) {\n            throw e;\n          }\n          return true;\n        }\n      }\n    };\n    exports2.AppUpdater = AppUpdater;\n    function hasPrereleaseComponents(version) {\n      const versionPrereleaseComponent = (0, semver_1.prerelease)(version);\n      return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;\n    }\n    var NoOpLogger = class {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      info(message) {\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      warn(message) {\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      error(message) {\n      }\n    };\n    exports2.NoOpLogger = NoOpLogger;\n  }\n});\n\n// node_modules/electron-updater/out/BaseUpdater.js\nvar require_BaseUpdater = __commonJS({\n  \"node_modules/electron-updater/out/BaseUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.BaseUpdater = void 0;\n    var child_process_1 = require(\"child_process\");\n    var AppUpdater_1 = require_AppUpdater();\n    var BaseUpdater = class extends AppUpdater_1.AppUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n        this.quitAndInstallCalled = false;\n        this.quitHandlerAdded = false;\n      }\n      quitAndInstall(isSilent = false, isForceRunAfter = false) {\n        this._logger.info(`Install on explicit quitAndInstall`);\n        const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);\n        if (isInstalled) {\n          setImmediate(() => {\n            require(\"electron\").autoUpdater.emit(\"before-quit-for-update\");\n            this.app.quit();\n          });\n        } else {\n          this.quitAndInstallCalled = false;\n        }\n      }\n      executeDownload(taskOptions) {\n        return super.executeDownload({\n          ...taskOptions,\n          done: (event) => {\n            this.dispatchUpdateDownloaded(event);\n            this.addQuitHandler();\n            return Promise.resolve();\n          }\n        });\n      }\n      get installerPath() {\n        return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;\n      }\n      // must be sync (because quit even handler is not async)\n      install(isSilent = false, isForceRunAfter = false) {\n        if (this.quitAndInstallCalled) {\n          this._logger.warn(\"install call ignored: quitAndInstallCalled is set to true\");\n          return false;\n        }\n        const downloadedUpdateHelper = this.downloadedUpdateHelper;\n        const installerPath = this.installerPath;\n        const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;\n        if (installerPath == null || downloadedFileInfo == null) {\n          this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n          return false;\n        }\n        this.quitAndInstallCalled = true;\n        try {\n          this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);\n          return this.doInstall({\n            isSilent,\n            isForceRunAfter,\n            isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired\n          });\n        } catch (e) {\n          this.dispatchError(e);\n          return false;\n        }\n      }\n      addQuitHandler() {\n        if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {\n          return;\n        }\n        this.quitHandlerAdded = true;\n        this.app.onQuit((exitCode) => {\n          if (this.quitAndInstallCalled) {\n            this._logger.info(\"Update installer has already been triggered. Quitting application.\");\n            return;\n          }\n          if (!this.autoInstallOnAppQuit) {\n            this._logger.info(\"Update will not be installed on quit because autoInstallOnAppQuit is set to false.\");\n            return;\n          }\n          if (exitCode !== 0) {\n            this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);\n            return;\n          }\n          this._logger.info(\"Auto install update on quit\");\n          this.install(true, false);\n        });\n      }\n      wrapSudo() {\n        const { name } = this.app;\n        const installComment = `\"${name} would like to update\"`;\n        const sudo = this.spawnSyncLog(\"which gksudo || which kdesudo || which pkexec || which beesu\");\n        const command = [sudo];\n        if (/kdesudo/i.test(sudo)) {\n          command.push(\"--comment\", installComment);\n          command.push(\"-c\");\n        } else if (/gksudo/i.test(sudo)) {\n          command.push(\"--message\", installComment);\n        } else if (/pkexec/i.test(sudo)) {\n          command.push(\"--disable-internal-agent\");\n        }\n        return command.join(\" \");\n      }\n      spawnSyncLog(cmd, args = [], env = {}) {\n        this._logger.info(`Executing: ${cmd} with args: ${args}`);\n        const response = (0, child_process_1.spawnSync)(cmd, args, {\n          env: { ...process.env, ...env },\n          encoding: \"utf-8\",\n          shell: true\n        });\n        const { error, status, stdout, stderr } = response;\n        if (error != null) {\n          this._logger.error(stderr);\n          throw error;\n        } else if (status != null && status !== 0) {\n          this._logger.error(stderr);\n          throw new Error(`Command ${cmd} exited with code ${status}`);\n        }\n        return stdout.trim();\n      }\n      /**\n       * This handles both node 8 and node 10 way of emitting error when spawning a process\n       *   - node 8: Throws the error\n       *   - node 10: Emit the error(Need to listen with on)\n       */\n      // https://github.com/electron-userland/electron-builder/issues/1129\n      // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors\n      async spawnLog(cmd, args = [], env = void 0, stdio = \"ignore\") {\n        this._logger.info(`Executing: ${cmd} with args: ${args}`);\n        return new Promise((resolve, reject) => {\n          try {\n            const params = { stdio, env, detached: true };\n            const p = (0, child_process_1.spawn)(cmd, args, params);\n            p.on(\"error\", (error) => {\n              reject(error);\n            });\n            p.unref();\n            if (p.pid !== void 0) {\n              resolve(true);\n            }\n          } catch (error) {\n            reject(error);\n          }\n        });\n      }\n    };\n    exports2.BaseUpdater = BaseUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader.js\nvar require_FileWithEmbeddedBlockMapDifferentialDownloader = __commonJS({\n  \"node_modules/electron-updater/out/differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;\n    var fs_extra_1 = require_lib();\n    var DifferentialDownloader_1 = require_DifferentialDownloader();\n    var zlib_1 = require(\"zlib\");\n    var FileWithEmbeddedBlockMapDifferentialDownloader = class extends DifferentialDownloader_1.DifferentialDownloader {\n      async download() {\n        const packageInfo = this.blockAwareFileInfo;\n        const fileSize = packageInfo.size;\n        const offset = fileSize - (packageInfo.blockMapSize + 4);\n        this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);\n        const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));\n        await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);\n      }\n    };\n    exports2.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;\n    function readBlockMap(data) {\n      return JSON.parse((0, zlib_1.inflateRawSync)(data).toString());\n    }\n    async function readEmbeddedBlockMapData(file) {\n      const fd = await (0, fs_extra_1.open)(file, \"r\");\n      try {\n        const fileSize = (await (0, fs_extra_1.fstat)(fd)).size;\n        const sizeBuffer = Buffer.allocUnsafe(4);\n        await (0, fs_extra_1.read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);\n        const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));\n        await (0, fs_extra_1.read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);\n        await (0, fs_extra_1.close)(fd);\n        return readBlockMap(dataBuffer);\n      } catch (e) {\n        await (0, fs_extra_1.close)(fd);\n        throw e;\n      }\n    }\n  }\n});\n\n// node_modules/electron-updater/out/AppImageUpdater.js\nvar require_AppImageUpdater = __commonJS({\n  \"node_modules/electron-updater/out/AppImageUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.AppImageUpdater = void 0;\n    var builder_util_runtime_1 = require_out();\n    var child_process_1 = require(\"child_process\");\n    var fs_extra_1 = require_lib();\n    var fs_1 = require(\"fs\");\n    var path6 = require(\"path\");\n    var BaseUpdater_1 = require_BaseUpdater();\n    var FileWithEmbeddedBlockMapDifferentialDownloader_1 = require_FileWithEmbeddedBlockMapDifferentialDownloader();\n    var Provider_1 = require_Provider();\n    var types_1 = require_types();\n    var AppImageUpdater = class extends BaseUpdater_1.BaseUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n      }\n      isUpdaterActive() {\n        if (process.env[\"APPIMAGE\"] == null) {\n          if (process.env[\"SNAP\"] == null) {\n            this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\");\n          } else {\n            this._logger.info(\"SNAP env is defined, updater is disabled\");\n          }\n          return false;\n        }\n        return super.isUpdaterActive();\n      }\n      /*** @private */\n      doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"AppImage\", [\"rpm\", \"deb\", \"pacman\"]);\n        return this.executeDownload({\n          fileExtension: \"AppImage\",\n          fileInfo,\n          downloadUpdateOptions,\n          task: async (updateFile, downloadOptions) => {\n            const oldFile = process.env[\"APPIMAGE\"];\n            if (oldFile == null) {\n              throw (0, builder_util_runtime_1.newError)(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\");\n            }\n            if (downloadUpdateOptions.disableDifferentialDownload || await this.downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions)) {\n              await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);\n            }\n            await (0, fs_extra_1.chmod)(updateFile, 493);\n          }\n        });\n      }\n      async downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions) {\n        try {\n          const downloadOptions = {\n            newUrl: fileInfo.url,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n            cancellationToken: downloadUpdateOptions.cancellationToken\n          };\n          if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n            downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n          }\n          await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download();\n          return false;\n        } catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);\n          return process.platform === \"linux\";\n        }\n      }\n      doInstall(options) {\n        const appImageFile = process.env[\"APPIMAGE\"];\n        if (appImageFile == null) {\n          throw (0, builder_util_runtime_1.newError)(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\");\n        }\n        (0, fs_1.unlinkSync)(appImageFile);\n        let destination;\n        const existingBaseName = path6.basename(appImageFile);\n        const installerPath = this.installerPath;\n        if (installerPath == null) {\n          this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n          return false;\n        }\n        if (path6.basename(installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n          destination = appImageFile;\n        } else {\n          destination = path6.join(path6.dirname(appImageFile), path6.basename(installerPath));\n        }\n        (0, child_process_1.execFileSync)(\"mv\", [\"-f\", installerPath, destination]);\n        if (destination !== appImageFile) {\n          this.emit(\"appimage-filename-updated\", destination);\n        }\n        const env = {\n          ...process.env,\n          APPIMAGE_SILENT_INSTALL: \"true\"\n        };\n        if (options.isForceRunAfter) {\n          this.spawnLog(destination, [], env);\n        } else {\n          env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\";\n          (0, child_process_1.execFileSync)(destination, [], { env });\n        }\n        return true;\n      }\n    };\n    exports2.AppImageUpdater = AppImageUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/DebUpdater.js\nvar require_DebUpdater = __commonJS({\n  \"node_modules/electron-updater/out/DebUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DebUpdater = void 0;\n    var BaseUpdater_1 = require_BaseUpdater();\n    var Provider_1 = require_Provider();\n    var types_1 = require_types();\n    var DebUpdater = class extends BaseUpdater_1.BaseUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n      }\n      /*** @private */\n      doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"deb\", [\"AppImage\", \"rpm\", \"pacman\"]);\n        return this.executeDownload({\n          fileExtension: \"deb\",\n          fileInfo,\n          downloadUpdateOptions,\n          task: async (updateFile, downloadOptions) => {\n            if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n              downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n            }\n            await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);\n          }\n        });\n      }\n      get installerPath() {\n        var _a, _b;\n        return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/ /g, \"\\\\ \")) !== null && _b !== void 0 ? _b : null;\n      }\n      doInstall(options) {\n        const sudo = this.wrapSudo();\n        const wrapper = /pkexec/i.test(sudo) ? \"\" : `\"`;\n        const installerPath = this.installerPath;\n        if (installerPath == null) {\n          this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n          return false;\n        }\n        const cmd = [\"dpkg\", \"-i\", installerPath, \"||\", \"apt-get\", \"install\", \"-f\", \"-y\"];\n        this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, \"-c\", `'${cmd.join(\" \")}'${wrapper}`]);\n        if (options.isForceRunAfter) {\n          this.app.relaunch();\n        }\n        return true;\n      }\n    };\n    exports2.DebUpdater = DebUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/PacmanUpdater.js\nvar require_PacmanUpdater = __commonJS({\n  \"node_modules/electron-updater/out/PacmanUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.PacmanUpdater = void 0;\n    var BaseUpdater_1 = require_BaseUpdater();\n    var types_1 = require_types();\n    var Provider_1 = require_Provider();\n    var PacmanUpdater = class extends BaseUpdater_1.BaseUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n      }\n      /*** @private */\n      doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"pacman\", [\"AppImage\", \"deb\", \"rpm\"]);\n        return this.executeDownload({\n          fileExtension: \"pacman\",\n          fileInfo,\n          downloadUpdateOptions,\n          task: async (updateFile, downloadOptions) => {\n            if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n              downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n            }\n            await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);\n          }\n        });\n      }\n      get installerPath() {\n        var _a, _b;\n        return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/ /g, \"\\\\ \")) !== null && _b !== void 0 ? _b : null;\n      }\n      doInstall(options) {\n        const sudo = this.wrapSudo();\n        const wrapper = /pkexec/i.test(sudo) ? \"\" : `\"`;\n        const installerPath = this.installerPath;\n        if (installerPath == null) {\n          this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n          return false;\n        }\n        const cmd = [\"pacman\", \"-U\", \"--noconfirm\", installerPath];\n        this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, \"-c\", `'${cmd.join(\" \")}'${wrapper}`]);\n        if (options.isForceRunAfter) {\n          this.app.relaunch();\n        }\n        return true;\n      }\n    };\n    exports2.PacmanUpdater = PacmanUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/RpmUpdater.js\nvar require_RpmUpdater = __commonJS({\n  \"node_modules/electron-updater/out/RpmUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.RpmUpdater = void 0;\n    var BaseUpdater_1 = require_BaseUpdater();\n    var types_1 = require_types();\n    var Provider_1 = require_Provider();\n    var RpmUpdater = class extends BaseUpdater_1.BaseUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n      }\n      /*** @private */\n      doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"rpm\", [\"AppImage\", \"deb\", \"pacman\"]);\n        return this.executeDownload({\n          fileExtension: \"rpm\",\n          fileInfo,\n          downloadUpdateOptions,\n          task: async (updateFile, downloadOptions) => {\n            if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n              downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n            }\n            await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);\n          }\n        });\n      }\n      get installerPath() {\n        var _a, _b;\n        return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/ /g, \"\\\\ \")) !== null && _b !== void 0 ? _b : null;\n      }\n      doInstall(options) {\n        const sudo = this.wrapSudo();\n        const wrapper = /pkexec/i.test(sudo) ? \"\" : `\"`;\n        const packageManager = this.spawnSyncLog(\"which zypper\");\n        const installerPath = this.installerPath;\n        if (installerPath == null) {\n          this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n          return false;\n        }\n        let cmd;\n        if (!packageManager) {\n          const packageManager2 = this.spawnSyncLog(\"which dnf || which yum\");\n          cmd = [packageManager2, \"-y\", \"install\", installerPath];\n        } else {\n          cmd = [packageManager, \"--no-refresh\", \"install\", \"--allow-unsigned-rpm\", \"-y\", \"-f\", installerPath];\n        }\n        this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, \"-c\", `'${cmd.join(\" \")}'${wrapper}`]);\n        if (options.isForceRunAfter) {\n          this.app.relaunch();\n        }\n        return true;\n      }\n    };\n    exports2.RpmUpdater = RpmUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/MacUpdater.js\nvar require_MacUpdater = __commonJS({\n  \"node_modules/electron-updater/out/MacUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.MacUpdater = void 0;\n    var builder_util_runtime_1 = require_out();\n    var fs_extra_1 = require_lib();\n    var fs_1 = require(\"fs\");\n    var path6 = require(\"path\");\n    var http_1 = require(\"http\");\n    var AppUpdater_1 = require_AppUpdater();\n    var Provider_1 = require_Provider();\n    var child_process_1 = require(\"child_process\");\n    var crypto_1 = require(\"crypto\");\n    var MacUpdater = class extends AppUpdater_1.AppUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n        this.nativeUpdater = require(\"electron\").autoUpdater;\n        this.squirrelDownloadedUpdate = false;\n        this.nativeUpdater.on(\"error\", (it) => {\n          this._logger.warn(it);\n          this.emit(\"error\", it);\n        });\n        this.nativeUpdater.on(\"update-downloaded\", () => {\n          this.squirrelDownloadedUpdate = true;\n          this.debug(\"nativeUpdater.update-downloaded\");\n        });\n      }\n      debug(message) {\n        if (this._logger.debug != null) {\n          this._logger.debug(message);\n        }\n      }\n      closeServerIfExists() {\n        if (this.server) {\n          this.debug(\"Closing proxy server\");\n          this.server.close((err) => {\n            if (err) {\n              this.debug(\"proxy server wasn't already open, probably attempted closing again as a safety check before quit\");\n            }\n          });\n        }\n      }\n      async doDownloadUpdate(downloadUpdateOptions) {\n        let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);\n        const log12 = this._logger;\n        const sysctlRosettaInfoKey = \"sysctl.proc_translated\";\n        let isRosetta = false;\n        try {\n          this.debug(\"Checking for macOS Rosetta environment\");\n          const result = (0, child_process_1.execFileSync)(\"sysctl\", [sysctlRosettaInfoKey], { encoding: \"utf8\" });\n          isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);\n          log12.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);\n        } catch (e) {\n          log12.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);\n        }\n        let isArm64Mac = false;\n        try {\n          this.debug(\"Checking for arm64 in uname\");\n          const result = (0, child_process_1.execFileSync)(\"uname\", [\"-a\"], { encoding: \"utf8\" });\n          const isArm = result.includes(\"ARM\");\n          log12.info(`Checked 'uname -a': arm64=${isArm}`);\n          isArm64Mac = isArm64Mac || isArm;\n        } catch (e) {\n          log12.warn(`uname shell command to check for arm64 failed: ${e}`);\n        }\n        isArm64Mac = isArm64Mac || process.arch === \"arm64\" || isRosetta;\n        const isArm64 = (file) => {\n          var _a;\n          return file.url.pathname.includes(\"arm64\") || ((_a = file.info.url) === null || _a === void 0 ? void 0 : _a.includes(\"arm64\"));\n        };\n        if (isArm64Mac && files.some(isArm64)) {\n          files = files.filter((file) => isArm64Mac === isArm64(file));\n        } else {\n          files = files.filter((file) => !isArm64(file));\n        }\n        const zipFileInfo = (0, Provider_1.findFile)(files, \"zip\", [\"pkg\", \"dmg\"]);\n        if (zipFileInfo == null) {\n          throw (0, builder_util_runtime_1.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1.safeStringifyJson)(files)}`, \"ERR_UPDATER_ZIP_FILE_NOT_FOUND\");\n        }\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const CURRENT_MAC_APP_ZIP_FILE_NAME = \"update.zip\";\n        return this.executeDownload({\n          fileExtension: \"zip\",\n          fileInfo: zipFileInfo,\n          downloadUpdateOptions,\n          task: async (destinationFile, downloadOptions) => {\n            const cachedUpdateFilePath = path6.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);\n            const canDifferentialDownload = () => {\n              if (!(0, fs_extra_1.pathExistsSync)(cachedUpdateFilePath)) {\n                log12.info(\"Unable to locate previous update.zip for differential download (is this first install?), falling back to full download\");\n                return false;\n              }\n              return !downloadUpdateOptions.disableDifferentialDownload;\n            };\n            let differentialDownloadFailed = true;\n            if (canDifferentialDownload()) {\n              differentialDownloadFailed = await this.differentialDownloadInstaller(zipFileInfo, downloadUpdateOptions, destinationFile, provider, CURRENT_MAC_APP_ZIP_FILE_NAME);\n            }\n            if (differentialDownloadFailed) {\n              await this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);\n            }\n          },\n          done: async (event) => {\n            if (!downloadUpdateOptions.disableDifferentialDownload) {\n              try {\n                const cachedUpdateFilePath = path6.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);\n                await (0, fs_extra_1.copyFile)(event.downloadedFile, cachedUpdateFilePath);\n              } catch (error) {\n                this._logger.warn(`Unable to copy file for caching for future differential downloads: ${error.message}`);\n              }\n            }\n            return this.updateDownloaded(zipFileInfo, event);\n          }\n        });\n      }\n      async updateDownloaded(zipFileInfo, event) {\n        var _a;\n        const downloadedFile = event.downloadedFile;\n        const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await (0, fs_extra_1.stat)(downloadedFile)).size;\n        const log12 = this._logger;\n        const logContext = `fileToProxy=${zipFileInfo.url.href}`;\n        this.closeServerIfExists();\n        this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);\n        this.server = (0, http_1.createServer)();\n        this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);\n        this.server.on(\"close\", () => {\n          log12.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);\n        });\n        const getServerUrl = (s) => {\n          const address = s.address();\n          if (typeof address === \"string\") {\n            return address;\n          }\n          return `http://127.0.0.1:${address === null || address === void 0 ? void 0 : address.port}`;\n        };\n        return await new Promise((resolve, reject) => {\n          const pass = (0, crypto_1.randomBytes)(64).toString(\"base64\").replace(/\\//g, \"_\").replace(/\\+/g, \"-\");\n          const authInfo = Buffer.from(`autoupdater:${pass}`, \"ascii\");\n          const fileUrl = `/${(0, crypto_1.randomBytes)(64).toString(\"hex\")}.zip`;\n          this.server.on(\"request\", (request, response) => {\n            const requestUrl = request.url;\n            log12.info(`${requestUrl} requested`);\n            if (requestUrl === \"/\") {\n              if (!request.headers.authorization || request.headers.authorization.indexOf(\"Basic \") === -1) {\n                response.statusCode = 401;\n                response.statusMessage = \"Invalid Authentication Credentials\";\n                response.end();\n                log12.warn(\"No authenthication info\");\n                return;\n              }\n              const base64Credentials = request.headers.authorization.split(\" \")[1];\n              const credentials = Buffer.from(base64Credentials, \"base64\").toString(\"ascii\");\n              const [username, password] = credentials.split(\":\");\n              if (username !== \"autoupdater\" || password !== pass) {\n                response.statusCode = 401;\n                response.statusMessage = \"Invalid Authentication Credentials\";\n                response.end();\n                log12.warn(\"Invalid authenthication credentials\");\n                return;\n              }\n              const data = Buffer.from(`{ \"url\": \"${getServerUrl(this.server)}${fileUrl}\" }`);\n              response.writeHead(200, { \"Content-Type\": \"application/json\", \"Content-Length\": data.length });\n              response.end(data);\n              return;\n            }\n            if (!requestUrl.startsWith(fileUrl)) {\n              log12.warn(`${requestUrl} requested, but not supported`);\n              response.writeHead(404);\n              response.end();\n              return;\n            }\n            log12.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);\n            let errorOccurred = false;\n            response.on(\"finish\", () => {\n              if (!errorOccurred) {\n                this.nativeUpdater.removeListener(\"error\", reject);\n                resolve([]);\n              }\n            });\n            const readStream = (0, fs_1.createReadStream)(downloadedFile);\n            readStream.on(\"error\", (error) => {\n              try {\n                response.end();\n              } catch (e) {\n                log12.warn(`cannot end response: ${e}`);\n              }\n              errorOccurred = true;\n              this.nativeUpdater.removeListener(\"error\", reject);\n              reject(new Error(`Cannot pipe \"${downloadedFile}\": ${error}`));\n            });\n            response.writeHead(200, {\n              \"Content-Type\": \"application/zip\",\n              \"Content-Length\": updateFileSize\n            });\n            readStream.pipe(response);\n          });\n          this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);\n          this.server.listen(0, \"127.0.0.1\", () => {\n            this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl(this.server)}, ${logContext})`);\n            this.nativeUpdater.setFeedURL({\n              url: getServerUrl(this.server),\n              headers: {\n                \"Cache-Control\": \"no-cache\",\n                Authorization: `Basic ${authInfo.toString(\"base64\")}`\n              }\n            });\n            this.dispatchUpdateDownloaded(event);\n            if (this.autoInstallOnAppQuit) {\n              this.nativeUpdater.once(\"error\", reject);\n              this.nativeUpdater.checkForUpdates();\n            } else {\n              resolve([]);\n            }\n          });\n        });\n      }\n      handleUpdateDownloaded() {\n        if (this.autoRunAppAfterInstall) {\n          this.nativeUpdater.quitAndInstall();\n        } else {\n          this.app.quit();\n        }\n        this.closeServerIfExists();\n      }\n      quitAndInstall() {\n        if (this.squirrelDownloadedUpdate) {\n          this.handleUpdateDownloaded();\n        } else {\n          this.nativeUpdater.on(\"update-downloaded\", () => this.handleUpdateDownloaded());\n          if (!this.autoInstallOnAppQuit) {\n            this.nativeUpdater.checkForUpdates();\n          }\n        }\n      }\n    };\n    exports2.MacUpdater = MacUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/windowsExecutableCodeSignatureVerifier.js\nvar require_windowsExecutableCodeSignatureVerifier = __commonJS({\n  \"node_modules/electron-updater/out/windowsExecutableCodeSignatureVerifier.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.verifySignature = verifySignature;\n    var builder_util_runtime_1 = require_out();\n    var child_process_1 = require(\"child_process\");\n    var os = require(\"os\");\n    var path6 = require(\"path\");\n    function verifySignature(publisherNames, unescapedTempUpdateFile, logger12) {\n      return new Promise((resolve, reject) => {\n        const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, \"''\");\n        logger12.info(`Verifying signature ${tempUpdateFile}`);\n        (0, child_process_1.execFile)(`set \"PSModulePath=\" & chcp 65001 >NUL & powershell.exe`, [\"-NoProfile\", \"-NonInteractive\", \"-InputFormat\", \"None\", \"-Command\", `\"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress\"`], {\n          shell: true,\n          timeout: 20 * 1e3\n        }, (error, stdout, stderr) => {\n          var _a;\n          try {\n            if (error != null || stderr) {\n              handleError(logger12, error, stderr, reject);\n              resolve(null);\n              return;\n            }\n            const data = parseOut(stdout);\n            if (data.Status === 0) {\n              try {\n                const normlaizedUpdateFilePath = path6.normalize(data.Path);\n                const normalizedTempUpdateFile = path6.normalize(unescapedTempUpdateFile);\n                logger12.info(`LiteralPath: ${normlaizedUpdateFilePath}. Update Path: ${normalizedTempUpdateFile}`);\n                if (normlaizedUpdateFilePath !== normalizedTempUpdateFile) {\n                  handleError(logger12, new Error(`LiteralPath of ${normlaizedUpdateFilePath} is different than ${normalizedTempUpdateFile}`), stderr, reject);\n                  resolve(null);\n                  return;\n                }\n              } catch (error2) {\n                logger12.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(_a = error2.message) !== null && _a !== void 0 ? _a : error2.stack}`);\n              }\n              const subject = (0, builder_util_runtime_1.parseDn)(data.SignerCertificate.Subject);\n              let match = false;\n              for (const name of publisherNames) {\n                const dn = (0, builder_util_runtime_1.parseDn)(name);\n                if (dn.size) {\n                  const allKeys = Array.from(dn.keys());\n                  match = allKeys.every((key) => {\n                    return dn.get(key) === subject.get(key);\n                  });\n                } else if (name === subject.get(\"CN\")) {\n                  logger12.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);\n                  match = true;\n                }\n                if (match) {\n                  resolve(null);\n                  return;\n                }\n              }\n            }\n            const result = `publisherNames: ${publisherNames.join(\" | \")}, raw info: ` + JSON.stringify(data, (name, value) => name === \"RawData\" ? void 0 : value, 2);\n            logger12.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);\n            resolve(result);\n          } catch (e) {\n            handleError(logger12, e, null, reject);\n            resolve(null);\n            return;\n          }\n        });\n      });\n    }\n    function parseOut(out) {\n      const data = JSON.parse(out);\n      delete data.PrivateKey;\n      delete data.IsOSBinary;\n      delete data.SignatureType;\n      const signerCertificate = data.SignerCertificate;\n      if (signerCertificate != null) {\n        delete signerCertificate.Archived;\n        delete signerCertificate.Extensions;\n        delete signerCertificate.Handle;\n        delete signerCertificate.HasPrivateKey;\n        delete signerCertificate.SubjectName;\n      }\n      return data;\n    }\n    function handleError(logger12, error, stderr, reject) {\n      if (isOldWin6()) {\n        logger12.warn(`Cannot execute Get-AuthenticodeSignature: ${error || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);\n        return;\n      }\n      try {\n        (0, child_process_1.execFileSync)(\"powershell.exe\", [\"-NoProfile\", \"-NonInteractive\", \"-Command\", \"ConvertTo-Json test\"], { timeout: 10 * 1e3 });\n      } catch (testError) {\n        logger12.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);\n        return;\n      }\n      if (error != null) {\n        reject(error);\n      }\n      if (stderr) {\n        reject(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Failing signature validation due to unknown stderr.`));\n      }\n    }\n    function isOldWin6() {\n      const winVersion = os.release();\n      return winVersion.startsWith(\"6.\") && !winVersion.startsWith(\"6.3\");\n    }\n  }\n});\n\n// node_modules/electron-updater/out/NsisUpdater.js\nvar require_NsisUpdater = __commonJS({\n  \"node_modules/electron-updater/out/NsisUpdater.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.NsisUpdater = void 0;\n    var builder_util_runtime_1 = require_out();\n    var path6 = require(\"path\");\n    var BaseUpdater_1 = require_BaseUpdater();\n    var FileWithEmbeddedBlockMapDifferentialDownloader_1 = require_FileWithEmbeddedBlockMapDifferentialDownloader();\n    var types_1 = require_types();\n    var Provider_1 = require_Provider();\n    var fs_extra_1 = require_lib();\n    var windowsExecutableCodeSignatureVerifier_1 = require_windowsExecutableCodeSignatureVerifier();\n    var url_1 = require(\"url\");\n    var NsisUpdater = class extends BaseUpdater_1.BaseUpdater {\n      constructor(options, app6) {\n        super(options, app6);\n        this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);\n      }\n      /**\n       * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.\n       * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)\n       */\n      get verifyUpdateCodeSignature() {\n        return this._verifyUpdateCodeSignature;\n      }\n      set verifyUpdateCodeSignature(value) {\n        if (value) {\n          this._verifyUpdateCodeSignature = value;\n        }\n      }\n      /*** @private */\n      doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"exe\");\n        return this.executeDownload({\n          fileExtension: \"exe\",\n          downloadUpdateOptions,\n          fileInfo,\n          task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {\n            const packageInfo = fileInfo.packageInfo;\n            const isWebInstaller = packageInfo != null && packageFile != null;\n            if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {\n              throw (0, builder_util_runtime_1.newError)(`Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`, \"ERR_UPDATER_WEB_INSTALLER_DISABLED\");\n            }\n            if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {\n              this._logger.warn(\"disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.\");\n            }\n            if (isWebInstaller || downloadUpdateOptions.disableDifferentialDownload || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME)) {\n              await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);\n            }\n            const signatureVerificationStatus = await this.verifySignature(destinationFile);\n            if (signatureVerificationStatus != null) {\n              await removeTempDirIfAny();\n              throw (0, builder_util_runtime_1.newError)(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, \"ERR_UPDATER_INVALID_SIGNATURE\");\n            }\n            if (isWebInstaller) {\n              if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {\n                try {\n                  await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {\n                    headers: downloadUpdateOptions.requestHeaders,\n                    cancellationToken: downloadUpdateOptions.cancellationToken,\n                    sha512: packageInfo.sha512\n                  });\n                } catch (e) {\n                  try {\n                    await (0, fs_extra_1.unlink)(packageFile);\n                  } catch (_ignored) {\n                  }\n                  throw e;\n                }\n              }\n            }\n          }\n        });\n      }\n      // $certificateInfo = (Get-AuthenticodeSignature 'xxx\\yyy.exe'\n      // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains(\"CN=siemens.com\")})\n      // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }\n      async verifySignature(tempUpdateFile) {\n        let publisherName;\n        try {\n          publisherName = (await this.configOnDisk.value).publisherName;\n          if (publisherName == null) {\n            return null;\n          }\n        } catch (e) {\n          if (e.code === \"ENOENT\") {\n            return null;\n          }\n          throw e;\n        }\n        return await this._verifyUpdateCodeSignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile);\n      }\n      doInstall(options) {\n        const installerPath = this.installerPath;\n        if (installerPath == null) {\n          this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n          return false;\n        }\n        const args = [\"--updated\"];\n        if (options.isSilent) {\n          args.push(\"/S\");\n        }\n        if (options.isForceRunAfter) {\n          args.push(\"--force-run\");\n        }\n        if (this.installDirectory) {\n          args.push(`/D=${this.installDirectory}`);\n        }\n        const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;\n        if (packagePath != null) {\n          args.push(`--package-file=${packagePath}`);\n        }\n        const callUsingElevation = () => {\n          this.spawnLog(path6.join(process.resourcesPath, \"elevate.exe\"), [installerPath].concat(args)).catch((e) => this.dispatchError(e));\n        };\n        if (options.isAdminRightsRequired) {\n          this._logger.info(\"isAdminRightsRequired is set to true, run installer using elevate.exe\");\n          callUsingElevation();\n          return true;\n        }\n        this.spawnLog(installerPath, args).catch((e) => {\n          const errorCode = e.code;\n          this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: \"${e.message}\", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`);\n          if (errorCode === \"UNKNOWN\" || errorCode === \"EACCES\") {\n            callUsingElevation();\n          } else if (errorCode === \"ENOENT\") {\n            require(\"electron\").shell.openPath(installerPath).catch((err) => this.dispatchError(err));\n          } else {\n            this.dispatchError(e);\n          }\n        });\n        return true;\n      }\n      async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {\n        if (packageInfo.blockMapSize == null) {\n          return true;\n        }\n        try {\n          const downloadOptions = {\n            newUrl: new url_1.URL(packageInfo.path),\n            oldFile: path6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),\n            logger: this._logger,\n            newFile: packagePath,\n            requestHeaders: this.requestHeaders,\n            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n            cancellationToken: downloadUpdateOptions.cancellationToken\n          };\n          if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {\n            downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);\n          }\n          await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();\n        } catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);\n          return process.platform === \"win32\";\n        }\n        return false;\n      }\n    };\n    exports2.NsisUpdater = NsisUpdater;\n  }\n});\n\n// node_modules/electron-updater/out/main.js\nvar require_main2 = __commonJS({\n  \"node_modules/electron-updater/out/main.js\"(exports2) {\n    \"use strict\";\n    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {\n      if (k2 === void 0) k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() {\n          return m[k];\n        } };\n      }\n      Object.defineProperty(o, k2, desc);\n    }) : (function(o, m, k, k2) {\n      if (k2 === void 0) k2 = k;\n      o[k2] = m[k];\n    }));\n    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {\n      for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);\n    };\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.NsisUpdater = exports2.MacUpdater = exports2.RpmUpdater = exports2.PacmanUpdater = exports2.DebUpdater = exports2.AppImageUpdater = exports2.Provider = exports2.NoOpLogger = exports2.AppUpdater = exports2.BaseUpdater = void 0;\n    var fs_extra_1 = require_lib();\n    var path6 = require(\"path\");\n    var BaseUpdater_1 = require_BaseUpdater();\n    Object.defineProperty(exports2, \"BaseUpdater\", { enumerable: true, get: function() {\n      return BaseUpdater_1.BaseUpdater;\n    } });\n    var AppUpdater_1 = require_AppUpdater();\n    Object.defineProperty(exports2, \"AppUpdater\", { enumerable: true, get: function() {\n      return AppUpdater_1.AppUpdater;\n    } });\n    Object.defineProperty(exports2, \"NoOpLogger\", { enumerable: true, get: function() {\n      return AppUpdater_1.NoOpLogger;\n    } });\n    var Provider_1 = require_Provider();\n    Object.defineProperty(exports2, \"Provider\", { enumerable: true, get: function() {\n      return Provider_1.Provider;\n    } });\n    var AppImageUpdater_1 = require_AppImageUpdater();\n    Object.defineProperty(exports2, \"AppImageUpdater\", { enumerable: true, get: function() {\n      return AppImageUpdater_1.AppImageUpdater;\n    } });\n    var DebUpdater_1 = require_DebUpdater();\n    Object.defineProperty(exports2, \"DebUpdater\", { enumerable: true, get: function() {\n      return DebUpdater_1.DebUpdater;\n    } });\n    var PacmanUpdater_1 = require_PacmanUpdater();\n    Object.defineProperty(exports2, \"PacmanUpdater\", { enumerable: true, get: function() {\n      return PacmanUpdater_1.PacmanUpdater;\n    } });\n    var RpmUpdater_1 = require_RpmUpdater();\n    Object.defineProperty(exports2, \"RpmUpdater\", { enumerable: true, get: function() {\n      return RpmUpdater_1.RpmUpdater;\n    } });\n    var MacUpdater_1 = require_MacUpdater();\n    Object.defineProperty(exports2, \"MacUpdater\", { enumerable: true, get: function() {\n      return MacUpdater_1.MacUpdater;\n    } });\n    var NsisUpdater_1 = require_NsisUpdater();\n    Object.defineProperty(exports2, \"NsisUpdater\", { enumerable: true, get: function() {\n      return NsisUpdater_1.NsisUpdater;\n    } });\n    __exportStar2(require_types(), exports2);\n    var _autoUpdater;\n    function doLoadAutoUpdater() {\n      if (process.platform === \"win32\") {\n        _autoUpdater = new (require_NsisUpdater()).NsisUpdater();\n      } else if (process.platform === \"darwin\") {\n        _autoUpdater = new (require_MacUpdater()).MacUpdater();\n      } else {\n        _autoUpdater = new (require_AppImageUpdater()).AppImageUpdater();\n        try {\n          const identity = path6.join(process.resourcesPath, \"package-type\");\n          if (!(0, fs_extra_1.existsSync)(identity)) {\n            return _autoUpdater;\n          }\n          console.info(\"Checking for beta autoupdate feature for deb/rpm distributions\");\n          const fileType = (0, fs_extra_1.readFileSync)(identity).toString().trim();\n          console.info(\"Found package-type:\", fileType);\n          switch (fileType) {\n            case \"deb\":\n              _autoUpdater = new (require_DebUpdater()).DebUpdater();\n              break;\n            case \"rpm\":\n              _autoUpdater = new (require_RpmUpdater()).RpmUpdater();\n              break;\n            case \"pacman\":\n              _autoUpdater = new (require_PacmanUpdater()).PacmanUpdater();\n              break;\n            default:\n              break;\n          }\n        } catch (error) {\n          console.warn(\"Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder\", error.message);\n        }\n      }\n      return _autoUpdater;\n    }\n    Object.defineProperty(exports2, \"autoUpdater\", {\n      enumerable: true,\n      get: () => {\n        return _autoUpdater || doLoadAutoUpdater();\n      }\n    });\n  }\n});\n\n// node_modules/electron-log/src/renderer/electron-log-preload.js\nvar require_electron_log_preload = __commonJS({\n  \"node_modules/electron-log/src/renderer/electron-log-preload.js\"(exports2, module2) {\n    \"use strict\";\n    var electron = {};\n    try {\n      electron = require(\"electron\");\n    } catch (e) {\n    }\n    if (electron.ipcRenderer) {\n      initialize(electron);\n    }\n    if (typeof module2 === \"object\") {\n      module2.exports = initialize;\n    }\n    function initialize({ contextBridge, ipcRenderer }) {\n      if (!ipcRenderer) {\n        return;\n      }\n      ipcRenderer.on(\"__ELECTRON_LOG_IPC__\", (_, message) => {\n        window.postMessage({ cmd: \"message\", ...message });\n      });\n      ipcRenderer.invoke(\"__ELECTRON_LOG__\", { cmd: \"getOptions\" }).catch((e) => console.error(new Error(\n        `electron-log isn't initialized in the main process. Please call log.initialize() before. ${e.message}`\n      )));\n      const electronLog = {\n        sendToMain(message) {\n          try {\n            ipcRenderer.send(\"__ELECTRON_LOG__\", message);\n          } catch (e) {\n            console.error(\"electronLog.sendToMain \", e, \"data:\", message);\n            ipcRenderer.send(\"__ELECTRON_LOG__\", {\n              cmd: \"errorHandler\",\n              error: { message: e?.message, stack: e?.stack },\n              errorName: \"sendToMain\"\n            });\n          }\n        },\n        log(...data) {\n          electronLog.sendToMain({ data, level: \"info\" });\n        }\n      };\n      for (const level of [\"error\", \"warn\", \"info\", \"verbose\", \"debug\", \"silly\"]) {\n        electronLog[level] = (...data) => electronLog.sendToMain({\n          data,\n          level\n        });\n      }\n      if (contextBridge && process.contextIsolated) {\n        try {\n          contextBridge.exposeInMainWorld(\"__electronLog\", electronLog);\n        } catch {\n        }\n      }\n      if (typeof window === \"object\") {\n        window.__electronLog = electronLog;\n      } else {\n        __electronLog = electronLog;\n      }\n    }\n  }\n});\n\n// node_modules/electron-log/src/core/scope.js\nvar require_scope = __commonJS({\n  \"node_modules/electron-log/src/core/scope.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = scopeFactory;\n    function scopeFactory(logger12) {\n      return Object.defineProperties(scope, {\n        defaultLabel: { value: \"\", writable: true },\n        labelPadding: { value: true, writable: true },\n        maxLabelLength: { value: 0, writable: true },\n        labelLength: {\n          get() {\n            switch (typeof scope.labelPadding) {\n              case \"boolean\":\n                return scope.labelPadding ? scope.maxLabelLength : 0;\n              case \"number\":\n                return scope.labelPadding;\n              default:\n                return 0;\n            }\n          }\n        }\n      });\n      function scope(label) {\n        scope.maxLabelLength = Math.max(scope.maxLabelLength, label.length);\n        const newScope = {};\n        for (const level of logger12.levels) {\n          newScope[level] = (...d) => logger12.logData(d, { level, scope: label });\n        }\n        newScope.log = newScope.info;\n        return newScope;\n      }\n    }\n  }\n});\n\n// node_modules/electron-log/src/core/Buffering.js\nvar require_Buffering = __commonJS({\n  \"node_modules/electron-log/src/core/Buffering.js\"(exports2, module2) {\n    \"use strict\";\n    var Buffering = class {\n      constructor({ processMessage }) {\n        this.processMessage = processMessage;\n        this.buffer = [];\n        this.enabled = false;\n        this.begin = this.begin.bind(this);\n        this.commit = this.commit.bind(this);\n        this.reject = this.reject.bind(this);\n      }\n      addMessage(message) {\n        this.buffer.push(message);\n      }\n      begin() {\n        this.enabled = [];\n      }\n      commit() {\n        this.enabled = false;\n        this.buffer.forEach((item) => this.processMessage(item));\n        this.buffer = [];\n      }\n      reject() {\n        this.enabled = false;\n        this.buffer = [];\n      }\n    };\n    module2.exports = Buffering;\n  }\n});\n\n// node_modules/electron-log/src/core/Logger.js\nvar require_Logger = __commonJS({\n  \"node_modules/electron-log/src/core/Logger.js\"(exports2, module2) {\n    \"use strict\";\n    var scopeFactory = require_scope();\n    var Buffering = require_Buffering();\n    var Logger = class _Logger {\n      static instances = {};\n      dependencies = {};\n      errorHandler = null;\n      eventLogger = null;\n      functions = {};\n      hooks = [];\n      isDev = false;\n      levels = null;\n      logId = null;\n      scope = null;\n      transports = {};\n      variables = {};\n      constructor({\n        allowUnknownLevel = false,\n        dependencies = {},\n        errorHandler,\n        eventLogger,\n        initializeFn,\n        isDev = false,\n        levels = [\"error\", \"warn\", \"info\", \"verbose\", \"debug\", \"silly\"],\n        logId,\n        transportFactories = {},\n        variables\n      } = {}) {\n        this.addLevel = this.addLevel.bind(this);\n        this.create = this.create.bind(this);\n        this.initialize = this.initialize.bind(this);\n        this.logData = this.logData.bind(this);\n        this.processMessage = this.processMessage.bind(this);\n        this.allowUnknownLevel = allowUnknownLevel;\n        this.buffering = new Buffering(this);\n        this.dependencies = dependencies;\n        this.initializeFn = initializeFn;\n        this.isDev = isDev;\n        this.levels = levels;\n        this.logId = logId;\n        this.scope = scopeFactory(this);\n        this.transportFactories = transportFactories;\n        this.variables = variables || {};\n        for (const name of this.levels) {\n          this.addLevel(name, false);\n        }\n        this.log = this.info;\n        this.functions.log = this.log;\n        this.errorHandler = errorHandler;\n        errorHandler?.setOptions({ ...dependencies, logFn: this.error });\n        this.eventLogger = eventLogger;\n        eventLogger?.setOptions({ ...dependencies, logger: this });\n        for (const [name, factory] of Object.entries(transportFactories)) {\n          this.transports[name] = factory(this, dependencies);\n        }\n        _Logger.instances[logId] = this;\n      }\n      static getInstance({ logId }) {\n        return this.instances[logId] || this.instances.default;\n      }\n      addLevel(level, index = this.levels.length) {\n        if (index !== false) {\n          this.levels.splice(index, 0, level);\n        }\n        this[level] = (...args) => this.logData(args, { level });\n        this.functions[level] = this[level];\n      }\n      catchErrors(options) {\n        this.processMessage(\n          {\n            data: [\"log.catchErrors is deprecated. Use log.errorHandler instead\"],\n            level: \"warn\"\n          },\n          { transports: [\"console\"] }\n        );\n        return this.errorHandler.startCatching(options);\n      }\n      create(options) {\n        if (typeof options === \"string\") {\n          options = { logId: options };\n        }\n        return new _Logger({\n          dependencies: this.dependencies,\n          errorHandler: this.errorHandler,\n          initializeFn: this.initializeFn,\n          isDev: this.isDev,\n          transportFactories: this.transportFactories,\n          variables: { ...this.variables },\n          ...options\n        });\n      }\n      compareLevels(passLevel, checkLevel, levels = this.levels) {\n        const pass = levels.indexOf(passLevel);\n        const check = levels.indexOf(checkLevel);\n        if (check === -1 || pass === -1) {\n          return true;\n        }\n        return check <= pass;\n      }\n      initialize(options = {}) {\n        this.initializeFn({ logger: this, ...this.dependencies, ...options });\n      }\n      logData(data, options = {}) {\n        if (this.buffering.enabled) {\n          this.buffering.addMessage({ data, date: /* @__PURE__ */ new Date(), ...options });\n        } else {\n          this.processMessage({ data, ...options });\n        }\n      }\n      processMessage(message, { transports = this.transports } = {}) {\n        if (message.cmd === \"errorHandler\") {\n          this.errorHandler.handle(message.error, {\n            errorName: message.errorName,\n            processType: \"renderer\",\n            showDialog: Boolean(message.showDialog)\n          });\n          return;\n        }\n        let level = message.level;\n        if (!this.allowUnknownLevel) {\n          level = this.levels.includes(message.level) ? message.level : \"info\";\n        }\n        const normalizedMessage = {\n          date: /* @__PURE__ */ new Date(),\n          logId: this.logId,\n          ...message,\n          level,\n          variables: {\n            ...this.variables,\n            ...message.variables\n          }\n        };\n        for (const [transName, transFn] of this.transportEntries(transports)) {\n          if (typeof transFn !== \"function\" || transFn.level === false) {\n            continue;\n          }\n          if (!this.compareLevels(transFn.level, message.level)) {\n            continue;\n          }\n          try {\n            const transformedMsg = this.hooks.reduce((msg, hook) => {\n              return msg ? hook(msg, transFn, transName) : msg;\n            }, normalizedMessage);\n            if (transformedMsg) {\n              transFn({ ...transformedMsg, data: [...transformedMsg.data] });\n            }\n          } catch (e) {\n            this.processInternalErrorFn(e);\n          }\n        }\n      }\n      processInternalErrorFn(_e) {\n      }\n      transportEntries(transports = this.transports) {\n        const transportArray = Array.isArray(transports) ? transports : Object.entries(transports);\n        return transportArray.map((item) => {\n          switch (typeof item) {\n            case \"string\":\n              return this.transports[item] ? [item, this.transports[item]] : null;\n            case \"function\":\n              return [item.name, item];\n            default:\n              return Array.isArray(item) ? item : null;\n          }\n        }).filter(Boolean);\n      }\n    };\n    module2.exports = Logger;\n  }\n});\n\n// node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js\nvar require_RendererErrorHandler = __commonJS({\n  \"node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js\"(exports2, module2) {\n    \"use strict\";\n    var consoleError = console.error;\n    var RendererErrorHandler = class {\n      logFn = null;\n      onError = null;\n      showDialog = false;\n      preventDefault = true;\n      constructor({ logFn = null } = {}) {\n        this.handleError = this.handleError.bind(this);\n        this.handleRejection = this.handleRejection.bind(this);\n        this.startCatching = this.startCatching.bind(this);\n        this.logFn = logFn;\n      }\n      handle(error, {\n        logFn = this.logFn,\n        errorName = \"\",\n        onError = this.onError,\n        showDialog = this.showDialog\n      } = {}) {\n        try {\n          if (onError?.({ error, errorName, processType: \"renderer\" }) !== false) {\n            logFn({ error, errorName, showDialog });\n          }\n        } catch {\n          consoleError(error);\n        }\n      }\n      setOptions({ logFn, onError, preventDefault, showDialog }) {\n        if (typeof logFn === \"function\") {\n          this.logFn = logFn;\n        }\n        if (typeof onError === \"function\") {\n          this.onError = onError;\n        }\n        if (typeof preventDefault === \"boolean\") {\n          this.preventDefault = preventDefault;\n        }\n        if (typeof showDialog === \"boolean\") {\n          this.showDialog = showDialog;\n        }\n      }\n      startCatching({ onError, showDialog } = {}) {\n        if (this.isActive) {\n          return;\n        }\n        this.isActive = true;\n        this.setOptions({ onError, showDialog });\n        window.addEventListener(\"error\", (event) => {\n          this.preventDefault && event.preventDefault?.();\n          this.handleError(event.error || event);\n        });\n        window.addEventListener(\"unhandledrejection\", (event) => {\n          this.preventDefault && event.preventDefault?.();\n          this.handleRejection(event.reason || event);\n        });\n      }\n      handleError(error) {\n        this.handle(error, { errorName: \"Unhandled\" });\n      }\n      handleRejection(reason) {\n        const error = reason instanceof Error ? reason : new Error(JSON.stringify(reason));\n        this.handle(error, { errorName: \"Unhandled rejection\" });\n      }\n    };\n    module2.exports = RendererErrorHandler;\n  }\n});\n\n// node_modules/electron-log/src/core/transforms/transform.js\nvar require_transform = __commonJS({\n  \"node_modules/electron-log/src/core/transforms/transform.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = { transform };\n    function transform({\n      logger: logger12,\n      message,\n      transport,\n      initialData = message?.data || [],\n      transforms = transport?.transforms\n    }) {\n      return transforms.reduce((data, trans) => {\n        if (typeof trans === \"function\") {\n          return trans({ data, logger: logger12, message, transport });\n        }\n        return data;\n      }, initialData);\n    }\n  }\n});\n\n// node_modules/electron-log/src/renderer/lib/transports/console.js\nvar require_console = __commonJS({\n  \"node_modules/electron-log/src/renderer/lib/transports/console.js\"(exports2, module2) {\n    \"use strict\";\n    var { transform } = require_transform();\n    module2.exports = consoleTransportRendererFactory;\n    var consoleMethods = {\n      error: console.error,\n      warn: console.warn,\n      info: console.info,\n      verbose: console.info,\n      debug: console.debug,\n      silly: console.debug,\n      log: console.log\n    };\n    function consoleTransportRendererFactory(logger12) {\n      return Object.assign(transport, {\n        format: \"{h}:{i}:{s}.{ms}{scope} \\u203A {text}\",\n        transforms: [formatDataFn],\n        writeFn({ message: { level, data } }) {\n          const consoleLogFn = consoleMethods[level] || consoleMethods.info;\n          setTimeout(() => consoleLogFn(...data));\n        }\n      });\n      function transport(message) {\n        transport.writeFn({\n          message: { ...message, data: transform({ logger: logger12, message, transport }) }\n        });\n      }\n    }\n    function formatDataFn({\n      data = [],\n      logger: logger12 = {},\n      message = {},\n      transport = {}\n    }) {\n      if (typeof transport.format === \"function\") {\n        return transport.format({\n          data,\n          level: message?.level || \"info\",\n          logger: logger12,\n          message,\n          transport\n        });\n      }\n      if (typeof transport.format !== \"string\") {\n        return data;\n      }\n      data.unshift(transport.format);\n      if (typeof data[1] === \"string\" && data[1].match(/%[1cdfiOos]/)) {\n        data = [`${data[0]}${data[1]}`, ...data.slice(2)];\n      }\n      const date = message.date || /* @__PURE__ */ new Date();\n      data[0] = data[0].replace(/\\{(\\w+)}/g, (substring, name) => {\n        switch (name) {\n          case \"level\":\n            return message.level;\n          case \"logId\":\n            return message.logId;\n          case \"scope\": {\n            const scope = message.scope || logger12.scope?.defaultLabel;\n            return scope ? ` (${scope})` : \"\";\n          }\n          case \"text\":\n            return \"\";\n          case \"y\":\n            return date.getFullYear().toString(10);\n          case \"m\":\n            return (date.getMonth() + 1).toString(10).padStart(2, \"0\");\n          case \"d\":\n            return date.getDate().toString(10).padStart(2, \"0\");\n          case \"h\":\n            return date.getHours().toString(10).padStart(2, \"0\");\n          case \"i\":\n            return date.getMinutes().toString(10).padStart(2, \"0\");\n          case \"s\":\n            return date.getSeconds().toString(10).padStart(2, \"0\");\n          case \"ms\":\n            return date.getMilliseconds().toString(10).padStart(3, \"0\");\n          case \"iso\":\n            return date.toISOString();\n          default:\n            return message.variables?.[name] || substring;\n        }\n      }).trim();\n      return data;\n    }\n  }\n});\n\n// node_modules/electron-log/src/renderer/lib/transports/ipc.js\nvar require_ipc = __commonJS({\n  \"node_modules/electron-log/src/renderer/lib/transports/ipc.js\"(exports2, module2) {\n    \"use strict\";\n    var { transform } = require_transform();\n    module2.exports = ipcTransportRendererFactory;\n    var RESTRICTED_TYPES = /* @__PURE__ */ new Set([Promise, WeakMap, WeakSet]);\n    function ipcTransportRendererFactory(logger12) {\n      return Object.assign(transport, {\n        depth: 5,\n        transforms: [serializeFn]\n      });\n      function transport(message) {\n        if (!window.__electronLog) {\n          logger12.processMessage(\n            {\n              data: [\"electron-log: logger isn't initialized in the main process\"],\n              level: \"error\"\n            },\n            { transports: [\"console\"] }\n          );\n          return;\n        }\n        try {\n          const serialized = transform({\n            initialData: message,\n            logger: logger12,\n            message,\n            transport\n          });\n          __electronLog.sendToMain(serialized);\n        } catch (e) {\n          logger12.transports.console({\n            data: [\"electronLog.transports.ipc\", e, \"data:\", message.data],\n            level: \"error\"\n          });\n        }\n      }\n    }\n    function isPrimitive(value) {\n      return Object(value) !== value;\n    }\n    function serializeFn({\n      data,\n      depth,\n      seen = /* @__PURE__ */ new WeakSet(),\n      transport = {}\n    } = {}) {\n      const actualDepth = depth || transport.depth || 5;\n      if (seen.has(data)) {\n        return \"[Circular]\";\n      }\n      if (actualDepth < 1) {\n        if (isPrimitive(data)) {\n          return data;\n        }\n        if (Array.isArray(data)) {\n          return \"[Array]\";\n        }\n        return `[${typeof data}]`;\n      }\n      if ([\"function\", \"symbol\"].includes(typeof data)) {\n        return data.toString();\n      }\n      if (isPrimitive(data)) {\n        return data;\n      }\n      if (RESTRICTED_TYPES.has(data.constructor)) {\n        return `[${data.constructor.name}]`;\n      }\n      if (Array.isArray(data)) {\n        return data.map((item) => serializeFn({\n          data: item,\n          depth: actualDepth - 1,\n          seen\n        }));\n      }\n      if (data instanceof Date) {\n        return data.toISOString();\n      }\n      if (data instanceof Error) {\n        return data.stack;\n      }\n      if (data instanceof Map) {\n        return new Map(\n          Array.from(data).map(([key, value]) => [\n            serializeFn({ data: key, depth: actualDepth - 1, seen }),\n            serializeFn({ data: value, depth: actualDepth - 1, seen })\n          ])\n        );\n      }\n      if (data instanceof Set) {\n        return new Set(\n          Array.from(data).map(\n            (val) => serializeFn({ data: val, depth: actualDepth - 1, seen })\n          )\n        );\n      }\n      seen.add(data);\n      return Object.fromEntries(\n        Object.entries(data).map(\n          ([key, value]) => [\n            key,\n            serializeFn({ data: value, depth: actualDepth - 1, seen })\n          ]\n        )\n      );\n    }\n  }\n});\n\n// node_modules/electron-log/src/renderer/index.js\nvar require_renderer = __commonJS({\n  \"node_modules/electron-log/src/renderer/index.js\"(exports2, module2) {\n    \"use strict\";\n    var Logger = require_Logger();\n    var RendererErrorHandler = require_RendererErrorHandler();\n    var transportConsole = require_console();\n    var transportIpc = require_ipc();\n    if (typeof process === \"object\" && process.type === \"browser\") {\n      console.warn(\n        \"electron-log/renderer is loaded in the main process. It could cause unexpected behaviour.\"\n      );\n    }\n    module2.exports = createLogger();\n    module2.exports.Logger = Logger;\n    module2.exports.default = module2.exports;\n    function createLogger() {\n      const logger12 = new Logger({\n        allowUnknownLevel: true,\n        errorHandler: new RendererErrorHandler(),\n        initializeFn: () => {\n        },\n        logId: \"default\",\n        transportFactories: {\n          console: transportConsole,\n          ipc: transportIpc\n        },\n        variables: {\n          processType: \"renderer\"\n        }\n      });\n      logger12.errorHandler.setOptions({\n        logFn({ error, errorName, showDialog }) {\n          logger12.transports.console({\n            data: [errorName, error].filter(Boolean),\n            level: \"error\"\n          });\n          logger12.transports.ipc({\n            cmd: \"errorHandler\",\n            error: {\n              cause: error?.cause,\n              code: error?.code,\n              name: error?.name,\n              message: error?.message,\n              stack: error?.stack\n            },\n            errorName,\n            logId: logger12.logId,\n            showDialog\n          });\n        }\n      });\n      if (typeof window === \"object\") {\n        window.addEventListener(\"message\", (event) => {\n          const { cmd, logId, ...message } = event.data || {};\n          const instance = Logger.getInstance({ logId });\n          if (cmd === \"message\") {\n            instance.processMessage(message, { transports: [\"console\"] });\n          }\n        });\n      }\n      return new Proxy(logger12, {\n        get(target, prop) {\n          if (typeof target[prop] !== \"undefined\") {\n            return target[prop];\n          }\n          return (...data) => logger12.logData(data, { level: prop });\n        }\n      });\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/packageJson.js\nvar require_packageJson = __commonJS({\n  \"node_modules/electron-log/src/node/packageJson.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require(\"fs\");\n    var path6 = require(\"path\");\n    module2.exports = {\n      findAndReadPackageJson,\n      tryReadJsonAt\n    };\n    function findAndReadPackageJson() {\n      return tryReadJsonAt(getMainModulePath()) || tryReadJsonAt(extractPathFromArgs()) || tryReadJsonAt(process.resourcesPath, \"app.asar\") || tryReadJsonAt(process.resourcesPath, \"app\") || tryReadJsonAt(process.cwd()) || { name: void 0, version: void 0 };\n    }\n    function tryReadJsonAt(...searchPaths) {\n      if (!searchPaths[0]) {\n        return void 0;\n      }\n      try {\n        const searchPath = path6.join(...searchPaths);\n        const fileName = findUp(\"package.json\", searchPath);\n        if (!fileName) {\n          return void 0;\n        }\n        const json = JSON.parse(fs4.readFileSync(fileName, \"utf8\"));\n        const name = json?.productName || json?.name;\n        if (!name || name.toLowerCase() === \"electron\") {\n          return void 0;\n        }\n        if (name) {\n          return { name, version: json?.version };\n        }\n        return void 0;\n      } catch (e) {\n        return void 0;\n      }\n    }\n    function findUp(fileName, cwd) {\n      let currentPath = cwd;\n      while (true) {\n        const parsedPath = path6.parse(currentPath);\n        const root = parsedPath.root;\n        const dir = parsedPath.dir;\n        if (fs4.existsSync(path6.join(currentPath, fileName))) {\n          return path6.resolve(path6.join(currentPath, fileName));\n        }\n        if (currentPath === root) {\n          return null;\n        }\n        currentPath = dir;\n      }\n    }\n    function extractPathFromArgs() {\n      const matchedArgs = process.argv.filter((arg) => {\n        return arg.indexOf(\"--user-data-dir=\") === 0;\n      });\n      if (matchedArgs.length === 0 || typeof matchedArgs[0] !== \"string\") {\n        return null;\n      }\n      const userDataDir = matchedArgs[0];\n      return userDataDir.replace(\"--user-data-dir=\", \"\");\n    }\n    function getMainModulePath() {\n      try {\n        return require.main?.filename;\n      } catch {\n        return void 0;\n      }\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/NodeExternalApi.js\nvar require_NodeExternalApi = __commonJS({\n  \"node_modules/electron-log/src/node/NodeExternalApi.js\"(exports2, module2) {\n    \"use strict\";\n    var childProcess = require(\"child_process\");\n    var os = require(\"os\");\n    var path6 = require(\"path\");\n    var packageJson = require_packageJson();\n    var NodeExternalApi = class {\n      appName = void 0;\n      appPackageJson = void 0;\n      platform = process.platform;\n      getAppLogPath(appName = this.getAppName()) {\n        if (this.platform === \"darwin\") {\n          return path6.join(this.getSystemPathHome(), \"Library/Logs\", appName);\n        }\n        return path6.join(this.getAppUserDataPath(appName), \"logs\");\n      }\n      getAppName() {\n        const appName = this.appName || this.getAppPackageJson()?.name;\n        if (!appName) {\n          throw new Error(\n            \"electron-log can't determine the app name. It tried these methods:\\n1. Use `electron.app.name`\\n2. Use productName or name from the nearest package.json`\\nYou can also set it through log.transports.file.setAppName()\"\n          );\n        }\n        return appName;\n      }\n      /**\n       * @private\n       * @returns {undefined}\n       */\n      getAppPackageJson() {\n        if (typeof this.appPackageJson !== \"object\") {\n          this.appPackageJson = packageJson.findAndReadPackageJson();\n        }\n        return this.appPackageJson;\n      }\n      getAppUserDataPath(appName = this.getAppName()) {\n        return appName ? path6.join(this.getSystemPathAppData(), appName) : void 0;\n      }\n      getAppVersion() {\n        return this.getAppPackageJson()?.version;\n      }\n      getElectronLogPath() {\n        return this.getAppLogPath();\n      }\n      getMacOsVersion() {\n        const release = Number(os.release().split(\".\")[0]);\n        if (release <= 19) {\n          return `10.${release - 4}`;\n        }\n        return release - 9;\n      }\n      /**\n       * @protected\n       * @returns {string}\n       */\n      getOsVersion() {\n        let osName = os.type().replace(\"_\", \" \");\n        let osVersion = os.release();\n        if (osName === \"Darwin\") {\n          osName = \"macOS\";\n          osVersion = this.getMacOsVersion();\n        }\n        return `${osName} ${osVersion}`;\n      }\n      /**\n       * @return {PathVariables}\n       */\n      getPathVariables() {\n        const appName = this.getAppName();\n        const appVersion = this.getAppVersion();\n        const self2 = this;\n        return {\n          appData: this.getSystemPathAppData(),\n          appName,\n          appVersion,\n          get electronDefaultDir() {\n            return self2.getElectronLogPath();\n          },\n          home: this.getSystemPathHome(),\n          libraryDefaultDir: this.getAppLogPath(appName),\n          libraryTemplate: this.getAppLogPath(\"{appName}\"),\n          temp: this.getSystemPathTemp(),\n          userData: this.getAppUserDataPath(appName)\n        };\n      }\n      getSystemPathAppData() {\n        const home = this.getSystemPathHome();\n        switch (this.platform) {\n          case \"darwin\": {\n            return path6.join(home, \"Library/Application Support\");\n          }\n          case \"win32\": {\n            return process.env.APPDATA || path6.join(home, \"AppData/Roaming\");\n          }\n          default: {\n            return process.env.XDG_CONFIG_HOME || path6.join(home, \".config\");\n          }\n        }\n      }\n      getSystemPathHome() {\n        return os.homedir?.() || process.env.HOME;\n      }\n      getSystemPathTemp() {\n        return os.tmpdir();\n      }\n      getVersions() {\n        return {\n          app: `${this.getAppName()} ${this.getAppVersion()}`,\n          electron: void 0,\n          os: this.getOsVersion()\n        };\n      }\n      isDev() {\n        return process.env.NODE_ENV === \"development\" || process.env.ELECTRON_IS_DEV === \"1\";\n      }\n      isElectron() {\n        return Boolean(process.versions.electron);\n      }\n      onAppEvent(_eventName, _handler) {\n      }\n      onAppReady(handler) {\n        handler();\n      }\n      onEveryWebContentsEvent(eventName, handler) {\n      }\n      /**\n       * Listen to async messages sent from opposite process\n       * @param {string} channel\n       * @param {function} listener\n       */\n      onIpc(channel, listener) {\n      }\n      onIpcInvoke(channel, listener) {\n      }\n      /**\n       * @param {string} url\n       * @param {Function} [logFunction]\n       */\n      openUrl(url, logFunction = console.error) {\n        const startMap = { darwin: \"open\", win32: \"start\", linux: \"xdg-open\" };\n        const start = startMap[process.platform] || \"xdg-open\";\n        childProcess.exec(`${start} ${url}`, {}, (err) => {\n          if (err) {\n            logFunction(err);\n          }\n        });\n      }\n      setAppName(appName) {\n        this.appName = appName;\n      }\n      setPlatform(platform) {\n        this.platform = platform;\n      }\n      setPreloadFileForSessions({\n        filePath,\n        // eslint-disable-line no-unused-vars\n        includeFutureSession = true,\n        // eslint-disable-line no-unused-vars\n        getSessions = () => []\n        // eslint-disable-line no-unused-vars\n      }) {\n      }\n      /**\n       * Sent a message to opposite process\n       * @param {string} channel\n       * @param {any} message\n       */\n      sendIpc(channel, message) {\n      }\n      showErrorBox(title, message) {\n      }\n    };\n    module2.exports = NodeExternalApi;\n  }\n});\n\n// node_modules/electron-log/src/main/ElectronExternalApi.js\nvar require_ElectronExternalApi = __commonJS({\n  \"node_modules/electron-log/src/main/ElectronExternalApi.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    var NodeExternalApi = require_NodeExternalApi();\n    var ElectronExternalApi = class extends NodeExternalApi {\n      /**\n       * @type {typeof Electron}\n       */\n      electron = void 0;\n      /**\n       * @param {object} options\n       * @param {typeof Electron} [options.electron]\n       */\n      constructor({ electron } = {}) {\n        super();\n        this.electron = electron;\n      }\n      getAppName() {\n        let appName;\n        try {\n          appName = this.appName || this.electron.app?.name || this.electron.app?.getName();\n        } catch {\n        }\n        return appName || super.getAppName();\n      }\n      getAppUserDataPath(appName) {\n        return this.getPath(\"userData\") || super.getAppUserDataPath(appName);\n      }\n      getAppVersion() {\n        let appVersion;\n        try {\n          appVersion = this.electron.app?.getVersion();\n        } catch {\n        }\n        return appVersion || super.getAppVersion();\n      }\n      getElectronLogPath() {\n        return this.getPath(\"logs\") || super.getElectronLogPath();\n      }\n      /**\n       * @private\n       * @param {any} name\n       * @returns {string|undefined}\n       */\n      getPath(name) {\n        try {\n          return this.electron.app?.getPath(name);\n        } catch {\n          return void 0;\n        }\n      }\n      getVersions() {\n        return {\n          app: `${this.getAppName()} ${this.getAppVersion()}`,\n          electron: `Electron ${process.versions.electron}`,\n          os: this.getOsVersion()\n        };\n      }\n      getSystemPathAppData() {\n        return this.getPath(\"appData\") || super.getSystemPathAppData();\n      }\n      isDev() {\n        if (this.electron.app?.isPackaged !== void 0) {\n          return !this.electron.app.isPackaged;\n        }\n        if (typeof process.execPath === \"string\") {\n          const execFileName = path6.basename(process.execPath).toLowerCase();\n          return execFileName.startsWith(\"electron\");\n        }\n        return super.isDev();\n      }\n      onAppEvent(eventName, handler) {\n        this.electron.app?.on(eventName, handler);\n        return () => {\n          this.electron.app?.off(eventName, handler);\n        };\n      }\n      onAppReady(handler) {\n        if (this.electron.app?.isReady()) {\n          handler();\n        } else if (this.electron.app?.once) {\n          this.electron.app?.once(\"ready\", handler);\n        } else {\n          handler();\n        }\n      }\n      onEveryWebContentsEvent(eventName, handler) {\n        this.electron.webContents?.getAllWebContents()?.forEach((webContents) => {\n          webContents.on(eventName, handler);\n        });\n        this.electron.app?.on(\"web-contents-created\", onWebContentsCreated);\n        return () => {\n          this.electron.webContents?.getAllWebContents().forEach((webContents) => {\n            webContents.off(eventName, handler);\n          });\n          this.electron.app?.off(\"web-contents-created\", onWebContentsCreated);\n        };\n        function onWebContentsCreated(_, webContents) {\n          webContents.on(eventName, handler);\n        }\n      }\n      /**\n       * Listen to async messages sent from opposite process\n       * @param {string} channel\n       * @param {function} listener\n       */\n      onIpc(channel, listener) {\n        this.electron.ipcMain?.on(channel, listener);\n      }\n      onIpcInvoke(channel, listener) {\n        this.electron.ipcMain?.handle?.(channel, listener);\n      }\n      /**\n       * @param {string} url\n       * @param {Function} [logFunction]\n       */\n      openUrl(url, logFunction = console.error) {\n        this.electron.shell?.openExternal(url).catch(logFunction);\n      }\n      setPreloadFileForSessions({\n        filePath,\n        includeFutureSession = true,\n        getSessions = () => [this.electron.session?.defaultSession]\n      }) {\n        for (const session of getSessions().filter(Boolean)) {\n          setPreload(session);\n        }\n        if (includeFutureSession) {\n          this.onAppEvent(\"session-created\", (session) => {\n            setPreload(session);\n          });\n        }\n        function setPreload(session) {\n          if (typeof session.registerPreloadScript === \"function\") {\n            session.registerPreloadScript({\n              filePath,\n              id: \"electron-log-preload\",\n              type: \"frame\"\n            });\n          } else {\n            session.setPreloads([...session.getPreloads(), filePath]);\n          }\n        }\n      }\n      /**\n       * Sent a message to opposite process\n       * @param {string} channel\n       * @param {any} message\n       */\n      sendIpc(channel, message) {\n        this.electron.BrowserWindow?.getAllWindows()?.forEach((wnd) => {\n          if (wnd.webContents?.isDestroyed() === false && wnd.webContents?.isCrashed() === false) {\n            wnd.webContents.send(channel, message);\n          }\n        });\n      }\n      showErrorBox(title, message) {\n        this.electron.dialog?.showErrorBox(title, message);\n      }\n    };\n    module2.exports = ElectronExternalApi;\n  }\n});\n\n// node_modules/electron-log/src/main/initialize.js\nvar require_initialize = __commonJS({\n  \"node_modules/electron-log/src/main/initialize.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require(\"fs\");\n    var os = require(\"os\");\n    var path6 = require(\"path\");\n    var preloadInitializeFn = require_electron_log_preload();\n    var preloadInitialized = false;\n    var spyConsoleInitialized = false;\n    module2.exports = {\n      initialize({\n        externalApi,\n        getSessions,\n        includeFutureSession,\n        logger: logger12,\n        preload = true,\n        spyRendererConsole = false\n      }) {\n        externalApi.onAppReady(() => {\n          try {\n            if (preload) {\n              initializePreload({\n                externalApi,\n                getSessions,\n                includeFutureSession,\n                logger: logger12,\n                preloadOption: preload\n              });\n            }\n            if (spyRendererConsole) {\n              initializeSpyRendererConsole({ externalApi, logger: logger12 });\n            }\n          } catch (err) {\n            logger12.warn(err);\n          }\n        });\n      }\n    };\n    function initializePreload({\n      externalApi,\n      getSessions,\n      includeFutureSession,\n      logger: logger12,\n      preloadOption\n    }) {\n      let preloadPath = typeof preloadOption === \"string\" ? preloadOption : void 0;\n      if (preloadInitialized) {\n        logger12.warn(new Error(\"log.initialize({ preload }) already called\").stack);\n        return;\n      }\n      preloadInitialized = true;\n      try {\n        preloadPath = path6.resolve(\n          __dirname,\n          \"../renderer/electron-log-preload.js\"\n        );\n      } catch {\n      }\n      if (!preloadPath || !fs4.existsSync(preloadPath)) {\n        preloadPath = path6.join(\n          externalApi.getAppUserDataPath() || os.tmpdir(),\n          \"electron-log-preload.js\"\n        );\n        const preloadCode = `\n      try {\n        (${preloadInitializeFn.toString()})(require('electron'));\n      } catch(e) {\n        console.error(e);\n      }\n    `;\n        fs4.writeFileSync(preloadPath, preloadCode, \"utf8\");\n      }\n      externalApi.setPreloadFileForSessions({\n        filePath: preloadPath,\n        includeFutureSession,\n        getSessions\n      });\n    }\n    function initializeSpyRendererConsole({ externalApi, logger: logger12 }) {\n      if (spyConsoleInitialized) {\n        logger12.warn(\n          new Error(\"log.initialize({ spyRendererConsole }) already called\").stack\n        );\n        return;\n      }\n      spyConsoleInitialized = true;\n      const levels = [\"debug\", \"info\", \"warn\", \"error\"];\n      externalApi.onEveryWebContentsEvent(\n        \"console-message\",\n        (event, level, message) => {\n          logger12.processMessage({\n            data: [message],\n            level: levels[level],\n            variables: { processType: \"renderer\" }\n          });\n        }\n      );\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/ErrorHandler.js\nvar require_ErrorHandler = __commonJS({\n  \"node_modules/electron-log/src/node/ErrorHandler.js\"(exports2, module2) {\n    \"use strict\";\n    var ErrorHandler = class {\n      externalApi = void 0;\n      isActive = false;\n      logFn = void 0;\n      onError = void 0;\n      showDialog = true;\n      constructor({\n        externalApi,\n        logFn = void 0,\n        onError = void 0,\n        showDialog = void 0\n      } = {}) {\n        this.createIssue = this.createIssue.bind(this);\n        this.handleError = this.handleError.bind(this);\n        this.handleRejection = this.handleRejection.bind(this);\n        this.setOptions({ externalApi, logFn, onError, showDialog });\n        this.startCatching = this.startCatching.bind(this);\n        this.stopCatching = this.stopCatching.bind(this);\n      }\n      handle(error, {\n        logFn = this.logFn,\n        onError = this.onError,\n        processType = \"browser\",\n        showDialog = this.showDialog,\n        errorName = \"\"\n      } = {}) {\n        error = normalizeError(error);\n        try {\n          if (typeof onError === \"function\") {\n            const versions = this.externalApi?.getVersions() || {};\n            const createIssue = this.createIssue;\n            const result = onError({\n              createIssue,\n              error,\n              errorName,\n              processType,\n              versions\n            });\n            if (result === false) {\n              return;\n            }\n          }\n          errorName ? logFn(errorName, error) : logFn(error);\n          if (showDialog && !errorName.includes(\"rejection\") && this.externalApi) {\n            this.externalApi.showErrorBox(\n              `A JavaScript error occurred in the ${processType} process`,\n              error.stack\n            );\n          }\n        } catch {\n          console.error(error);\n        }\n      }\n      setOptions({ externalApi, logFn, onError, showDialog }) {\n        if (typeof externalApi === \"object\") {\n          this.externalApi = externalApi;\n        }\n        if (typeof logFn === \"function\") {\n          this.logFn = logFn;\n        }\n        if (typeof onError === \"function\") {\n          this.onError = onError;\n        }\n        if (typeof showDialog === \"boolean\") {\n          this.showDialog = showDialog;\n        }\n      }\n      startCatching({ onError, showDialog } = {}) {\n        if (this.isActive) {\n          return;\n        }\n        this.isActive = true;\n        this.setOptions({ onError, showDialog });\n        process.on(\"uncaughtException\", this.handleError);\n        process.on(\"unhandledRejection\", this.handleRejection);\n      }\n      stopCatching() {\n        this.isActive = false;\n        process.removeListener(\"uncaughtException\", this.handleError);\n        process.removeListener(\"unhandledRejection\", this.handleRejection);\n      }\n      createIssue(pageUrl, queryParams) {\n        this.externalApi?.openUrl(\n          `${pageUrl}?${new URLSearchParams(queryParams).toString()}`\n        );\n      }\n      handleError(error) {\n        this.handle(error, { errorName: \"Unhandled\" });\n      }\n      handleRejection(reason) {\n        const error = reason instanceof Error ? reason : new Error(JSON.stringify(reason));\n        this.handle(error, { errorName: \"Unhandled rejection\" });\n      }\n    };\n    function normalizeError(e) {\n      if (e instanceof Error) {\n        return e;\n      }\n      if (e && typeof e === \"object\") {\n        if (e.message) {\n          return Object.assign(new Error(e.message), e);\n        }\n        try {\n          return new Error(JSON.stringify(e));\n        } catch (serErr) {\n          return new Error(`Couldn't normalize error ${String(e)}: ${serErr}`);\n        }\n      }\n      return new Error(`Can't normalize error ${String(e)}`);\n    }\n    module2.exports = ErrorHandler;\n  }\n});\n\n// node_modules/electron-log/src/node/EventLogger.js\nvar require_EventLogger = __commonJS({\n  \"node_modules/electron-log/src/node/EventLogger.js\"(exports2, module2) {\n    \"use strict\";\n    var EventLogger = class {\n      disposers = [];\n      format = \"{eventSource}#{eventName}:\";\n      formatters = {\n        app: {\n          \"certificate-error\": ({ args }) => {\n            return this.arrayToObject(args.slice(1, 4), [\n              \"url\",\n              \"error\",\n              \"certificate\"\n            ]);\n          },\n          \"child-process-gone\": ({ args }) => {\n            return args.length === 1 ? args[0] : args;\n          },\n          \"render-process-gone\": ({ args: [webContents, details] }) => {\n            return details && typeof details === \"object\" ? { ...details, ...this.getWebContentsDetails(webContents) } : [];\n          }\n        },\n        webContents: {\n          \"console-message\": ({ args: [level, message, line, sourceId] }) => {\n            if (level < 3) {\n              return void 0;\n            }\n            return { message, source: `${sourceId}:${line}` };\n          },\n          \"did-fail-load\": ({ args }) => {\n            return this.arrayToObject(args, [\n              \"errorCode\",\n              \"errorDescription\",\n              \"validatedURL\",\n              \"isMainFrame\",\n              \"frameProcessId\",\n              \"frameRoutingId\"\n            ]);\n          },\n          \"did-fail-provisional-load\": ({ args }) => {\n            return this.arrayToObject(args, [\n              \"errorCode\",\n              \"errorDescription\",\n              \"validatedURL\",\n              \"isMainFrame\",\n              \"frameProcessId\",\n              \"frameRoutingId\"\n            ]);\n          },\n          \"plugin-crashed\": ({ args }) => {\n            return this.arrayToObject(args, [\"name\", \"version\"]);\n          },\n          \"preload-error\": ({ args }) => {\n            return this.arrayToObject(args, [\"preloadPath\", \"error\"]);\n          }\n        }\n      };\n      events = {\n        app: {\n          \"certificate-error\": true,\n          \"child-process-gone\": true,\n          \"render-process-gone\": true\n        },\n        webContents: {\n          // 'console-message': true,\n          \"did-fail-load\": true,\n          \"did-fail-provisional-load\": true,\n          \"plugin-crashed\": true,\n          \"preload-error\": true,\n          \"unresponsive\": true\n        }\n      };\n      externalApi = void 0;\n      level = \"error\";\n      scope = \"\";\n      constructor(options = {}) {\n        this.setOptions(options);\n      }\n      setOptions({\n        events,\n        externalApi,\n        level,\n        logger: logger12,\n        format,\n        formatters,\n        scope\n      }) {\n        if (typeof events === \"object\") {\n          this.events = events;\n        }\n        if (typeof externalApi === \"object\") {\n          this.externalApi = externalApi;\n        }\n        if (typeof level === \"string\") {\n          this.level = level;\n        }\n        if (typeof logger12 === \"object\") {\n          this.logger = logger12;\n        }\n        if (typeof format === \"string\" || typeof format === \"function\") {\n          this.format = format;\n        }\n        if (typeof formatters === \"object\") {\n          this.formatters = formatters;\n        }\n        if (typeof scope === \"string\") {\n          this.scope = scope;\n        }\n      }\n      startLogging(options = {}) {\n        this.setOptions(options);\n        this.disposeListeners();\n        for (const eventName of this.getEventNames(this.events.app)) {\n          this.disposers.push(\n            this.externalApi.onAppEvent(eventName, (...handlerArgs) => {\n              this.handleEvent({ eventSource: \"app\", eventName, handlerArgs });\n            })\n          );\n        }\n        for (const eventName of this.getEventNames(this.events.webContents)) {\n          this.disposers.push(\n            this.externalApi.onEveryWebContentsEvent(\n              eventName,\n              (...handlerArgs) => {\n                this.handleEvent(\n                  { eventSource: \"webContents\", eventName, handlerArgs }\n                );\n              }\n            )\n          );\n        }\n      }\n      stopLogging() {\n        this.disposeListeners();\n      }\n      arrayToObject(array, fieldNames) {\n        const obj = {};\n        fieldNames.forEach((fieldName, index) => {\n          obj[fieldName] = array[index];\n        });\n        if (array.length > fieldNames.length) {\n          obj.unknownArgs = array.slice(fieldNames.length);\n        }\n        return obj;\n      }\n      disposeListeners() {\n        this.disposers.forEach((disposer) => disposer());\n        this.disposers = [];\n      }\n      formatEventLog({ eventName, eventSource, handlerArgs }) {\n        const [event, ...args] = handlerArgs;\n        if (typeof this.format === \"function\") {\n          return this.format({ args, event, eventName, eventSource });\n        }\n        const formatter = this.formatters[eventSource]?.[eventName];\n        let formattedArgs = args;\n        if (typeof formatter === \"function\") {\n          formattedArgs = formatter({ args, event, eventName, eventSource });\n        }\n        if (!formattedArgs) {\n          return void 0;\n        }\n        const eventData = {};\n        if (Array.isArray(formattedArgs)) {\n          eventData.args = formattedArgs;\n        } else if (typeof formattedArgs === \"object\") {\n          Object.assign(eventData, formattedArgs);\n        }\n        if (eventSource === \"webContents\") {\n          Object.assign(eventData, this.getWebContentsDetails(event?.sender));\n        }\n        const title = this.format.replace(\"{eventSource}\", eventSource === \"app\" ? \"App\" : \"WebContents\").replace(\"{eventName}\", eventName);\n        return [title, eventData];\n      }\n      getEventNames(eventMap) {\n        if (!eventMap || typeof eventMap !== \"object\") {\n          return [];\n        }\n        return Object.entries(eventMap).filter(([_, listen]) => listen).map(([eventName]) => eventName);\n      }\n      getWebContentsDetails(webContents) {\n        if (!webContents?.loadURL) {\n          return {};\n        }\n        try {\n          return {\n            webContents: {\n              id: webContents.id,\n              url: webContents.getURL()\n            }\n          };\n        } catch {\n          return {};\n        }\n      }\n      handleEvent({ eventName, eventSource, handlerArgs }) {\n        const log12 = this.formatEventLog({ eventName, eventSource, handlerArgs });\n        if (log12) {\n          const logFns = this.scope ? this.logger.scope(this.scope) : this.logger;\n          logFns?.[this.level]?.(...log12);\n        }\n      }\n    };\n    module2.exports = EventLogger;\n  }\n});\n\n// node_modules/electron-log/src/core/transforms/format.js\nvar require_format = __commonJS({\n  \"node_modules/electron-log/src/core/transforms/format.js\"(exports2, module2) {\n    \"use strict\";\n    var { transform } = require_transform();\n    module2.exports = {\n      concatFirstStringElements,\n      formatScope,\n      formatText,\n      formatVariables,\n      timeZoneFromOffset,\n      format({ message, logger: logger12, transport, data = message?.data }) {\n        switch (typeof transport.format) {\n          case \"string\": {\n            return transform({\n              message,\n              logger: logger12,\n              transforms: [formatVariables, formatScope, formatText],\n              transport,\n              initialData: [transport.format, ...data]\n            });\n          }\n          case \"function\": {\n            return transport.format({\n              data,\n              level: message?.level || \"info\",\n              logger: logger12,\n              message,\n              transport\n            });\n          }\n          default: {\n            return data;\n          }\n        }\n      }\n    };\n    function concatFirstStringElements({ data }) {\n      if (typeof data[0] !== \"string\" || typeof data[1] !== \"string\") {\n        return data;\n      }\n      if (data[0].match(/%[1cdfiOos]/)) {\n        return data;\n      }\n      return [`${data[0]} ${data[1]}`, ...data.slice(2)];\n    }\n    function timeZoneFromOffset(minutesOffset) {\n      const minutesPositive = Math.abs(minutesOffset);\n      const sign = minutesOffset > 0 ? \"-\" : \"+\";\n      const hours = Math.floor(minutesPositive / 60).toString().padStart(2, \"0\");\n      const minutes = (minutesPositive % 60).toString().padStart(2, \"0\");\n      return `${sign}${hours}:${minutes}`;\n    }\n    function formatScope({ data, logger: logger12, message }) {\n      const { defaultLabel, labelLength } = logger12?.scope || {};\n      const template = data[0];\n      let label = message.scope;\n      if (!label) {\n        label = defaultLabel;\n      }\n      let scopeText;\n      if (label === \"\") {\n        scopeText = labelLength > 0 ? \"\".padEnd(labelLength + 3) : \"\";\n      } else if (typeof label === \"string\") {\n        scopeText = ` (${label})`.padEnd(labelLength + 3);\n      } else {\n        scopeText = \"\";\n      }\n      data[0] = template.replace(\"{scope}\", scopeText);\n      return data;\n    }\n    function formatVariables({ data, message }) {\n      let template = data[0];\n      if (typeof template !== \"string\") {\n        return data;\n      }\n      template = template.replace(\"{level}]\", `${message.level}]`.padEnd(6, \" \"));\n      const date = message.date || /* @__PURE__ */ new Date();\n      data[0] = template.replace(/\\{(\\w+)}/g, (substring, name) => {\n        switch (name) {\n          case \"level\":\n            return message.level || \"info\";\n          case \"logId\":\n            return message.logId;\n          case \"y\":\n            return date.getFullYear().toString(10);\n          case \"m\":\n            return (date.getMonth() + 1).toString(10).padStart(2, \"0\");\n          case \"d\":\n            return date.getDate().toString(10).padStart(2, \"0\");\n          case \"h\":\n            return date.getHours().toString(10).padStart(2, \"0\");\n          case \"i\":\n            return date.getMinutes().toString(10).padStart(2, \"0\");\n          case \"s\":\n            return date.getSeconds().toString(10).padStart(2, \"0\");\n          case \"ms\":\n            return date.getMilliseconds().toString(10).padStart(3, \"0\");\n          case \"z\":\n            return timeZoneFromOffset(date.getTimezoneOffset());\n          case \"iso\":\n            return date.toISOString();\n          default: {\n            return message.variables?.[name] || substring;\n          }\n        }\n      }).trim();\n      return data;\n    }\n    function formatText({ data }) {\n      const template = data[0];\n      if (typeof template !== \"string\") {\n        return data;\n      }\n      const textTplPosition = template.lastIndexOf(\"{text}\");\n      if (textTplPosition === template.length - 6) {\n        data[0] = template.replace(/\\s?{text}/, \"\");\n        if (data[0] === \"\") {\n          data.shift();\n        }\n        return data;\n      }\n      const templatePieces = template.split(\"{text}\");\n      let result = [];\n      if (templatePieces[0] !== \"\") {\n        result.push(templatePieces[0]);\n      }\n      result = result.concat(data.slice(1));\n      if (templatePieces[1] !== \"\") {\n        result.push(templatePieces[1]);\n      }\n      return result;\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/transforms/object.js\nvar require_object = __commonJS({\n  \"node_modules/electron-log/src/node/transforms/object.js\"(exports2, module2) {\n    \"use strict\";\n    var util = require(\"util\");\n    module2.exports = {\n      serialize,\n      maxDepth({ data, transport, depth = transport?.depth ?? 6 }) {\n        if (!data) {\n          return data;\n        }\n        if (depth < 1) {\n          if (Array.isArray(data)) return \"[array]\";\n          if (typeof data === \"object\" && data) return \"[object]\";\n          return data;\n        }\n        if (Array.isArray(data)) {\n          return data.map((child) => module2.exports.maxDepth({\n            data: child,\n            depth: depth - 1\n          }));\n        }\n        if (typeof data !== \"object\") {\n          return data;\n        }\n        if (data && typeof data.toISOString === \"function\") {\n          return data;\n        }\n        if (data === null) {\n          return null;\n        }\n        if (data instanceof Error) {\n          return data;\n        }\n        const newJson = {};\n        for (const i in data) {\n          if (!Object.prototype.hasOwnProperty.call(data, i)) continue;\n          newJson[i] = module2.exports.maxDepth({\n            data: data[i],\n            depth: depth - 1\n          });\n        }\n        return newJson;\n      },\n      toJSON({ data }) {\n        return JSON.parse(JSON.stringify(data, createSerializer()));\n      },\n      toString({ data, transport }) {\n        const inspectOptions = transport?.inspectOptions || {};\n        const simplifiedData = data.map((item) => {\n          if (item === void 0) {\n            return void 0;\n          }\n          try {\n            const str = JSON.stringify(item, createSerializer(), \"  \");\n            return str === void 0 ? void 0 : JSON.parse(str);\n          } catch (e) {\n            return item;\n          }\n        });\n        return util.formatWithOptions(inspectOptions, ...simplifiedData);\n      }\n    };\n    function createSerializer(options = {}) {\n      const seen = /* @__PURE__ */ new WeakSet();\n      return function(key, value) {\n        if (typeof value === \"object\" && value !== null) {\n          if (seen.has(value)) {\n            return void 0;\n          }\n          seen.add(value);\n        }\n        return serialize(key, value, options);\n      };\n    }\n    function serialize(key, value, options = {}) {\n      const serializeMapAndSet = options?.serializeMapAndSet !== false;\n      if (value instanceof Error) {\n        return value.stack;\n      }\n      if (!value) {\n        return value;\n      }\n      if (typeof value === \"function\") {\n        return `[function] ${value.toString()}`;\n      }\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n      if (serializeMapAndSet && value instanceof Map && Object.fromEntries) {\n        return Object.fromEntries(value);\n      }\n      if (serializeMapAndSet && value instanceof Set && Array.from) {\n        return Array.from(value);\n      }\n      return value;\n    }\n  }\n});\n\n// node_modules/electron-log/src/core/transforms/style.js\nvar require_style = __commonJS({\n  \"node_modules/electron-log/src/core/transforms/style.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {\n      transformStyles,\n      applyAnsiStyles({ data }) {\n        return transformStyles(data, styleToAnsi, resetAnsiStyle);\n      },\n      removeStyles({ data }) {\n        return transformStyles(data, () => \"\");\n      }\n    };\n    var ANSI_COLORS = {\n      unset: \"\\x1B[0m\",\n      black: \"\\x1B[30m\",\n      red: \"\\x1B[31m\",\n      green: \"\\x1B[32m\",\n      yellow: \"\\x1B[33m\",\n      blue: \"\\x1B[34m\",\n      magenta: \"\\x1B[35m\",\n      cyan: \"\\x1B[36m\",\n      white: \"\\x1B[37m\",\n      gray: \"\\x1B[90m\"\n    };\n    function styleToAnsi(style) {\n      const color = style.replace(/color:\\s*(\\w+).*/, \"$1\").toLowerCase();\n      return ANSI_COLORS[color] || \"\";\n    }\n    function resetAnsiStyle(string) {\n      return string + ANSI_COLORS.unset;\n    }\n    function transformStyles(data, onStyleFound, onStyleApplied) {\n      const foundStyles = {};\n      return data.reduce((result, item, index, array) => {\n        if (foundStyles[index]) {\n          return result;\n        }\n        if (typeof item === \"string\") {\n          let valueIndex = index;\n          let styleApplied = false;\n          item = item.replace(/%[1cdfiOos]/g, (match) => {\n            valueIndex += 1;\n            if (match !== \"%c\") {\n              return match;\n            }\n            const style = array[valueIndex];\n            if (typeof style === \"string\") {\n              foundStyles[valueIndex] = true;\n              styleApplied = true;\n              return onStyleFound(style, item);\n            }\n            return match;\n          });\n          if (styleApplied && onStyleApplied) {\n            item = onStyleApplied(item);\n          }\n        }\n        result.push(item);\n        return result;\n      }, []);\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/transports/console.js\nvar require_console2 = __commonJS({\n  \"node_modules/electron-log/src/node/transports/console.js\"(exports2, module2) {\n    \"use strict\";\n    var {\n      concatFirstStringElements,\n      format\n    } = require_format();\n    var { maxDepth, toJSON } = require_object();\n    var {\n      applyAnsiStyles,\n      removeStyles\n    } = require_style();\n    var { transform } = require_transform();\n    var consoleMethods = {\n      error: console.error,\n      warn: console.warn,\n      info: console.info,\n      verbose: console.info,\n      debug: console.debug,\n      silly: console.debug,\n      log: console.log\n    };\n    module2.exports = consoleTransportFactory;\n    var separator = process.platform === \"win32\" ? \">\" : \"\\u203A\";\n    var DEFAULT_FORMAT = `%c{h}:{i}:{s}.{ms}{scope}%c ${separator} {text}`;\n    Object.assign(consoleTransportFactory, {\n      DEFAULT_FORMAT\n    });\n    function consoleTransportFactory(logger12) {\n      return Object.assign(transport, {\n        colorMap: {\n          error: \"red\",\n          warn: \"yellow\",\n          info: \"cyan\",\n          verbose: \"unset\",\n          debug: \"gray\",\n          silly: \"gray\",\n          default: \"unset\"\n        },\n        format: DEFAULT_FORMAT,\n        level: \"silly\",\n        transforms: [\n          addTemplateColors,\n          format,\n          formatStyles,\n          concatFirstStringElements,\n          maxDepth,\n          toJSON\n        ],\n        useStyles: process.env.FORCE_STYLES,\n        writeFn({ message }) {\n          const consoleLogFn = consoleMethods[message.level] || consoleMethods.info;\n          consoleLogFn(...message.data);\n        }\n      });\n      function transport(message) {\n        const data = transform({ logger: logger12, message, transport });\n        transport.writeFn({\n          message: { ...message, data }\n        });\n      }\n    }\n    function addTemplateColors({ data, message, transport }) {\n      if (typeof transport.format !== \"string\" || !transport.format.includes(\"%c\")) {\n        return data;\n      }\n      return [\n        `color:${levelToStyle(message.level, transport)}`,\n        \"color:unset\",\n        ...data\n      ];\n    }\n    function canUseStyles(useStyleValue, level) {\n      if (typeof useStyleValue === \"boolean\") {\n        return useStyleValue;\n      }\n      const useStderr = level === \"error\" || level === \"warn\";\n      const stream = useStderr ? process.stderr : process.stdout;\n      return stream && stream.isTTY;\n    }\n    function formatStyles(args) {\n      const { message, transport } = args;\n      const useStyles = canUseStyles(transport.useStyles, message.level);\n      const nextTransform = useStyles ? applyAnsiStyles : removeStyles;\n      return nextTransform(args);\n    }\n    function levelToStyle(level, transport) {\n      return transport.colorMap[level] || transport.colorMap.default;\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/transports/file/File.js\nvar require_File = __commonJS({\n  \"node_modules/electron-log/src/node/transports/file/File.js\"(exports2, module2) {\n    \"use strict\";\n    var EventEmitter2 = require(\"events\");\n    var fs4 = require(\"fs\");\n    var os = require(\"os\");\n    var File = class extends EventEmitter2 {\n      asyncWriteQueue = [];\n      bytesWritten = 0;\n      hasActiveAsyncWriting = false;\n      path = null;\n      initialSize = void 0;\n      writeOptions = null;\n      writeAsync = false;\n      constructor({\n        path: path6,\n        writeOptions = { encoding: \"utf8\", flag: \"a\", mode: 438 },\n        writeAsync = false\n      }) {\n        super();\n        this.path = path6;\n        this.writeOptions = writeOptions;\n        this.writeAsync = writeAsync;\n      }\n      get size() {\n        return this.getSize();\n      }\n      clear() {\n        try {\n          fs4.writeFileSync(this.path, \"\", {\n            mode: this.writeOptions.mode,\n            flag: \"w\"\n          });\n          this.reset();\n          return true;\n        } catch (e) {\n          if (e.code === \"ENOENT\") {\n            return true;\n          }\n          this.emit(\"error\", e, this);\n          return false;\n        }\n      }\n      crop(bytesAfter) {\n        try {\n          const content = readFileSyncFromEnd(this.path, bytesAfter || 4096);\n          this.clear();\n          this.writeLine(`[log cropped]${os.EOL}${content}`);\n        } catch (e) {\n          this.emit(\n            \"error\",\n            new Error(`Couldn't crop file ${this.path}. ${e.message}`),\n            this\n          );\n        }\n      }\n      getSize() {\n        if (this.initialSize === void 0) {\n          try {\n            const stats = fs4.statSync(this.path);\n            this.initialSize = stats.size;\n          } catch (e) {\n            this.initialSize = 0;\n          }\n        }\n        return this.initialSize + this.bytesWritten;\n      }\n      increaseBytesWrittenCounter(text) {\n        this.bytesWritten += Buffer.byteLength(text, this.writeOptions.encoding);\n      }\n      isNull() {\n        return false;\n      }\n      nextAsyncWrite() {\n        const file = this;\n        if (this.hasActiveAsyncWriting || this.asyncWriteQueue.length === 0) {\n          return;\n        }\n        const text = this.asyncWriteQueue.join(\"\");\n        this.asyncWriteQueue = [];\n        this.hasActiveAsyncWriting = true;\n        fs4.writeFile(this.path, text, this.writeOptions, (e) => {\n          file.hasActiveAsyncWriting = false;\n          if (e) {\n            file.emit(\n              \"error\",\n              new Error(`Couldn't write to ${file.path}. ${e.message}`),\n              this\n            );\n          } else {\n            file.increaseBytesWrittenCounter(text);\n          }\n          file.nextAsyncWrite();\n        });\n      }\n      reset() {\n        this.initialSize = void 0;\n        this.bytesWritten = 0;\n      }\n      toString() {\n        return this.path;\n      }\n      writeLine(text) {\n        text += os.EOL;\n        if (this.writeAsync) {\n          this.asyncWriteQueue.push(text);\n          this.nextAsyncWrite();\n          return;\n        }\n        try {\n          fs4.writeFileSync(this.path, text, this.writeOptions);\n          this.increaseBytesWrittenCounter(text);\n        } catch (e) {\n          this.emit(\n            \"error\",\n            new Error(`Couldn't write to ${this.path}. ${e.message}`),\n            this\n          );\n        }\n      }\n    };\n    module2.exports = File;\n    function readFileSyncFromEnd(filePath, bytesCount) {\n      const buffer = Buffer.alloc(bytesCount);\n      const stats = fs4.statSync(filePath);\n      const readLength = Math.min(stats.size, bytesCount);\n      const offset = Math.max(0, stats.size - bytesCount);\n      const fd = fs4.openSync(filePath, \"r\");\n      const totalBytes = fs4.readSync(fd, buffer, 0, readLength, offset);\n      fs4.closeSync(fd);\n      return buffer.toString(\"utf8\", 0, totalBytes);\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/transports/file/NullFile.js\nvar require_NullFile = __commonJS({\n  \"node_modules/electron-log/src/node/transports/file/NullFile.js\"(exports2, module2) {\n    \"use strict\";\n    var File = require_File();\n    var NullFile = class extends File {\n      clear() {\n      }\n      crop() {\n      }\n      getSize() {\n        return 0;\n      }\n      isNull() {\n        return true;\n      }\n      writeLine() {\n      }\n    };\n    module2.exports = NullFile;\n  }\n});\n\n// node_modules/electron-log/src/node/transports/file/FileRegistry.js\nvar require_FileRegistry = __commonJS({\n  \"node_modules/electron-log/src/node/transports/file/FileRegistry.js\"(exports2, module2) {\n    \"use strict\";\n    var EventEmitter2 = require(\"events\");\n    var fs4 = require(\"fs\");\n    var path6 = require(\"path\");\n    var File = require_File();\n    var NullFile = require_NullFile();\n    var FileRegistry = class extends EventEmitter2 {\n      store = {};\n      constructor() {\n        super();\n        this.emitError = this.emitError.bind(this);\n      }\n      /**\n       * Provide a File object corresponding to the filePath\n       * @param {string} filePath\n       * @param {WriteOptions} [writeOptions]\n       * @param {boolean} [writeAsync]\n       * @return {File}\n       */\n      provide({ filePath, writeOptions = {}, writeAsync = false }) {\n        let file;\n        try {\n          filePath = path6.resolve(filePath);\n          if (this.store[filePath]) {\n            return this.store[filePath];\n          }\n          file = this.createFile({ filePath, writeOptions, writeAsync });\n        } catch (e) {\n          file = new NullFile({ path: filePath });\n          this.emitError(e, file);\n        }\n        file.on(\"error\", this.emitError);\n        this.store[filePath] = file;\n        return file;\n      }\n      /**\n       * @param {string} filePath\n       * @param {WriteOptions} writeOptions\n       * @param {boolean} async\n       * @return {File}\n       * @private\n       */\n      createFile({ filePath, writeOptions, writeAsync }) {\n        this.testFileWriting({ filePath, writeOptions });\n        return new File({ path: filePath, writeOptions, writeAsync });\n      }\n      /**\n       * @param {Error} error\n       * @param {File} file\n       * @private\n       */\n      emitError(error, file) {\n        this.emit(\"error\", error, file);\n      }\n      /**\n       * @param {string} filePath\n       * @param {WriteOptions} writeOptions\n       * @private\n       */\n      testFileWriting({ filePath, writeOptions }) {\n        fs4.mkdirSync(path6.dirname(filePath), { recursive: true });\n        fs4.writeFileSync(filePath, \"\", { flag: \"a\", mode: writeOptions.mode });\n      }\n    };\n    module2.exports = FileRegistry;\n  }\n});\n\n// node_modules/electron-log/src/node/transports/file/index.js\nvar require_file2 = __commonJS({\n  \"node_modules/electron-log/src/node/transports/file/index.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require(\"fs\");\n    var os = require(\"os\");\n    var path6 = require(\"path\");\n    var FileRegistry = require_FileRegistry();\n    var { transform } = require_transform();\n    var { removeStyles } = require_style();\n    var {\n      format,\n      concatFirstStringElements\n    } = require_format();\n    var { toString } = require_object();\n    module2.exports = fileTransportFactory;\n    var globalRegistry = new FileRegistry();\n    function fileTransportFactory(logger12, { registry = globalRegistry, externalApi } = {}) {\n      let pathVariables;\n      if (registry.listenerCount(\"error\") < 1) {\n        registry.on(\"error\", (e, file) => {\n          logConsole(`Can't write to ${file}`, e);\n        });\n      }\n      return Object.assign(transport, {\n        fileName: getDefaultFileName(logger12.variables.processType),\n        format: \"[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}\",\n        getFile,\n        inspectOptions: { depth: 5 },\n        level: \"silly\",\n        maxSize: 1024 ** 2,\n        readAllLogs,\n        sync: true,\n        transforms: [removeStyles, format, concatFirstStringElements, toString],\n        writeOptions: { flag: \"a\", mode: 438, encoding: \"utf8\" },\n        archiveLogFn(file) {\n          const oldPath = file.toString();\n          const inf = path6.parse(oldPath);\n          try {\n            fs4.renameSync(oldPath, path6.join(inf.dir, `${inf.name}.old${inf.ext}`));\n          } catch (e) {\n            logConsole(\"Could not rotate log\", e);\n            const quarterOfMaxSize = Math.round(transport.maxSize / 4);\n            file.crop(Math.min(quarterOfMaxSize, 256 * 1024));\n          }\n        },\n        resolvePathFn(vars) {\n          return path6.join(vars.libraryDefaultDir, vars.fileName);\n        },\n        setAppName(name) {\n          logger12.dependencies.externalApi.setAppName(name);\n        }\n      });\n      function transport(message) {\n        const file = getFile(message);\n        const needLogRotation = transport.maxSize > 0 && file.size > transport.maxSize;\n        if (needLogRotation) {\n          transport.archiveLogFn(file);\n          file.reset();\n        }\n        const content = transform({ logger: logger12, message, transport });\n        file.writeLine(content);\n      }\n      function initializeOnFirstAccess() {\n        if (pathVariables) {\n          return;\n        }\n        pathVariables = Object.create(\n          Object.prototype,\n          {\n            ...Object.getOwnPropertyDescriptors(\n              externalApi.getPathVariables()\n            ),\n            fileName: {\n              get() {\n                return transport.fileName;\n              },\n              enumerable: true\n            }\n          }\n        );\n        if (typeof transport.archiveLog === \"function\") {\n          transport.archiveLogFn = transport.archiveLog;\n          logConsole(\"archiveLog is deprecated. Use archiveLogFn instead\");\n        }\n        if (typeof transport.resolvePath === \"function\") {\n          transport.resolvePathFn = transport.resolvePath;\n          logConsole(\"resolvePath is deprecated. Use resolvePathFn instead\");\n        }\n      }\n      function logConsole(message, error = null, level = \"error\") {\n        const data = [`electron-log.transports.file: ${message}`];\n        if (error) {\n          data.push(error);\n        }\n        logger12.transports.console({ data, date: /* @__PURE__ */ new Date(), level });\n      }\n      function getFile(msg) {\n        initializeOnFirstAccess();\n        const filePath = transport.resolvePathFn(pathVariables, msg);\n        return registry.provide({\n          filePath,\n          writeAsync: !transport.sync,\n          writeOptions: transport.writeOptions\n        });\n      }\n      function readAllLogs({ fileFilter = (f) => f.endsWith(\".log\") } = {}) {\n        initializeOnFirstAccess();\n        const logsPath = path6.dirname(transport.resolvePathFn(pathVariables));\n        if (!fs4.existsSync(logsPath)) {\n          return [];\n        }\n        return fs4.readdirSync(logsPath).map((fileName) => path6.join(logsPath, fileName)).filter(fileFilter).map((logPath) => {\n          try {\n            return {\n              path: logPath,\n              lines: fs4.readFileSync(logPath, \"utf8\").split(os.EOL)\n            };\n          } catch {\n            return null;\n          }\n        }).filter(Boolean);\n      }\n    }\n    function getDefaultFileName(processType = process.type) {\n      switch (processType) {\n        case \"renderer\":\n          return \"renderer.log\";\n        case \"worker\":\n          return \"worker.log\";\n        default:\n          return \"main.log\";\n      }\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/transports/ipc.js\nvar require_ipc2 = __commonJS({\n  \"node_modules/electron-log/src/node/transports/ipc.js\"(exports2, module2) {\n    \"use strict\";\n    var { maxDepth, toJSON } = require_object();\n    var { transform } = require_transform();\n    module2.exports = ipcTransportFactory;\n    function ipcTransportFactory(logger12, { externalApi }) {\n      Object.assign(transport, {\n        depth: 3,\n        eventId: \"__ELECTRON_LOG_IPC__\",\n        level: logger12.isDev ? \"silly\" : false,\n        transforms: [toJSON, maxDepth]\n      });\n      return externalApi?.isElectron() ? transport : void 0;\n      function transport(message) {\n        if (message?.variables?.processType === \"renderer\") {\n          return;\n        }\n        externalApi?.sendIpc(transport.eventId, {\n          ...message,\n          data: transform({ logger: logger12, message, transport })\n        });\n      }\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/transports/remote.js\nvar require_remote = __commonJS({\n  \"node_modules/electron-log/src/node/transports/remote.js\"(exports2, module2) {\n    \"use strict\";\n    var http = require(\"http\");\n    var https = require(\"https\");\n    var { transform } = require_transform();\n    var { removeStyles } = require_style();\n    var { toJSON, maxDepth } = require_object();\n    module2.exports = remoteTransportFactory;\n    function remoteTransportFactory(logger12) {\n      return Object.assign(transport, {\n        client: { name: \"electron-application\" },\n        depth: 6,\n        level: false,\n        requestOptions: {},\n        transforms: [removeStyles, toJSON, maxDepth],\n        makeBodyFn({ message }) {\n          return JSON.stringify({\n            client: transport.client,\n            data: message.data,\n            date: message.date.getTime(),\n            level: message.level,\n            scope: message.scope,\n            variables: message.variables\n          });\n        },\n        processErrorFn({ error }) {\n          logger12.processMessage(\n            {\n              data: [`electron-log: can't POST ${transport.url}`, error],\n              level: \"warn\"\n            },\n            { transports: [\"console\", \"file\"] }\n          );\n        },\n        sendRequestFn({ serverUrl, requestOptions, body }) {\n          const httpTransport = serverUrl.startsWith(\"https:\") ? https : http;\n          const request = httpTransport.request(serverUrl, {\n            method: \"POST\",\n            ...requestOptions,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Content-Length\": body.length,\n              ...requestOptions.headers\n            }\n          });\n          request.write(body);\n          request.end();\n          return request;\n        }\n      });\n      function transport(message) {\n        if (!transport.url) {\n          return;\n        }\n        const body = transport.makeBodyFn({\n          logger: logger12,\n          message: { ...message, data: transform({ logger: logger12, message, transport }) },\n          transport\n        });\n        const request = transport.sendRequestFn({\n          serverUrl: transport.url,\n          requestOptions: transport.requestOptions,\n          body: Buffer.from(body, \"utf8\")\n        });\n        request.on(\"error\", (error) => transport.processErrorFn({\n          error,\n          logger: logger12,\n          message,\n          request,\n          transport\n        }));\n      }\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/createDefaultLogger.js\nvar require_createDefaultLogger = __commonJS({\n  \"node_modules/electron-log/src/node/createDefaultLogger.js\"(exports2, module2) {\n    \"use strict\";\n    var Logger = require_Logger();\n    var ErrorHandler = require_ErrorHandler();\n    var EventLogger = require_EventLogger();\n    var transportConsole = require_console2();\n    var transportFile = require_file2();\n    var transportIpc = require_ipc2();\n    var transportRemote = require_remote();\n    module2.exports = createDefaultLogger;\n    function createDefaultLogger({ dependencies, initializeFn }) {\n      const defaultLogger = new Logger({\n        dependencies,\n        errorHandler: new ErrorHandler(),\n        eventLogger: new EventLogger(),\n        initializeFn,\n        isDev: dependencies.externalApi?.isDev(),\n        logId: \"default\",\n        transportFactories: {\n          console: transportConsole,\n          file: transportFile,\n          ipc: transportIpc,\n          remote: transportRemote\n        },\n        variables: {\n          processType: \"main\"\n        }\n      });\n      defaultLogger.default = defaultLogger;\n      defaultLogger.Logger = Logger;\n      defaultLogger.processInternalErrorFn = (e) => {\n        defaultLogger.transports.console.writeFn({\n          message: {\n            data: [\"Unhandled electron-log error\", e],\n            level: \"error\"\n          }\n        });\n      };\n      return defaultLogger;\n    }\n  }\n});\n\n// node_modules/electron-log/src/main/index.js\nvar require_main3 = __commonJS({\n  \"node_modules/electron-log/src/main/index.js\"(exports2, module2) {\n    \"use strict\";\n    var electron = require(\"electron\");\n    var ElectronExternalApi = require_ElectronExternalApi();\n    var { initialize } = require_initialize();\n    var createDefaultLogger = require_createDefaultLogger();\n    var externalApi = new ElectronExternalApi({ electron });\n    var defaultLogger = createDefaultLogger({\n      dependencies: { externalApi },\n      initializeFn: initialize\n    });\n    module2.exports = defaultLogger;\n    externalApi.onIpc(\"__ELECTRON_LOG__\", (_, message) => {\n      if (message.scope) {\n        defaultLogger.Logger.getInstance(message).scope(message.scope);\n      }\n      const date = new Date(message.date);\n      processMessage({\n        ...message,\n        date: date.getTime() ? date : /* @__PURE__ */ new Date()\n      });\n    });\n    externalApi.onIpcInvoke(\"__ELECTRON_LOG__\", (_, { cmd = \"\", logId }) => {\n      switch (cmd) {\n        case \"getOptions\": {\n          const logger12 = defaultLogger.Logger.getInstance({ logId });\n          return {\n            levels: logger12.levels,\n            logId\n          };\n        }\n        default: {\n          processMessage({ data: [`Unknown cmd '${cmd}'`], level: \"error\" });\n          return {};\n        }\n      }\n    });\n    function processMessage(message) {\n      defaultLogger.Logger.getInstance(message)?.processMessage(message);\n    }\n  }\n});\n\n// node_modules/electron-log/src/node/index.js\nvar require_node2 = __commonJS({\n  \"node_modules/electron-log/src/node/index.js\"(exports2, module2) {\n    \"use strict\";\n    var NodeExternalApi = require_NodeExternalApi();\n    var createDefaultLogger = require_createDefaultLogger();\n    var externalApi = new NodeExternalApi();\n    var defaultLogger = createDefaultLogger({\n      dependencies: { externalApi }\n    });\n    module2.exports = defaultLogger;\n  }\n});\n\n// node_modules/electron-log/src/index.js\nvar require_src2 = __commonJS({\n  \"node_modules/electron-log/src/index.js\"(exports2, module2) {\n    \"use strict\";\n    var isRenderer = typeof process === \"undefined\" || (process.type === \"renderer\" || process.type === \"worker\");\n    var isMain = typeof process === \"object\" && process.type === \"browser\";\n    if (isRenderer) {\n      require_electron_log_preload();\n      module2.exports = require_renderer();\n    } else if (isMain) {\n      module2.exports = require_main3();\n    } else {\n      module2.exports = require_node2();\n    }\n  }\n});\n\n// node_modules/is-obj/index.js\nvar require_is_obj = __commonJS({\n  \"node_modules/is-obj/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = (value) => {\n      const type = typeof value;\n      return value !== null && (type === \"object\" || type === \"function\");\n    };\n  }\n});\n\n// node_modules/dot-prop/index.js\nvar require_dot_prop = __commonJS({\n  \"node_modules/dot-prop/index.js\"(exports2, module2) {\n    \"use strict\";\n    var isObj = require_is_obj();\n    var disallowedKeys = /* @__PURE__ */ new Set([\n      \"__proto__\",\n      \"prototype\",\n      \"constructor\"\n    ]);\n    var isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));\n    function getPathSegments(path6) {\n      const pathArray = path6.split(\".\");\n      const parts = [];\n      for (let i = 0; i < pathArray.length; i++) {\n        let p = pathArray[i];\n        while (p[p.length - 1] === \"\\\\\" && pathArray[i + 1] !== void 0) {\n          p = p.slice(0, -1) + \".\";\n          p += pathArray[++i];\n        }\n        parts.push(p);\n      }\n      if (!isValidPath(parts)) {\n        return [];\n      }\n      return parts;\n    }\n    module2.exports = {\n      get(object, path6, value) {\n        if (!isObj(object) || typeof path6 !== \"string\") {\n          return value === void 0 ? object : value;\n        }\n        const pathArray = getPathSegments(path6);\n        if (pathArray.length === 0) {\n          return;\n        }\n        for (let i = 0; i < pathArray.length; i++) {\n          object = object[pathArray[i]];\n          if (object === void 0 || object === null) {\n            if (i !== pathArray.length - 1) {\n              return value;\n            }\n            break;\n          }\n        }\n        return object === void 0 ? value : object;\n      },\n      set(object, path6, value) {\n        if (!isObj(object) || typeof path6 !== \"string\") {\n          return object;\n        }\n        const root = object;\n        const pathArray = getPathSegments(path6);\n        for (let i = 0; i < pathArray.length; i++) {\n          const p = pathArray[i];\n          if (!isObj(object[p])) {\n            object[p] = {};\n          }\n          if (i === pathArray.length - 1) {\n            object[p] = value;\n          }\n          object = object[p];\n        }\n        return root;\n      },\n      delete(object, path6) {\n        if (!isObj(object) || typeof path6 !== \"string\") {\n          return false;\n        }\n        const pathArray = getPathSegments(path6);\n        for (let i = 0; i < pathArray.length; i++) {\n          const p = pathArray[i];\n          if (i === pathArray.length - 1) {\n            delete object[p];\n            return true;\n          }\n          object = object[p];\n          if (!isObj(object)) {\n            return false;\n          }\n        }\n      },\n      has(object, path6) {\n        if (!isObj(object) || typeof path6 !== \"string\") {\n          return false;\n        }\n        const pathArray = getPathSegments(path6);\n        if (pathArray.length === 0) {\n          return false;\n        }\n        for (let i = 0; i < pathArray.length; i++) {\n          if (isObj(object)) {\n            if (!(pathArray[i] in object)) {\n              return false;\n            }\n            object = object[pathArray[i]];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      }\n    };\n  }\n});\n\n// node_modules/pkg-up/node_modules/path-exists/index.js\nvar require_path_exists2 = __commonJS({\n  \"node_modules/pkg-up/node_modules/path-exists/index.js\"(exports2, module2) {\n    \"use strict\";\n    var fs4 = require(\"fs\");\n    module2.exports = (fp) => new Promise((resolve) => {\n      fs4.access(fp, (err) => {\n        resolve(!err);\n      });\n    });\n    module2.exports.sync = (fp) => {\n      try {\n        fs4.accessSync(fp);\n        return true;\n      } catch (err) {\n        return false;\n      }\n    };\n  }\n});\n\n// node_modules/p-try/index.js\nvar require_p_try = __commonJS({\n  \"node_modules/p-try/index.js\"(exports2, module2) {\n    \"use strict\";\n    var pTry = (fn, ...arguments_) => new Promise((resolve) => {\n      resolve(fn(...arguments_));\n    });\n    module2.exports = pTry;\n    module2.exports.default = pTry;\n  }\n});\n\n// node_modules/pkg-up/node_modules/p-limit/index.js\nvar require_p_limit = __commonJS({\n  \"node_modules/pkg-up/node_modules/p-limit/index.js\"(exports2, module2) {\n    \"use strict\";\n    var pTry = require_p_try();\n    var pLimit = (concurrency) => {\n      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n        return Promise.reject(new TypeError(\"Expected `concurrency` to be a number from 1 and up\"));\n      }\n      const queue = [];\n      let activeCount = 0;\n      const next = () => {\n        activeCount--;\n        if (queue.length > 0) {\n          queue.shift()();\n        }\n      };\n      const run = (fn, resolve, ...args) => {\n        activeCount++;\n        const result = pTry(fn, ...args);\n        resolve(result);\n        result.then(next, next);\n      };\n      const enqueue = (fn, resolve, ...args) => {\n        if (activeCount < concurrency) {\n          run(fn, resolve, ...args);\n        } else {\n          queue.push(run.bind(null, fn, resolve, ...args));\n        }\n      };\n      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));\n      Object.defineProperties(generator, {\n        activeCount: {\n          get: () => activeCount\n        },\n        pendingCount: {\n          get: () => queue.length\n        },\n        clearQueue: {\n          value: () => {\n            queue.length = 0;\n          }\n        }\n      });\n      return generator;\n    };\n    module2.exports = pLimit;\n    module2.exports.default = pLimit;\n  }\n});\n\n// node_modules/pkg-up/node_modules/p-locate/index.js\nvar require_p_locate = __commonJS({\n  \"node_modules/pkg-up/node_modules/p-locate/index.js\"(exports2, module2) {\n    \"use strict\";\n    var pLimit = require_p_limit();\n    var EndError = class extends Error {\n      constructor(value) {\n        super();\n        this.value = value;\n      }\n    };\n    var testElement = (el, tester) => Promise.resolve(el).then(tester);\n    var finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));\n    module2.exports = (iterable, tester, opts) => {\n      opts = Object.assign({\n        concurrency: Infinity,\n        preserveOrder: true\n      }, opts);\n      const limit = pLimit(opts.concurrency);\n      const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);\n      const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n      return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {\n      }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));\n    };\n  }\n});\n\n// node_modules/pkg-up/node_modules/locate-path/index.js\nvar require_locate_path = __commonJS({\n  \"node_modules/pkg-up/node_modules/locate-path/index.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    var pathExists = require_path_exists2();\n    var pLocate = require_p_locate();\n    module2.exports = (iterable, options) => {\n      options = Object.assign({\n        cwd: process.cwd()\n      }, options);\n      return pLocate(iterable, (el) => pathExists(path6.resolve(options.cwd, el)), options);\n    };\n    module2.exports.sync = (iterable, options) => {\n      options = Object.assign({\n        cwd: process.cwd()\n      }, options);\n      for (const el of iterable) {\n        if (pathExists.sync(path6.resolve(options.cwd, el))) {\n          return el;\n        }\n      }\n    };\n  }\n});\n\n// node_modules/pkg-up/node_modules/find-up/index.js\nvar require_find_up = __commonJS({\n  \"node_modules/pkg-up/node_modules/find-up/index.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    var locatePath = require_locate_path();\n    module2.exports = (filename, opts = {}) => {\n      const startDir = path6.resolve(opts.cwd || \"\");\n      const { root } = path6.parse(startDir);\n      const filenames = [].concat(filename);\n      return new Promise((resolve) => {\n        (function find(dir) {\n          locatePath(filenames, { cwd: dir }).then((file) => {\n            if (file) {\n              resolve(path6.join(dir, file));\n            } else if (dir === root) {\n              resolve(null);\n            } else {\n              find(path6.dirname(dir));\n            }\n          });\n        })(startDir);\n      });\n    };\n    module2.exports.sync = (filename, opts = {}) => {\n      let dir = path6.resolve(opts.cwd || \"\");\n      const { root } = path6.parse(dir);\n      const filenames = [].concat(filename);\n      while (true) {\n        const file = locatePath.sync(filenames, { cwd: dir });\n        if (file) {\n          return path6.join(dir, file);\n        }\n        if (dir === root) {\n          return null;\n        }\n        dir = path6.dirname(dir);\n      }\n    };\n  }\n});\n\n// node_modules/pkg-up/index.js\nvar require_pkg_up = __commonJS({\n  \"node_modules/pkg-up/index.js\"(exports2, module2) {\n    \"use strict\";\n    var findUp = require_find_up();\n    module2.exports = async ({ cwd } = {}) => findUp(\"package.json\", { cwd });\n    module2.exports.sync = ({ cwd } = {}) => findUp.sync(\"package.json\", { cwd });\n  }\n});\n\n// node_modules/env-paths/index.js\nvar require_env_paths = __commonJS({\n  \"node_modules/env-paths/index.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    var os = require(\"os\");\n    var homedir = os.homedir();\n    var tmpdir = os.tmpdir();\n    var { env } = process;\n    var macos = (name) => {\n      const library = path6.join(homedir, \"Library\");\n      return {\n        data: path6.join(library, \"Application Support\", name),\n        config: path6.join(library, \"Preferences\", name),\n        cache: path6.join(library, \"Caches\", name),\n        log: path6.join(library, \"Logs\", name),\n        temp: path6.join(tmpdir, name)\n      };\n    };\n    var windows = (name) => {\n      const appData = env.APPDATA || path6.join(homedir, \"AppData\", \"Roaming\");\n      const localAppData = env.LOCALAPPDATA || path6.join(homedir, \"AppData\", \"Local\");\n      return {\n        // Data/config/cache/log are invented by me as Windows isn't opinionated about this\n        data: path6.join(localAppData, name, \"Data\"),\n        config: path6.join(appData, name, \"Config\"),\n        cache: path6.join(localAppData, name, \"Cache\"),\n        log: path6.join(localAppData, name, \"Log\"),\n        temp: path6.join(tmpdir, name)\n      };\n    };\n    var linux = (name) => {\n      const username = path6.basename(homedir);\n      return {\n        data: path6.join(env.XDG_DATA_HOME || path6.join(homedir, \".local\", \"share\"), name),\n        config: path6.join(env.XDG_CONFIG_HOME || path6.join(homedir, \".config\"), name),\n        cache: path6.join(env.XDG_CACHE_HOME || path6.join(homedir, \".cache\"), name),\n        // https://wiki.debian.org/XDGBaseDirectorySpecification#state\n        log: path6.join(env.XDG_STATE_HOME || path6.join(homedir, \".local\", \"state\"), name),\n        temp: path6.join(tmpdir, username, name)\n      };\n    };\n    var envPaths = (name, options) => {\n      if (typeof name !== \"string\") {\n        throw new TypeError(`Expected string, got ${typeof name}`);\n      }\n      options = Object.assign({ suffix: \"nodejs\" }, options);\n      if (options.suffix) {\n        name += `-${options.suffix}`;\n      }\n      if (process.platform === \"darwin\") {\n        return macos(name);\n      }\n      if (process.platform === \"win32\") {\n        return windows(name);\n      }\n      return linux(name);\n    };\n    module2.exports = envPaths;\n    module2.exports.default = envPaths;\n  }\n});\n\n// node_modules/atomically/dist/consts.js\nvar require_consts = __commonJS({\n  \"node_modules/atomically/dist/consts.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.NOOP = exports2.LIMIT_FILES_DESCRIPTORS = exports2.LIMIT_BASENAME_LENGTH = exports2.IS_USER_ROOT = exports2.IS_POSIX = exports2.DEFAULT_TIMEOUT_SYNC = exports2.DEFAULT_TIMEOUT_ASYNC = exports2.DEFAULT_WRITE_OPTIONS = exports2.DEFAULT_READ_OPTIONS = exports2.DEFAULT_FOLDER_MODE = exports2.DEFAULT_FILE_MODE = exports2.DEFAULT_ENCODING = void 0;\n    var DEFAULT_ENCODING = \"utf8\";\n    exports2.DEFAULT_ENCODING = DEFAULT_ENCODING;\n    var DEFAULT_FILE_MODE = 438;\n    exports2.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;\n    var DEFAULT_FOLDER_MODE = 511;\n    exports2.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;\n    var DEFAULT_READ_OPTIONS = {};\n    exports2.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;\n    var DEFAULT_WRITE_OPTIONS = {};\n    exports2.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;\n    var DEFAULT_TIMEOUT_ASYNC = 5e3;\n    exports2.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;\n    var DEFAULT_TIMEOUT_SYNC = 100;\n    exports2.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;\n    var IS_POSIX = !!process.getuid;\n    exports2.IS_POSIX = IS_POSIX;\n    var IS_USER_ROOT = process.getuid ? !process.getuid() : false;\n    exports2.IS_USER_ROOT = IS_USER_ROOT;\n    var LIMIT_BASENAME_LENGTH = 128;\n    exports2.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;\n    var LIMIT_FILES_DESCRIPTORS = 1e4;\n    exports2.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;\n    var NOOP = () => {\n    };\n    exports2.NOOP = NOOP;\n  }\n});\n\n// node_modules/atomically/dist/utils/attemptify.js\nvar require_attemptify = __commonJS({\n  \"node_modules/atomically/dist/utils/attemptify.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.attemptifySync = exports2.attemptifyAsync = void 0;\n    var consts_1 = require_consts();\n    var attemptifyAsync = (fn, onError = consts_1.NOOP) => {\n      return function() {\n        return fn.apply(void 0, arguments).catch(onError);\n      };\n    };\n    exports2.attemptifyAsync = attemptifyAsync;\n    var attemptifySync = (fn, onError = consts_1.NOOP) => {\n      return function() {\n        try {\n          return fn.apply(void 0, arguments);\n        } catch (error) {\n          return onError(error);\n        }\n      };\n    };\n    exports2.attemptifySync = attemptifySync;\n  }\n});\n\n// node_modules/atomically/dist/utils/fs_handlers.js\nvar require_fs_handlers = __commonJS({\n  \"node_modules/atomically/dist/utils/fs_handlers.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var consts_1 = require_consts();\n    var Handlers = {\n      isChangeErrorOk: (error) => {\n        const { code } = error;\n        if (code === \"ENOSYS\")\n          return true;\n        if (!consts_1.IS_USER_ROOT && (code === \"EINVAL\" || code === \"EPERM\"))\n          return true;\n        return false;\n      },\n      isRetriableError: (error) => {\n        const { code } = error;\n        if (code === \"EMFILE\" || code === \"ENFILE\" || code === \"EAGAIN\" || code === \"EBUSY\" || code === \"EACCESS\" || code === \"EACCS\" || code === \"EPERM\")\n          return true;\n        return false;\n      },\n      onChangeError: (error) => {\n        if (Handlers.isChangeErrorOk(error))\n          return;\n        throw error;\n      }\n    };\n    exports2.default = Handlers;\n  }\n});\n\n// node_modules/atomically/dist/utils/retryify_queue.js\nvar require_retryify_queue = __commonJS({\n  \"node_modules/atomically/dist/utils/retryify_queue.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var consts_1 = require_consts();\n    var RetryfyQueue = {\n      interval: 25,\n      intervalId: void 0,\n      limit: consts_1.LIMIT_FILES_DESCRIPTORS,\n      queueActive: /* @__PURE__ */ new Set(),\n      queueWaiting: /* @__PURE__ */ new Set(),\n      init: () => {\n        if (RetryfyQueue.intervalId)\n          return;\n        RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);\n      },\n      reset: () => {\n        if (!RetryfyQueue.intervalId)\n          return;\n        clearInterval(RetryfyQueue.intervalId);\n        delete RetryfyQueue.intervalId;\n      },\n      add: (fn) => {\n        RetryfyQueue.queueWaiting.add(fn);\n        if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {\n          RetryfyQueue.tick();\n        } else {\n          RetryfyQueue.init();\n        }\n      },\n      remove: (fn) => {\n        RetryfyQueue.queueWaiting.delete(fn);\n        RetryfyQueue.queueActive.delete(fn);\n      },\n      schedule: () => {\n        return new Promise((resolve) => {\n          const cleanup = () => RetryfyQueue.remove(resolver);\n          const resolver = () => resolve(cleanup);\n          RetryfyQueue.add(resolver);\n        });\n      },\n      tick: () => {\n        if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)\n          return;\n        if (!RetryfyQueue.queueWaiting.size)\n          return RetryfyQueue.reset();\n        for (const fn of RetryfyQueue.queueWaiting) {\n          if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)\n            break;\n          RetryfyQueue.queueWaiting.delete(fn);\n          RetryfyQueue.queueActive.add(fn);\n          fn();\n        }\n      }\n    };\n    exports2.default = RetryfyQueue;\n  }\n});\n\n// node_modules/atomically/dist/utils/retryify.js\nvar require_retryify = __commonJS({\n  \"node_modules/atomically/dist/utils/retryify.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.retryifySync = exports2.retryifyAsync = void 0;\n    var retryify_queue_1 = require_retryify_queue();\n    var retryifyAsync = (fn, isRetriableError) => {\n      return function(timestamp) {\n        return function attempt() {\n          return retryify_queue_1.default.schedule().then((cleanup) => {\n            return fn.apply(void 0, arguments).then((result) => {\n              cleanup();\n              return result;\n            }, (error) => {\n              cleanup();\n              if (Date.now() >= timestamp)\n                throw error;\n              if (isRetriableError(error)) {\n                const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve) => setTimeout(resolve, delay));\n                return delayPromise.then(() => attempt.apply(void 0, arguments));\n              }\n              throw error;\n            });\n          });\n        };\n      };\n    };\n    exports2.retryifyAsync = retryifyAsync;\n    var retryifySync = (fn, isRetriableError) => {\n      return function(timestamp) {\n        return function attempt() {\n          try {\n            return fn.apply(void 0, arguments);\n          } catch (error) {\n            if (Date.now() > timestamp)\n              throw error;\n            if (isRetriableError(error))\n              return attempt.apply(void 0, arguments);\n            throw error;\n          }\n        };\n      };\n    };\n    exports2.retryifySync = retryifySync;\n  }\n});\n\n// node_modules/atomically/dist/utils/fs.js\nvar require_fs2 = __commonJS({\n  \"node_modules/atomically/dist/utils/fs.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var fs4 = require(\"fs\");\n    var util_1 = require(\"util\");\n    var attemptify_1 = require_attemptify();\n    var fs_handlers_1 = require_fs_handlers();\n    var retryify_1 = require_retryify();\n    var FS = {\n      chmodAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.chmod), fs_handlers_1.default.onChangeError),\n      chownAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.chown), fs_handlers_1.default.onChangeError),\n      closeAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.close)),\n      fsyncAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.fsync)),\n      mkdirAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.mkdir)),\n      realpathAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.realpath)),\n      statAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.stat)),\n      unlinkAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs4.unlink)),\n      closeRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.close), fs_handlers_1.default.isRetriableError),\n      fsyncRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.fsync), fs_handlers_1.default.isRetriableError),\n      openRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.open), fs_handlers_1.default.isRetriableError),\n      readFileRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.readFile), fs_handlers_1.default.isRetriableError),\n      renameRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.rename), fs_handlers_1.default.isRetriableError),\n      statRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.stat), fs_handlers_1.default.isRetriableError),\n      writeRetry: retryify_1.retryifyAsync(util_1.promisify(fs4.write), fs_handlers_1.default.isRetriableError),\n      chmodSyncAttempt: attemptify_1.attemptifySync(fs4.chmodSync, fs_handlers_1.default.onChangeError),\n      chownSyncAttempt: attemptify_1.attemptifySync(fs4.chownSync, fs_handlers_1.default.onChangeError),\n      closeSyncAttempt: attemptify_1.attemptifySync(fs4.closeSync),\n      mkdirSyncAttempt: attemptify_1.attemptifySync(fs4.mkdirSync),\n      realpathSyncAttempt: attemptify_1.attemptifySync(fs4.realpathSync),\n      statSyncAttempt: attemptify_1.attemptifySync(fs4.statSync),\n      unlinkSyncAttempt: attemptify_1.attemptifySync(fs4.unlinkSync),\n      closeSyncRetry: retryify_1.retryifySync(fs4.closeSync, fs_handlers_1.default.isRetriableError),\n      fsyncSyncRetry: retryify_1.retryifySync(fs4.fsyncSync, fs_handlers_1.default.isRetriableError),\n      openSyncRetry: retryify_1.retryifySync(fs4.openSync, fs_handlers_1.default.isRetriableError),\n      readFileSyncRetry: retryify_1.retryifySync(fs4.readFileSync, fs_handlers_1.default.isRetriableError),\n      renameSyncRetry: retryify_1.retryifySync(fs4.renameSync, fs_handlers_1.default.isRetriableError),\n      statSyncRetry: retryify_1.retryifySync(fs4.statSync, fs_handlers_1.default.isRetriableError),\n      writeSyncRetry: retryify_1.retryifySync(fs4.writeSync, fs_handlers_1.default.isRetriableError)\n    };\n    exports2.default = FS;\n  }\n});\n\n// node_modules/atomically/dist/utils/lang.js\nvar require_lang = __commonJS({\n  \"node_modules/atomically/dist/utils/lang.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var Lang = {\n      isFunction: (x) => {\n        return typeof x === \"function\";\n      },\n      isString: (x) => {\n        return typeof x === \"string\";\n      },\n      isUndefined: (x) => {\n        return typeof x === \"undefined\";\n      }\n    };\n    exports2.default = Lang;\n  }\n});\n\n// node_modules/atomically/dist/utils/scheduler.js\nvar require_scheduler = __commonJS({\n  \"node_modules/atomically/dist/utils/scheduler.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var Queues = {};\n    var Scheduler = {\n      next: (id) => {\n        const queue = Queues[id];\n        if (!queue)\n          return;\n        queue.shift();\n        const job = queue[0];\n        if (job) {\n          job(() => Scheduler.next(id));\n        } else {\n          delete Queues[id];\n        }\n      },\n      schedule: (id) => {\n        return new Promise((resolve) => {\n          let queue = Queues[id];\n          if (!queue)\n            queue = Queues[id] = [];\n          queue.push(resolve);\n          if (queue.length > 1)\n            return;\n          resolve(() => Scheduler.next(id));\n        });\n      }\n    };\n    exports2.default = Scheduler;\n  }\n});\n\n// node_modules/atomically/dist/utils/temp.js\nvar require_temp = __commonJS({\n  \"node_modules/atomically/dist/utils/temp.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var path6 = require(\"path\");\n    var consts_1 = require_consts();\n    var fs_1 = require_fs2();\n    var Temp = {\n      store: {},\n      create: (filePath) => {\n        const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = \"tmp-\", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;\n        return tempPath;\n      },\n      get: (filePath, creator, purge = true) => {\n        const tempPath = Temp.truncate(creator(filePath));\n        if (tempPath in Temp.store)\n          return Temp.get(filePath, creator, purge);\n        Temp.store[tempPath] = purge;\n        const disposer = () => delete Temp.store[tempPath];\n        return [tempPath, disposer];\n      },\n      purge: (filePath) => {\n        if (!Temp.store[filePath])\n          return;\n        delete Temp.store[filePath];\n        fs_1.default.unlinkAttempt(filePath);\n      },\n      purgeSync: (filePath) => {\n        if (!Temp.store[filePath])\n          return;\n        delete Temp.store[filePath];\n        fs_1.default.unlinkSyncAttempt(filePath);\n      },\n      purgeSyncAll: () => {\n        for (const filePath in Temp.store) {\n          Temp.purgeSync(filePath);\n        }\n      },\n      truncate: (filePath) => {\n        const basename = path6.basename(filePath);\n        if (basename.length <= consts_1.LIMIT_BASENAME_LENGTH)\n          return filePath;\n        const truncable = /^(\\.?)(.*?)((?:\\.[^.]+)?(?:\\.tmp-\\d{10}[a-f0-9]{6})?)$/.exec(basename);\n        if (!truncable)\n          return filePath;\n        const truncationLength = basename.length - consts_1.LIMIT_BASENAME_LENGTH;\n        return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;\n      }\n    };\n    process.on(\"exit\", Temp.purgeSyncAll);\n    exports2.default = Temp;\n  }\n});\n\n// node_modules/atomically/dist/index.js\nvar require_dist = __commonJS({\n  \"node_modules/atomically/dist/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.writeFileSync = exports2.writeFile = exports2.readFileSync = exports2.readFile = void 0;\n    var path6 = require(\"path\");\n    var consts_1 = require_consts();\n    var fs_1 = require_fs2();\n    var lang_1 = require_lang();\n    var scheduler_1 = require_scheduler();\n    var temp_1 = require_temp();\n    function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {\n      var _a;\n      if (lang_1.default.isString(options))\n        return readFile(filePath, { encoding: options });\n      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);\n      return fs_1.default.readFileRetry(timeout)(filePath, options);\n    }\n    exports2.readFile = readFile;\n    function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {\n      var _a;\n      if (lang_1.default.isString(options))\n        return readFileSync(filePath, { encoding: options });\n      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);\n      return fs_1.default.readFileSyncRetry(timeout)(filePath, options);\n    }\n    exports2.readFileSync = readFileSync;\n    var writeFile = (filePath, data, options, callback) => {\n      if (lang_1.default.isFunction(options))\n        return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);\n      const promise = writeFileAsync(filePath, data, options);\n      if (callback)\n        promise.then(callback, callback);\n      return promise;\n    };\n    exports2.writeFile = writeFile;\n    var writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {\n      var _a;\n      if (lang_1.default.isString(options))\n        return writeFileAsync(filePath, data, { encoding: options });\n      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);\n      let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;\n      try {\n        if (options.schedule)\n          schedulerCustomDisposer = await options.schedule(filePath);\n        schedulerDisposer = await scheduler_1.default.schedule(filePath);\n        filePath = await fs_1.default.realpathAttempt(filePath) || filePath;\n        [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));\n        const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);\n        if (useStatChown || useStatMode) {\n          const stat = await fs_1.default.statAttempt(filePath);\n          if (stat) {\n            options = { ...options };\n            if (useStatChown)\n              options.chown = { uid: stat.uid, gid: stat.gid };\n            if (useStatMode)\n              options.mode = stat.mode;\n          }\n        }\n        const parentPath = path6.dirname(filePath);\n        await fs_1.default.mkdirAttempt(parentPath, {\n          mode: consts_1.DEFAULT_FOLDER_MODE,\n          recursive: true\n        });\n        fd = await fs_1.default.openRetry(timeout)(tempPath, \"w\", options.mode || consts_1.DEFAULT_FILE_MODE);\n        if (options.tmpCreated)\n          options.tmpCreated(tempPath);\n        if (lang_1.default.isString(data)) {\n          await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);\n        } else if (!lang_1.default.isUndefined(data)) {\n          await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);\n        }\n        if (options.fsync !== false) {\n          if (options.fsyncWait !== false) {\n            await fs_1.default.fsyncRetry(timeout)(fd);\n          } else {\n            fs_1.default.fsyncAttempt(fd);\n          }\n        }\n        await fs_1.default.closeRetry(timeout)(fd);\n        fd = null;\n        if (options.chown)\n          await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);\n        if (options.mode)\n          await fs_1.default.chmodAttempt(tempPath, options.mode);\n        try {\n          await fs_1.default.renameRetry(timeout)(tempPath, filePath);\n        } catch (error) {\n          if (error.code !== \"ENAMETOOLONG\")\n            throw error;\n          await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));\n        }\n        tempDisposer();\n        tempPath = null;\n      } finally {\n        if (fd)\n          await fs_1.default.closeAttempt(fd);\n        if (tempPath)\n          temp_1.default.purge(tempPath);\n        if (schedulerCustomDisposer)\n          schedulerCustomDisposer();\n        if (schedulerDisposer)\n          schedulerDisposer();\n      }\n    };\n    var writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {\n      var _a;\n      if (lang_1.default.isString(options))\n        return writeFileSync(filePath, data, { encoding: options });\n      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);\n      let tempDisposer = null, tempPath = null, fd = null;\n      try {\n        filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;\n        [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));\n        const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);\n        if (useStatChown || useStatMode) {\n          const stat = fs_1.default.statSyncAttempt(filePath);\n          if (stat) {\n            options = { ...options };\n            if (useStatChown)\n              options.chown = { uid: stat.uid, gid: stat.gid };\n            if (useStatMode)\n              options.mode = stat.mode;\n          }\n        }\n        const parentPath = path6.dirname(filePath);\n        fs_1.default.mkdirSyncAttempt(parentPath, {\n          mode: consts_1.DEFAULT_FOLDER_MODE,\n          recursive: true\n        });\n        fd = fs_1.default.openSyncRetry(timeout)(tempPath, \"w\", options.mode || consts_1.DEFAULT_FILE_MODE);\n        if (options.tmpCreated)\n          options.tmpCreated(tempPath);\n        if (lang_1.default.isString(data)) {\n          fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);\n        } else if (!lang_1.default.isUndefined(data)) {\n          fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);\n        }\n        if (options.fsync !== false) {\n          if (options.fsyncWait !== false) {\n            fs_1.default.fsyncSyncRetry(timeout)(fd);\n          } else {\n            fs_1.default.fsyncAttempt(fd);\n          }\n        }\n        fs_1.default.closeSyncRetry(timeout)(fd);\n        fd = null;\n        if (options.chown)\n          fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);\n        if (options.mode)\n          fs_1.default.chmodSyncAttempt(tempPath, options.mode);\n        try {\n          fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);\n        } catch (error) {\n          if (error.code !== \"ENAMETOOLONG\")\n            throw error;\n          fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));\n        }\n        tempDisposer();\n        tempPath = null;\n      } finally {\n        if (fd)\n          fs_1.default.closeSyncAttempt(fd);\n        if (tempPath)\n          temp_1.default.purge(tempPath);\n      }\n    };\n    exports2.writeFileSync = writeFileSync;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/codegen/code.js\nvar require_code = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/codegen/code.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;\n    var _CodeOrName = class {\n    };\n    exports2._CodeOrName = _CodeOrName;\n    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\n    var Name = class extends _CodeOrName {\n      constructor(s) {\n        super();\n        if (!exports2.IDENTIFIER.test(s))\n          throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n      }\n      toString() {\n        return this.str;\n      }\n      emptyStr() {\n        return false;\n      }\n      get names() {\n        return { [this.str]: 1 };\n      }\n    };\n    exports2.Name = Name;\n    var _Code = class extends _CodeOrName {\n      constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n      }\n      toString() {\n        return this.str;\n      }\n      emptyStr() {\n        if (this._items.length > 1)\n          return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n      }\n      get str() {\n        var _a;\n        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, \"\");\n      }\n      get names() {\n        var _a;\n        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {\n          if (c instanceof Name)\n            names[c.str] = (names[c.str] || 0) + 1;\n          return names;\n        }, {});\n      }\n    };\n    exports2._Code = _Code;\n    exports2.nil = new _Code(\"\");\n    function _(strs, ...args) {\n      const code = [strs[0]];\n      let i = 0;\n      while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n      }\n      return new _Code(code);\n    }\n    exports2._ = _;\n    var plus = new _Code(\"+\");\n    function str(strs, ...args) {\n      const expr = [safeStringify(strs[0])];\n      let i = 0;\n      while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n      }\n      optimize(expr);\n      return new _Code(expr);\n    }\n    exports2.str = str;\n    function addCodeArg(code, arg) {\n      if (arg instanceof _Code)\n        code.push(...arg._items);\n      else if (arg instanceof Name)\n        code.push(arg);\n      else\n        code.push(interpolate(arg));\n    }\n    exports2.addCodeArg = addCodeArg;\n    function optimize(expr) {\n      let i = 1;\n      while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n          const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n          if (res !== void 0) {\n            expr.splice(i - 1, 3, res);\n            continue;\n          }\n          expr[i++] = \"+\";\n        }\n        i++;\n      }\n    }\n    function mergeExprItems(a, b) {\n      if (b === '\"\"')\n        return a;\n      if (a === '\"\"')\n        return b;\n      if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n          return;\n        if (typeof b != \"string\")\n          return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n          return a.slice(0, -1) + b.slice(1);\n        return;\n      }\n      if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n      return;\n    }\n    function strConcat(c1, c2) {\n      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;\n    }\n    exports2.strConcat = strConcat;\n    function interpolate(x) {\n      return typeof x == \"number\" || typeof x == \"boolean\" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n    }\n    function stringify(x) {\n      return new _Code(safeStringify(x));\n    }\n    exports2.stringify = stringify;\n    function safeStringify(x) {\n      return JSON.stringify(x).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n    }\n    exports2.safeStringify = safeStringify;\n    function getProperty(key) {\n      return typeof key == \"string\" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;\n    }\n    exports2.getProperty = getProperty;\n    function getEsmExportName(key) {\n      if (typeof key == \"string\" && exports2.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n      }\n      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n    }\n    exports2.getEsmExportName = getEsmExportName;\n    function regexpCode(rx) {\n      return new _Code(rx.toString());\n    }\n    exports2.regexpCode = regexpCode;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/codegen/scope.js\nvar require_scope2 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/codegen/scope.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;\n    var code_1 = require_code();\n    var ValueError = class extends Error {\n      constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n      }\n    };\n    var UsedValueState;\n    (function(UsedValueState2) {\n      UsedValueState2[UsedValueState2[\"Started\"] = 0] = \"Started\";\n      UsedValueState2[UsedValueState2[\"Completed\"] = 1] = \"Completed\";\n    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));\n    exports2.varKinds = {\n      const: new code_1.Name(\"const\"),\n      let: new code_1.Name(\"let\"),\n      var: new code_1.Name(\"var\")\n    };\n    var Scope = class {\n      constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n      }\n      toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n      }\n      name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n      }\n      _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n      }\n      _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n          throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return this._names[prefix] = { prefix, index: 0 };\n      }\n    };\n    exports2.Scope = Scope;\n    var ValueScopeName = class extends code_1.Name {\n      constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n      }\n      setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n      }\n    };\n    exports2.ValueScopeName = ValueScopeName;\n    var line = (0, code_1._)`\\n`;\n    var ValueScope = class extends Scope {\n      constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n      }\n      get() {\n        return this._scope;\n      }\n      name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n      }\n      value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === void 0)\n          throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n          const _name = vs.get(valueKey);\n          if (_name)\n            return _name;\n        } else {\n          vs = this._values[prefix] = /* @__PURE__ */ new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n      }\n      getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n          return;\n        return vs.get(keyOrRef);\n      }\n      scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n          if (name.scopePath === void 0)\n            throw new Error(`CodeGen: name \"${name}\" has no value`);\n          return (0, code_1._)`${scopeName}${name.scopePath}`;\n        });\n      }\n      scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n          if (name.value === void 0)\n            throw new Error(`CodeGen: name \"${name}\" has no value`);\n          return name.value.code;\n        }, usedValues, getCode);\n      }\n      _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n          const vs = values[prefix];\n          if (!vs)\n            continue;\n          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();\n          vs.forEach((name) => {\n            if (nameSet.has(name))\n              return;\n            nameSet.set(name, UsedValueState.Started);\n            let c = valueCode(name);\n            if (c) {\n              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;\n              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n              code = (0, code_1._)`${code}${c}${this.opts._n}`;\n            } else {\n              throw new ValueError(name);\n            }\n            nameSet.set(name, UsedValueState.Completed);\n          });\n        }\n        return code;\n      }\n    };\n    exports2.ValueScope = ValueScope;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/codegen/index.js\nvar require_codegen = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/codegen/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;\n    var code_1 = require_code();\n    var scope_1 = require_scope2();\n    var code_2 = require_code();\n    Object.defineProperty(exports2, \"_\", { enumerable: true, get: function() {\n      return code_2._;\n    } });\n    Object.defineProperty(exports2, \"str\", { enumerable: true, get: function() {\n      return code_2.str;\n    } });\n    Object.defineProperty(exports2, \"strConcat\", { enumerable: true, get: function() {\n      return code_2.strConcat;\n    } });\n    Object.defineProperty(exports2, \"nil\", { enumerable: true, get: function() {\n      return code_2.nil;\n    } });\n    Object.defineProperty(exports2, \"getProperty\", { enumerable: true, get: function() {\n      return code_2.getProperty;\n    } });\n    Object.defineProperty(exports2, \"stringify\", { enumerable: true, get: function() {\n      return code_2.stringify;\n    } });\n    Object.defineProperty(exports2, \"regexpCode\", { enumerable: true, get: function() {\n      return code_2.regexpCode;\n    } });\n    Object.defineProperty(exports2, \"Name\", { enumerable: true, get: function() {\n      return code_2.Name;\n    } });\n    var scope_2 = require_scope2();\n    Object.defineProperty(exports2, \"Scope\", { enumerable: true, get: function() {\n      return scope_2.Scope;\n    } });\n    Object.defineProperty(exports2, \"ValueScope\", { enumerable: true, get: function() {\n      return scope_2.ValueScope;\n    } });\n    Object.defineProperty(exports2, \"ValueScopeName\", { enumerable: true, get: function() {\n      return scope_2.ValueScopeName;\n    } });\n    Object.defineProperty(exports2, \"varKinds\", { enumerable: true, get: function() {\n      return scope_2.varKinds;\n    } });\n    exports2.operators = {\n      GT: new code_1._Code(\">\"),\n      GTE: new code_1._Code(\">=\"),\n      LT: new code_1._Code(\"<\"),\n      LTE: new code_1._Code(\"<=\"),\n      EQ: new code_1._Code(\"===\"),\n      NEQ: new code_1._Code(\"!==\"),\n      NOT: new code_1._Code(\"!\"),\n      OR: new code_1._Code(\"||\"),\n      AND: new code_1._Code(\"&&\"),\n      ADD: new code_1._Code(\"+\")\n    };\n    var Node = class {\n      optimizeNodes() {\n        return this;\n      }\n      optimizeNames(_names, _constants) {\n        return this;\n      }\n    };\n    var Def = class extends Node {\n      constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n      }\n      render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === void 0 ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n      }\n      optimizeNames(names, constants) {\n        if (!names[this.name.str])\n          return;\n        if (this.rhs)\n          this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n      }\n      get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n      }\n    };\n    var Assign = class extends Node {\n      constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n      }\n      render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n      }\n      optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n          return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n      }\n      get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n      }\n    };\n    var AssignOp = class extends Assign {\n      constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n      }\n      render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n      }\n    };\n    var Label = class extends Node {\n      constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n      }\n      render({ _n }) {\n        return `${this.label}:` + _n;\n      }\n    };\n    var Break = class extends Node {\n      constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n      }\n      render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n      }\n    };\n    var Throw = class extends Node {\n      constructor(error) {\n        super();\n        this.error = error;\n      }\n      render({ _n }) {\n        return `throw ${this.error};` + _n;\n      }\n      get names() {\n        return this.error.names;\n      }\n    };\n    var AnyCode = class extends Node {\n      constructor(code) {\n        super();\n        this.code = code;\n      }\n      render({ _n }) {\n        return `${this.code};` + _n;\n      }\n      optimizeNodes() {\n        return `${this.code}` ? this : void 0;\n      }\n      optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n      }\n      get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n      }\n    };\n    var ParentNode = class extends Node {\n      constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n      }\n      render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n      }\n      optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n          const n = nodes[i].optimizeNodes();\n          if (Array.isArray(n))\n            nodes.splice(i, 1, ...n);\n          else if (n)\n            nodes[i] = n;\n          else\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : void 0;\n      }\n      optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n          const n = nodes[i];\n          if (n.optimizeNames(names, constants))\n            continue;\n          subtractNames(names, n.names);\n          nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : void 0;\n      }\n      get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n      }\n    };\n    var BlockNode = class extends ParentNode {\n      render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n      }\n    };\n    var Root = class extends ParentNode {\n    };\n    var Else = class extends BlockNode {\n    };\n    Else.kind = \"else\";\n    var If = class _If extends BlockNode {\n      constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n      }\n      render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n          code += \"else \" + this.else.render(opts);\n        return code;\n      }\n      optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n          return this.nodes;\n        let e = this.else;\n        if (e) {\n          const ns = e.optimizeNodes();\n          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n          if (cond === false)\n            return e instanceof _If ? e : e.nodes;\n          if (this.nodes.length)\n            return this;\n          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n          return void 0;\n        return this;\n      }\n      optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n          return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n      }\n      get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n          addNames(names, this.else.names);\n        return names;\n      }\n    };\n    If.kind = \"if\";\n    var For = class extends BlockNode {\n    };\n    For.kind = \"for\";\n    var ForLoop = class extends For {\n      constructor(iteration) {\n        super();\n        this.iteration = iteration;\n      }\n      render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n      }\n      optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n          return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n      }\n      get names() {\n        return addNames(super.names, this.iteration.names);\n      }\n    };\n    var ForRange = class extends For {\n      constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n      }\n      render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n      }\n      get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n      }\n    };\n    var ForIter = class extends For {\n      constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n      }\n      render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n      }\n      optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n          return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n      }\n      get names() {\n        return addNames(super.names, this.iterable.names);\n      }\n    };\n    var Func = class extends BlockNode {\n      constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n      }\n      render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n      }\n    };\n    Func.kind = \"func\";\n    var Return = class extends ParentNode {\n      render(opts) {\n        return \"return \" + super.render(opts);\n      }\n    };\n    Return.kind = \"return\";\n    var Try = class extends BlockNode {\n      render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n          code += this.catch.render(opts);\n        if (this.finally)\n          code += this.finally.render(opts);\n        return code;\n      }\n      optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n      }\n      optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n      }\n      get names() {\n        const names = super.names;\n        if (this.catch)\n          addNames(names, this.catch.names);\n        if (this.finally)\n          addNames(names, this.finally.names);\n        return names;\n      }\n    };\n    var Catch = class extends BlockNode {\n      constructor(error) {\n        super();\n        this.error = error;\n      }\n      render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n      }\n    };\n    Catch.kind = \"catch\";\n    var Finally = class extends BlockNode {\n      render(opts) {\n        return \"finally\" + super.render(opts);\n      }\n    };\n    Finally.kind = \"finally\";\n    var CodeGen = class {\n      constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n      }\n      toString() {\n        return this._root.render(this.opts);\n      }\n      // returns unique name in the internal scope\n      name(prefix) {\n        return this._scope.name(prefix);\n      }\n      // reserves unique name in the external scope\n      scopeName(prefix) {\n        return this._extScope.name(prefix);\n      }\n      // reserves unique name in the external scope and assigns value to it\n      scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());\n        vs.add(name);\n        return name;\n      }\n      getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n      }\n      // return code that assigns values in the external scope to the names that are used internally\n      // (same names that were returned by gen.scopeName or gen.scopeValue)\n      scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n      }\n      scopeCode() {\n        return this._extScope.scopeCode(this._values);\n      }\n      _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== void 0 && constant)\n          this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n      }\n      // `const` declaration (`var` in es5 mode)\n      const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n      }\n      // `let` declaration with optional assignment (`var` in es5 mode)\n      let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n      }\n      // `var` declaration with optional assignment\n      var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n      }\n      // assignment code\n      assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n      }\n      // `+=` code\n      add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));\n      }\n      // appends passed SafeExpr to code or executes Block\n      code(c) {\n        if (typeof c == \"function\")\n          c();\n        else if (c !== code_1.nil)\n          this._leafNode(new AnyCode(c));\n        return this;\n      }\n      // returns code for object literal for the passed argument list of key-value pairs\n      object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n          if (code.length > 1)\n            code.push(\",\");\n          code.push(key);\n          if (key !== value || this.opts.es5) {\n            code.push(\":\");\n            (0, code_1.addCodeArg)(code, value);\n          }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n      }\n      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n      if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n          this.code(thenBody).else().code(elseBody).endIf();\n        } else if (thenBody) {\n          this.code(thenBody).endIf();\n        } else if (elseBody) {\n          throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n      }\n      // `else if` clause - invalid without `if` or after `else` clauses\n      elseIf(condition) {\n        return this._elseNode(new If(condition));\n      }\n      // `else` clause - only valid after `if` or `else if` clauses\n      else() {\n        return this._elseNode(new Else());\n      }\n      // end `if` statement (needed if gen.if was used only with condition)\n      endIf() {\n        return this._endBlockNode(If, Else);\n      }\n      _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n          this.code(forBody).endFor();\n        return this;\n      }\n      // a generic `for` clause (or statement if `forBody` is passed)\n      for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n      }\n      // `for` statement for a range of values\n      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n      }\n      // `for-of` statement (in es5 mode replace with a normal for loop)\n      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n          const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n          return this.forRange(\"_i\", 0, (0, code_1._)`${arr}.length`, (i) => {\n            this.var(name, (0, code_1._)`${arr}[${i}]`);\n            forBody(name);\n          });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n      }\n      // `for-in` statement.\n      // With option `ownProperties` replaced with a `for-of` loop for object keys\n      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n      }\n      // end `for` loop\n      endFor() {\n        return this._endBlockNode(For);\n      }\n      // `label` statement\n      label(label) {\n        return this._leafNode(new Label(label));\n      }\n      // `break` statement\n      break(label) {\n        return this._leafNode(new Break(label));\n      }\n      // `return` statement\n      return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n          throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n      }\n      // `try` statement\n      try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n          throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n          const error = this.name(\"e\");\n          this._currNode = node.catch = new Catch(error);\n          catchCode(error);\n        }\n        if (finallyCode) {\n          this._currNode = node.finally = new Finally();\n          this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n      }\n      // `throw` statement\n      throw(error) {\n        return this._leafNode(new Throw(error));\n      }\n      // start self-balancing block\n      block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n          this.code(body).endBlock(nodeCount);\n        return this;\n      }\n      // end the current self-balancing block\n      endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === void 0)\n          throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {\n          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n      }\n      // `function` heading (or definition if funcBody is passed)\n      func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n          this.code(funcBody).endFunc();\n        return this;\n      }\n      // end function definition\n      endFunc() {\n        return this._endBlockNode(Func);\n      }\n      optimize(n = 1) {\n        while (n-- > 0) {\n          this._root.optimizeNodes();\n          this._root.optimizeNames(this._root.names, this._constants);\n        }\n      }\n      _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n      }\n      _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n      }\n      _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || N2 && n instanceof N2) {\n          this._nodes.pop();\n          return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n      }\n      _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n          throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n      }\n      get _root() {\n        return this._nodes[0];\n      }\n      get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n      }\n      set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n      }\n    };\n    exports2.CodeGen = CodeGen;\n    function addNames(names, from) {\n      for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n      return names;\n    }\n    function addExprNames(names, from) {\n      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n    }\n    function optimizeExpr(expr, names, constants) {\n      if (expr instanceof code_1.Name)\n        return replaceName(expr);\n      if (!canOptimize(expr))\n        return expr;\n      return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n          c = replaceName(c);\n        if (c instanceof code_1._Code)\n          items.push(...c._items);\n        else\n          items.push(c);\n        return items;\n      }, []));\n      function replaceName(n) {\n        const c = constants[n.str];\n        if (c === void 0 || names[n.str] !== 1)\n          return n;\n        delete names[n.str];\n        return c;\n      }\n      function canOptimize(e) {\n        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);\n      }\n    }\n    function subtractNames(names, from) {\n      for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n    }\n    function not(x) {\n      return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._)`!${par(x)}`;\n    }\n    exports2.not = not;\n    var andCode = mappend(exports2.operators.AND);\n    function and(...args) {\n      return args.reduce(andCode);\n    }\n    exports2.and = and;\n    var orCode = mappend(exports2.operators.OR);\n    function or(...args) {\n      return args.reduce(orCode);\n    }\n    exports2.or = or;\n    function mappend(op) {\n      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;\n    }\n    function par(x) {\n      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/util.js\nvar require_util2 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/util.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;\n    var codegen_1 = require_codegen();\n    var code_1 = require_code();\n    function toHash(arr) {\n      const hash = {};\n      for (const item of arr)\n        hash[item] = true;\n      return hash;\n    }\n    exports2.toHash = toHash;\n    function alwaysValidSchema(it, schema) {\n      if (typeof schema == \"boolean\")\n        return schema;\n      if (Object.keys(schema).length === 0)\n        return true;\n      checkUnknownRules(it, schema);\n      return !schemaHasRules(schema, it.self.RULES.all);\n    }\n    exports2.alwaysValidSchema = alwaysValidSchema;\n    function checkUnknownRules(it, schema = it.schema) {\n      const { opts, self: self2 } = it;\n      if (!opts.strictSchema)\n        return;\n      if (typeof schema === \"boolean\")\n        return;\n      const rules = self2.RULES.keywords;\n      for (const key in schema) {\n        if (!rules[key])\n          checkStrictMode(it, `unknown keyword: \"${key}\"`);\n      }\n    }\n    exports2.checkUnknownRules = checkUnknownRules;\n    function schemaHasRules(schema, rules) {\n      if (typeof schema == \"boolean\")\n        return !schema;\n      for (const key in schema)\n        if (rules[key])\n          return true;\n      return false;\n    }\n    exports2.schemaHasRules = schemaHasRules;\n    function schemaHasRulesButRef(schema, RULES) {\n      if (typeof schema == \"boolean\")\n        return !schema;\n      for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n          return true;\n      return false;\n    }\n    exports2.schemaHasRulesButRef = schemaHasRulesButRef;\n    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n      if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n          return schema;\n        if (typeof schema == \"string\")\n          return (0, codegen_1._)`${schema}`;\n      }\n      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n    }\n    exports2.schemaRefOrVal = schemaRefOrVal;\n    function unescapeFragment(str) {\n      return unescapeJsonPointer(decodeURIComponent(str));\n    }\n    exports2.unescapeFragment = unescapeFragment;\n    function escapeFragment(str) {\n      return encodeURIComponent(escapeJsonPointer(str));\n    }\n    exports2.escapeFragment = escapeFragment;\n    function escapeJsonPointer(str) {\n      if (typeof str == \"number\")\n        return `${str}`;\n      return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n    }\n    exports2.escapeJsonPointer = escapeJsonPointer;\n    function unescapeJsonPointer(str) {\n      return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n    }\n    exports2.unescapeJsonPointer = unescapeJsonPointer;\n    function eachItem(xs, f) {\n      if (Array.isArray(xs)) {\n        for (const x of xs)\n          f(x);\n      } else {\n        f(xs);\n      }\n    }\n    exports2.eachItem = eachItem;\n    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {\n      return (gen, from, to, toName) => {\n        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n      };\n    }\n    exports2.mergeEvaluated = {\n      props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {\n          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {\n          if (from === true) {\n            gen.assign(to, true);\n          } else {\n            gen.assign(to, (0, codegen_1._)`${to} || {}`);\n            setEvaluated(gen, to, from);\n          }\n        }),\n        mergeValues: (from, to) => from === true ? true : { ...from, ...to },\n        resultToName: evaluatedPropsToName\n      }),\n      items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n        resultToName: (gen, items) => gen.var(\"items\", items)\n      })\n    };\n    function evaluatedPropsToName(gen, ps) {\n      if (ps === true)\n        return gen.var(\"props\", true);\n      const props = gen.var(\"props\", (0, codegen_1._)`{}`);\n      if (ps !== void 0)\n        setEvaluated(gen, props, ps);\n      return props;\n    }\n    exports2.evaluatedPropsToName = evaluatedPropsToName;\n    function setEvaluated(gen, props, ps) {\n      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));\n    }\n    exports2.setEvaluated = setEvaluated;\n    var snippets = {};\n    function useFunc(gen, f) {\n      return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n      });\n    }\n    exports2.useFunc = useFunc;\n    var Type;\n    (function(Type2) {\n      Type2[Type2[\"Num\"] = 0] = \"Num\";\n      Type2[Type2[\"Str\"] = 1] = \"Str\";\n    })(Type || (exports2.Type = Type = {}));\n    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n      if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`\"[\" + ${dataProp} + \"]\"` : (0, codegen_1._)`\"['\" + ${dataProp} + \"']\"` : isNumber ? (0, codegen_1._)`\"/\" + ${dataProp}` : (0, codegen_1._)`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`;\n      }\n      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n    }\n    exports2.getErrorPath = getErrorPath;\n    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n      if (!mode)\n        return;\n      msg = `strict mode: ${msg}`;\n      if (mode === true)\n        throw new Error(msg);\n      it.self.logger.warn(msg);\n    }\n    exports2.checkStrictMode = checkStrictMode;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/names.js\nvar require_names = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/names.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var names = {\n      // validation function arguments\n      data: new codegen_1.Name(\"data\"),\n      // data passed to validation function\n      // args passed from referencing schema\n      valCxt: new codegen_1.Name(\"valCxt\"),\n      // validation/data context - should not be used directly, it is destructured to the names below\n      instancePath: new codegen_1.Name(\"instancePath\"),\n      parentData: new codegen_1.Name(\"parentData\"),\n      parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n      rootData: new codegen_1.Name(\"rootData\"),\n      // root data - same as the data passed to the first/top validation function\n      dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"),\n      // used to support recursiveRef and dynamicRef\n      // function scoped variables\n      vErrors: new codegen_1.Name(\"vErrors\"),\n      // null or array of validation errors\n      errors: new codegen_1.Name(\"errors\"),\n      // counter of validation errors\n      this: new codegen_1.Name(\"this\"),\n      // \"globals\"\n      self: new codegen_1.Name(\"self\"),\n      scope: new codegen_1.Name(\"scope\"),\n      // JTD serialize/parse name for JSON string and position\n      json: new codegen_1.Name(\"json\"),\n      jsonPos: new codegen_1.Name(\"jsonPos\"),\n      jsonLen: new codegen_1.Name(\"jsonLen\"),\n      jsonPart: new codegen_1.Name(\"jsonPart\")\n    };\n    exports2.default = names;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/errors.js\nvar require_errors = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/errors.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var names_1 = require_names();\n    exports2.keywordError = {\n      message: ({ keyword }) => (0, codegen_1.str)`must pass \"${keyword}\" keyword validation`\n    };\n    exports2.keyword$DataError = {\n      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`\"${keyword}\" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`\"${keyword}\" keyword is invalid ($data)`\n    };\n    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {\n      const { it } = cxt;\n      const { gen, compositeRule, allErrors } = it;\n      const errObj = errorObjectCode(cxt, error, errorPaths);\n      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {\n        addError(gen, errObj);\n      } else {\n        returnErrors(it, (0, codegen_1._)`[${errObj}]`);\n      }\n    }\n    exports2.reportError = reportError;\n    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {\n      const { it } = cxt;\n      const { gen, compositeRule, allErrors } = it;\n      const errObj = errorObjectCode(cxt, error, errorPaths);\n      addError(gen, errObj);\n      if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n      }\n    }\n    exports2.reportExtraError = reportExtraError;\n    function resetErrorsCount(gen, errsCount) {\n      gen.assign(names_1.default.errors, errsCount);\n      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n    }\n    exports2.resetErrorsCount = resetErrorsCount;\n    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {\n      if (errsCount === void 0)\n        throw new Error(\"ajv implementation error\");\n      const err = gen.name(\"err\");\n      gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);\n          gen.assign((0, codegen_1._)`${err}.data`, data);\n        }\n      });\n    }\n    exports2.extendErrors = extendErrors;\n    function addError(gen, errObj) {\n      const err = gen.const(\"err\", errObj);\n      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);\n      gen.code((0, codegen_1._)`${names_1.default.errors}++`);\n    }\n    function returnErrors(it, errs) {\n      const { gen, validateName, schemaEnv } = it;\n      if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);\n      } else {\n        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);\n        gen.return(false);\n      }\n    }\n    var E = {\n      keyword: new codegen_1.Name(\"keyword\"),\n      schemaPath: new codegen_1.Name(\"schemaPath\"),\n      // also used in JTD errors\n      params: new codegen_1.Name(\"params\"),\n      propertyName: new codegen_1.Name(\"propertyName\"),\n      message: new codegen_1.Name(\"message\"),\n      schema: new codegen_1.Name(\"schema\"),\n      parentSchema: new codegen_1.Name(\"parentSchema\")\n    };\n    function errorObjectCode(cxt, error, errorPaths) {\n      const { createErrors } = cxt.it;\n      if (createErrors === false)\n        return (0, codegen_1._)`{}`;\n      return errorObject(cxt, error, errorPaths);\n    }\n    function errorObject(cxt, error, errorPaths = {}) {\n      const { gen, it } = cxt;\n      const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths)\n      ];\n      extraErrorProps(cxt, error, keyValues);\n      return gen.object(...keyValues);\n    }\n    function errorInstancePath({ errorPath }, { instancePath }) {\n      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;\n      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n    }\n    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;\n      if (schemaPath) {\n        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n      }\n      return [E.schemaPath, schPath];\n    }\n    function extraErrorProps(cxt, { params, message }, keyValues) {\n      const { keyword, data, schemaValue, it } = cxt;\n      const { opts, propertyName, topSchemaRef, schemaPath } = it;\n      keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._)`{}`]);\n      if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n      }\n      if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n      }\n      if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/boolSchema.js\nvar require_boolSchema = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/boolSchema.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;\n    var errors_1 = require_errors();\n    var codegen_1 = require_codegen();\n    var names_1 = require_names();\n    var boolError = {\n      message: \"boolean schema is false\"\n    };\n    function topBoolOrEmptySchema(it) {\n      const { gen, schema, validateName } = it;\n      if (schema === false) {\n        falseSchemaError(it, false);\n      } else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n      } else {\n        gen.assign((0, codegen_1._)`${validateName}.errors`, null);\n        gen.return(true);\n      }\n    }\n    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;\n    function boolOrEmptySchema(it, valid) {\n      const { gen, schema } = it;\n      if (schema === false) {\n        gen.var(valid, false);\n        falseSchemaError(it);\n      } else {\n        gen.var(valid, true);\n      }\n    }\n    exports2.boolOrEmptySchema = boolOrEmptySchema;\n    function falseSchemaError(it, overrideAllErrors) {\n      const { gen, data } = it;\n      const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it\n      };\n      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/rules.js\nvar require_rules = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/rules.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getRules = exports2.isJSONType = void 0;\n    var _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\n    var jsonTypes = new Set(_jsonTypes);\n    function isJSONType(x) {\n      return typeof x == \"string\" && jsonTypes.has(x);\n    }\n    exports2.isJSONType = isJSONType;\n    function getRules() {\n      const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] }\n      };\n      return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {}\n      };\n    }\n    exports2.getRules = getRules;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/applicability.js\nvar require_applicability = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/applicability.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;\n    function schemaHasRulesForType({ schema, self: self2 }, type) {\n      const group = self2.RULES.types[type];\n      return group && group !== true && shouldUseGroup(schema, group);\n    }\n    exports2.schemaHasRulesForType = schemaHasRulesForType;\n    function shouldUseGroup(schema, group) {\n      return group.rules.some((rule) => shouldUseRule(schema, rule));\n    }\n    exports2.shouldUseGroup = shouldUseGroup;\n    function shouldUseRule(schema, rule) {\n      var _a;\n      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));\n    }\n    exports2.shouldUseRule = shouldUseRule;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/dataType.js\nvar require_dataType = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/dataType.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;\n    var rules_1 = require_rules();\n    var applicability_1 = require_applicability();\n    var errors_1 = require_errors();\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var DataType;\n    (function(DataType2) {\n      DataType2[DataType2[\"Correct\"] = 0] = \"Correct\";\n      DataType2[DataType2[\"Wrong\"] = 1] = \"Wrong\";\n    })(DataType || (exports2.DataType = DataType = {}));\n    function getSchemaTypes(schema) {\n      const types = getJSONTypes(schema.type);\n      const hasNull = types.includes(\"null\");\n      if (hasNull) {\n        if (schema.nullable === false)\n          throw new Error(\"type: null contradicts nullable: false\");\n      } else {\n        if (!types.length && schema.nullable !== void 0) {\n          throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n          types.push(\"null\");\n      }\n      return types;\n    }\n    exports2.getSchemaTypes = getSchemaTypes;\n    function getJSONTypes(ts) {\n      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n      if (types.every(rules_1.isJSONType))\n        return types;\n      throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n    }\n    exports2.getJSONTypes = getJSONTypes;\n    function coerceAndCheckDataType(it, types) {\n      const { gen, data, opts } = it;\n      const coerceTo = coerceToTypes(types, opts.coerceTypes);\n      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n      if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n          if (coerceTo.length)\n            coerceData(it, types, coerceTo);\n          else\n            reportTypeError(it);\n        });\n      }\n      return checkTypes;\n    }\n    exports2.coerceAndCheckDataType = coerceAndCheckDataType;\n    var COERCIBLE = /* @__PURE__ */ new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\n    function coerceToTypes(types, coerceTypes) {\n      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n    }\n    function coerceData(it, types, coerceTo) {\n      const { gen, data, opts } = it;\n      const dataType = gen.let(\"dataType\", (0, codegen_1._)`typeof ${data}`);\n      const coerced = gen.let(\"coerced\", (0, codegen_1._)`undefined`);\n      if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n      }\n      gen.if((0, codegen_1._)`${coerced} !== undefined`);\n      for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n          coerceSpecificType(t);\n        }\n      }\n      gen.else();\n      reportTypeError(it);\n      gen.endIf();\n      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n      });\n      function coerceSpecificType(t) {\n        switch (t) {\n          case \"string\":\n            gen.elseIf((0, codegen_1._)`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, (0, codegen_1._)`\"\" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`\"\"`);\n            return;\n          case \"number\":\n            gen.elseIf((0, codegen_1._)`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);\n            return;\n          case \"integer\":\n            gen.elseIf((0, codegen_1._)`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);\n            return;\n          case \"boolean\":\n            gen.elseIf((0, codegen_1._)`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n            return;\n          case \"null\":\n            gen.elseIf((0, codegen_1._)`${data} === \"\" || ${data} === 0 || ${data} === false`);\n            gen.assign(coerced, null);\n            return;\n          case \"array\":\n            gen.elseIf((0, codegen_1._)`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);\n        }\n      }\n    }\n    function assignParentData({ gen, parentData, parentDataProperty }, expr) {\n      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));\n    }\n    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n      let cond;\n      switch (dataType) {\n        case \"null\":\n          return (0, codegen_1._)`${data} ${EQ} null`;\n        case \"array\":\n          cond = (0, codegen_1._)`Array.isArray(${data})`;\n          break;\n        case \"object\":\n          cond = (0, codegen_1._)`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n          break;\n        case \"integer\":\n          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);\n          break;\n        case \"number\":\n          cond = numCond();\n          break;\n        default:\n          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;\n      }\n      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n      function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);\n      }\n    }\n    exports2.checkDataType = checkDataType;\n    function checkDataTypes(dataTypes, data, strictNums, correct) {\n      if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n      }\n      let cond;\n      const types = (0, util_1.toHash)(dataTypes);\n      if (types.array && types.object) {\n        const notObj = (0, codegen_1._)`typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      } else {\n        cond = codegen_1.nil;\n      }\n      if (types.number)\n        delete types.integer;\n      for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n      return cond;\n    }\n    exports2.checkDataTypes = checkDataTypes;\n    var typeError = {\n      message: ({ schema }) => `must be ${schema}`,\n      params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`\n    };\n    function reportTypeError(it) {\n      const cxt = getTypeErrorContext(it);\n      (0, errors_1.reportError)(cxt, typeError);\n    }\n    exports2.reportTypeError = reportTypeError;\n    function getTypeErrorContext(it) {\n      const { gen, data, schema } = it;\n      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n      return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it\n      };\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/defaults.js\nvar require_defaults = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/defaults.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.assignDefaults = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    function assignDefaults(it, ty) {\n      const { properties, items } = it.schema;\n      if (ty === \"object\" && properties) {\n        for (const key in properties) {\n          assignDefault(it, key, properties[key].default);\n        }\n      } else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n      }\n    }\n    exports2.assignDefaults = assignDefaults;\n    function assignDefault(it, prop, defaultValue) {\n      const { gen, compositeRule, data, opts } = it;\n      if (defaultValue === void 0)\n        return;\n      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;\n      if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n      }\n      let condition = (0, codegen_1._)`${childData} === undefined`;\n      if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === \"\"`;\n      }\n      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/code.js\nvar require_code2 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/code.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var names_1 = require_names();\n    var util_2 = require_util2();\n    function checkReportMissingProp(cxt, prop) {\n      const { gen, data, it } = cxt;\n      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);\n        cxt.error();\n      });\n    }\n    exports2.checkReportMissingProp = checkReportMissingProp;\n    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));\n    }\n    exports2.checkMissingProp = checkMissingProp;\n    function reportMissingProp(cxt, missing) {\n      cxt.setParams({ missingProperty: missing }, true);\n      cxt.error();\n    }\n    exports2.reportMissingProp = reportMissingProp;\n    function hasPropFunc(gen) {\n      return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`\n      });\n    }\n    exports2.hasPropFunc = hasPropFunc;\n    function isOwnProperty(gen, data, property) {\n      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;\n    }\n    exports2.isOwnProperty = isOwnProperty;\n    function propertyInData(gen, data, property, ownProperties) {\n      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n    }\n    exports2.propertyInData = propertyInData;\n    function noPropertyInData(gen, data, property, ownProperties) {\n      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n    }\n    exports2.noPropertyInData = noPropertyInData;\n    function allSchemaProperties(schemaMap) {\n      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n    }\n    exports2.allSchemaProperties = allSchemaProperties;\n    function schemaProperties(it, schemaMap) {\n      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n    }\n    exports2.schemaProperties = schemaProperties;\n    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n      const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData]\n      ];\n      if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;\n      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;\n    }\n    exports2.callValidateCode = callValidateCode;\n    var newRegExp = (0, codegen_1._)`new RegExp`;\n    function usePattern({ gen, it: { opts } }, pattern) {\n      const u = opts.unicodeRegExp ? \"u\" : \"\";\n      const { regExp } = opts.code;\n      const rx = regExp(pattern, u);\n      return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._)`${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`\n      });\n    }\n    exports2.usePattern = usePattern;\n    function validateArray(cxt) {\n      const { gen, data, keyword, it } = cxt;\n      const valid = gen.name(\"valid\");\n      if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n      }\n      gen.var(valid, true);\n      validateItems(() => gen.break());\n      return valid;\n      function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n          cxt.subschema({\n            keyword,\n            dataProp: i,\n            dataPropType: util_1.Type.Num\n          }, valid);\n          gen.if((0, codegen_1.not)(valid), notValid);\n        });\n      }\n    }\n    exports2.validateArray = validateArray;\n    function validateUnion(cxt) {\n      const { gen, schema, keyword, it } = cxt;\n      if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n      if (alwaysValid && !it.opts.unevaluated)\n        return;\n      const valid = gen.let(\"valid\", false);\n      const schValid = gen.name(\"_valid\");\n      gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n          keyword,\n          schemaProp: i,\n          compositeRule: true\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        if (!merged)\n          gen.if((0, codegen_1.not)(valid));\n      }));\n      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n    }\n    exports2.validateUnion = validateUnion;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/keyword.js\nvar require_keyword = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/keyword.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;\n    var codegen_1 = require_codegen();\n    var names_1 = require_names();\n    var code_1 = require_code2();\n    var errors_1 = require_errors();\n    function macroKeywordCode(cxt, def) {\n      const { gen, keyword, schema, parentSchema, it } = cxt;\n      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n      const schemaRef = useKeyword(gen, keyword, macroSchema);\n      if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n      const valid = gen.name(\"valid\");\n      cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true\n      }, valid);\n      cxt.pass(valid, () => cxt.error(true));\n    }\n    exports2.macroKeywordCode = macroKeywordCode;\n    function funcKeywordCode(cxt, def) {\n      var _a;\n      const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n      checkAsyncKeyword(it, def);\n      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n      const validateRef = useKeyword(gen, keyword, validate);\n      const valid = gen.let(\"valid\");\n      cxt.block$data(valid, validateKeyword);\n      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n      function validateKeyword() {\n        if (def.errors === false) {\n          assignValid();\n          if (def.modifying)\n            modifyData(cxt);\n          reportErrs(() => cxt.error());\n        } else {\n          const ruleErrs = def.async ? validateAsync() : validateSync();\n          if (def.modifying)\n            modifyData(cxt);\n          reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n      }\n      function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n      }\n      function validateSync() {\n        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n      }\n      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n      }\n      function reportErrs(errors) {\n        var _a2;\n        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);\n      }\n    }\n    exports2.funcKeywordCode = funcKeywordCode;\n    function modifyData(cxt) {\n      const { gen, data, it } = cxt;\n      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n    }\n    function addErrs(cxt, errs) {\n      const { gen } = cxt;\n      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n      }, () => cxt.error());\n    }\n    function checkAsyncKeyword({ schemaEnv }, def) {\n      if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n    }\n    function useKeyword(gen, keyword, result) {\n      if (result === void 0)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n      return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n    }\n    function validSchemaType(schema, schemaType, allowUndefined = false) {\n      return !schemaType.length || schemaType.some((st) => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n    }\n    exports2.validSchemaType = validSchemaType;\n    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {\n      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n      }\n      const deps = def.dependencies;\n      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n      }\n      if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n          const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self2.errorsText(def.validateSchema.errors);\n          if (opts.validateSchema === \"log\")\n            self2.logger.error(msg);\n          else\n            throw new Error(msg);\n        }\n      }\n    }\n    exports2.validateKeywordUsage = validateKeywordUsage;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/subschema.js\nvar require_subschema = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/subschema.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n      if (keyword !== void 0 && schema !== void 0) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n      }\n      if (keyword !== void 0) {\n        const sch = it.schema[keyword];\n        return schemaProp === void 0 ? {\n          schema: sch,\n          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`\n        } : {\n          schema: sch[schemaProp],\n          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`\n        };\n      }\n      if (schema !== void 0) {\n        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {\n          throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n          schema,\n          schemaPath,\n          topSchemaRef,\n          errSchemaPath\n        };\n      }\n      throw new Error('either \"keyword\" or \"schema\" must be passed');\n    }\n    exports2.getSubschema = getSubschema;\n    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n      if (data !== void 0 && dataProp !== void 0) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n      }\n      const { gen } = it;\n      if (dataProp !== void 0) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n      }\n      if (data !== void 0) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true);\n        dataContextProps(nextData);\n        if (propertyName !== void 0)\n          subschema.propertyName = propertyName;\n      }\n      if (dataTypes)\n        subschema.dataTypes = dataTypes;\n      function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = /* @__PURE__ */ new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n      }\n    }\n    exports2.extendSubschemaData = extendSubschemaData;\n    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n      if (compositeRule !== void 0)\n        subschema.compositeRule = compositeRule;\n      if (createErrors !== void 0)\n        subschema.createErrors = createErrors;\n      if (allErrors !== void 0)\n        subschema.allErrors = allErrors;\n      subschema.jtdDiscriminator = jtdDiscriminator;\n      subschema.jtdMetadata = jtdMetadata;\n    }\n    exports2.extendSubschemaMode = extendSubschemaMode;\n  }\n});\n\n// node_modules/fast-deep-equal/index.js\nvar require_fast_deep_equal = __commonJS({\n  \"node_modules/fast-deep-equal/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function equal(a, b) {\n      if (a === b) return true;\n      if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n          length = a.length;\n          if (length != b.length) return false;\n          for (i = length; i-- !== 0; )\n            if (!equal(a[i], b[i])) return false;\n          return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for (i = length; i-- !== 0; )\n          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for (i = length; i-- !== 0; ) {\n          var key = keys[i];\n          if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n      }\n      return a !== a && b !== b;\n    };\n  }\n});\n\n// node_modules/conf/node_modules/json-schema-traverse/index.js\nvar require_json_schema_traverse = __commonJS({\n  \"node_modules/conf/node_modules/json-schema-traverse/index.js\"(exports2, module2) {\n    \"use strict\";\n    var traverse = module2.exports = function(schema, opts, cb) {\n      if (typeof opts == \"function\") {\n        cb = opts;\n        opts = {};\n      }\n      cb = opts.cb || cb;\n      var pre = typeof cb == \"function\" ? cb : cb.pre || function() {\n      };\n      var post = cb.post || function() {\n      };\n      _traverse(opts, pre, post, schema, \"\", schema);\n    };\n    traverse.keywords = {\n      additionalItems: true,\n      items: true,\n      contains: true,\n      additionalProperties: true,\n      propertyNames: true,\n      not: true,\n      if: true,\n      then: true,\n      else: true\n    };\n    traverse.arrayKeywords = {\n      items: true,\n      allOf: true,\n      anyOf: true,\n      oneOf: true\n    };\n    traverse.propsKeywords = {\n      $defs: true,\n      definitions: true,\n      properties: true,\n      patternProperties: true,\n      dependencies: true\n    };\n    traverse.skipKeywords = {\n      default: true,\n      enum: true,\n      const: true,\n      required: true,\n      maximum: true,\n      minimum: true,\n      exclusiveMaximum: true,\n      exclusiveMinimum: true,\n      multipleOf: true,\n      maxLength: true,\n      minLength: true,\n      pattern: true,\n      format: true,\n      maxItems: true,\n      minItems: true,\n      uniqueItems: true,\n      maxProperties: true,\n      minProperties: true\n    };\n    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n      if (schema && typeof schema == \"object\" && !Array.isArray(schema)) {\n        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n        for (var key in schema) {\n          var sch = schema[key];\n          if (Array.isArray(sch)) {\n            if (key in traverse.arrayKeywords) {\n              for (var i = 0; i < sch.length; i++)\n                _traverse(opts, pre, post, sch[i], jsonPtr + \"/\" + key + \"/\" + i, rootSchema, jsonPtr, key, schema, i);\n            }\n          } else if (key in traverse.propsKeywords) {\n            if (sch && typeof sch == \"object\") {\n              for (var prop in sch)\n                _traverse(opts, pre, post, sch[prop], jsonPtr + \"/\" + key + \"/\" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n            }\n          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {\n            _traverse(opts, pre, post, sch, jsonPtr + \"/\" + key, rootSchema, jsonPtr, key, schema);\n          }\n        }\n        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n      }\n    }\n    function escapeJsonPtr(str) {\n      return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/resolve.js\nvar require_resolve = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/resolve.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;\n    var util_1 = require_util2();\n    var equal = require_fast_deep_equal();\n    var traverse = require_json_schema_traverse();\n    var SIMPLE_INLINED = /* @__PURE__ */ new Set([\n      \"type\",\n      \"format\",\n      \"pattern\",\n      \"maxLength\",\n      \"minLength\",\n      \"maxProperties\",\n      \"minProperties\",\n      \"maxItems\",\n      \"minItems\",\n      \"maximum\",\n      \"minimum\",\n      \"uniqueItems\",\n      \"multipleOf\",\n      \"required\",\n      \"enum\",\n      \"const\"\n    ]);\n    function inlineRef(schema, limit = true) {\n      if (typeof schema == \"boolean\")\n        return true;\n      if (limit === true)\n        return !hasRef(schema);\n      if (!limit)\n        return false;\n      return countKeys(schema) <= limit;\n    }\n    exports2.inlineRef = inlineRef;\n    var REF_KEYWORDS = /* @__PURE__ */ new Set([\n      \"$ref\",\n      \"$recursiveRef\",\n      \"$recursiveAnchor\",\n      \"$dynamicRef\",\n      \"$dynamicAnchor\"\n    ]);\n    function hasRef(schema) {\n      for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n          return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n          return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n          return true;\n      }\n      return false;\n    }\n    function countKeys(schema) {\n      let count = 0;\n      for (const key in schema) {\n        if (key === \"$ref\")\n          return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n          continue;\n        if (typeof schema[key] == \"object\") {\n          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));\n        }\n        if (count === Infinity)\n          return Infinity;\n      }\n      return count;\n    }\n    function getFullPath(resolver, id = \"\", normalize) {\n      if (normalize !== false)\n        id = normalizeId(id);\n      const p = resolver.parse(id);\n      return _getFullPath(resolver, p);\n    }\n    exports2.getFullPath = getFullPath;\n    function _getFullPath(resolver, p) {\n      const serialized = resolver.serialize(p);\n      return serialized.split(\"#\")[0] + \"#\";\n    }\n    exports2._getFullPath = _getFullPath;\n    var TRAILING_SLASH_HASH = /#\\/?$/;\n    function normalizeId(id) {\n      return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n    }\n    exports2.normalizeId = normalizeId;\n    function resolveUrl(resolver, baseId, id) {\n      id = normalizeId(id);\n      return resolver.resolve(baseId, id);\n    }\n    exports2.resolveUrl = resolveUrl;\n    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n    function getSchemaRefs(schema, baseId) {\n      if (typeof schema == \"boolean\")\n        return {};\n      const { schemaId, uriResolver } = this.opts;\n      const schId = normalizeId(schema[schemaId] || baseId);\n      const baseIds = { \"\": schId };\n      const pathPrefix = getFullPath(uriResolver, schId, false);\n      const localRefs = {};\n      const schemaRefs = /* @__PURE__ */ new Set();\n      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === void 0)\n          return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n          innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n          const _resolve = this.opts.uriResolver.resolve;\n          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n          if (schemaRefs.has(ref))\n            throw ambiguos(ref);\n          schemaRefs.add(ref);\n          let schOrRef = this.refs[ref];\n          if (typeof schOrRef == \"string\")\n            schOrRef = this.refs[schOrRef];\n          if (typeof schOrRef == \"object\") {\n            checkAmbiguosRef(sch, schOrRef.schema, ref);\n          } else if (ref !== normalizeId(fullPath)) {\n            if (ref[0] === \"#\") {\n              checkAmbiguosRef(sch, localRefs[ref], ref);\n              localRefs[ref] = sch;\n            } else {\n              this.refs[ref] = fullPath;\n            }\n          }\n          return ref;\n        }\n        function addAnchor(anchor) {\n          if (typeof anchor == \"string\") {\n            if (!ANCHOR.test(anchor))\n              throw new Error(`invalid anchor \"${anchor}\"`);\n            addRef.call(this, `#${anchor}`);\n          }\n        }\n      });\n      return localRefs;\n      function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== void 0 && !equal(sch1, sch2))\n          throw ambiguos(ref);\n      }\n      function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n      }\n    }\n    exports2.getSchemaRefs = getSchemaRefs;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/validate/index.js\nvar require_validate = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/validate/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;\n    var boolSchema_1 = require_boolSchema();\n    var dataType_1 = require_dataType();\n    var applicability_1 = require_applicability();\n    var dataType_2 = require_dataType();\n    var defaults_1 = require_defaults();\n    var keyword_1 = require_keyword();\n    var subschema_1 = require_subschema();\n    var codegen_1 = require_codegen();\n    var names_1 = require_names();\n    var resolve_1 = require_resolve();\n    var util_1 = require_util2();\n    var errors_1 = require_errors();\n    function validateFunctionCode(it) {\n      if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n          topSchemaObjCode(it);\n          return;\n        }\n      }\n      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n    }\n    exports2.validateFunctionCode = validateFunctionCode;\n    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n      if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n          gen.code((0, codegen_1._)`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n          destructureValCxtES5(gen, opts);\n          gen.code(body);\n        });\n      } else {\n        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n      }\n    }\n    function destructureValCxt(opts) {\n      return (0, codegen_1._)`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n    }\n    function destructureValCxtES5(gen, opts) {\n      gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n      }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._)`\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);\n      });\n    }\n    function topSchemaObjCode(it) {\n      const { schema, opts, gen } = it;\n      validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n          commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n          resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n      });\n      return;\n    }\n    function resetEvaluated(it) {\n      const { gen, validateName } = it;\n      it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)`${validateName}.evaluated`);\n      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));\n      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));\n    }\n    function funcSourceUrl(schema, opts) {\n      const schId = typeof schema == \"object\" && schema[opts.schemaId];\n      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;\n    }\n    function subschemaCode(it, valid) {\n      if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n          subSchemaObjCode(it, valid);\n          return;\n        }\n      }\n      (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n    }\n    function schemaCxtHasRules({ schema, self: self2 }) {\n      if (typeof schema == \"boolean\")\n        return !schema;\n      for (const key in schema)\n        if (self2.RULES.all[key])\n          return true;\n      return false;\n    }\n    function isSchemaObj(it) {\n      return typeof it.schema != \"boolean\";\n    }\n    function subSchemaObjCode(it, valid) {\n      const { schema, gen, opts } = it;\n      if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n      updateContext(it);\n      checkAsyncSchema(it);\n      const errsCount = gen.const(\"_errs\", names_1.default.errors);\n      typeAndKeywords(it, errsCount);\n      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n    }\n    function checkKeywords(it) {\n      (0, util_1.checkUnknownRules)(it);\n      checkRefsAndKeywords(it);\n    }\n    function typeAndKeywords(it, errsCount) {\n      if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n      const types = (0, dataType_1.getSchemaTypes)(it.schema);\n      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n      schemaKeywords(it, types, !checkedTypes, errsCount);\n    }\n    function checkRefsAndKeywords(it) {\n      const { schema, errSchemaPath, opts, self: self2 } = it;\n      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {\n        self2.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n      }\n    }\n    function checkNoDefault(it) {\n      const { schema, opts } = it;\n      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n      }\n    }\n    function updateContext(it) {\n      const schId = it.schema[it.opts.schemaId];\n      if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n    }\n    function checkAsyncSchema(it) {\n      if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n    }\n    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n      const msg = schema.$comment;\n      if (opts.$comment === true) {\n        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);\n      } else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n      }\n    }\n    function returnResults(it) {\n      const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n      if (schemaEnv.$async) {\n        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));\n      } else {\n        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n          assignEvaluated(it);\n        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);\n      }\n    }\n    function assignEvaluated({ gen, evaluated, props, items }) {\n      if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._)`${evaluated}.props`, props);\n      if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._)`${evaluated}.items`, items);\n    }\n    function schemaKeywords(it, types, typeErrors, errsCount) {\n      const { gen, schema, data, allErrors, opts, self: self2 } = it;\n      const { RULES } = self2;\n      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition));\n        return;\n      }\n      if (!opts.jtd)\n        checkStrictTypes(it, types);\n      gen.block(() => {\n        for (const group of RULES.rules)\n          groupKeywords(group);\n        groupKeywords(RULES.post);\n      });\n      function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n          return;\n        if (group.type) {\n          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n          iterateKeywords(it, group);\n          if (types.length === 1 && types[0] === group.type && typeErrors) {\n            gen.else();\n            (0, dataType_2.reportTypeError)(it);\n          }\n          gen.endIf();\n        } else {\n          iterateKeywords(it, group);\n        }\n        if (!allErrors)\n          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);\n      }\n    }\n    function iterateKeywords(it, group) {\n      const { gen, schema, opts: { useDefaults } } = it;\n      if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n      gen.block(() => {\n        for (const rule of group.rules) {\n          if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n            keywordCode(it, rule.keyword, rule.definition, group.type);\n          }\n        }\n      });\n    }\n    function checkStrictTypes(it, types) {\n      if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n      checkContextTypes(it, types);\n      if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n      checkKeywordTypes(it, it.dataTypes);\n    }\n    function checkContextTypes(it, types) {\n      if (!types.length)\n        return;\n      if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n      }\n      types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n          strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n      });\n      narrowSchemaTypes(it, types);\n    }\n    function checkMultipleTypes(it, ts) {\n      if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n      }\n    }\n    function checkKeywordTypes(it, ts) {\n      const rules = it.self.RULES.all;\n      for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n          const { type } = rule.definition;\n          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n            strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n          }\n        }\n      }\n    }\n    function hasApplicableType(schTs, kwdT) {\n      return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n    }\n    function includesType(ts, t) {\n      return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n    }\n    function narrowSchemaTypes(it, withTypes) {\n      const ts = [];\n      for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n          ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n          ts.push(\"integer\");\n      }\n      it.dataTypes = ts;\n    }\n    function strictTypesError(it, msg) {\n      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n      msg += ` at \"${schemaPath}\" (strictTypes)`;\n      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n    }\n    var KeywordCxt = class {\n      constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n          this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        } else {\n          this.schemaCode = this.schemaValue;\n          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n          }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n          this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n      }\n      result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n      }\n      failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n          failAction();\n        else\n          this.error();\n        if (successAction) {\n          this.gen.else();\n          successAction();\n          if (this.allErrors)\n            this.gen.endIf();\n        } else {\n          if (this.allErrors)\n            this.gen.endIf();\n          else\n            this.gen.else();\n        }\n      }\n      pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), void 0, failAction);\n      }\n      fail(condition) {\n        if (condition === void 0) {\n          this.error();\n          if (!this.allErrors)\n            this.gen.if(false);\n          return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n          this.gen.endIf();\n        else\n          this.gen.else();\n      }\n      fail$data(condition) {\n        if (!this.$data)\n          return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n      }\n      error(append, errorParams, errorPaths) {\n        if (errorParams) {\n          this.setParams(errorParams);\n          this._error(append, errorPaths);\n          this.setParams({});\n          return;\n        }\n        this._error(append, errorPaths);\n      }\n      _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n      }\n      $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n      }\n      reset() {\n        if (this.errsCount === void 0)\n          throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n      }\n      ok(cond) {\n        if (!this.allErrors)\n          this.gen.if(cond);\n      }\n      setParams(obj, assign) {\n        if (assign)\n          Object.assign(this.params, obj);\n        else\n          this.params = obj;\n      }\n      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n          this.check$data(valid, $dataValid);\n          codeBlock();\n        });\n      }\n      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n          return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n          gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n          gen.elseIf(this.invalid$data());\n          this.$dataError();\n          if (valid !== codegen_1.nil)\n            gen.assign(valid, false);\n        }\n        gen.else();\n      }\n      invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n          if (schemaType.length) {\n            if (!(schemaCode instanceof codegen_1.Name))\n              throw new Error(\"ajv implementation error\");\n            const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n          }\n          return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n          if (def.validateSchema) {\n            const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema });\n            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;\n          }\n          return codegen_1.nil;\n        }\n      }\n      subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n      }\n      mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n          return;\n        if (it.props !== true && schemaCxt.props !== void 0) {\n          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== void 0) {\n          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n      }\n      mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n          return true;\n        }\n      }\n    };\n    exports2.KeywordCxt = KeywordCxt;\n    function keywordCode(it, keyword, def, ruleType) {\n      const cxt = new KeywordCxt(it, def, keyword);\n      if (\"code\" in def) {\n        def.code(cxt, ruleType);\n      } else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n      } else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n      } else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n      }\n    }\n    var JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\n    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n    function getData($data, { dataLevel, dataNames, dataPathArr }) {\n      let jsonPointer;\n      let data;\n      if ($data === \"\")\n        return names_1.default.rootData;\n      if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n          throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n      } else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n          throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n          if (up >= dataLevel)\n            throw new Error(errorMsg(\"property/index\", up));\n          return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n          throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n          return data;\n      }\n      let expr = data;\n      const segments = jsonPointer.split(\"/\");\n      for (const segment of segments) {\n        if (segment) {\n          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n          expr = (0, codegen_1._)`${expr} && ${data}`;\n        }\n      }\n      return expr;\n      function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n      }\n    }\n    exports2.getData = getData;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/runtime/validation_error.js\nvar require_validation_error = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/runtime/validation_error.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var ValidationError = class extends Error {\n      constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n      }\n    };\n    exports2.default = ValidationError;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/ref_error.js\nvar require_ref_error = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/ref_error.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var resolve_1 = require_resolve();\n    var MissingRefError = class extends Error {\n      constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n      }\n    };\n    exports2.default = MissingRefError;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/compile/index.js\nvar require_compile = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/compile/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;\n    var codegen_1 = require_codegen();\n    var validation_error_1 = require_validation_error();\n    var names_1 = require_names();\n    var resolve_1 = require_resolve();\n    var util_1 = require_util2();\n    var validate_1 = require_validate();\n    var SchemaEnv = class {\n      constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n          schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n      }\n    };\n    exports2.SchemaEnv = SchemaEnv;\n    function compileSchema(sch) {\n      const _sch = getCompilingSchema.call(this, sch);\n      if (_sch)\n        return _sch;\n      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);\n      const { es5, lines } = this.opts.code;\n      const { ownProperties } = this.opts;\n      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n      let _ValidationError;\n      if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n          ref: validation_error_1.default,\n          code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n        });\n      }\n      const validateName = gen.scopeName(\"validate\");\n      sch.validateName = validateName;\n      const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: /* @__PURE__ */ new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._)`\"\"`,\n        opts: this.opts,\n        self: this\n      };\n      let sourceCode;\n      try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        if (this.opts.code.process)\n          sourceCode = this.opts.code.process(sourceCode, sch);\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n          validate.$async = true;\n        if (this.opts.code.source === true) {\n          validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n          const { props, items } = schemaCxt;\n          validate.evaluated = {\n            props: props instanceof codegen_1.Name ? void 0 : props,\n            items: items instanceof codegen_1.Name ? void 0 : items,\n            dynamicProps: props instanceof codegen_1.Name,\n            dynamicItems: items instanceof codegen_1.Name\n          };\n          if (validate.source)\n            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n      } catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n          this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        throw e;\n      } finally {\n        this._compilations.delete(sch);\n      }\n    }\n    exports2.compileSchema = compileSchema;\n    function resolveRef(root, baseId, ref) {\n      var _a;\n      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n      const schOrFunc = root.refs[ref];\n      if (schOrFunc)\n        return schOrFunc;\n      let _sch = resolve.call(this, root, ref);\n      if (_sch === void 0) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];\n        const { schemaId } = this.opts;\n        if (schema)\n          _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n      }\n      if (_sch === void 0)\n        return;\n      return root.refs[ref] = inlineOrCompile.call(this, _sch);\n    }\n    exports2.resolveRef = resolveRef;\n    function inlineOrCompile(sch) {\n      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n      return sch.validate ? sch : compileSchema.call(this, sch);\n    }\n    function getCompilingSchema(schEnv) {\n      for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n          return sch;\n      }\n    }\n    exports2.getCompilingSchema = getCompilingSchema;\n    function sameSchemaEnv(s1, s2) {\n      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n    }\n    function resolve(root, ref) {\n      let sch;\n      while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n    }\n    function resolveSchema(root, ref) {\n      const p = this.opts.uriResolver.parse(ref);\n      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);\n      if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n      }\n      const id = (0, resolve_1.normalizeId)(refPath);\n      const schOrRef = this.refs[id] || this.schemas[id];\n      if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n          return;\n        return getJsonPointer.call(this, p, sch);\n      }\n      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n      if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n      if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n      }\n      return getJsonPointer.call(this, p, schOrRef);\n    }\n    exports2.resolveSchema = resolveSchema;\n    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([\n      \"properties\",\n      \"patternProperties\",\n      \"enum\",\n      \"dependencies\",\n      \"definitions\"\n    ]);\n    function getJsonPointer(parsedRef, { baseId, schema, root }) {\n      var _a;\n      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n      for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n          return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === void 0)\n          return;\n        schema = partSchema;\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n      }\n      let env;\n      if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n      }\n      const { schemaId } = this.opts;\n      env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n      if (env.schema !== env.root.schema)\n        return env;\n      return void 0;\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/refs/data.json\nvar require_data = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/refs/data.json\"(exports2, module2) {\n    module2.exports = {\n      $id: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n      description: \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n      type: \"object\",\n      required: [\"$data\"],\n      properties: {\n        $data: {\n          type: \"string\",\n          anyOf: [{ format: \"relative-json-pointer\" }, { format: \"json-pointer\" }]\n        }\n      },\n      additionalProperties: false\n    };\n  }\n});\n\n// node_modules/fast-uri/lib/utils.js\nvar require_utils3 = __commonJS({\n  \"node_modules/fast-uri/lib/utils.js\"(exports2, module2) {\n    \"use strict\";\n    var isUUID = RegExp.prototype.test.bind(/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu);\n    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u);\n    function stringArrayToHexStripped(input) {\n      let acc = \"\";\n      let code = 0;\n      let i = 0;\n      for (i = 0; i < input.length; i++) {\n        code = input[i].charCodeAt(0);\n        if (code === 48) {\n          continue;\n        }\n        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n          return \"\";\n        }\n        acc += input[i];\n        break;\n      }\n      for (i += 1; i < input.length; i++) {\n        code = input[i].charCodeAt(0);\n        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n          return \"\";\n        }\n        acc += input[i];\n      }\n      return acc;\n    }\n    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!\"$&'()*+,\\-.;=_`a-z{}~]/u);\n    function consumeIsZone(buffer) {\n      buffer.length = 0;\n      return true;\n    }\n    function consumeHextets(buffer, address, output) {\n      if (buffer.length) {\n        const hex = stringArrayToHexStripped(buffer);\n        if (hex !== \"\") {\n          address.push(hex);\n        } else {\n          output.error = true;\n          return false;\n        }\n        buffer.length = 0;\n      }\n      return true;\n    }\n    function getIPV6(input) {\n      let tokenCount = 0;\n      const output = { error: false, address: \"\", zone: \"\" };\n      const address = [];\n      const buffer = [];\n      let endipv6Encountered = false;\n      let endIpv6 = false;\n      let consume = consumeHextets;\n      for (let i = 0; i < input.length; i++) {\n        const cursor = input[i];\n        if (cursor === \"[\" || cursor === \"]\") {\n          continue;\n        }\n        if (cursor === \":\") {\n          if (endipv6Encountered === true) {\n            endIpv6 = true;\n          }\n          if (!consume(buffer, address, output)) {\n            break;\n          }\n          if (++tokenCount > 7) {\n            output.error = true;\n            break;\n          }\n          if (i > 0 && input[i - 1] === \":\") {\n            endipv6Encountered = true;\n          }\n          address.push(\":\");\n          continue;\n        } else if (cursor === \"%\") {\n          if (!consume(buffer, address, output)) {\n            break;\n          }\n          consume = consumeIsZone;\n        } else {\n          buffer.push(cursor);\n          continue;\n        }\n      }\n      if (buffer.length) {\n        if (consume === consumeIsZone) {\n          output.zone = buffer.join(\"\");\n        } else if (endIpv6) {\n          address.push(buffer.join(\"\"));\n        } else {\n          address.push(stringArrayToHexStripped(buffer));\n        }\n      }\n      output.address = address.join(\"\");\n      return output;\n    }\n    function normalizeIPv6(host) {\n      if (findToken(host, \":\") < 2) {\n        return { host, isIPV6: false };\n      }\n      const ipv6 = getIPV6(host);\n      if (!ipv6.error) {\n        let newHost = ipv6.address;\n        let escapedHost = ipv6.address;\n        if (ipv6.zone) {\n          newHost += \"%\" + ipv6.zone;\n          escapedHost += \"%25\" + ipv6.zone;\n        }\n        return { host: newHost, isIPV6: true, escapedHost };\n      } else {\n        return { host, isIPV6: false };\n      }\n    }\n    function findToken(str, token) {\n      let ind = 0;\n      for (let i = 0; i < str.length; i++) {\n        if (str[i] === token) ind++;\n      }\n      return ind;\n    }\n    function removeDotSegments(path6) {\n      let input = path6;\n      const output = [];\n      let nextSlash = -1;\n      let len = 0;\n      while (len = input.length) {\n        if (len === 1) {\n          if (input === \".\") {\n            break;\n          } else if (input === \"/\") {\n            output.push(\"/\");\n            break;\n          } else {\n            output.push(input);\n            break;\n          }\n        } else if (len === 2) {\n          if (input[0] === \".\") {\n            if (input[1] === \".\") {\n              break;\n            } else if (input[1] === \"/\") {\n              input = input.slice(2);\n              continue;\n            }\n          } else if (input[0] === \"/\") {\n            if (input[1] === \".\" || input[1] === \"/\") {\n              output.push(\"/\");\n              break;\n            }\n          }\n        } else if (len === 3) {\n          if (input === \"/..\") {\n            if (output.length !== 0) {\n              output.pop();\n            }\n            output.push(\"/\");\n            break;\n          }\n        }\n        if (input[0] === \".\") {\n          if (input[1] === \".\") {\n            if (input[2] === \"/\") {\n              input = input.slice(3);\n              continue;\n            }\n          } else if (input[1] === \"/\") {\n            input = input.slice(2);\n            continue;\n          }\n        } else if (input[0] === \"/\") {\n          if (input[1] === \".\") {\n            if (input[2] === \"/\") {\n              input = input.slice(2);\n              continue;\n            } else if (input[2] === \".\") {\n              if (input[3] === \"/\") {\n                input = input.slice(3);\n                if (output.length !== 0) {\n                  output.pop();\n                }\n                continue;\n              }\n            }\n          }\n        }\n        if ((nextSlash = input.indexOf(\"/\", 1)) === -1) {\n          output.push(input);\n          break;\n        } else {\n          output.push(input.slice(0, nextSlash));\n          input = input.slice(nextSlash);\n        }\n      }\n      return output.join(\"\");\n    }\n    function normalizeComponentEncoding(component, esc) {\n      const func = esc !== true ? escape : unescape;\n      if (component.scheme !== void 0) {\n        component.scheme = func(component.scheme);\n      }\n      if (component.userinfo !== void 0) {\n        component.userinfo = func(component.userinfo);\n      }\n      if (component.host !== void 0) {\n        component.host = func(component.host);\n      }\n      if (component.path !== void 0) {\n        component.path = func(component.path);\n      }\n      if (component.query !== void 0) {\n        component.query = func(component.query);\n      }\n      if (component.fragment !== void 0) {\n        component.fragment = func(component.fragment);\n      }\n      return component;\n    }\n    function recomposeAuthority(component) {\n      const uriTokens = [];\n      if (component.userinfo !== void 0) {\n        uriTokens.push(component.userinfo);\n        uriTokens.push(\"@\");\n      }\n      if (component.host !== void 0) {\n        let host = unescape(component.host);\n        if (!isIPv4(host)) {\n          const ipV6res = normalizeIPv6(host);\n          if (ipV6res.isIPV6 === true) {\n            host = `[${ipV6res.escapedHost}]`;\n          } else {\n            host = component.host;\n          }\n        }\n        uriTokens.push(host);\n      }\n      if (typeof component.port === \"number\" || typeof component.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(component.port));\n      }\n      return uriTokens.length ? uriTokens.join(\"\") : void 0;\n    }\n    module2.exports = {\n      nonSimpleDomain,\n      recomposeAuthority,\n      normalizeComponentEncoding,\n      removeDotSegments,\n      isIPv4,\n      isUUID,\n      normalizeIPv6,\n      stringArrayToHexStripped\n    };\n  }\n});\n\n// node_modules/fast-uri/lib/schemes.js\nvar require_schemes = __commonJS({\n  \"node_modules/fast-uri/lib/schemes.js\"(exports2, module2) {\n    \"use strict\";\n    var { isUUID } = require_utils3();\n    var URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu;\n    var supportedSchemeNames = (\n      /** @type {const} */\n      [\n        \"http\",\n        \"https\",\n        \"ws\",\n        \"wss\",\n        \"urn\",\n        \"urn:uuid\"\n      ]\n    );\n    function isValidSchemeName(name) {\n      return supportedSchemeNames.indexOf(\n        /** @type {*} */\n        name\n      ) !== -1;\n    }\n    function wsIsSecure(wsComponent) {\n      if (wsComponent.secure === true) {\n        return true;\n      } else if (wsComponent.secure === false) {\n        return false;\n      } else if (wsComponent.scheme) {\n        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === \"w\" || wsComponent.scheme[0] === \"W\") && (wsComponent.scheme[1] === \"s\" || wsComponent.scheme[1] === \"S\") && (wsComponent.scheme[2] === \"s\" || wsComponent.scheme[2] === \"S\");\n      } else {\n        return false;\n      }\n    }\n    function httpParse(component) {\n      if (!component.host) {\n        component.error = component.error || \"HTTP URIs must have a host.\";\n      }\n      return component;\n    }\n    function httpSerialize(component) {\n      const secure = String(component.scheme).toLowerCase() === \"https\";\n      if (component.port === (secure ? 443 : 80) || component.port === \"\") {\n        component.port = void 0;\n      }\n      if (!component.path) {\n        component.path = \"/\";\n      }\n      return component;\n    }\n    function wsParse(wsComponent) {\n      wsComponent.secure = wsIsSecure(wsComponent);\n      wsComponent.resourceName = (wsComponent.path || \"/\") + (wsComponent.query ? \"?\" + wsComponent.query : \"\");\n      wsComponent.path = void 0;\n      wsComponent.query = void 0;\n      return wsComponent;\n    }\n    function wsSerialize(wsComponent) {\n      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === \"\") {\n        wsComponent.port = void 0;\n      }\n      if (typeof wsComponent.secure === \"boolean\") {\n        wsComponent.scheme = wsComponent.secure ? \"wss\" : \"ws\";\n        wsComponent.secure = void 0;\n      }\n      if (wsComponent.resourceName) {\n        const [path6, query] = wsComponent.resourceName.split(\"?\");\n        wsComponent.path = path6 && path6 !== \"/\" ? path6 : void 0;\n        wsComponent.query = query;\n        wsComponent.resourceName = void 0;\n      }\n      wsComponent.fragment = void 0;\n      return wsComponent;\n    }\n    function urnParse(urnComponent, options) {\n      if (!urnComponent.path) {\n        urnComponent.error = \"URN can not be parsed\";\n        return urnComponent;\n      }\n      const matches = urnComponent.path.match(URN_REG);\n      if (matches) {\n        const scheme = options.scheme || urnComponent.scheme || \"urn\";\n        urnComponent.nid = matches[1].toLowerCase();\n        urnComponent.nss = matches[2];\n        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;\n        const schemeHandler = getSchemeHandler(urnScheme);\n        urnComponent.path = void 0;\n        if (schemeHandler) {\n          urnComponent = schemeHandler.parse(urnComponent, options);\n        }\n      } else {\n        urnComponent.error = urnComponent.error || \"URN can not be parsed.\";\n      }\n      return urnComponent;\n    }\n    function urnSerialize(urnComponent, options) {\n      if (urnComponent.nid === void 0) {\n        throw new Error(\"URN without nid cannot be serialized\");\n      }\n      const scheme = options.scheme || urnComponent.scheme || \"urn\";\n      const nid = urnComponent.nid.toLowerCase();\n      const urnScheme = `${scheme}:${options.nid || nid}`;\n      const schemeHandler = getSchemeHandler(urnScheme);\n      if (schemeHandler) {\n        urnComponent = schemeHandler.serialize(urnComponent, options);\n      }\n      const uriComponent = urnComponent;\n      const nss = urnComponent.nss;\n      uriComponent.path = `${nid || options.nid}:${nss}`;\n      options.skipEscape = true;\n      return uriComponent;\n    }\n    function urnuuidParse(urnComponent, options) {\n      const uuidComponent = urnComponent;\n      uuidComponent.uuid = uuidComponent.nss;\n      uuidComponent.nss = void 0;\n      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {\n        uuidComponent.error = uuidComponent.error || \"UUID is not valid.\";\n      }\n      return uuidComponent;\n    }\n    function urnuuidSerialize(uuidComponent) {\n      const urnComponent = uuidComponent;\n      urnComponent.nss = (uuidComponent.uuid || \"\").toLowerCase();\n      return urnComponent;\n    }\n    var http = (\n      /** @type {SchemeHandler} */\n      {\n        scheme: \"http\",\n        domainHost: true,\n        parse: httpParse,\n        serialize: httpSerialize\n      }\n    );\n    var https = (\n      /** @type {SchemeHandler} */\n      {\n        scheme: \"https\",\n        domainHost: http.domainHost,\n        parse: httpParse,\n        serialize: httpSerialize\n      }\n    );\n    var ws = (\n      /** @type {SchemeHandler} */\n      {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: wsParse,\n        serialize: wsSerialize\n      }\n    );\n    var wss = (\n      /** @type {SchemeHandler} */\n      {\n        scheme: \"wss\",\n        domainHost: ws.domainHost,\n        parse: ws.parse,\n        serialize: ws.serialize\n      }\n    );\n    var urn = (\n      /** @type {SchemeHandler} */\n      {\n        scheme: \"urn\",\n        parse: urnParse,\n        serialize: urnSerialize,\n        skipNormalize: true\n      }\n    );\n    var urnuuid = (\n      /** @type {SchemeHandler} */\n      {\n        scheme: \"urn:uuid\",\n        parse: urnuuidParse,\n        serialize: urnuuidSerialize,\n        skipNormalize: true\n      }\n    );\n    var SCHEMES = (\n      /** @type {Record<SchemeName, SchemeHandler>} */\n      {\n        http,\n        https,\n        ws,\n        wss,\n        urn,\n        \"urn:uuid\": urnuuid\n      }\n    );\n    Object.setPrototypeOf(SCHEMES, null);\n    function getSchemeHandler(scheme) {\n      return scheme && (SCHEMES[\n        /** @type {SchemeName} */\n        scheme\n      ] || SCHEMES[\n        /** @type {SchemeName} */\n        scheme.toLowerCase()\n      ]) || void 0;\n    }\n    module2.exports = {\n      wsIsSecure,\n      SCHEMES,\n      isValidSchemeName,\n      getSchemeHandler\n    };\n  }\n});\n\n// node_modules/fast-uri/index.js\nvar require_fast_uri = __commonJS({\n  \"node_modules/fast-uri/index.js\"(exports2, module2) {\n    \"use strict\";\n    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils3();\n    var { SCHEMES, getSchemeHandler } = require_schemes();\n    function normalize(uri, options) {\n      if (typeof uri === \"string\") {\n        uri = /** @type {T} */\n        serialize(parse(uri, options), options);\n      } else if (typeof uri === \"object\") {\n        uri = /** @type {T} */\n        parse(serialize(uri, options), options);\n      }\n      return uri;\n    }\n    function resolve(baseURI, relativeURI, options) {\n      const schemelessOptions = options ? Object.assign({ scheme: \"null\" }, options) : { scheme: \"null\" };\n      const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);\n      schemelessOptions.skipEscape = true;\n      return serialize(resolved, schemelessOptions);\n    }\n    function resolveComponent(base, relative, options, skipNormalization) {\n      const target = {};\n      if (!skipNormalization) {\n        base = parse(serialize(base, options), options);\n        relative = parse(serialize(relative, options), options);\n      }\n      options = options || {};\n      if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n      } else {\n        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {\n          target.userinfo = relative.userinfo;\n          target.host = relative.host;\n          target.port = relative.port;\n          target.path = removeDotSegments(relative.path || \"\");\n          target.query = relative.query;\n        } else {\n          if (!relative.path) {\n            target.path = base.path;\n            if (relative.query !== void 0) {\n              target.query = relative.query;\n            } else {\n              target.query = base.query;\n            }\n          } else {\n            if (relative.path[0] === \"/\") {\n              target.path = removeDotSegments(relative.path);\n            } else {\n              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {\n                target.path = \"/\" + relative.path;\n              } else if (!base.path) {\n                target.path = relative.path;\n              } else {\n                target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n              }\n              target.path = removeDotSegments(target.path);\n            }\n            target.query = relative.query;\n          }\n          target.userinfo = base.userinfo;\n          target.host = base.host;\n          target.port = base.port;\n        }\n        target.scheme = base.scheme;\n      }\n      target.fragment = relative.fragment;\n      return target;\n    }\n    function equal(uriA, uriB, options) {\n      if (typeof uriA === \"string\") {\n        uriA = unescape(uriA);\n        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });\n      } else if (typeof uriA === \"object\") {\n        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });\n      }\n      if (typeof uriB === \"string\") {\n        uriB = unescape(uriB);\n        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });\n      } else if (typeof uriB === \"object\") {\n        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });\n      }\n      return uriA.toLowerCase() === uriB.toLowerCase();\n    }\n    function serialize(cmpts, opts) {\n      const component = {\n        host: cmpts.host,\n        scheme: cmpts.scheme,\n        userinfo: cmpts.userinfo,\n        port: cmpts.port,\n        path: cmpts.path,\n        query: cmpts.query,\n        nid: cmpts.nid,\n        nss: cmpts.nss,\n        uuid: cmpts.uuid,\n        fragment: cmpts.fragment,\n        reference: cmpts.reference,\n        resourceName: cmpts.resourceName,\n        secure: cmpts.secure,\n        error: \"\"\n      };\n      const options = Object.assign({}, opts);\n      const uriTokens = [];\n      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);\n      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);\n      if (component.path !== void 0) {\n        if (!options.skipEscape) {\n          component.path = escape(component.path);\n          if (component.scheme !== void 0) {\n            component.path = component.path.split(\"%3A\").join(\":\");\n          }\n        } else {\n          component.path = unescape(component.path);\n        }\n      }\n      if (options.reference !== \"suffix\" && component.scheme) {\n        uriTokens.push(component.scheme, \":\");\n      }\n      const authority = recomposeAuthority(component);\n      if (authority !== void 0) {\n        if (options.reference !== \"suffix\") {\n          uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (component.path && component.path[0] !== \"/\") {\n          uriTokens.push(\"/\");\n        }\n      }\n      if (component.path !== void 0) {\n        let s = component.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n          s = removeDotSegments(s);\n        }\n        if (authority === void 0 && s[0] === \"/\" && s[1] === \"/\") {\n          s = \"/%2F\" + s.slice(2);\n        }\n        uriTokens.push(s);\n      }\n      if (component.query !== void 0) {\n        uriTokens.push(\"?\", component.query);\n      }\n      if (component.fragment !== void 0) {\n        uriTokens.push(\"#\", component.fragment);\n      }\n      return uriTokens.join(\"\");\n    }\n    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u;\n    function parse(uri, opts) {\n      const options = Object.assign({}, opts);\n      const parsed = {\n        scheme: void 0,\n        userinfo: void 0,\n        host: \"\",\n        port: void 0,\n        path: \"\",\n        query: void 0,\n        fragment: void 0\n      };\n      let isIP = false;\n      if (options.reference === \"suffix\") {\n        if (options.scheme) {\n          uri = options.scheme + \":\" + uri;\n        } else {\n          uri = \"//\" + uri;\n        }\n      }\n      const matches = uri.match(URI_PARSE);\n      if (matches) {\n        parsed.scheme = matches[1];\n        parsed.userinfo = matches[3];\n        parsed.host = matches[4];\n        parsed.port = parseInt(matches[5], 10);\n        parsed.path = matches[6] || \"\";\n        parsed.query = matches[7];\n        parsed.fragment = matches[8];\n        if (isNaN(parsed.port)) {\n          parsed.port = matches[5];\n        }\n        if (parsed.host) {\n          const ipv4result = isIPv4(parsed.host);\n          if (ipv4result === false) {\n            const ipv6result = normalizeIPv6(parsed.host);\n            parsed.host = ipv6result.host.toLowerCase();\n            isIP = ipv6result.isIPV6;\n          } else {\n            isIP = true;\n          }\n        }\n        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {\n          parsed.reference = \"same-document\";\n        } else if (parsed.scheme === void 0) {\n          parsed.reference = \"relative\";\n        } else if (parsed.fragment === void 0) {\n          parsed.reference = \"absolute\";\n        } else {\n          parsed.reference = \"uri\";\n        }\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== parsed.reference) {\n          parsed.error = parsed.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {\n            try {\n              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());\n            } catch (e) {\n              parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e;\n            }\n          }\n        }\n        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {\n          if (uri.indexOf(\"%\") !== -1) {\n            if (parsed.scheme !== void 0) {\n              parsed.scheme = unescape(parsed.scheme);\n            }\n            if (parsed.host !== void 0) {\n              parsed.host = unescape(parsed.host);\n            }\n          }\n          if (parsed.path) {\n            parsed.path = escape(unescape(parsed.path));\n          }\n          if (parsed.fragment) {\n            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));\n          }\n        }\n        if (schemeHandler && schemeHandler.parse) {\n          schemeHandler.parse(parsed, options);\n        }\n      } else {\n        parsed.error = parsed.error || \"URI can not be parsed.\";\n      }\n      return parsed;\n    }\n    var fastUri = {\n      SCHEMES,\n      normalize,\n      resolve,\n      resolveComponent,\n      equal,\n      serialize,\n      parse\n    };\n    module2.exports = fastUri;\n    module2.exports.default = fastUri;\n    module2.exports.fastUri = fastUri;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/runtime/uri.js\nvar require_uri = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/runtime/uri.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var uri = require_fast_uri();\n    uri.code = 'require(\"ajv/dist/runtime/uri\").default';\n    exports2.default = uri;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/core.js\nvar require_core2 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/core.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;\n    var validate_1 = require_validate();\n    Object.defineProperty(exports2, \"KeywordCxt\", { enumerable: true, get: function() {\n      return validate_1.KeywordCxt;\n    } });\n    var codegen_1 = require_codegen();\n    Object.defineProperty(exports2, \"_\", { enumerable: true, get: function() {\n      return codegen_1._;\n    } });\n    Object.defineProperty(exports2, \"str\", { enumerable: true, get: function() {\n      return codegen_1.str;\n    } });\n    Object.defineProperty(exports2, \"stringify\", { enumerable: true, get: function() {\n      return codegen_1.stringify;\n    } });\n    Object.defineProperty(exports2, \"nil\", { enumerable: true, get: function() {\n      return codegen_1.nil;\n    } });\n    Object.defineProperty(exports2, \"Name\", { enumerable: true, get: function() {\n      return codegen_1.Name;\n    } });\n    Object.defineProperty(exports2, \"CodeGen\", { enumerable: true, get: function() {\n      return codegen_1.CodeGen;\n    } });\n    var validation_error_1 = require_validation_error();\n    var ref_error_1 = require_ref_error();\n    var rules_1 = require_rules();\n    var compile_1 = require_compile();\n    var codegen_2 = require_codegen();\n    var resolve_1 = require_resolve();\n    var dataType_1 = require_dataType();\n    var util_1 = require_util2();\n    var $dataRefSchema = require_data();\n    var uri_1 = require_uri();\n    var defaultRegExp = (str, flags) => new RegExp(str, flags);\n    defaultRegExp.code = \"new RegExp\";\n    var META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\n    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([\n      \"validate\",\n      \"serialize\",\n      \"parse\",\n      \"wrapper\",\n      \"root\",\n      \"schema\",\n      \"keyword\",\n      \"pattern\",\n      \"formats\",\n      \"validate$data\",\n      \"func\",\n      \"obj\",\n      \"Error\"\n    ]);\n    var removedOptions = {\n      errorDataPath: \"\",\n      format: \"`validateFormats: false` can be used instead.\",\n      nullable: '\"nullable\" keyword is supported by default.',\n      jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n      extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n      missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n      processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n      sourceCode: \"Use option `code: {source: true}`\",\n      strictDefaults: \"It is default now, see option `strict`.\",\n      strictKeywords: \"It is default now, see option `strict`.\",\n      uniqueItems: '\"uniqueItems\" keyword is always validated.',\n      unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n      cache: \"Map is used as cache, schema object as key.\",\n      serialize: \"Map is used as cache, schema object as key.\",\n      ajvErrors: \"It is default now.\"\n    };\n    var deprecatedOptions = {\n      ignoreKeywordsWithRef: \"\",\n      jsPropertySyntax: \"\",\n      unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n    };\n    var MAX_EXPRESSION = 200;\n    function requiredOptions(o) {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n      const s = o.strict;\n      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;\n      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n      return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver\n      };\n    }\n    var Ajv = class {\n      constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = /* @__PURE__ */ new Set();\n        this._loading = {};\n        this._cache = /* @__PURE__ */ new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n          addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n          addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n          this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n      }\n      _addVocabularies() {\n        this.addKeyword(\"$async\");\n      }\n      _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n          _dataRefSchema = { ...$dataRefSchema };\n          _dataRefSchema.id = _dataRefSchema.$id;\n          delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n      }\n      defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : void 0;\n      }\n      validate(schemaKeyRef, data) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n          v = this.getSchema(schemaKeyRef);\n          if (!v)\n            throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        } else {\n          v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n          this.errors = v.errors;\n        return valid;\n      }\n      compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return sch.validate || this._compileSchemaEnv(sch);\n      }\n      compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n          throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n          await loadMetaSchema.call(this, _schema.$schema);\n          const sch = this._addSchema(_schema, _meta);\n          return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n          if ($ref && !this.getSchema($ref)) {\n            await runCompileAsync.call(this, { $ref }, true);\n          }\n        }\n        async function _compileAsync(sch) {\n          try {\n            return this._compileSchemaEnv(sch);\n          } catch (e) {\n            if (!(e instanceof ref_error_1.default))\n              throw e;\n            checkLoaded.call(this, e);\n            await loadMissingSchema.call(this, e.missingSchema);\n            return _compileAsync.call(this, sch);\n          }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n          if (this.refs[ref]) {\n            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n          }\n        }\n        async function loadMissingSchema(ref) {\n          const _schema = await _loadSchema.call(this, ref);\n          if (!this.refs[ref])\n            await loadMetaSchema.call(this, _schema.$schema);\n          if (!this.refs[ref])\n            this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n          const p = this._loading[ref];\n          if (p)\n            return p;\n          try {\n            return await (this._loading[ref] = loadSchema(ref));\n          } finally {\n            delete this._loading[ref];\n          }\n        }\n      }\n      // Adds schema to the instance\n      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {\n        if (Array.isArray(schema)) {\n          for (const sch of schema)\n            this.addSchema(sch, void 0, _meta, _validateSchema);\n          return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n          const { schemaId } = this.opts;\n          id = schema[schemaId];\n          if (id !== void 0 && typeof id != \"string\") {\n            throw new Error(`schema ${schemaId} must be string`);\n          }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n      }\n      // Add schema that will be used to validate other schemas\n      // options in META_IGNORE_OPTIONS are alway set to false\n      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n      }\n      //  Validate schema against its meta-schema\n      validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n          return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== void 0 && typeof $schema != \"string\") {\n          throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n          this.logger.warn(\"meta-schema not available\");\n          this.errors = null;\n          return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n          const message = \"schema is invalid: \" + this.errorsText();\n          if (this.opts.validateSchema === \"log\")\n            this.logger.error(message);\n          else\n            throw new Error(message);\n        }\n        return valid;\n      }\n      // Get compiled schema by `key` or `ref`.\n      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n      getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n          keyRef = sch;\n        if (sch === void 0) {\n          const { schemaId } = this.opts;\n          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n          sch = compile_1.resolveSchema.call(this, root, keyRef);\n          if (!sch)\n            return;\n          this.refs[keyRef] = sch;\n        }\n        return sch.validate || this._compileSchemaEnv(sch);\n      }\n      // Remove cached schema(s).\n      // If no parameter is passed all schemas but meta-schemas are removed.\n      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n      removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n          this._removeAllSchemas(this.schemas, schemaKeyRef);\n          this._removeAllSchemas(this.refs, schemaKeyRef);\n          return this;\n        }\n        switch (typeof schemaKeyRef) {\n          case \"undefined\":\n            this._removeAllSchemas(this.schemas);\n            this._removeAllSchemas(this.refs);\n            this._cache.clear();\n            return this;\n          case \"string\": {\n            const sch = getSchEnv.call(this, schemaKeyRef);\n            if (typeof sch == \"object\")\n              this._cache.delete(sch.schema);\n            delete this.schemas[schemaKeyRef];\n            delete this.refs[schemaKeyRef];\n            return this;\n          }\n          case \"object\": {\n            const cacheKey = schemaKeyRef;\n            this._cache.delete(cacheKey);\n            let id = schemaKeyRef[this.opts.schemaId];\n            if (id) {\n              id = (0, resolve_1.normalizeId)(id);\n              delete this.schemas[id];\n              delete this.refs[id];\n            }\n            return this;\n          }\n          default:\n            throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n      }\n      // add \"vocabulary\" - a collection of keywords\n      addVocabulary(definitions) {\n        for (const def of definitions)\n          this.addKeyword(def);\n        return this;\n      }\n      addKeyword(kwdOrDef, def) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n          keyword = kwdOrDef;\n          if (typeof def == \"object\") {\n            this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n            def.keyword = keyword;\n          }\n        } else if (typeof kwdOrDef == \"object\" && def === void 0) {\n          def = kwdOrDef;\n          keyword = def.keyword;\n          if (Array.isArray(keyword) && !keyword.length) {\n            throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n          }\n        } else {\n          throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n          return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n          ...def,\n          type: (0, dataType_1.getJSONTypes)(def.type),\n          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n      }\n      getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n      }\n      // Remove keyword\n      removeKeyword(keyword) {\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n          const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n          if (i >= 0)\n            group.rules.splice(i, 1);\n        }\n        return this;\n      }\n      // Add format\n      addFormat(name, format) {\n        if (typeof format == \"string\")\n          format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n      }\n      errorsText(errors = this.errors, { separator = \", \", dataVar = \"data\" } = {}) {\n        if (!errors || errors.length === 0)\n          return \"No errors\";\n        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n      }\n      $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n          const segments = jsonPointer.split(\"/\").slice(1);\n          let keywords = metaSchema;\n          for (const seg of segments)\n            keywords = keywords[seg];\n          for (const key in rules) {\n            const rule = rules[key];\n            if (typeof rule != \"object\")\n              continue;\n            const { $data } = rule.definition;\n            const schema = keywords[key];\n            if ($data && schema)\n              keywords[key] = schemaOrData(schema);\n          }\n        }\n        return metaSchema;\n      }\n      _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n          const sch = schemas[keyRef];\n          if (!regex || regex.test(keyRef)) {\n            if (typeof sch == \"string\") {\n              delete schemas[keyRef];\n            } else if (sch && !sch.meta) {\n              this._cache.delete(sch.schema);\n              delete schemas[keyRef];\n            }\n          }\n        }\n      }\n      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n          id = schema[schemaId];\n        } else {\n          if (this.opts.jtd)\n            throw new Error(\"schema must be object\");\n          else if (typeof schema != \"boolean\")\n            throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== void 0)\n          return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n          if (baseId)\n            this._checkUnique(baseId);\n          this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n          this.validateSchema(schema, true);\n        return sch;\n      }\n      _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n          throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n      }\n      _compileSchemaEnv(sch) {\n        if (sch.meta)\n          this._compileMetaSchema(sch);\n        else\n          compile_1.compileSchema.call(this, sch);\n        if (!sch.validate)\n          throw new Error(\"ajv implementation error\");\n        return sch.validate;\n      }\n      _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n          compile_1.compileSchema.call(this, sch);\n        } finally {\n          this.opts = currentOpts;\n        }\n      }\n    };\n    Ajv.ValidationError = validation_error_1.default;\n    Ajv.MissingRefError = ref_error_1.default;\n    exports2.default = Ajv;\n    function checkOptions(checkOpts, options, msg, log12 = \"error\") {\n      for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n          this.logger[log12](`${msg}: option ${key}. ${checkOpts[opt]}`);\n      }\n    }\n    function getSchEnv(keyRef) {\n      keyRef = (0, resolve_1.normalizeId)(keyRef);\n      return this.schemas[keyRef] || this.refs[keyRef];\n    }\n    function addInitialSchemas() {\n      const optsSchemas = this.opts.schemas;\n      if (!optsSchemas)\n        return;\n      if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n      else\n        for (const key in optsSchemas)\n          this.addSchema(optsSchemas[key], key);\n    }\n    function addInitialFormats() {\n      for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n          this.addFormat(name, format);\n      }\n    }\n    function addInitialKeywords(defs) {\n      if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n      }\n      this.logger.warn(\"keywords option as map is deprecated, pass array\");\n      for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n          def.keyword = keyword;\n        this.addKeyword(def);\n      }\n    }\n    function getMetaSchemaOptions() {\n      const metaOpts = { ...this.opts };\n      for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n      return metaOpts;\n    }\n    var noLogs = { log() {\n    }, warn() {\n    }, error() {\n    } };\n    function getLogger(logger12) {\n      if (logger12 === false)\n        return noLogs;\n      if (logger12 === void 0)\n        return console;\n      if (logger12.log && logger12.warn && logger12.error)\n        return logger12;\n      throw new Error(\"logger must implement log, warn and error methods\");\n    }\n    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\n    function checkKeyword(keyword, def) {\n      const { RULES } = this;\n      (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n          throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n          throw new Error(`Keyword ${kwd} has invalid name`);\n      });\n      if (!def)\n        return;\n      if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n      }\n    }\n    function addRule(keyword, definition, dataType) {\n      var _a;\n      const post = definition === null || definition === void 0 ? void 0 : definition.post;\n      if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n      const { RULES } = this;\n      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n      if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n      }\n      RULES.keywords[keyword] = true;\n      if (!definition)\n        return;\n      const rule = {\n        keyword,\n        definition: {\n          ...definition,\n          type: (0, dataType_1.getJSONTypes)(definition.type),\n          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n        }\n      };\n      if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n      else\n        ruleGroup.rules.push(rule);\n      RULES.all[keyword] = rule;\n      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n    }\n    function addBeforeRule(ruleGroup, rule, before) {\n      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n      if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n      } else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n      }\n    }\n    function keywordMetaschema(def) {\n      let { metaSchema } = def;\n      if (metaSchema === void 0)\n        return;\n      if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n      def.validateSchema = this.compile(metaSchema, true);\n    }\n    var $dataRef = {\n      $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n    };\n    function schemaOrData(schema) {\n      return { anyOf: [schema, $dataRef] };\n    }\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/core/id.js\nvar require_id = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/core/id.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var def = {\n      keyword: \"id\",\n      code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/core/ref.js\nvar require_ref = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/core/ref.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.callRef = exports2.getValidate = void 0;\n    var ref_error_1 = require_ref_error();\n    var code_1 = require_code2();\n    var codegen_1 = require_codegen();\n    var names_1 = require_names();\n    var compile_1 = require_compile();\n    var util_1 = require_util2();\n    var def = {\n      keyword: \"$ref\",\n      schemaType: \"string\",\n      code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n          return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);\n        if (schOrEnv === void 0)\n          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n          return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n          if (env === root)\n            return callRef(cxt, validateName, env, env.$async);\n          const rootName = gen.scopeValue(\"root\", { ref: root });\n          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n          const v = getValidate(cxt, sch);\n          callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n          const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n          const valid = gen.name(\"valid\");\n          const schCxt = cxt.subschema({\n            schema: sch,\n            dataTypes: [],\n            schemaPath: codegen_1.nil,\n            topSchemaRef: schName,\n            errSchemaPath: $ref\n          }, valid);\n          cxt.mergeEvaluated(schCxt);\n          cxt.ok(valid);\n        }\n      }\n    };\n    function getValidate(cxt, sch) {\n      const { gen } = cxt;\n      return sch.validate ? gen.scopeValue(\"validate\", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n    }\n    exports2.getValidate = getValidate;\n    function callRef(cxt, v, sch, $async) {\n      const { gen, it } = cxt;\n      const { allErrors, schemaEnv: env, opts } = it;\n      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n      if ($async)\n        callAsyncRef();\n      else\n        callSyncRef();\n      function callAsyncRef() {\n        if (!env.$async)\n          throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n          addEvaluatedFrom(v);\n          if (!allErrors)\n            gen.assign(valid, true);\n        }, (e) => {\n          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n          addErrorsFrom(e);\n          if (!allErrors)\n            gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n      }\n      function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n      }\n      function addErrorsFrom(source) {\n        const errs = (0, codegen_1._)`${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);\n        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n      }\n      function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n          return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        if (it.props !== true) {\n          if (schEvaluated && !schEvaluated.dynamicProps) {\n            if (schEvaluated.props !== void 0) {\n              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n            }\n          } else {\n            const props = gen.var(\"props\", (0, codegen_1._)`${source}.evaluated.props`);\n            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n          }\n        }\n        if (it.items !== true) {\n          if (schEvaluated && !schEvaluated.dynamicItems) {\n            if (schEvaluated.items !== void 0) {\n              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n            }\n          } else {\n            const items = gen.var(\"items\", (0, codegen_1._)`${source}.evaluated.items`);\n            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n          }\n        }\n      }\n    }\n    exports2.callRef = callRef;\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/core/index.js\nvar require_core3 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/core/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var id_1 = require_id();\n    var ref_1 = require_ref();\n    var core = [\n      \"$schema\",\n      \"$id\",\n      \"$defs\",\n      \"$vocabulary\",\n      { keyword: \"$comment\" },\n      \"definitions\",\n      id_1.default,\n      ref_1.default\n    ];\n    exports2.default = core;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitNumber.js\nvar require_limitNumber = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitNumber.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var ops = codegen_1.operators;\n    var KWDs = {\n      maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n      minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n      exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n      exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE }\n    };\n    var error = {\n      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,\n      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: Object.keys(KWDs),\n      type: \"number\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/multipleOf.js\nvar require_multipleOf = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/multipleOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var error = {\n      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,\n      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"multipleOf\",\n      type: \"number\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/runtime/ucs2length.js\nvar require_ucs2length = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/runtime/ucs2length.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    function ucs2length(str) {\n      const len = str.length;\n      let length = 0;\n      let pos = 0;\n      let value;\n      while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 55296 && value <= 56319 && pos < len) {\n          value = str.charCodeAt(pos);\n          if ((value & 64512) === 56320)\n            pos++;\n        }\n      }\n      return length;\n    }\n    exports2.default = ucs2length;\n    ucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitLength.js\nvar require_limitLength = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitLength.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var ucs2length_1 = require_ucs2length();\n    var error = {\n      message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;\n      },\n      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: [\"maxLength\", \"minLength\"],\n      type: \"string\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/pattern.js\nvar require_pattern = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/pattern.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code2();\n    var codegen_1 = require_codegen();\n    var error = {\n      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern \"${schemaCode}\"`,\n      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"pattern\",\n      type: \"string\",\n      schemaType: \"string\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitProperties.js\nvar require_limitProperties = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitProperties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var error = {\n      message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;\n      },\n      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: [\"maxProperties\", \"minProperties\"],\n      type: \"object\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/required.js\nvar require_required = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/required.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code2();\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var error = {\n      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,\n      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`\n    };\n    var def = {\n      keyword: \"required\",\n      type: \"object\",\n      schemaType: \"array\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n          return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n          allErrorsMode();\n        else\n          exitOnErrorMode();\n        if (opts.strictRequired) {\n          const props = cxt.parentSchema.properties;\n          const { definedProperties } = cxt.it;\n          for (const requiredKey of schema) {\n            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {\n              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n              const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n            }\n          }\n        }\n        function allErrorsMode() {\n          if (useLoop || $data) {\n            cxt.block$data(codegen_1.nil, loopAllRequired);\n          } else {\n            for (const prop of schema) {\n              (0, code_1.checkReportMissingProp)(cxt, prop);\n            }\n          }\n        }\n        function exitOnErrorMode() {\n          const missing = gen.let(\"missing\");\n          if (useLoop || $data) {\n            const valid = gen.let(\"valid\", true);\n            cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n            cxt.ok(valid);\n          } else {\n            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n          }\n        }\n        function loopAllRequired() {\n          gen.forOf(\"prop\", schemaCode, (prop) => {\n            cxt.setParams({ missingProperty: prop });\n            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n          });\n        }\n        function loopUntilMissing(missing, valid) {\n          cxt.setParams({ missingProperty: missing });\n          gen.forOf(missing, schemaCode, () => {\n            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n            gen.if((0, codegen_1.not)(valid), () => {\n              cxt.error();\n              gen.break();\n            });\n          }, codegen_1.nil);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitItems.js\nvar require_limitItems = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var error = {\n      message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;\n      },\n      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: [\"maxItems\", \"minItems\"],\n      type: \"array\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/runtime/equal.js\nvar require_equal = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/runtime/equal.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var equal = require_fast_deep_equal();\n    equal.code = 'require(\"ajv/dist/runtime/equal\").default';\n    exports2.default = equal;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\nvar require_uniqueItems = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var dataType_1 = require_dataType();\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var equal_1 = require_equal();\n    var error = {\n      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`\n    };\n    var def = {\n      keyword: \"uniqueItems\",\n      type: \"array\",\n      schemaType: \"boolean\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n          return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n          const i = gen.let(\"i\", (0, codegen_1._)`${data}.length`);\n          const j = gen.let(\"j\");\n          cxt.setParams({ i, j });\n          gen.assign(valid, true);\n          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n          return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n          const item = gen.name(\"item\");\n          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n          const indices = gen.const(\"indices\", (0, codegen_1._)`{}`);\n          gen.for((0, codegen_1._)`;${i}--;`, () => {\n            gen.let(item, (0, codegen_1._)`${data}[${i}]`);\n            gen.if(wrongType, (0, codegen_1._)`continue`);\n            if (itemTypes.length > 1)\n              gen.if((0, codegen_1._)`typeof ${item} == \"string\"`, (0, codegen_1._)`${item} += \"_\"`);\n            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == \"number\"`, () => {\n              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);\n              cxt.error();\n              gen.assign(valid, false).break();\n            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);\n          });\n        }\n        function loopN2(i, j) {\n          const eql = (0, util_1.useFunc)(gen, equal_1.default);\n          const outer = gen.name(\"outer\");\n          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error();\n            gen.assign(valid, false).break(outer);\n          })));\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/const.js\nvar require_const = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/const.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var equal_1 = require_equal();\n    var error = {\n      message: \"must be equal to constant\",\n      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"const\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || schema && typeof schema == \"object\") {\n          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        } else {\n          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/enum.js\nvar require_enum = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/enum.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var equal_1 = require_equal();\n    var error = {\n      message: \"must be equal to one of the allowed values\",\n      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"enum\",\n      schemaType: \"array\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n          throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n        let valid;\n        if (useLoop || $data) {\n          valid = gen.let(\"valid\");\n          cxt.block$data(valid, loopEnum);\n        } else {\n          if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n          const vSchema = gen.const(\"vSchema\", schemaCode);\n          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n          gen.assign(valid, false);\n          gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n          const sch = schema[i];\n          return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/index.js\nvar require_validation = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/validation/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var limitNumber_1 = require_limitNumber();\n    var multipleOf_1 = require_multipleOf();\n    var limitLength_1 = require_limitLength();\n    var pattern_1 = require_pattern();\n    var limitProperties_1 = require_limitProperties();\n    var required_1 = require_required();\n    var limitItems_1 = require_limitItems();\n    var uniqueItems_1 = require_uniqueItems();\n    var const_1 = require_const();\n    var enum_1 = require_enum();\n    var validation = [\n      // number\n      limitNumber_1.default,\n      multipleOf_1.default,\n      // string\n      limitLength_1.default,\n      pattern_1.default,\n      // object\n      limitProperties_1.default,\n      required_1.default,\n      // array\n      limitItems_1.default,\n      uniqueItems_1.default,\n      // any\n      { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n      { keyword: \"nullable\", schemaType: \"boolean\" },\n      const_1.default,\n      enum_1.default\n    ];\n    exports2.default = validation;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\nvar require_additionalItems = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateAdditionalItems = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var error = {\n      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,\n      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`\n    };\n    var def = {\n      keyword: \"additionalItems\",\n      type: \"array\",\n      schemaType: [\"boolean\", \"object\"],\n      before: \"uniqueItems\",\n      error,\n      code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n          (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n          return;\n        }\n        validateAdditionalItems(cxt, items);\n      }\n    };\n    function validateAdditionalItems(cxt, items) {\n      const { gen, schema, data, keyword, it } = cxt;\n      it.items = true;\n      const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n      if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);\n      } else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._)`${len} <= ${items.length}`);\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n      }\n      function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n          if (!it.allErrors)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n      }\n    }\n    exports2.validateAdditionalItems = validateAdditionalItems;\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items.js\nvar require_items = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateTuple = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var code_1 = require_code2();\n    var def = {\n      keyword: \"items\",\n      type: \"array\",\n      schemaType: [\"object\", \"array\", \"boolean\"],\n      before: \"uniqueItems\",\n      code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n          return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n      }\n    };\n    function validateTuple(cxt, extraItems, schArr = cxt.schema) {\n      const { gen, parentSchema, data, keyword, it } = cxt;\n      checkStrictTuple(parentSchema);\n      if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n      }\n      const valid = gen.name(\"valid\");\n      const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n      schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n          return;\n        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({\n          keyword,\n          schemaProp: i,\n          dataProp: i\n        }, valid));\n        cxt.ok(valid);\n      });\n      function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n          const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n      }\n    }\n    exports2.validateTuple = validateTuple;\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\nvar require_prefixItems = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var items_1 = require_items();\n    var def = {\n      keyword: \"prefixItems\",\n      type: \"array\",\n      schemaType: [\"array\"],\n      before: \"uniqueItems\",\n      code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\")\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items2020.js\nvar require_items2020 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items2020.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var code_1 = require_code2();\n    var additionalItems_1 = require_additionalItems();\n    var error = {\n      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,\n      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`\n    };\n    var def = {\n      keyword: \"items\",\n      type: \"array\",\n      schemaType: [\"object\", \"boolean\"],\n      before: \"uniqueItems\",\n      error,\n      code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        if (prefixItems)\n          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n          cxt.ok((0, code_1.validateArray)(cxt));\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/contains.js\nvar require_contains = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/contains.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var error = {\n      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,\n      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`\n    };\n    var def = {\n      keyword: \"contains\",\n      type: \"array\",\n      schemaType: [\"object\", \"boolean\"],\n      before: \"uniqueItems\",\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n          min = minContains === void 0 ? 1 : minContains;\n          max = maxContains;\n        } else {\n          min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === void 0 && min === 0) {\n          (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n          return;\n        }\n        if (max !== void 0 && min > max) {\n          (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n          cxt.fail();\n          return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n          let cond = (0, codegen_1._)`${len} >= ${min}`;\n          if (max !== void 0)\n            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;\n          cxt.pass(cond);\n          return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === void 0 && min === 1) {\n          validateItems(valid, () => gen.if(valid, () => gen.break()));\n        } else if (min === 0) {\n          gen.let(valid, true);\n          if (max !== void 0)\n            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);\n        } else {\n          gen.let(valid, false);\n          validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n          const schValid = gen.name(\"_valid\");\n          const count = gen.let(\"count\", 0);\n          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n          gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n              keyword: \"contains\",\n              dataProp: i,\n              dataPropType: util_1.Type.Num,\n              compositeRule: true\n            }, _valid);\n            block();\n          });\n        }\n        function checkLimits(count) {\n          gen.code((0, codegen_1._)`${count}++`);\n          if (max === void 0) {\n            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());\n          } else {\n            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());\n            if (min === 1)\n              gen.assign(valid, true);\n            else\n              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));\n          }\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/dependencies.js\nvar require_dependencies = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/dependencies.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var code_1 = require_code2();\n    exports2.error = {\n      message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;\n      },\n      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`\n      // TODO change to reference\n    };\n    var def = {\n      keyword: \"dependencies\",\n      type: \"object\",\n      schemaType: \"object\",\n      error: exports2.error,\n      code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n      }\n    };\n    function splitDependencies({ schema }) {\n      const propertyDeps = {};\n      const schemaDeps = {};\n      for (const key in schema) {\n        if (key === \"__proto__\")\n          continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n      }\n      return [propertyDeps, schemaDeps];\n    }\n    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n      const { gen, data, it } = cxt;\n      if (Object.keys(propertyDeps).length === 0)\n        return;\n      const missing = gen.let(\"missing\");\n      for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n          continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n          property: prop,\n          depsCount: deps.length,\n          deps: deps.join(\", \")\n        });\n        if (it.allErrors) {\n          gen.if(hasProperty, () => {\n            for (const depProp of deps) {\n              (0, code_1.checkReportMissingProp)(cxt, depProp);\n            }\n          });\n        } else {\n          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n          (0, code_1.reportMissingProp)(cxt, missing);\n          gen.else();\n        }\n      }\n    }\n    exports2.validatePropertyDeps = validatePropertyDeps;\n    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n      const { gen, data, keyword, it } = cxt;\n      const valid = gen.name(\"valid\");\n      for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n          continue;\n        gen.if(\n          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),\n          () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n          },\n          () => gen.var(valid, true)\n          // TODO var\n        );\n        cxt.ok(valid);\n      }\n    }\n    exports2.validateSchemaDeps = validateSchemaDeps;\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\nvar require_propertyNames = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var error = {\n      message: \"property name must be valid\",\n      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`\n    };\n    var def = {\n      keyword: \"propertyNames\",\n      type: \"object\",\n      schemaType: [\"object\", \"boolean\"],\n      error,\n      code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n          cxt.setParams({ propertyName: key });\n          cxt.subschema({\n            keyword: \"propertyNames\",\n            data: key,\n            dataTypes: [\"string\"],\n            propertyName: key,\n            compositeRule: true\n          }, valid);\n          gen.if((0, codegen_1.not)(valid), () => {\n            cxt.error(true);\n            if (!it.allErrors)\n              gen.break();\n          });\n        });\n        cxt.ok(valid);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\nvar require_additionalProperties = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code2();\n    var codegen_1 = require_codegen();\n    var names_1 = require_names();\n    var util_1 = require_util2();\n    var error = {\n      message: \"must NOT have additional properties\",\n      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`\n    };\n    var def = {\n      keyword: \"additionalProperties\",\n      type: [\"object\"],\n      schemaType: [\"boolean\", \"object\"],\n      allowUndefined: true,\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        if (!errsCount)\n          throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n          gen.forIn(\"key\", data, (key) => {\n            if (!props.length && !patProps.length)\n              additionalPropertyCode(key);\n            else\n              gen.if(isAdditional(key), () => additionalPropertyCode(key));\n          });\n        }\n        function isAdditional(key) {\n          let definedProp;\n          if (props.length > 8) {\n            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n          } else if (props.length) {\n            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));\n          } else {\n            definedProp = codegen_1.nil;\n          }\n          if (patProps.length) {\n            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n          }\n          return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n          gen.code((0, codegen_1._)`delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n          if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n            deleteAdditional(key);\n            return;\n          }\n          if (schema === false) {\n            cxt.setParams({ additionalProperty: key });\n            cxt.error();\n            if (!allErrors)\n              gen.break();\n            return;\n          }\n          if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n            const valid = gen.name(\"valid\");\n            if (opts.removeAdditional === \"failing\") {\n              applyAdditionalSchema(key, valid, false);\n              gen.if((0, codegen_1.not)(valid), () => {\n                cxt.reset();\n                deleteAdditional(key);\n              });\n            } else {\n              applyAdditionalSchema(key, valid);\n              if (!allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n            }\n          }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n          const subschema = {\n            keyword: \"additionalProperties\",\n            dataProp: key,\n            dataPropType: util_1.Type.Str\n          };\n          if (errors === false) {\n            Object.assign(subschema, {\n              compositeRule: true,\n              createErrors: false,\n              allErrors: false\n            });\n          }\n          cxt.subschema(subschema, valid);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/properties.js\nvar require_properties = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/properties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var validate_1 = require_validate();\n    var code_1 = require_code2();\n    var util_1 = require_util2();\n    var additionalProperties_1 = require_additionalProperties();\n    var def = {\n      keyword: \"properties\",\n      type: \"object\",\n      schemaType: \"object\",\n      code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === void 0) {\n          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n          it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n          return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n          if (hasDefault(prop)) {\n            applyPropertySchema(prop);\n          } else {\n            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n            applyPropertySchema(prop);\n            if (!it.allErrors)\n              gen.else().var(valid, true);\n            gen.endIf();\n          }\n          cxt.it.definedProperties.add(prop);\n          cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;\n        }\n        function applyPropertySchema(prop) {\n          cxt.subschema({\n            keyword: \"properties\",\n            schemaProp: prop,\n            dataProp: prop\n          }, valid);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\nvar require_patternProperties = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code2();\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var util_2 = require_util2();\n    var def = {\n      keyword: \"patternProperties\",\n      type: \"object\",\n      schemaType: \"object\",\n      code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n          return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n          for (const pat of patterns) {\n            if (checkProperties)\n              checkMatchingProperties(pat);\n            if (it.allErrors) {\n              validateProperties(pat);\n            } else {\n              gen.var(valid, true);\n              validateProperties(pat);\n              gen.if(valid);\n            }\n          }\n        }\n        function checkMatchingProperties(pat) {\n          for (const prop in checkProperties) {\n            if (new RegExp(pat).test(prop)) {\n              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n            }\n          }\n        }\n        function validateProperties(pat) {\n          gen.forIn(\"key\", data, (key) => {\n            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n              const alwaysValid = alwaysValidPatterns.includes(pat);\n              if (!alwaysValid) {\n                cxt.subschema({\n                  keyword: \"patternProperties\",\n                  schemaProp: pat,\n                  dataProp: key,\n                  dataPropType: util_2.Type.Str\n                }, valid);\n              }\n              if (it.opts.unevaluated && props !== true) {\n                gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n              } else if (!alwaysValid && !it.allErrors) {\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n              }\n            });\n          });\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/not.js\nvar require_not = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/not.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require_util2();\n    var def = {\n      keyword: \"not\",\n      schemaType: [\"object\", \"boolean\"],\n      trackErrors: true,\n      code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n          cxt.fail();\n          return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n          keyword: \"not\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n      },\n      error: { message: \"must NOT be valid\" }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/anyOf.js\nvar require_anyOf = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/anyOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code2();\n    var def = {\n      keyword: \"anyOf\",\n      schemaType: \"array\",\n      trackErrors: true,\n      code: code_1.validateUnion,\n      error: { message: \"must match a schema in anyOf\" }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/oneOf.js\nvar require_oneOf = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/oneOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var error = {\n      message: \"must match exactly one schema in oneOf\",\n      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`\n    };\n    var def = {\n      keyword: \"oneOf\",\n      schemaType: \"array\",\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        if (!Array.isArray(schema))\n          throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n          return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n          schArr.forEach((sch, i) => {\n            let schCxt;\n            if ((0, util_1.alwaysValidSchema)(it, sch)) {\n              gen.var(schValid, true);\n            } else {\n              schCxt = cxt.subschema({\n                keyword: \"oneOf\",\n                schemaProp: i,\n                compositeRule: true\n              }, schValid);\n            }\n            if (i > 0) {\n              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();\n            }\n            gen.if(schValid, () => {\n              gen.assign(valid, true);\n              gen.assign(passing, i);\n              if (schCxt)\n                cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            });\n          });\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/allOf.js\nvar require_allOf = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/allOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require_util2();\n    var def = {\n      keyword: \"allOf\",\n      schemaType: \"array\",\n      code(cxt) {\n        const { gen, schema, it } = cxt;\n        if (!Array.isArray(schema))\n          throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n          if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n          const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n          cxt.ok(valid);\n          cxt.mergeEvaluated(schCxt);\n        });\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/if.js\nvar require_if = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/if.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var util_1 = require_util2();\n    var error = {\n      message: ({ params }) => (0, codegen_1.str)`must match \"${params.ifClause}\" schema`,\n      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`\n    };\n    var def = {\n      keyword: \"if\",\n      schemaType: [\"object\", \"boolean\"],\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === void 0 && parentSchema.else === void 0) {\n          (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n          return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n          const ifClause = gen.let(\"ifClause\");\n          cxt.setParams({ ifClause });\n          gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        } else if (hasThen) {\n          gen.if(schValid, validateClause(\"then\"));\n        } else {\n          gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n          const schCxt = cxt.subschema({\n            keyword: \"if\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false\n          }, schValid);\n          cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n          return () => {\n            const schCxt = cxt.subschema({ keyword }, schValid);\n            gen.assign(valid, schValid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n            if (ifClause)\n              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);\n            else\n              cxt.setParams({ ifClause: keyword });\n          };\n        }\n      }\n    };\n    function hasSchema(it, keyword) {\n      const schema = it.schema[keyword];\n      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);\n    }\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/thenElse.js\nvar require_thenElse = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/thenElse.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require_util2();\n    var def = {\n      keyword: [\"then\", \"else\"],\n      schemaType: [\"object\", \"boolean\"],\n      code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === void 0)\n          (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/index.js\nvar require_applicator = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var additionalItems_1 = require_additionalItems();\n    var prefixItems_1 = require_prefixItems();\n    var items_1 = require_items();\n    var items2020_1 = require_items2020();\n    var contains_1 = require_contains();\n    var dependencies_1 = require_dependencies();\n    var propertyNames_1 = require_propertyNames();\n    var additionalProperties_1 = require_additionalProperties();\n    var properties_1 = require_properties();\n    var patternProperties_1 = require_patternProperties();\n    var not_1 = require_not();\n    var anyOf_1 = require_anyOf();\n    var oneOf_1 = require_oneOf();\n    var allOf_1 = require_allOf();\n    var if_1 = require_if();\n    var thenElse_1 = require_thenElse();\n    function getApplicator(draft2020 = false) {\n      const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default\n      ];\n      if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n      else\n        applicator.push(additionalItems_1.default, items_1.default);\n      applicator.push(contains_1.default);\n      return applicator;\n    }\n    exports2.default = getApplicator;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/format/format.js\nvar require_format2 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/format/format.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var error = {\n      message: ({ schemaCode }) => (0, codegen_1.str)`must match format \"${schemaCode}\"`,\n      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"format\",\n      type: [\"number\", \"string\"],\n      schemaType: \"string\",\n      $data: true,\n      error,\n      code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;\n        if (!opts.validateFormats)\n          return;\n        if ($data)\n          validate$DataFormat();\n        else\n          validateFormat();\n        function validate$DataFormat() {\n          const fmts = gen.scopeValue(\"formats\", {\n            ref: self2.formats,\n            code: opts.code.formats\n          });\n          const fDef = gen.const(\"fDef\", (0, codegen_1._)`${fmts}[${schemaCode}]`);\n          const fType = gen.let(\"fType\");\n          const format = gen.let(\"format\");\n          gen.if((0, codegen_1._)`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || \"string\"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`\"string\"`).assign(format, fDef));\n          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n          function unknownFmt() {\n            if (opts.strictSchema === false)\n              return codegen_1.nil;\n            return (0, codegen_1._)`${schemaCode} && !${format}`;\n          }\n          function invalidFmt() {\n            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;\n            const validData = (0, codegen_1._)`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n          }\n        }\n        function validateFormat() {\n          const formatDef = self2.formats[schema];\n          if (!formatDef) {\n            unknownFormat();\n            return;\n          }\n          if (formatDef === true)\n            return;\n          const [fmtType, format, fmtRef] = getFormat(formatDef);\n          if (fmtType === ruleType)\n            cxt.pass(validCondition());\n          function unknownFormat() {\n            if (opts.strictSchema === false) {\n              self2.logger.warn(unknownMsg());\n              return;\n            }\n            throw new Error(unknownMsg());\n            function unknownMsg() {\n              return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n            }\n          }\n          function getFormat(fmtDef) {\n            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;\n            const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n            if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n              return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];\n            }\n            return [\"string\", fmtDef, fmt];\n          }\n          function validCondition() {\n            if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n              if (!schemaEnv.$async)\n                throw new Error(\"async format in sync schema\");\n              return (0, codegen_1._)`await ${fmtRef}(${data})`;\n            }\n            return typeof format == \"function\" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;\n          }\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/format/index.js\nvar require_format3 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/format/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var format_1 = require_format2();\n    var format = [format_1.default];\n    exports2.default = format;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/metadata.js\nvar require_metadata = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/metadata.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;\n    exports2.metadataVocabulary = [\n      \"title\",\n      \"description\",\n      \"default\",\n      \"deprecated\",\n      \"readOnly\",\n      \"writeOnly\",\n      \"examples\"\n    ];\n    exports2.contentVocabulary = [\n      \"contentMediaType\",\n      \"contentEncoding\",\n      \"contentSchema\"\n    ];\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/draft7.js\nvar require_draft7 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/draft7.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var core_1 = require_core3();\n    var validation_1 = require_validation();\n    var applicator_1 = require_applicator();\n    var format_1 = require_format3();\n    var metadata_1 = require_metadata();\n    var draft7Vocabularies = [\n      core_1.default,\n      validation_1.default,\n      (0, applicator_1.default)(),\n      format_1.default,\n      metadata_1.metadataVocabulary,\n      metadata_1.contentVocabulary\n    ];\n    exports2.default = draft7Vocabularies;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/types.js\nvar require_types2 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/types.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DiscrError = void 0;\n    var DiscrError;\n    (function(DiscrError2) {\n      DiscrError2[\"Tag\"] = \"tag\";\n      DiscrError2[\"Mapping\"] = \"mapping\";\n    })(DiscrError || (exports2.DiscrError = DiscrError = {}));\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/index.js\nvar require_discriminator = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen();\n    var types_1 = require_types2();\n    var compile_1 = require_compile();\n    var ref_error_1 = require_ref_error();\n    var util_1 = require_util2();\n    var error = {\n      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`,\n      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`\n    };\n    var def = {\n      keyword: \"discriminator\",\n      type: \"object\",\n      schemaType: \"object\",\n      error,\n      code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n          throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n          throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n          throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n          throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._)`typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n          const mapping = getMapping();\n          gen.if(false);\n          for (const tagValue in mapping) {\n            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n            gen.assign(valid, applyTagSchema(mapping[tagValue]));\n          }\n          gen.else();\n          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n          gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n          const _valid = gen.name(\"valid\");\n          const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n          cxt.mergeEvaluated(schCxt, codegen_1.Name);\n          return _valid;\n        }\n        function getMapping() {\n          var _a;\n          const oneOfMapping = {};\n          const topRequired = hasRequired(parentSchema);\n          let tagRequired = true;\n          for (let i = 0; i < oneOf.length; i++) {\n            let sch = oneOf[i];\n            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n              const ref = sch.$ref;\n              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n              if (sch instanceof compile_1.SchemaEnv)\n                sch = sch.schema;\n              if (sch === void 0)\n                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n            }\n            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n            if (typeof propSch != \"object\") {\n              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n            }\n            tagRequired = tagRequired && (topRequired || hasRequired(sch));\n            addMappings(propSch, i);\n          }\n          if (!tagRequired)\n            throw new Error(`discriminator: \"${tagName}\" must be required`);\n          return oneOfMapping;\n          function hasRequired({ required }) {\n            return Array.isArray(required) && required.includes(tagName);\n          }\n          function addMappings(sch, i) {\n            if (sch.const) {\n              addMapping(sch.const, i);\n            } else if (sch.enum) {\n              for (const tagValue of sch.enum) {\n                addMapping(tagValue, i);\n              }\n            } else {\n              throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n            }\n          }\n          function addMapping(tagValue, i) {\n            if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n              throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n            }\n            oneOfMapping[tagValue] = i;\n          }\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/refs/json-schema-draft-07.json\nvar require_json_schema_draft_07 = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/refs/json-schema-draft-07.json\"(exports2, module2) {\n    module2.exports = {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      $id: \"http://json-schema.org/draft-07/schema#\",\n      title: \"Core schema meta-schema\",\n      definitions: {\n        schemaArray: {\n          type: \"array\",\n          minItems: 1,\n          items: { $ref: \"#\" }\n        },\n        nonNegativeInteger: {\n          type: \"integer\",\n          minimum: 0\n        },\n        nonNegativeIntegerDefault0: {\n          allOf: [{ $ref: \"#/definitions/nonNegativeInteger\" }, { default: 0 }]\n        },\n        simpleTypes: {\n          enum: [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n        },\n        stringArray: {\n          type: \"array\",\n          items: { type: \"string\" },\n          uniqueItems: true,\n          default: []\n        }\n      },\n      type: [\"object\", \"boolean\"],\n      properties: {\n        $id: {\n          type: \"string\",\n          format: \"uri-reference\"\n        },\n        $schema: {\n          type: \"string\",\n          format: \"uri\"\n        },\n        $ref: {\n          type: \"string\",\n          format: \"uri-reference\"\n        },\n        $comment: {\n          type: \"string\"\n        },\n        title: {\n          type: \"string\"\n        },\n        description: {\n          type: \"string\"\n        },\n        default: true,\n        readOnly: {\n          type: \"boolean\",\n          default: false\n        },\n        examples: {\n          type: \"array\",\n          items: true\n        },\n        multipleOf: {\n          type: \"number\",\n          exclusiveMinimum: 0\n        },\n        maximum: {\n          type: \"number\"\n        },\n        exclusiveMaximum: {\n          type: \"number\"\n        },\n        minimum: {\n          type: \"number\"\n        },\n        exclusiveMinimum: {\n          type: \"number\"\n        },\n        maxLength: { $ref: \"#/definitions/nonNegativeInteger\" },\n        minLength: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n        pattern: {\n          type: \"string\",\n          format: \"regex\"\n        },\n        additionalItems: { $ref: \"#\" },\n        items: {\n          anyOf: [{ $ref: \"#\" }, { $ref: \"#/definitions/schemaArray\" }],\n          default: true\n        },\n        maxItems: { $ref: \"#/definitions/nonNegativeInteger\" },\n        minItems: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n        uniqueItems: {\n          type: \"boolean\",\n          default: false\n        },\n        contains: { $ref: \"#\" },\n        maxProperties: { $ref: \"#/definitions/nonNegativeInteger\" },\n        minProperties: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n        required: { $ref: \"#/definitions/stringArray\" },\n        additionalProperties: { $ref: \"#\" },\n        definitions: {\n          type: \"object\",\n          additionalProperties: { $ref: \"#\" },\n          default: {}\n        },\n        properties: {\n          type: \"object\",\n          additionalProperties: { $ref: \"#\" },\n          default: {}\n        },\n        patternProperties: {\n          type: \"object\",\n          additionalProperties: { $ref: \"#\" },\n          propertyNames: { format: \"regex\" },\n          default: {}\n        },\n        dependencies: {\n          type: \"object\",\n          additionalProperties: {\n            anyOf: [{ $ref: \"#\" }, { $ref: \"#/definitions/stringArray\" }]\n          }\n        },\n        propertyNames: { $ref: \"#\" },\n        const: true,\n        enum: {\n          type: \"array\",\n          items: true,\n          minItems: 1,\n          uniqueItems: true\n        },\n        type: {\n          anyOf: [\n            { $ref: \"#/definitions/simpleTypes\" },\n            {\n              type: \"array\",\n              items: { $ref: \"#/definitions/simpleTypes\" },\n              minItems: 1,\n              uniqueItems: true\n            }\n          ]\n        },\n        format: { type: \"string\" },\n        contentMediaType: { type: \"string\" },\n        contentEncoding: { type: \"string\" },\n        if: { $ref: \"#\" },\n        then: { $ref: \"#\" },\n        else: { $ref: \"#\" },\n        allOf: { $ref: \"#/definitions/schemaArray\" },\n        anyOf: { $ref: \"#/definitions/schemaArray\" },\n        oneOf: { $ref: \"#/definitions/schemaArray\" },\n        not: { $ref: \"#\" }\n      },\n      default: true\n    };\n  }\n});\n\n// node_modules/conf/node_modules/ajv/dist/ajv.js\nvar require_ajv = __commonJS({\n  \"node_modules/conf/node_modules/ajv/dist/ajv.js\"(exports2, module2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;\n    var core_1 = require_core2();\n    var draft7_1 = require_draft7();\n    var discriminator_1 = require_discriminator();\n    var draft7MetaSchema = require_json_schema_draft_07();\n    var META_SUPPORT_DATA = [\"/properties\"];\n    var META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\n    var Ajv = class extends core_1.default {\n      _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n          this.addKeyword(discriminator_1.default);\n      }\n      _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n          return;\n        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n      }\n      defaultMeta() {\n        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);\n      }\n    };\n    exports2.Ajv = Ajv;\n    module2.exports = exports2 = Ajv;\n    module2.exports.Ajv = Ajv;\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.default = Ajv;\n    var validate_1 = require_validate();\n    Object.defineProperty(exports2, \"KeywordCxt\", { enumerable: true, get: function() {\n      return validate_1.KeywordCxt;\n    } });\n    var codegen_1 = require_codegen();\n    Object.defineProperty(exports2, \"_\", { enumerable: true, get: function() {\n      return codegen_1._;\n    } });\n    Object.defineProperty(exports2, \"str\", { enumerable: true, get: function() {\n      return codegen_1.str;\n    } });\n    Object.defineProperty(exports2, \"stringify\", { enumerable: true, get: function() {\n      return codegen_1.stringify;\n    } });\n    Object.defineProperty(exports2, \"nil\", { enumerable: true, get: function() {\n      return codegen_1.nil;\n    } });\n    Object.defineProperty(exports2, \"Name\", { enumerable: true, get: function() {\n      return codegen_1.Name;\n    } });\n    Object.defineProperty(exports2, \"CodeGen\", { enumerable: true, get: function() {\n      return codegen_1.CodeGen;\n    } });\n    var validation_error_1 = require_validation_error();\n    Object.defineProperty(exports2, \"ValidationError\", { enumerable: true, get: function() {\n      return validation_error_1.default;\n    } });\n    var ref_error_1 = require_ref_error();\n    Object.defineProperty(exports2, \"MissingRefError\", { enumerable: true, get: function() {\n      return ref_error_1.default;\n    } });\n  }\n});\n\n// node_modules/ajv-formats/dist/formats.js\nvar require_formats = __commonJS({\n  \"node_modules/ajv-formats/dist/formats.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;\n    function fmtDef(validate, compare) {\n      return { validate, compare };\n    }\n    exports2.fullFormats = {\n      // date: http://tools.ietf.org/html/rfc3339#section-5.6\n      date: fmtDef(date, compareDate),\n      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n      time: fmtDef(time, compareTime),\n      \"date-time\": fmtDef(date_time, compareDateTime),\n      // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n      duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n      uri,\n      \"uri-reference\": /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n      // uri-template: https://tools.ietf.org/html/rfc6570\n      \"uri-template\": /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n      // For the source: https://gist.github.com/dperini/729294\n      // For test cases: https://mathiasbynens.be/demo/url-regex\n      url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n      hostname: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n      ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n      regex,\n      // uuid: http://tools.ietf.org/html/rfc4122\n      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n      // JSON-pointer: https://tools.ietf.org/html/rfc6901\n      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n      \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n      \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n      \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n      // byte: https://github.com/miguelmota/is-base64\n      byte,\n      // signed 32 bit integer\n      int32: { type: \"number\", validate: validateInt32 },\n      // signed 64 bit integer\n      int64: { type: \"number\", validate: validateInt64 },\n      // C-type float\n      float: { type: \"number\", validate: validateNumber },\n      // C-type double\n      double: { type: \"number\", validate: validateNumber },\n      // hint to the UI to hide input strings\n      password: true,\n      // unchecked string payload\n      binary: true\n    };\n    exports2.fastFormats = {\n      ...exports2.fullFormats,\n      date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n      time: fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareTime),\n      \"date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareDateTime),\n      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n      uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n      \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n      // email (sources from jsen validator):\n      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i\n    };\n    exports2.formatNames = Object.keys(exports2.fullFormats);\n    function isLeapYear(year) {\n      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    }\n    var DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    function date(str) {\n      const matches = DATE.exec(str);\n      if (!matches)\n        return false;\n      const year = +matches[1];\n      const month = +matches[2];\n      const day = +matches[3];\n      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);\n    }\n    function compareDate(d1, d2) {\n      if (!(d1 && d2))\n        return void 0;\n      if (d1 > d2)\n        return 1;\n      if (d1 < d2)\n        return -1;\n      return 0;\n    }\n    var TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\n    function time(str, withTimeZone) {\n      const matches = TIME.exec(str);\n      if (!matches)\n        return false;\n      const hour = +matches[1];\n      const minute = +matches[2];\n      const second = +matches[3];\n      const timeZone = matches[5];\n      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== \"\");\n    }\n    function compareTime(t1, t2) {\n      if (!(t1 && t2))\n        return void 0;\n      const a1 = TIME.exec(t1);\n      const a2 = TIME.exec(t2);\n      if (!(a1 && a2))\n        return void 0;\n      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || \"\");\n      t2 = a2[1] + a2[2] + a2[3] + (a2[4] || \"\");\n      if (t1 > t2)\n        return 1;\n      if (t1 < t2)\n        return -1;\n      return 0;\n    }\n    var DATE_TIME_SEPARATOR = /t|\\s/i;\n    function date_time(str) {\n      const dateTime = str.split(DATE_TIME_SEPARATOR);\n      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);\n    }\n    function compareDateTime(dt1, dt2) {\n      if (!(dt1 && dt2))\n        return void 0;\n      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);\n      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);\n      const res = compareDate(d1, d2);\n      if (res === void 0)\n        return void 0;\n      return res || compareTime(t1, t2);\n    }\n    var NOT_URI_FRAGMENT = /\\/|:/;\n    var URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n    function uri(str) {\n      return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n    }\n    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;\n    function byte(str) {\n      BYTE.lastIndex = 0;\n      return BYTE.test(str);\n    }\n    var MIN_INT32 = -(2 ** 31);\n    var MAX_INT32 = 2 ** 31 - 1;\n    function validateInt32(value) {\n      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;\n    }\n    function validateInt64(value) {\n      return Number.isInteger(value);\n    }\n    function validateNumber() {\n      return true;\n    }\n    var Z_ANCHOR = /[^\\\\]\\\\Z/;\n    function regex(str) {\n      if (Z_ANCHOR.test(str))\n        return false;\n      try {\n        new RegExp(str);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js\nvar require_code3 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;\n    var _CodeOrName = class {\n    };\n    exports2._CodeOrName = _CodeOrName;\n    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\n    var Name = class extends _CodeOrName {\n      constructor(s) {\n        super();\n        if (!exports2.IDENTIFIER.test(s))\n          throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n      }\n      toString() {\n        return this.str;\n      }\n      emptyStr() {\n        return false;\n      }\n      get names() {\n        return { [this.str]: 1 };\n      }\n    };\n    exports2.Name = Name;\n    var _Code = class extends _CodeOrName {\n      constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n      }\n      toString() {\n        return this.str;\n      }\n      emptyStr() {\n        if (this._items.length > 1)\n          return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n      }\n      get str() {\n        var _a;\n        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, \"\");\n      }\n      get names() {\n        var _a;\n        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {\n          if (c instanceof Name)\n            names[c.str] = (names[c.str] || 0) + 1;\n          return names;\n        }, {});\n      }\n    };\n    exports2._Code = _Code;\n    exports2.nil = new _Code(\"\");\n    function _(strs, ...args) {\n      const code = [strs[0]];\n      let i = 0;\n      while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n      }\n      return new _Code(code);\n    }\n    exports2._ = _;\n    var plus = new _Code(\"+\");\n    function str(strs, ...args) {\n      const expr = [safeStringify(strs[0])];\n      let i = 0;\n      while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n      }\n      optimize(expr);\n      return new _Code(expr);\n    }\n    exports2.str = str;\n    function addCodeArg(code, arg) {\n      if (arg instanceof _Code)\n        code.push(...arg._items);\n      else if (arg instanceof Name)\n        code.push(arg);\n      else\n        code.push(interpolate(arg));\n    }\n    exports2.addCodeArg = addCodeArg;\n    function optimize(expr) {\n      let i = 1;\n      while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n          const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n          if (res !== void 0) {\n            expr.splice(i - 1, 3, res);\n            continue;\n          }\n          expr[i++] = \"+\";\n        }\n        i++;\n      }\n    }\n    function mergeExprItems(a, b) {\n      if (b === '\"\"')\n        return a;\n      if (a === '\"\"')\n        return b;\n      if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n          return;\n        if (typeof b != \"string\")\n          return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n          return a.slice(0, -1) + b.slice(1);\n        return;\n      }\n      if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n      return;\n    }\n    function strConcat(c1, c2) {\n      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;\n    }\n    exports2.strConcat = strConcat;\n    function interpolate(x) {\n      return typeof x == \"number\" || typeof x == \"boolean\" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n    }\n    function stringify(x) {\n      return new _Code(safeStringify(x));\n    }\n    exports2.stringify = stringify;\n    function safeStringify(x) {\n      return JSON.stringify(x).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n    }\n    exports2.safeStringify = safeStringify;\n    function getProperty(key) {\n      return typeof key == \"string\" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;\n    }\n    exports2.getProperty = getProperty;\n    function getEsmExportName(key) {\n      if (typeof key == \"string\" && exports2.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n      }\n      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n    }\n    exports2.getEsmExportName = getEsmExportName;\n    function regexpCode(rx) {\n      return new _Code(rx.toString());\n    }\n    exports2.regexpCode = regexpCode;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js\nvar require_scope3 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;\n    var code_1 = require_code3();\n    var ValueError = class extends Error {\n      constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n      }\n    };\n    var UsedValueState;\n    (function(UsedValueState2) {\n      UsedValueState2[UsedValueState2[\"Started\"] = 0] = \"Started\";\n      UsedValueState2[UsedValueState2[\"Completed\"] = 1] = \"Completed\";\n    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));\n    exports2.varKinds = {\n      const: new code_1.Name(\"const\"),\n      let: new code_1.Name(\"let\"),\n      var: new code_1.Name(\"var\")\n    };\n    var Scope = class {\n      constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n      }\n      toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n      }\n      name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n      }\n      _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n      }\n      _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n          throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return this._names[prefix] = { prefix, index: 0 };\n      }\n    };\n    exports2.Scope = Scope;\n    var ValueScopeName = class extends code_1.Name {\n      constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n      }\n      setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n      }\n    };\n    exports2.ValueScopeName = ValueScopeName;\n    var line = (0, code_1._)`\\n`;\n    var ValueScope = class extends Scope {\n      constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n      }\n      get() {\n        return this._scope;\n      }\n      name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n      }\n      value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === void 0)\n          throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n          const _name = vs.get(valueKey);\n          if (_name)\n            return _name;\n        } else {\n          vs = this._values[prefix] = /* @__PURE__ */ new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n      }\n      getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n          return;\n        return vs.get(keyOrRef);\n      }\n      scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n          if (name.scopePath === void 0)\n            throw new Error(`CodeGen: name \"${name}\" has no value`);\n          return (0, code_1._)`${scopeName}${name.scopePath}`;\n        });\n      }\n      scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n          if (name.value === void 0)\n            throw new Error(`CodeGen: name \"${name}\" has no value`);\n          return name.value.code;\n        }, usedValues, getCode);\n      }\n      _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n          const vs = values[prefix];\n          if (!vs)\n            continue;\n          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();\n          vs.forEach((name) => {\n            if (nameSet.has(name))\n              return;\n            nameSet.set(name, UsedValueState.Started);\n            let c = valueCode(name);\n            if (c) {\n              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;\n              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n              code = (0, code_1._)`${code}${c}${this.opts._n}`;\n            } else {\n              throw new ValueError(name);\n            }\n            nameSet.set(name, UsedValueState.Completed);\n          });\n        }\n        return code;\n      }\n    };\n    exports2.ValueScope = ValueScope;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js\nvar require_codegen2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;\n    var code_1 = require_code3();\n    var scope_1 = require_scope3();\n    var code_2 = require_code3();\n    Object.defineProperty(exports2, \"_\", { enumerable: true, get: function() {\n      return code_2._;\n    } });\n    Object.defineProperty(exports2, \"str\", { enumerable: true, get: function() {\n      return code_2.str;\n    } });\n    Object.defineProperty(exports2, \"strConcat\", { enumerable: true, get: function() {\n      return code_2.strConcat;\n    } });\n    Object.defineProperty(exports2, \"nil\", { enumerable: true, get: function() {\n      return code_2.nil;\n    } });\n    Object.defineProperty(exports2, \"getProperty\", { enumerable: true, get: function() {\n      return code_2.getProperty;\n    } });\n    Object.defineProperty(exports2, \"stringify\", { enumerable: true, get: function() {\n      return code_2.stringify;\n    } });\n    Object.defineProperty(exports2, \"regexpCode\", { enumerable: true, get: function() {\n      return code_2.regexpCode;\n    } });\n    Object.defineProperty(exports2, \"Name\", { enumerable: true, get: function() {\n      return code_2.Name;\n    } });\n    var scope_2 = require_scope3();\n    Object.defineProperty(exports2, \"Scope\", { enumerable: true, get: function() {\n      return scope_2.Scope;\n    } });\n    Object.defineProperty(exports2, \"ValueScope\", { enumerable: true, get: function() {\n      return scope_2.ValueScope;\n    } });\n    Object.defineProperty(exports2, \"ValueScopeName\", { enumerable: true, get: function() {\n      return scope_2.ValueScopeName;\n    } });\n    Object.defineProperty(exports2, \"varKinds\", { enumerable: true, get: function() {\n      return scope_2.varKinds;\n    } });\n    exports2.operators = {\n      GT: new code_1._Code(\">\"),\n      GTE: new code_1._Code(\">=\"),\n      LT: new code_1._Code(\"<\"),\n      LTE: new code_1._Code(\"<=\"),\n      EQ: new code_1._Code(\"===\"),\n      NEQ: new code_1._Code(\"!==\"),\n      NOT: new code_1._Code(\"!\"),\n      OR: new code_1._Code(\"||\"),\n      AND: new code_1._Code(\"&&\"),\n      ADD: new code_1._Code(\"+\")\n    };\n    var Node = class {\n      optimizeNodes() {\n        return this;\n      }\n      optimizeNames(_names, _constants) {\n        return this;\n      }\n    };\n    var Def = class extends Node {\n      constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n      }\n      render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === void 0 ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n      }\n      optimizeNames(names, constants) {\n        if (!names[this.name.str])\n          return;\n        if (this.rhs)\n          this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n      }\n      get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n      }\n    };\n    var Assign = class extends Node {\n      constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n      }\n      render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n      }\n      optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n          return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n      }\n      get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n      }\n    };\n    var AssignOp = class extends Assign {\n      constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n      }\n      render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n      }\n    };\n    var Label = class extends Node {\n      constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n      }\n      render({ _n }) {\n        return `${this.label}:` + _n;\n      }\n    };\n    var Break = class extends Node {\n      constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n      }\n      render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n      }\n    };\n    var Throw = class extends Node {\n      constructor(error) {\n        super();\n        this.error = error;\n      }\n      render({ _n }) {\n        return `throw ${this.error};` + _n;\n      }\n      get names() {\n        return this.error.names;\n      }\n    };\n    var AnyCode = class extends Node {\n      constructor(code) {\n        super();\n        this.code = code;\n      }\n      render({ _n }) {\n        return `${this.code};` + _n;\n      }\n      optimizeNodes() {\n        return `${this.code}` ? this : void 0;\n      }\n      optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n      }\n      get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n      }\n    };\n    var ParentNode = class extends Node {\n      constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n      }\n      render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n      }\n      optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n          const n = nodes[i].optimizeNodes();\n          if (Array.isArray(n))\n            nodes.splice(i, 1, ...n);\n          else if (n)\n            nodes[i] = n;\n          else\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : void 0;\n      }\n      optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n          const n = nodes[i];\n          if (n.optimizeNames(names, constants))\n            continue;\n          subtractNames(names, n.names);\n          nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : void 0;\n      }\n      get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n      }\n    };\n    var BlockNode = class extends ParentNode {\n      render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n      }\n    };\n    var Root = class extends ParentNode {\n    };\n    var Else = class extends BlockNode {\n    };\n    Else.kind = \"else\";\n    var If = class _If extends BlockNode {\n      constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n      }\n      render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n          code += \"else \" + this.else.render(opts);\n        return code;\n      }\n      optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n          return this.nodes;\n        let e = this.else;\n        if (e) {\n          const ns = e.optimizeNodes();\n          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n          if (cond === false)\n            return e instanceof _If ? e : e.nodes;\n          if (this.nodes.length)\n            return this;\n          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n          return void 0;\n        return this;\n      }\n      optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n          return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n      }\n      get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n          addNames(names, this.else.names);\n        return names;\n      }\n    };\n    If.kind = \"if\";\n    var For = class extends BlockNode {\n    };\n    For.kind = \"for\";\n    var ForLoop = class extends For {\n      constructor(iteration) {\n        super();\n        this.iteration = iteration;\n      }\n      render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n      }\n      optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n          return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n      }\n      get names() {\n        return addNames(super.names, this.iteration.names);\n      }\n    };\n    var ForRange = class extends For {\n      constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n      }\n      render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n      }\n      get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n      }\n    };\n    var ForIter = class extends For {\n      constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n      }\n      render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n      }\n      optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n          return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n      }\n      get names() {\n        return addNames(super.names, this.iterable.names);\n      }\n    };\n    var Func = class extends BlockNode {\n      constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n      }\n      render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n      }\n    };\n    Func.kind = \"func\";\n    var Return = class extends ParentNode {\n      render(opts) {\n        return \"return \" + super.render(opts);\n      }\n    };\n    Return.kind = \"return\";\n    var Try = class extends BlockNode {\n      render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n          code += this.catch.render(opts);\n        if (this.finally)\n          code += this.finally.render(opts);\n        return code;\n      }\n      optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n      }\n      optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n      }\n      get names() {\n        const names = super.names;\n        if (this.catch)\n          addNames(names, this.catch.names);\n        if (this.finally)\n          addNames(names, this.finally.names);\n        return names;\n      }\n    };\n    var Catch = class extends BlockNode {\n      constructor(error) {\n        super();\n        this.error = error;\n      }\n      render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n      }\n    };\n    Catch.kind = \"catch\";\n    var Finally = class extends BlockNode {\n      render(opts) {\n        return \"finally\" + super.render(opts);\n      }\n    };\n    Finally.kind = \"finally\";\n    var CodeGen = class {\n      constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n      }\n      toString() {\n        return this._root.render(this.opts);\n      }\n      // returns unique name in the internal scope\n      name(prefix) {\n        return this._scope.name(prefix);\n      }\n      // reserves unique name in the external scope\n      scopeName(prefix) {\n        return this._extScope.name(prefix);\n      }\n      // reserves unique name in the external scope and assigns value to it\n      scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());\n        vs.add(name);\n        return name;\n      }\n      getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n      }\n      // return code that assigns values in the external scope to the names that are used internally\n      // (same names that were returned by gen.scopeName or gen.scopeValue)\n      scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n      }\n      scopeCode() {\n        return this._extScope.scopeCode(this._values);\n      }\n      _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== void 0 && constant)\n          this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n      }\n      // `const` declaration (`var` in es5 mode)\n      const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n      }\n      // `let` declaration with optional assignment (`var` in es5 mode)\n      let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n      }\n      // `var` declaration with optional assignment\n      var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n      }\n      // assignment code\n      assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n      }\n      // `+=` code\n      add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));\n      }\n      // appends passed SafeExpr to code or executes Block\n      code(c) {\n        if (typeof c == \"function\")\n          c();\n        else if (c !== code_1.nil)\n          this._leafNode(new AnyCode(c));\n        return this;\n      }\n      // returns code for object literal for the passed argument list of key-value pairs\n      object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n          if (code.length > 1)\n            code.push(\",\");\n          code.push(key);\n          if (key !== value || this.opts.es5) {\n            code.push(\":\");\n            (0, code_1.addCodeArg)(code, value);\n          }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n      }\n      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n      if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n          this.code(thenBody).else().code(elseBody).endIf();\n        } else if (thenBody) {\n          this.code(thenBody).endIf();\n        } else if (elseBody) {\n          throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n      }\n      // `else if` clause - invalid without `if` or after `else` clauses\n      elseIf(condition) {\n        return this._elseNode(new If(condition));\n      }\n      // `else` clause - only valid after `if` or `else if` clauses\n      else() {\n        return this._elseNode(new Else());\n      }\n      // end `if` statement (needed if gen.if was used only with condition)\n      endIf() {\n        return this._endBlockNode(If, Else);\n      }\n      _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n          this.code(forBody).endFor();\n        return this;\n      }\n      // a generic `for` clause (or statement if `forBody` is passed)\n      for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n      }\n      // `for` statement for a range of values\n      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n      }\n      // `for-of` statement (in es5 mode replace with a normal for loop)\n      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n          const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n          return this.forRange(\"_i\", 0, (0, code_1._)`${arr}.length`, (i) => {\n            this.var(name, (0, code_1._)`${arr}[${i}]`);\n            forBody(name);\n          });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n      }\n      // `for-in` statement.\n      // With option `ownProperties` replaced with a `for-of` loop for object keys\n      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n      }\n      // end `for` loop\n      endFor() {\n        return this._endBlockNode(For);\n      }\n      // `label` statement\n      label(label) {\n        return this._leafNode(new Label(label));\n      }\n      // `break` statement\n      break(label) {\n        return this._leafNode(new Break(label));\n      }\n      // `return` statement\n      return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n          throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n      }\n      // `try` statement\n      try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n          throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n          const error = this.name(\"e\");\n          this._currNode = node.catch = new Catch(error);\n          catchCode(error);\n        }\n        if (finallyCode) {\n          this._currNode = node.finally = new Finally();\n          this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n      }\n      // `throw` statement\n      throw(error) {\n        return this._leafNode(new Throw(error));\n      }\n      // start self-balancing block\n      block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n          this.code(body).endBlock(nodeCount);\n        return this;\n      }\n      // end the current self-balancing block\n      endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === void 0)\n          throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {\n          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n      }\n      // `function` heading (or definition if funcBody is passed)\n      func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n          this.code(funcBody).endFunc();\n        return this;\n      }\n      // end function definition\n      endFunc() {\n        return this._endBlockNode(Func);\n      }\n      optimize(n = 1) {\n        while (n-- > 0) {\n          this._root.optimizeNodes();\n          this._root.optimizeNames(this._root.names, this._constants);\n        }\n      }\n      _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n      }\n      _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n      }\n      _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || N2 && n instanceof N2) {\n          this._nodes.pop();\n          return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n      }\n      _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n          throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n      }\n      get _root() {\n        return this._nodes[0];\n      }\n      get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n      }\n      set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n      }\n    };\n    exports2.CodeGen = CodeGen;\n    function addNames(names, from) {\n      for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n      return names;\n    }\n    function addExprNames(names, from) {\n      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n    }\n    function optimizeExpr(expr, names, constants) {\n      if (expr instanceof code_1.Name)\n        return replaceName(expr);\n      if (!canOptimize(expr))\n        return expr;\n      return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n          c = replaceName(c);\n        if (c instanceof code_1._Code)\n          items.push(...c._items);\n        else\n          items.push(c);\n        return items;\n      }, []));\n      function replaceName(n) {\n        const c = constants[n.str];\n        if (c === void 0 || names[n.str] !== 1)\n          return n;\n        delete names[n.str];\n        return c;\n      }\n      function canOptimize(e) {\n        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);\n      }\n    }\n    function subtractNames(names, from) {\n      for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n    }\n    function not(x) {\n      return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._)`!${par(x)}`;\n    }\n    exports2.not = not;\n    var andCode = mappend(exports2.operators.AND);\n    function and(...args) {\n      return args.reduce(andCode);\n    }\n    exports2.and = and;\n    var orCode = mappend(exports2.operators.OR);\n    function or(...args) {\n      return args.reduce(orCode);\n    }\n    exports2.or = or;\n    function mappend(op) {\n      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;\n    }\n    function par(x) {\n      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js\nvar require_util3 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;\n    var codegen_1 = require_codegen2();\n    var code_1 = require_code3();\n    function toHash(arr) {\n      const hash = {};\n      for (const item of arr)\n        hash[item] = true;\n      return hash;\n    }\n    exports2.toHash = toHash;\n    function alwaysValidSchema(it, schema) {\n      if (typeof schema == \"boolean\")\n        return schema;\n      if (Object.keys(schema).length === 0)\n        return true;\n      checkUnknownRules(it, schema);\n      return !schemaHasRules(schema, it.self.RULES.all);\n    }\n    exports2.alwaysValidSchema = alwaysValidSchema;\n    function checkUnknownRules(it, schema = it.schema) {\n      const { opts, self: self2 } = it;\n      if (!opts.strictSchema)\n        return;\n      if (typeof schema === \"boolean\")\n        return;\n      const rules = self2.RULES.keywords;\n      for (const key in schema) {\n        if (!rules[key])\n          checkStrictMode(it, `unknown keyword: \"${key}\"`);\n      }\n    }\n    exports2.checkUnknownRules = checkUnknownRules;\n    function schemaHasRules(schema, rules) {\n      if (typeof schema == \"boolean\")\n        return !schema;\n      for (const key in schema)\n        if (rules[key])\n          return true;\n      return false;\n    }\n    exports2.schemaHasRules = schemaHasRules;\n    function schemaHasRulesButRef(schema, RULES) {\n      if (typeof schema == \"boolean\")\n        return !schema;\n      for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n          return true;\n      return false;\n    }\n    exports2.schemaHasRulesButRef = schemaHasRulesButRef;\n    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n      if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n          return schema;\n        if (typeof schema == \"string\")\n          return (0, codegen_1._)`${schema}`;\n      }\n      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n    }\n    exports2.schemaRefOrVal = schemaRefOrVal;\n    function unescapeFragment(str) {\n      return unescapeJsonPointer(decodeURIComponent(str));\n    }\n    exports2.unescapeFragment = unescapeFragment;\n    function escapeFragment(str) {\n      return encodeURIComponent(escapeJsonPointer(str));\n    }\n    exports2.escapeFragment = escapeFragment;\n    function escapeJsonPointer(str) {\n      if (typeof str == \"number\")\n        return `${str}`;\n      return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n    }\n    exports2.escapeJsonPointer = escapeJsonPointer;\n    function unescapeJsonPointer(str) {\n      return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n    }\n    exports2.unescapeJsonPointer = unescapeJsonPointer;\n    function eachItem(xs, f) {\n      if (Array.isArray(xs)) {\n        for (const x of xs)\n          f(x);\n      } else {\n        f(xs);\n      }\n    }\n    exports2.eachItem = eachItem;\n    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {\n      return (gen, from, to, toName) => {\n        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n      };\n    }\n    exports2.mergeEvaluated = {\n      props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {\n          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {\n          if (from === true) {\n            gen.assign(to, true);\n          } else {\n            gen.assign(to, (0, codegen_1._)`${to} || {}`);\n            setEvaluated(gen, to, from);\n          }\n        }),\n        mergeValues: (from, to) => from === true ? true : { ...from, ...to },\n        resultToName: evaluatedPropsToName\n      }),\n      items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n        resultToName: (gen, items) => gen.var(\"items\", items)\n      })\n    };\n    function evaluatedPropsToName(gen, ps) {\n      if (ps === true)\n        return gen.var(\"props\", true);\n      const props = gen.var(\"props\", (0, codegen_1._)`{}`);\n      if (ps !== void 0)\n        setEvaluated(gen, props, ps);\n      return props;\n    }\n    exports2.evaluatedPropsToName = evaluatedPropsToName;\n    function setEvaluated(gen, props, ps) {\n      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));\n    }\n    exports2.setEvaluated = setEvaluated;\n    var snippets = {};\n    function useFunc(gen, f) {\n      return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n      });\n    }\n    exports2.useFunc = useFunc;\n    var Type;\n    (function(Type2) {\n      Type2[Type2[\"Num\"] = 0] = \"Num\";\n      Type2[Type2[\"Str\"] = 1] = \"Str\";\n    })(Type || (exports2.Type = Type = {}));\n    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n      if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`\"[\" + ${dataProp} + \"]\"` : (0, codegen_1._)`\"['\" + ${dataProp} + \"']\"` : isNumber ? (0, codegen_1._)`\"/\" + ${dataProp}` : (0, codegen_1._)`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`;\n      }\n      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n    }\n    exports2.getErrorPath = getErrorPath;\n    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n      if (!mode)\n        return;\n      msg = `strict mode: ${msg}`;\n      if (mode === true)\n        throw new Error(msg);\n      it.self.logger.warn(msg);\n    }\n    exports2.checkStrictMode = checkStrictMode;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js\nvar require_names2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var names = {\n      // validation function arguments\n      data: new codegen_1.Name(\"data\"),\n      // data passed to validation function\n      // args passed from referencing schema\n      valCxt: new codegen_1.Name(\"valCxt\"),\n      // validation/data context - should not be used directly, it is destructured to the names below\n      instancePath: new codegen_1.Name(\"instancePath\"),\n      parentData: new codegen_1.Name(\"parentData\"),\n      parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n      rootData: new codegen_1.Name(\"rootData\"),\n      // root data - same as the data passed to the first/top validation function\n      dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"),\n      // used to support recursiveRef and dynamicRef\n      // function scoped variables\n      vErrors: new codegen_1.Name(\"vErrors\"),\n      // null or array of validation errors\n      errors: new codegen_1.Name(\"errors\"),\n      // counter of validation errors\n      this: new codegen_1.Name(\"this\"),\n      // \"globals\"\n      self: new codegen_1.Name(\"self\"),\n      scope: new codegen_1.Name(\"scope\"),\n      // JTD serialize/parse name for JSON string and position\n      json: new codegen_1.Name(\"json\"),\n      jsonPos: new codegen_1.Name(\"jsonPos\"),\n      jsonLen: new codegen_1.Name(\"jsonLen\"),\n      jsonPart: new codegen_1.Name(\"jsonPart\")\n    };\n    exports2.default = names;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js\nvar require_errors2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var names_1 = require_names2();\n    exports2.keywordError = {\n      message: ({ keyword }) => (0, codegen_1.str)`must pass \"${keyword}\" keyword validation`\n    };\n    exports2.keyword$DataError = {\n      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`\"${keyword}\" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`\"${keyword}\" keyword is invalid ($data)`\n    };\n    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {\n      const { it } = cxt;\n      const { gen, compositeRule, allErrors } = it;\n      const errObj = errorObjectCode(cxt, error, errorPaths);\n      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {\n        addError(gen, errObj);\n      } else {\n        returnErrors(it, (0, codegen_1._)`[${errObj}]`);\n      }\n    }\n    exports2.reportError = reportError;\n    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {\n      const { it } = cxt;\n      const { gen, compositeRule, allErrors } = it;\n      const errObj = errorObjectCode(cxt, error, errorPaths);\n      addError(gen, errObj);\n      if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n      }\n    }\n    exports2.reportExtraError = reportExtraError;\n    function resetErrorsCount(gen, errsCount) {\n      gen.assign(names_1.default.errors, errsCount);\n      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n    }\n    exports2.resetErrorsCount = resetErrorsCount;\n    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {\n      if (errsCount === void 0)\n        throw new Error(\"ajv implementation error\");\n      const err = gen.name(\"err\");\n      gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);\n          gen.assign((0, codegen_1._)`${err}.data`, data);\n        }\n      });\n    }\n    exports2.extendErrors = extendErrors;\n    function addError(gen, errObj) {\n      const err = gen.const(\"err\", errObj);\n      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);\n      gen.code((0, codegen_1._)`${names_1.default.errors}++`);\n    }\n    function returnErrors(it, errs) {\n      const { gen, validateName, schemaEnv } = it;\n      if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);\n      } else {\n        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);\n        gen.return(false);\n      }\n    }\n    var E = {\n      keyword: new codegen_1.Name(\"keyword\"),\n      schemaPath: new codegen_1.Name(\"schemaPath\"),\n      // also used in JTD errors\n      params: new codegen_1.Name(\"params\"),\n      propertyName: new codegen_1.Name(\"propertyName\"),\n      message: new codegen_1.Name(\"message\"),\n      schema: new codegen_1.Name(\"schema\"),\n      parentSchema: new codegen_1.Name(\"parentSchema\")\n    };\n    function errorObjectCode(cxt, error, errorPaths) {\n      const { createErrors } = cxt.it;\n      if (createErrors === false)\n        return (0, codegen_1._)`{}`;\n      return errorObject(cxt, error, errorPaths);\n    }\n    function errorObject(cxt, error, errorPaths = {}) {\n      const { gen, it } = cxt;\n      const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths)\n      ];\n      extraErrorProps(cxt, error, keyValues);\n      return gen.object(...keyValues);\n    }\n    function errorInstancePath({ errorPath }, { instancePath }) {\n      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;\n      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n    }\n    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;\n      if (schemaPath) {\n        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n      }\n      return [E.schemaPath, schPath];\n    }\n    function extraErrorProps(cxt, { params, message }, keyValues) {\n      const { keyword, data, schemaValue, it } = cxt;\n      const { opts, propertyName, topSchemaRef, schemaPath } = it;\n      keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._)`{}`]);\n      if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n      }\n      if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n      }\n      if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js\nvar require_boolSchema2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;\n    var errors_1 = require_errors2();\n    var codegen_1 = require_codegen2();\n    var names_1 = require_names2();\n    var boolError = {\n      message: \"boolean schema is false\"\n    };\n    function topBoolOrEmptySchema(it) {\n      const { gen, schema, validateName } = it;\n      if (schema === false) {\n        falseSchemaError(it, false);\n      } else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n      } else {\n        gen.assign((0, codegen_1._)`${validateName}.errors`, null);\n        gen.return(true);\n      }\n    }\n    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;\n    function boolOrEmptySchema(it, valid) {\n      const { gen, schema } = it;\n      if (schema === false) {\n        gen.var(valid, false);\n        falseSchemaError(it);\n      } else {\n        gen.var(valid, true);\n      }\n    }\n    exports2.boolOrEmptySchema = boolOrEmptySchema;\n    function falseSchemaError(it, overrideAllErrors) {\n      const { gen, data } = it;\n      const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it\n      };\n      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js\nvar require_rules2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getRules = exports2.isJSONType = void 0;\n    var _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\n    var jsonTypes = new Set(_jsonTypes);\n    function isJSONType(x) {\n      return typeof x == \"string\" && jsonTypes.has(x);\n    }\n    exports2.isJSONType = isJSONType;\n    function getRules() {\n      const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] }\n      };\n      return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {}\n      };\n    }\n    exports2.getRules = getRules;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js\nvar require_applicability2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;\n    function schemaHasRulesForType({ schema, self: self2 }, type) {\n      const group = self2.RULES.types[type];\n      return group && group !== true && shouldUseGroup(schema, group);\n    }\n    exports2.schemaHasRulesForType = schemaHasRulesForType;\n    function shouldUseGroup(schema, group) {\n      return group.rules.some((rule) => shouldUseRule(schema, rule));\n    }\n    exports2.shouldUseGroup = shouldUseGroup;\n    function shouldUseRule(schema, rule) {\n      var _a;\n      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));\n    }\n    exports2.shouldUseRule = shouldUseRule;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js\nvar require_dataType2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;\n    var rules_1 = require_rules2();\n    var applicability_1 = require_applicability2();\n    var errors_1 = require_errors2();\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var DataType;\n    (function(DataType2) {\n      DataType2[DataType2[\"Correct\"] = 0] = \"Correct\";\n      DataType2[DataType2[\"Wrong\"] = 1] = \"Wrong\";\n    })(DataType || (exports2.DataType = DataType = {}));\n    function getSchemaTypes(schema) {\n      const types = getJSONTypes(schema.type);\n      const hasNull = types.includes(\"null\");\n      if (hasNull) {\n        if (schema.nullable === false)\n          throw new Error(\"type: null contradicts nullable: false\");\n      } else {\n        if (!types.length && schema.nullable !== void 0) {\n          throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n          types.push(\"null\");\n      }\n      return types;\n    }\n    exports2.getSchemaTypes = getSchemaTypes;\n    function getJSONTypes(ts) {\n      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n      if (types.every(rules_1.isJSONType))\n        return types;\n      throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n    }\n    exports2.getJSONTypes = getJSONTypes;\n    function coerceAndCheckDataType(it, types) {\n      const { gen, data, opts } = it;\n      const coerceTo = coerceToTypes(types, opts.coerceTypes);\n      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n      if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n          if (coerceTo.length)\n            coerceData(it, types, coerceTo);\n          else\n            reportTypeError(it);\n        });\n      }\n      return checkTypes;\n    }\n    exports2.coerceAndCheckDataType = coerceAndCheckDataType;\n    var COERCIBLE = /* @__PURE__ */ new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\n    function coerceToTypes(types, coerceTypes) {\n      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n    }\n    function coerceData(it, types, coerceTo) {\n      const { gen, data, opts } = it;\n      const dataType = gen.let(\"dataType\", (0, codegen_1._)`typeof ${data}`);\n      const coerced = gen.let(\"coerced\", (0, codegen_1._)`undefined`);\n      if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n      }\n      gen.if((0, codegen_1._)`${coerced} !== undefined`);\n      for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n          coerceSpecificType(t);\n        }\n      }\n      gen.else();\n      reportTypeError(it);\n      gen.endIf();\n      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n      });\n      function coerceSpecificType(t) {\n        switch (t) {\n          case \"string\":\n            gen.elseIf((0, codegen_1._)`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, (0, codegen_1._)`\"\" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`\"\"`);\n            return;\n          case \"number\":\n            gen.elseIf((0, codegen_1._)`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);\n            return;\n          case \"integer\":\n            gen.elseIf((0, codegen_1._)`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);\n            return;\n          case \"boolean\":\n            gen.elseIf((0, codegen_1._)`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n            return;\n          case \"null\":\n            gen.elseIf((0, codegen_1._)`${data} === \"\" || ${data} === 0 || ${data} === false`);\n            gen.assign(coerced, null);\n            return;\n          case \"array\":\n            gen.elseIf((0, codegen_1._)`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);\n        }\n      }\n    }\n    function assignParentData({ gen, parentData, parentDataProperty }, expr) {\n      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));\n    }\n    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n      let cond;\n      switch (dataType) {\n        case \"null\":\n          return (0, codegen_1._)`${data} ${EQ} null`;\n        case \"array\":\n          cond = (0, codegen_1._)`Array.isArray(${data})`;\n          break;\n        case \"object\":\n          cond = (0, codegen_1._)`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n          break;\n        case \"integer\":\n          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);\n          break;\n        case \"number\":\n          cond = numCond();\n          break;\n        default:\n          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;\n      }\n      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n      function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);\n      }\n    }\n    exports2.checkDataType = checkDataType;\n    function checkDataTypes(dataTypes, data, strictNums, correct) {\n      if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n      }\n      let cond;\n      const types = (0, util_1.toHash)(dataTypes);\n      if (types.array && types.object) {\n        const notObj = (0, codegen_1._)`typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      } else {\n        cond = codegen_1.nil;\n      }\n      if (types.number)\n        delete types.integer;\n      for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n      return cond;\n    }\n    exports2.checkDataTypes = checkDataTypes;\n    var typeError = {\n      message: ({ schema }) => `must be ${schema}`,\n      params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`\n    };\n    function reportTypeError(it) {\n      const cxt = getTypeErrorContext(it);\n      (0, errors_1.reportError)(cxt, typeError);\n    }\n    exports2.reportTypeError = reportTypeError;\n    function getTypeErrorContext(it) {\n      const { gen, data, schema } = it;\n      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n      return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it\n      };\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js\nvar require_defaults2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.assignDefaults = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    function assignDefaults(it, ty) {\n      const { properties, items } = it.schema;\n      if (ty === \"object\" && properties) {\n        for (const key in properties) {\n          assignDefault(it, key, properties[key].default);\n        }\n      } else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n      }\n    }\n    exports2.assignDefaults = assignDefaults;\n    function assignDefault(it, prop, defaultValue) {\n      const { gen, compositeRule, data, opts } = it;\n      if (defaultValue === void 0)\n        return;\n      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;\n      if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n      }\n      let condition = (0, codegen_1._)`${childData} === undefined`;\n      if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === \"\"`;\n      }\n      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js\nvar require_code4 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var names_1 = require_names2();\n    var util_2 = require_util3();\n    function checkReportMissingProp(cxt, prop) {\n      const { gen, data, it } = cxt;\n      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);\n        cxt.error();\n      });\n    }\n    exports2.checkReportMissingProp = checkReportMissingProp;\n    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));\n    }\n    exports2.checkMissingProp = checkMissingProp;\n    function reportMissingProp(cxt, missing) {\n      cxt.setParams({ missingProperty: missing }, true);\n      cxt.error();\n    }\n    exports2.reportMissingProp = reportMissingProp;\n    function hasPropFunc(gen) {\n      return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`\n      });\n    }\n    exports2.hasPropFunc = hasPropFunc;\n    function isOwnProperty(gen, data, property) {\n      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;\n    }\n    exports2.isOwnProperty = isOwnProperty;\n    function propertyInData(gen, data, property, ownProperties) {\n      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n    }\n    exports2.propertyInData = propertyInData;\n    function noPropertyInData(gen, data, property, ownProperties) {\n      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n    }\n    exports2.noPropertyInData = noPropertyInData;\n    function allSchemaProperties(schemaMap) {\n      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n    }\n    exports2.allSchemaProperties = allSchemaProperties;\n    function schemaProperties(it, schemaMap) {\n      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n    }\n    exports2.schemaProperties = schemaProperties;\n    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n      const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData]\n      ];\n      if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;\n      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;\n    }\n    exports2.callValidateCode = callValidateCode;\n    var newRegExp = (0, codegen_1._)`new RegExp`;\n    function usePattern({ gen, it: { opts } }, pattern) {\n      const u = opts.unicodeRegExp ? \"u\" : \"\";\n      const { regExp } = opts.code;\n      const rx = regExp(pattern, u);\n      return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._)`${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`\n      });\n    }\n    exports2.usePattern = usePattern;\n    function validateArray(cxt) {\n      const { gen, data, keyword, it } = cxt;\n      const valid = gen.name(\"valid\");\n      if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n      }\n      gen.var(valid, true);\n      validateItems(() => gen.break());\n      return valid;\n      function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n          cxt.subschema({\n            keyword,\n            dataProp: i,\n            dataPropType: util_1.Type.Num\n          }, valid);\n          gen.if((0, codegen_1.not)(valid), notValid);\n        });\n      }\n    }\n    exports2.validateArray = validateArray;\n    function validateUnion(cxt) {\n      const { gen, schema, keyword, it } = cxt;\n      if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n      if (alwaysValid && !it.opts.unevaluated)\n        return;\n      const valid = gen.let(\"valid\", false);\n      const schValid = gen.name(\"_valid\");\n      gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n          keyword,\n          schemaProp: i,\n          compositeRule: true\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        if (!merged)\n          gen.if((0, codegen_1.not)(valid));\n      }));\n      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n    }\n    exports2.validateUnion = validateUnion;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js\nvar require_keyword2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;\n    var codegen_1 = require_codegen2();\n    var names_1 = require_names2();\n    var code_1 = require_code4();\n    var errors_1 = require_errors2();\n    function macroKeywordCode(cxt, def) {\n      const { gen, keyword, schema, parentSchema, it } = cxt;\n      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n      const schemaRef = useKeyword(gen, keyword, macroSchema);\n      if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n      const valid = gen.name(\"valid\");\n      cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true\n      }, valid);\n      cxt.pass(valid, () => cxt.error(true));\n    }\n    exports2.macroKeywordCode = macroKeywordCode;\n    function funcKeywordCode(cxt, def) {\n      var _a;\n      const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n      checkAsyncKeyword(it, def);\n      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n      const validateRef = useKeyword(gen, keyword, validate);\n      const valid = gen.let(\"valid\");\n      cxt.block$data(valid, validateKeyword);\n      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n      function validateKeyword() {\n        if (def.errors === false) {\n          assignValid();\n          if (def.modifying)\n            modifyData(cxt);\n          reportErrs(() => cxt.error());\n        } else {\n          const ruleErrs = def.async ? validateAsync() : validateSync();\n          if (def.modifying)\n            modifyData(cxt);\n          reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n      }\n      function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n      }\n      function validateSync() {\n        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n      }\n      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n      }\n      function reportErrs(errors) {\n        var _a2;\n        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);\n      }\n    }\n    exports2.funcKeywordCode = funcKeywordCode;\n    function modifyData(cxt) {\n      const { gen, data, it } = cxt;\n      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n    }\n    function addErrs(cxt, errs) {\n      const { gen } = cxt;\n      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n      }, () => cxt.error());\n    }\n    function checkAsyncKeyword({ schemaEnv }, def) {\n      if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n    }\n    function useKeyword(gen, keyword, result) {\n      if (result === void 0)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n      return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n    }\n    function validSchemaType(schema, schemaType, allowUndefined = false) {\n      return !schemaType.length || schemaType.some((st) => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n    }\n    exports2.validSchemaType = validSchemaType;\n    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {\n      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n      }\n      const deps = def.dependencies;\n      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n      }\n      if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n          const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self2.errorsText(def.validateSchema.errors);\n          if (opts.validateSchema === \"log\")\n            self2.logger.error(msg);\n          else\n            throw new Error(msg);\n        }\n      }\n    }\n    exports2.validateKeywordUsage = validateKeywordUsage;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js\nvar require_subschema2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n      if (keyword !== void 0 && schema !== void 0) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n      }\n      if (keyword !== void 0) {\n        const sch = it.schema[keyword];\n        return schemaProp === void 0 ? {\n          schema: sch,\n          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`\n        } : {\n          schema: sch[schemaProp],\n          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`\n        };\n      }\n      if (schema !== void 0) {\n        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {\n          throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n          schema,\n          schemaPath,\n          topSchemaRef,\n          errSchemaPath\n        };\n      }\n      throw new Error('either \"keyword\" or \"schema\" must be passed');\n    }\n    exports2.getSubschema = getSubschema;\n    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n      if (data !== void 0 && dataProp !== void 0) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n      }\n      const { gen } = it;\n      if (dataProp !== void 0) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n      }\n      if (data !== void 0) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true);\n        dataContextProps(nextData);\n        if (propertyName !== void 0)\n          subschema.propertyName = propertyName;\n      }\n      if (dataTypes)\n        subschema.dataTypes = dataTypes;\n      function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = /* @__PURE__ */ new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n      }\n    }\n    exports2.extendSubschemaData = extendSubschemaData;\n    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n      if (compositeRule !== void 0)\n        subschema.compositeRule = compositeRule;\n      if (createErrors !== void 0)\n        subschema.createErrors = createErrors;\n      if (allErrors !== void 0)\n        subschema.allErrors = allErrors;\n      subschema.jtdDiscriminator = jtdDiscriminator;\n      subschema.jtdMetadata = jtdMetadata;\n    }\n    exports2.extendSubschemaMode = extendSubschemaMode;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/json-schema-traverse/index.js\nvar require_json_schema_traverse2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/json-schema-traverse/index.js\"(exports2, module2) {\n    \"use strict\";\n    var traverse = module2.exports = function(schema, opts, cb) {\n      if (typeof opts == \"function\") {\n        cb = opts;\n        opts = {};\n      }\n      cb = opts.cb || cb;\n      var pre = typeof cb == \"function\" ? cb : cb.pre || function() {\n      };\n      var post = cb.post || function() {\n      };\n      _traverse(opts, pre, post, schema, \"\", schema);\n    };\n    traverse.keywords = {\n      additionalItems: true,\n      items: true,\n      contains: true,\n      additionalProperties: true,\n      propertyNames: true,\n      not: true,\n      if: true,\n      then: true,\n      else: true\n    };\n    traverse.arrayKeywords = {\n      items: true,\n      allOf: true,\n      anyOf: true,\n      oneOf: true\n    };\n    traverse.propsKeywords = {\n      $defs: true,\n      definitions: true,\n      properties: true,\n      patternProperties: true,\n      dependencies: true\n    };\n    traverse.skipKeywords = {\n      default: true,\n      enum: true,\n      const: true,\n      required: true,\n      maximum: true,\n      minimum: true,\n      exclusiveMaximum: true,\n      exclusiveMinimum: true,\n      multipleOf: true,\n      maxLength: true,\n      minLength: true,\n      pattern: true,\n      format: true,\n      maxItems: true,\n      minItems: true,\n      uniqueItems: true,\n      maxProperties: true,\n      minProperties: true\n    };\n    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n      if (schema && typeof schema == \"object\" && !Array.isArray(schema)) {\n        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n        for (var key in schema) {\n          var sch = schema[key];\n          if (Array.isArray(sch)) {\n            if (key in traverse.arrayKeywords) {\n              for (var i = 0; i < sch.length; i++)\n                _traverse(opts, pre, post, sch[i], jsonPtr + \"/\" + key + \"/\" + i, rootSchema, jsonPtr, key, schema, i);\n            }\n          } else if (key in traverse.propsKeywords) {\n            if (sch && typeof sch == \"object\") {\n              for (var prop in sch)\n                _traverse(opts, pre, post, sch[prop], jsonPtr + \"/\" + key + \"/\" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n            }\n          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {\n            _traverse(opts, pre, post, sch, jsonPtr + \"/\" + key, rootSchema, jsonPtr, key, schema);\n          }\n        }\n        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n      }\n    }\n    function escapeJsonPtr(str) {\n      return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js\nvar require_resolve2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;\n    var util_1 = require_util3();\n    var equal = require_fast_deep_equal();\n    var traverse = require_json_schema_traverse2();\n    var SIMPLE_INLINED = /* @__PURE__ */ new Set([\n      \"type\",\n      \"format\",\n      \"pattern\",\n      \"maxLength\",\n      \"minLength\",\n      \"maxProperties\",\n      \"minProperties\",\n      \"maxItems\",\n      \"minItems\",\n      \"maximum\",\n      \"minimum\",\n      \"uniqueItems\",\n      \"multipleOf\",\n      \"required\",\n      \"enum\",\n      \"const\"\n    ]);\n    function inlineRef(schema, limit = true) {\n      if (typeof schema == \"boolean\")\n        return true;\n      if (limit === true)\n        return !hasRef(schema);\n      if (!limit)\n        return false;\n      return countKeys(schema) <= limit;\n    }\n    exports2.inlineRef = inlineRef;\n    var REF_KEYWORDS = /* @__PURE__ */ new Set([\n      \"$ref\",\n      \"$recursiveRef\",\n      \"$recursiveAnchor\",\n      \"$dynamicRef\",\n      \"$dynamicAnchor\"\n    ]);\n    function hasRef(schema) {\n      for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n          return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n          return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n          return true;\n      }\n      return false;\n    }\n    function countKeys(schema) {\n      let count = 0;\n      for (const key in schema) {\n        if (key === \"$ref\")\n          return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n          continue;\n        if (typeof schema[key] == \"object\") {\n          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));\n        }\n        if (count === Infinity)\n          return Infinity;\n      }\n      return count;\n    }\n    function getFullPath(resolver, id = \"\", normalize) {\n      if (normalize !== false)\n        id = normalizeId(id);\n      const p = resolver.parse(id);\n      return _getFullPath(resolver, p);\n    }\n    exports2.getFullPath = getFullPath;\n    function _getFullPath(resolver, p) {\n      const serialized = resolver.serialize(p);\n      return serialized.split(\"#\")[0] + \"#\";\n    }\n    exports2._getFullPath = _getFullPath;\n    var TRAILING_SLASH_HASH = /#\\/?$/;\n    function normalizeId(id) {\n      return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n    }\n    exports2.normalizeId = normalizeId;\n    function resolveUrl(resolver, baseId, id) {\n      id = normalizeId(id);\n      return resolver.resolve(baseId, id);\n    }\n    exports2.resolveUrl = resolveUrl;\n    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n    function getSchemaRefs(schema, baseId) {\n      if (typeof schema == \"boolean\")\n        return {};\n      const { schemaId, uriResolver } = this.opts;\n      const schId = normalizeId(schema[schemaId] || baseId);\n      const baseIds = { \"\": schId };\n      const pathPrefix = getFullPath(uriResolver, schId, false);\n      const localRefs = {};\n      const schemaRefs = /* @__PURE__ */ new Set();\n      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === void 0)\n          return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n          innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n          const _resolve = this.opts.uriResolver.resolve;\n          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n          if (schemaRefs.has(ref))\n            throw ambiguos(ref);\n          schemaRefs.add(ref);\n          let schOrRef = this.refs[ref];\n          if (typeof schOrRef == \"string\")\n            schOrRef = this.refs[schOrRef];\n          if (typeof schOrRef == \"object\") {\n            checkAmbiguosRef(sch, schOrRef.schema, ref);\n          } else if (ref !== normalizeId(fullPath)) {\n            if (ref[0] === \"#\") {\n              checkAmbiguosRef(sch, localRefs[ref], ref);\n              localRefs[ref] = sch;\n            } else {\n              this.refs[ref] = fullPath;\n            }\n          }\n          return ref;\n        }\n        function addAnchor(anchor) {\n          if (typeof anchor == \"string\") {\n            if (!ANCHOR.test(anchor))\n              throw new Error(`invalid anchor \"${anchor}\"`);\n            addRef.call(this, `#${anchor}`);\n          }\n        }\n      });\n      return localRefs;\n      function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== void 0 && !equal(sch1, sch2))\n          throw ambiguos(ref);\n      }\n      function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n      }\n    }\n    exports2.getSchemaRefs = getSchemaRefs;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js\nvar require_validate2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;\n    var boolSchema_1 = require_boolSchema2();\n    var dataType_1 = require_dataType2();\n    var applicability_1 = require_applicability2();\n    var dataType_2 = require_dataType2();\n    var defaults_1 = require_defaults2();\n    var keyword_1 = require_keyword2();\n    var subschema_1 = require_subschema2();\n    var codegen_1 = require_codegen2();\n    var names_1 = require_names2();\n    var resolve_1 = require_resolve2();\n    var util_1 = require_util3();\n    var errors_1 = require_errors2();\n    function validateFunctionCode(it) {\n      if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n          topSchemaObjCode(it);\n          return;\n        }\n      }\n      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n    }\n    exports2.validateFunctionCode = validateFunctionCode;\n    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n      if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n          gen.code((0, codegen_1._)`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n          destructureValCxtES5(gen, opts);\n          gen.code(body);\n        });\n      } else {\n        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n      }\n    }\n    function destructureValCxt(opts) {\n      return (0, codegen_1._)`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n    }\n    function destructureValCxtES5(gen, opts) {\n      gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n      }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._)`\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);\n      });\n    }\n    function topSchemaObjCode(it) {\n      const { schema, opts, gen } = it;\n      validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n          commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n          resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n      });\n      return;\n    }\n    function resetEvaluated(it) {\n      const { gen, validateName } = it;\n      it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)`${validateName}.evaluated`);\n      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));\n      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));\n    }\n    function funcSourceUrl(schema, opts) {\n      const schId = typeof schema == \"object\" && schema[opts.schemaId];\n      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;\n    }\n    function subschemaCode(it, valid) {\n      if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n          subSchemaObjCode(it, valid);\n          return;\n        }\n      }\n      (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n    }\n    function schemaCxtHasRules({ schema, self: self2 }) {\n      if (typeof schema == \"boolean\")\n        return !schema;\n      for (const key in schema)\n        if (self2.RULES.all[key])\n          return true;\n      return false;\n    }\n    function isSchemaObj(it) {\n      return typeof it.schema != \"boolean\";\n    }\n    function subSchemaObjCode(it, valid) {\n      const { schema, gen, opts } = it;\n      if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n      updateContext(it);\n      checkAsyncSchema(it);\n      const errsCount = gen.const(\"_errs\", names_1.default.errors);\n      typeAndKeywords(it, errsCount);\n      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n    }\n    function checkKeywords(it) {\n      (0, util_1.checkUnknownRules)(it);\n      checkRefsAndKeywords(it);\n    }\n    function typeAndKeywords(it, errsCount) {\n      if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n      const types = (0, dataType_1.getSchemaTypes)(it.schema);\n      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n      schemaKeywords(it, types, !checkedTypes, errsCount);\n    }\n    function checkRefsAndKeywords(it) {\n      const { schema, errSchemaPath, opts, self: self2 } = it;\n      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {\n        self2.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n      }\n    }\n    function checkNoDefault(it) {\n      const { schema, opts } = it;\n      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n      }\n    }\n    function updateContext(it) {\n      const schId = it.schema[it.opts.schemaId];\n      if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n    }\n    function checkAsyncSchema(it) {\n      if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n    }\n    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n      const msg = schema.$comment;\n      if (opts.$comment === true) {\n        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);\n      } else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n      }\n    }\n    function returnResults(it) {\n      const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n      if (schemaEnv.$async) {\n        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));\n      } else {\n        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n          assignEvaluated(it);\n        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);\n      }\n    }\n    function assignEvaluated({ gen, evaluated, props, items }) {\n      if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._)`${evaluated}.props`, props);\n      if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._)`${evaluated}.items`, items);\n    }\n    function schemaKeywords(it, types, typeErrors, errsCount) {\n      const { gen, schema, data, allErrors, opts, self: self2 } = it;\n      const { RULES } = self2;\n      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition));\n        return;\n      }\n      if (!opts.jtd)\n        checkStrictTypes(it, types);\n      gen.block(() => {\n        for (const group of RULES.rules)\n          groupKeywords(group);\n        groupKeywords(RULES.post);\n      });\n      function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n          return;\n        if (group.type) {\n          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n          iterateKeywords(it, group);\n          if (types.length === 1 && types[0] === group.type && typeErrors) {\n            gen.else();\n            (0, dataType_2.reportTypeError)(it);\n          }\n          gen.endIf();\n        } else {\n          iterateKeywords(it, group);\n        }\n        if (!allErrors)\n          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);\n      }\n    }\n    function iterateKeywords(it, group) {\n      const { gen, schema, opts: { useDefaults } } = it;\n      if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n      gen.block(() => {\n        for (const rule of group.rules) {\n          if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n            keywordCode(it, rule.keyword, rule.definition, group.type);\n          }\n        }\n      });\n    }\n    function checkStrictTypes(it, types) {\n      if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n      checkContextTypes(it, types);\n      if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n      checkKeywordTypes(it, it.dataTypes);\n    }\n    function checkContextTypes(it, types) {\n      if (!types.length)\n        return;\n      if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n      }\n      types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n          strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n      });\n      narrowSchemaTypes(it, types);\n    }\n    function checkMultipleTypes(it, ts) {\n      if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n      }\n    }\n    function checkKeywordTypes(it, ts) {\n      const rules = it.self.RULES.all;\n      for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n          const { type } = rule.definition;\n          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n            strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n          }\n        }\n      }\n    }\n    function hasApplicableType(schTs, kwdT) {\n      return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n    }\n    function includesType(ts, t) {\n      return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n    }\n    function narrowSchemaTypes(it, withTypes) {\n      const ts = [];\n      for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n          ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n          ts.push(\"integer\");\n      }\n      it.dataTypes = ts;\n    }\n    function strictTypesError(it, msg) {\n      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n      msg += ` at \"${schemaPath}\" (strictTypes)`;\n      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n    }\n    var KeywordCxt = class {\n      constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n          this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        } else {\n          this.schemaCode = this.schemaValue;\n          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n          }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n          this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n      }\n      result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n      }\n      failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n          failAction();\n        else\n          this.error();\n        if (successAction) {\n          this.gen.else();\n          successAction();\n          if (this.allErrors)\n            this.gen.endIf();\n        } else {\n          if (this.allErrors)\n            this.gen.endIf();\n          else\n            this.gen.else();\n        }\n      }\n      pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), void 0, failAction);\n      }\n      fail(condition) {\n        if (condition === void 0) {\n          this.error();\n          if (!this.allErrors)\n            this.gen.if(false);\n          return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n          this.gen.endIf();\n        else\n          this.gen.else();\n      }\n      fail$data(condition) {\n        if (!this.$data)\n          return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n      }\n      error(append, errorParams, errorPaths) {\n        if (errorParams) {\n          this.setParams(errorParams);\n          this._error(append, errorPaths);\n          this.setParams({});\n          return;\n        }\n        this._error(append, errorPaths);\n      }\n      _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n      }\n      $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n      }\n      reset() {\n        if (this.errsCount === void 0)\n          throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n      }\n      ok(cond) {\n        if (!this.allErrors)\n          this.gen.if(cond);\n      }\n      setParams(obj, assign) {\n        if (assign)\n          Object.assign(this.params, obj);\n        else\n          this.params = obj;\n      }\n      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n          this.check$data(valid, $dataValid);\n          codeBlock();\n        });\n      }\n      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n          return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n          gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n          gen.elseIf(this.invalid$data());\n          this.$dataError();\n          if (valid !== codegen_1.nil)\n            gen.assign(valid, false);\n        }\n        gen.else();\n      }\n      invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n          if (schemaType.length) {\n            if (!(schemaCode instanceof codegen_1.Name))\n              throw new Error(\"ajv implementation error\");\n            const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n          }\n          return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n          if (def.validateSchema) {\n            const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema });\n            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;\n          }\n          return codegen_1.nil;\n        }\n      }\n      subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n      }\n      mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n          return;\n        if (it.props !== true && schemaCxt.props !== void 0) {\n          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== void 0) {\n          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n      }\n      mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n          return true;\n        }\n      }\n    };\n    exports2.KeywordCxt = KeywordCxt;\n    function keywordCode(it, keyword, def, ruleType) {\n      const cxt = new KeywordCxt(it, def, keyword);\n      if (\"code\" in def) {\n        def.code(cxt, ruleType);\n      } else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n      } else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n      } else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n      }\n    }\n    var JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\n    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n    function getData($data, { dataLevel, dataNames, dataPathArr }) {\n      let jsonPointer;\n      let data;\n      if ($data === \"\")\n        return names_1.default.rootData;\n      if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n          throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n      } else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n          throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n          if (up >= dataLevel)\n            throw new Error(errorMsg(\"property/index\", up));\n          return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n          throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n          return data;\n      }\n      let expr = data;\n      const segments = jsonPointer.split(\"/\");\n      for (const segment of segments) {\n        if (segment) {\n          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n          expr = (0, codegen_1._)`${expr} && ${data}`;\n        }\n      }\n      return expr;\n      function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n      }\n    }\n    exports2.getData = getData;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js\nvar require_validation_error2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var ValidationError = class extends Error {\n      constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n      }\n    };\n    exports2.default = ValidationError;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js\nvar require_ref_error2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var resolve_1 = require_resolve2();\n    var MissingRefError = class extends Error {\n      constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n      }\n    };\n    exports2.default = MissingRefError;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js\nvar require_compile2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;\n    var codegen_1 = require_codegen2();\n    var validation_error_1 = require_validation_error2();\n    var names_1 = require_names2();\n    var resolve_1 = require_resolve2();\n    var util_1 = require_util3();\n    var validate_1 = require_validate2();\n    var SchemaEnv = class {\n      constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n          schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n      }\n    };\n    exports2.SchemaEnv = SchemaEnv;\n    function compileSchema(sch) {\n      const _sch = getCompilingSchema.call(this, sch);\n      if (_sch)\n        return _sch;\n      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);\n      const { es5, lines } = this.opts.code;\n      const { ownProperties } = this.opts;\n      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n      let _ValidationError;\n      if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n          ref: validation_error_1.default,\n          code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n        });\n      }\n      const validateName = gen.scopeName(\"validate\");\n      sch.validateName = validateName;\n      const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: /* @__PURE__ */ new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._)`\"\"`,\n        opts: this.opts,\n        self: this\n      };\n      let sourceCode;\n      try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        if (this.opts.code.process)\n          sourceCode = this.opts.code.process(sourceCode, sch);\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n          validate.$async = true;\n        if (this.opts.code.source === true) {\n          validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n          const { props, items } = schemaCxt;\n          validate.evaluated = {\n            props: props instanceof codegen_1.Name ? void 0 : props,\n            items: items instanceof codegen_1.Name ? void 0 : items,\n            dynamicProps: props instanceof codegen_1.Name,\n            dynamicItems: items instanceof codegen_1.Name\n          };\n          if (validate.source)\n            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n      } catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n          this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        throw e;\n      } finally {\n        this._compilations.delete(sch);\n      }\n    }\n    exports2.compileSchema = compileSchema;\n    function resolveRef(root, baseId, ref) {\n      var _a;\n      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n      const schOrFunc = root.refs[ref];\n      if (schOrFunc)\n        return schOrFunc;\n      let _sch = resolve.call(this, root, ref);\n      if (_sch === void 0) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];\n        const { schemaId } = this.opts;\n        if (schema)\n          _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n      }\n      if (_sch === void 0)\n        return;\n      return root.refs[ref] = inlineOrCompile.call(this, _sch);\n    }\n    exports2.resolveRef = resolveRef;\n    function inlineOrCompile(sch) {\n      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n      return sch.validate ? sch : compileSchema.call(this, sch);\n    }\n    function getCompilingSchema(schEnv) {\n      for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n          return sch;\n      }\n    }\n    exports2.getCompilingSchema = getCompilingSchema;\n    function sameSchemaEnv(s1, s2) {\n      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n    }\n    function resolve(root, ref) {\n      let sch;\n      while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n    }\n    function resolveSchema(root, ref) {\n      const p = this.opts.uriResolver.parse(ref);\n      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);\n      if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n      }\n      const id = (0, resolve_1.normalizeId)(refPath);\n      const schOrRef = this.refs[id] || this.schemas[id];\n      if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n          return;\n        return getJsonPointer.call(this, p, sch);\n      }\n      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n      if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n      if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n      }\n      return getJsonPointer.call(this, p, schOrRef);\n    }\n    exports2.resolveSchema = resolveSchema;\n    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([\n      \"properties\",\n      \"patternProperties\",\n      \"enum\",\n      \"dependencies\",\n      \"definitions\"\n    ]);\n    function getJsonPointer(parsedRef, { baseId, schema, root }) {\n      var _a;\n      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n      for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n          return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === void 0)\n          return;\n        schema = partSchema;\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n      }\n      let env;\n      if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n      }\n      const { schemaId } = this.opts;\n      env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n      if (env.schema !== env.root.schema)\n        return env;\n      return void 0;\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json\nvar require_data2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json\"(exports2, module2) {\n    module2.exports = {\n      $id: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n      description: \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n      type: \"object\",\n      required: [\"$data\"],\n      properties: {\n        $data: {\n          type: \"string\",\n          anyOf: [{ format: \"relative-json-pointer\" }, { format: \"json-pointer\" }]\n        }\n      },\n      additionalProperties: false\n    };\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js\nvar require_uri2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var uri = require_fast_uri();\n    uri.code = 'require(\"ajv/dist/runtime/uri\").default';\n    exports2.default = uri;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/core.js\nvar require_core4 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/core.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;\n    var validate_1 = require_validate2();\n    Object.defineProperty(exports2, \"KeywordCxt\", { enumerable: true, get: function() {\n      return validate_1.KeywordCxt;\n    } });\n    var codegen_1 = require_codegen2();\n    Object.defineProperty(exports2, \"_\", { enumerable: true, get: function() {\n      return codegen_1._;\n    } });\n    Object.defineProperty(exports2, \"str\", { enumerable: true, get: function() {\n      return codegen_1.str;\n    } });\n    Object.defineProperty(exports2, \"stringify\", { enumerable: true, get: function() {\n      return codegen_1.stringify;\n    } });\n    Object.defineProperty(exports2, \"nil\", { enumerable: true, get: function() {\n      return codegen_1.nil;\n    } });\n    Object.defineProperty(exports2, \"Name\", { enumerable: true, get: function() {\n      return codegen_1.Name;\n    } });\n    Object.defineProperty(exports2, \"CodeGen\", { enumerable: true, get: function() {\n      return codegen_1.CodeGen;\n    } });\n    var validation_error_1 = require_validation_error2();\n    var ref_error_1 = require_ref_error2();\n    var rules_1 = require_rules2();\n    var compile_1 = require_compile2();\n    var codegen_2 = require_codegen2();\n    var resolve_1 = require_resolve2();\n    var dataType_1 = require_dataType2();\n    var util_1 = require_util3();\n    var $dataRefSchema = require_data2();\n    var uri_1 = require_uri2();\n    var defaultRegExp = (str, flags) => new RegExp(str, flags);\n    defaultRegExp.code = \"new RegExp\";\n    var META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\n    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([\n      \"validate\",\n      \"serialize\",\n      \"parse\",\n      \"wrapper\",\n      \"root\",\n      \"schema\",\n      \"keyword\",\n      \"pattern\",\n      \"formats\",\n      \"validate$data\",\n      \"func\",\n      \"obj\",\n      \"Error\"\n    ]);\n    var removedOptions = {\n      errorDataPath: \"\",\n      format: \"`validateFormats: false` can be used instead.\",\n      nullable: '\"nullable\" keyword is supported by default.',\n      jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n      extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n      missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n      processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n      sourceCode: \"Use option `code: {source: true}`\",\n      strictDefaults: \"It is default now, see option `strict`.\",\n      strictKeywords: \"It is default now, see option `strict`.\",\n      uniqueItems: '\"uniqueItems\" keyword is always validated.',\n      unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n      cache: \"Map is used as cache, schema object as key.\",\n      serialize: \"Map is used as cache, schema object as key.\",\n      ajvErrors: \"It is default now.\"\n    };\n    var deprecatedOptions = {\n      ignoreKeywordsWithRef: \"\",\n      jsPropertySyntax: \"\",\n      unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n    };\n    var MAX_EXPRESSION = 200;\n    function requiredOptions(o) {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n      const s = o.strict;\n      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;\n      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n      return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver\n      };\n    }\n    var Ajv = class {\n      constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = /* @__PURE__ */ new Set();\n        this._loading = {};\n        this._cache = /* @__PURE__ */ new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n          addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n          addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n          this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n      }\n      _addVocabularies() {\n        this.addKeyword(\"$async\");\n      }\n      _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n          _dataRefSchema = { ...$dataRefSchema };\n          _dataRefSchema.id = _dataRefSchema.$id;\n          delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n      }\n      defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : void 0;\n      }\n      validate(schemaKeyRef, data) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n          v = this.getSchema(schemaKeyRef);\n          if (!v)\n            throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        } else {\n          v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n          this.errors = v.errors;\n        return valid;\n      }\n      compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return sch.validate || this._compileSchemaEnv(sch);\n      }\n      compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n          throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n          await loadMetaSchema.call(this, _schema.$schema);\n          const sch = this._addSchema(_schema, _meta);\n          return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n          if ($ref && !this.getSchema($ref)) {\n            await runCompileAsync.call(this, { $ref }, true);\n          }\n        }\n        async function _compileAsync(sch) {\n          try {\n            return this._compileSchemaEnv(sch);\n          } catch (e) {\n            if (!(e instanceof ref_error_1.default))\n              throw e;\n            checkLoaded.call(this, e);\n            await loadMissingSchema.call(this, e.missingSchema);\n            return _compileAsync.call(this, sch);\n          }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n          if (this.refs[ref]) {\n            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n          }\n        }\n        async function loadMissingSchema(ref) {\n          const _schema = await _loadSchema.call(this, ref);\n          if (!this.refs[ref])\n            await loadMetaSchema.call(this, _schema.$schema);\n          if (!this.refs[ref])\n            this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n          const p = this._loading[ref];\n          if (p)\n            return p;\n          try {\n            return await (this._loading[ref] = loadSchema(ref));\n          } finally {\n            delete this._loading[ref];\n          }\n        }\n      }\n      // Adds schema to the instance\n      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {\n        if (Array.isArray(schema)) {\n          for (const sch of schema)\n            this.addSchema(sch, void 0, _meta, _validateSchema);\n          return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n          const { schemaId } = this.opts;\n          id = schema[schemaId];\n          if (id !== void 0 && typeof id != \"string\") {\n            throw new Error(`schema ${schemaId} must be string`);\n          }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n      }\n      // Add schema that will be used to validate other schemas\n      // options in META_IGNORE_OPTIONS are alway set to false\n      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n      }\n      //  Validate schema against its meta-schema\n      validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n          return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== void 0 && typeof $schema != \"string\") {\n          throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n          this.logger.warn(\"meta-schema not available\");\n          this.errors = null;\n          return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n          const message = \"schema is invalid: \" + this.errorsText();\n          if (this.opts.validateSchema === \"log\")\n            this.logger.error(message);\n          else\n            throw new Error(message);\n        }\n        return valid;\n      }\n      // Get compiled schema by `key` or `ref`.\n      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n      getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n          keyRef = sch;\n        if (sch === void 0) {\n          const { schemaId } = this.opts;\n          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n          sch = compile_1.resolveSchema.call(this, root, keyRef);\n          if (!sch)\n            return;\n          this.refs[keyRef] = sch;\n        }\n        return sch.validate || this._compileSchemaEnv(sch);\n      }\n      // Remove cached schema(s).\n      // If no parameter is passed all schemas but meta-schemas are removed.\n      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n      removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n          this._removeAllSchemas(this.schemas, schemaKeyRef);\n          this._removeAllSchemas(this.refs, schemaKeyRef);\n          return this;\n        }\n        switch (typeof schemaKeyRef) {\n          case \"undefined\":\n            this._removeAllSchemas(this.schemas);\n            this._removeAllSchemas(this.refs);\n            this._cache.clear();\n            return this;\n          case \"string\": {\n            const sch = getSchEnv.call(this, schemaKeyRef);\n            if (typeof sch == \"object\")\n              this._cache.delete(sch.schema);\n            delete this.schemas[schemaKeyRef];\n            delete this.refs[schemaKeyRef];\n            return this;\n          }\n          case \"object\": {\n            const cacheKey = schemaKeyRef;\n            this._cache.delete(cacheKey);\n            let id = schemaKeyRef[this.opts.schemaId];\n            if (id) {\n              id = (0, resolve_1.normalizeId)(id);\n              delete this.schemas[id];\n              delete this.refs[id];\n            }\n            return this;\n          }\n          default:\n            throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n      }\n      // add \"vocabulary\" - a collection of keywords\n      addVocabulary(definitions) {\n        for (const def of definitions)\n          this.addKeyword(def);\n        return this;\n      }\n      addKeyword(kwdOrDef, def) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n          keyword = kwdOrDef;\n          if (typeof def == \"object\") {\n            this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n            def.keyword = keyword;\n          }\n        } else if (typeof kwdOrDef == \"object\" && def === void 0) {\n          def = kwdOrDef;\n          keyword = def.keyword;\n          if (Array.isArray(keyword) && !keyword.length) {\n            throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n          }\n        } else {\n          throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n          return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n          ...def,\n          type: (0, dataType_1.getJSONTypes)(def.type),\n          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n      }\n      getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n      }\n      // Remove keyword\n      removeKeyword(keyword) {\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n          const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n          if (i >= 0)\n            group.rules.splice(i, 1);\n        }\n        return this;\n      }\n      // Add format\n      addFormat(name, format) {\n        if (typeof format == \"string\")\n          format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n      }\n      errorsText(errors = this.errors, { separator = \", \", dataVar = \"data\" } = {}) {\n        if (!errors || errors.length === 0)\n          return \"No errors\";\n        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n      }\n      $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n          const segments = jsonPointer.split(\"/\").slice(1);\n          let keywords = metaSchema;\n          for (const seg of segments)\n            keywords = keywords[seg];\n          for (const key in rules) {\n            const rule = rules[key];\n            if (typeof rule != \"object\")\n              continue;\n            const { $data } = rule.definition;\n            const schema = keywords[key];\n            if ($data && schema)\n              keywords[key] = schemaOrData(schema);\n          }\n        }\n        return metaSchema;\n      }\n      _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n          const sch = schemas[keyRef];\n          if (!regex || regex.test(keyRef)) {\n            if (typeof sch == \"string\") {\n              delete schemas[keyRef];\n            } else if (sch && !sch.meta) {\n              this._cache.delete(sch.schema);\n              delete schemas[keyRef];\n            }\n          }\n        }\n      }\n      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n          id = schema[schemaId];\n        } else {\n          if (this.opts.jtd)\n            throw new Error(\"schema must be object\");\n          else if (typeof schema != \"boolean\")\n            throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== void 0)\n          return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n          if (baseId)\n            this._checkUnique(baseId);\n          this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n          this.validateSchema(schema, true);\n        return sch;\n      }\n      _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n          throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n      }\n      _compileSchemaEnv(sch) {\n        if (sch.meta)\n          this._compileMetaSchema(sch);\n        else\n          compile_1.compileSchema.call(this, sch);\n        if (!sch.validate)\n          throw new Error(\"ajv implementation error\");\n        return sch.validate;\n      }\n      _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n          compile_1.compileSchema.call(this, sch);\n        } finally {\n          this.opts = currentOpts;\n        }\n      }\n    };\n    Ajv.ValidationError = validation_error_1.default;\n    Ajv.MissingRefError = ref_error_1.default;\n    exports2.default = Ajv;\n    function checkOptions(checkOpts, options, msg, log12 = \"error\") {\n      for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n          this.logger[log12](`${msg}: option ${key}. ${checkOpts[opt]}`);\n      }\n    }\n    function getSchEnv(keyRef) {\n      keyRef = (0, resolve_1.normalizeId)(keyRef);\n      return this.schemas[keyRef] || this.refs[keyRef];\n    }\n    function addInitialSchemas() {\n      const optsSchemas = this.opts.schemas;\n      if (!optsSchemas)\n        return;\n      if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n      else\n        for (const key in optsSchemas)\n          this.addSchema(optsSchemas[key], key);\n    }\n    function addInitialFormats() {\n      for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n          this.addFormat(name, format);\n      }\n    }\n    function addInitialKeywords(defs) {\n      if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n      }\n      this.logger.warn(\"keywords option as map is deprecated, pass array\");\n      for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n          def.keyword = keyword;\n        this.addKeyword(def);\n      }\n    }\n    function getMetaSchemaOptions() {\n      const metaOpts = { ...this.opts };\n      for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n      return metaOpts;\n    }\n    var noLogs = { log() {\n    }, warn() {\n    }, error() {\n    } };\n    function getLogger(logger12) {\n      if (logger12 === false)\n        return noLogs;\n      if (logger12 === void 0)\n        return console;\n      if (logger12.log && logger12.warn && logger12.error)\n        return logger12;\n      throw new Error(\"logger must implement log, warn and error methods\");\n    }\n    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\n    function checkKeyword(keyword, def) {\n      const { RULES } = this;\n      (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n          throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n          throw new Error(`Keyword ${kwd} has invalid name`);\n      });\n      if (!def)\n        return;\n      if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n      }\n    }\n    function addRule(keyword, definition, dataType) {\n      var _a;\n      const post = definition === null || definition === void 0 ? void 0 : definition.post;\n      if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n      const { RULES } = this;\n      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n      if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n      }\n      RULES.keywords[keyword] = true;\n      if (!definition)\n        return;\n      const rule = {\n        keyword,\n        definition: {\n          ...definition,\n          type: (0, dataType_1.getJSONTypes)(definition.type),\n          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n        }\n      };\n      if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n      else\n        ruleGroup.rules.push(rule);\n      RULES.all[keyword] = rule;\n      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n    }\n    function addBeforeRule(ruleGroup, rule, before) {\n      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n      if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n      } else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n      }\n    }\n    function keywordMetaschema(def) {\n      let { metaSchema } = def;\n      if (metaSchema === void 0)\n        return;\n      if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n      def.validateSchema = this.compile(metaSchema, true);\n    }\n    var $dataRef = {\n      $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n    };\n    function schemaOrData(schema) {\n      return { anyOf: [schema, $dataRef] };\n    }\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js\nvar require_id2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var def = {\n      keyword: \"id\",\n      code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js\nvar require_ref2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.callRef = exports2.getValidate = void 0;\n    var ref_error_1 = require_ref_error2();\n    var code_1 = require_code4();\n    var codegen_1 = require_codegen2();\n    var names_1 = require_names2();\n    var compile_1 = require_compile2();\n    var util_1 = require_util3();\n    var def = {\n      keyword: \"$ref\",\n      schemaType: \"string\",\n      code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n          return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);\n        if (schOrEnv === void 0)\n          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n          return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n          if (env === root)\n            return callRef(cxt, validateName, env, env.$async);\n          const rootName = gen.scopeValue(\"root\", { ref: root });\n          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n          const v = getValidate(cxt, sch);\n          callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n          const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n          const valid = gen.name(\"valid\");\n          const schCxt = cxt.subschema({\n            schema: sch,\n            dataTypes: [],\n            schemaPath: codegen_1.nil,\n            topSchemaRef: schName,\n            errSchemaPath: $ref\n          }, valid);\n          cxt.mergeEvaluated(schCxt);\n          cxt.ok(valid);\n        }\n      }\n    };\n    function getValidate(cxt, sch) {\n      const { gen } = cxt;\n      return sch.validate ? gen.scopeValue(\"validate\", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n    }\n    exports2.getValidate = getValidate;\n    function callRef(cxt, v, sch, $async) {\n      const { gen, it } = cxt;\n      const { allErrors, schemaEnv: env, opts } = it;\n      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n      if ($async)\n        callAsyncRef();\n      else\n        callSyncRef();\n      function callAsyncRef() {\n        if (!env.$async)\n          throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n          addEvaluatedFrom(v);\n          if (!allErrors)\n            gen.assign(valid, true);\n        }, (e) => {\n          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n          addErrorsFrom(e);\n          if (!allErrors)\n            gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n      }\n      function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n      }\n      function addErrorsFrom(source) {\n        const errs = (0, codegen_1._)`${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);\n        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n      }\n      function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n          return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        if (it.props !== true) {\n          if (schEvaluated && !schEvaluated.dynamicProps) {\n            if (schEvaluated.props !== void 0) {\n              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n            }\n          } else {\n            const props = gen.var(\"props\", (0, codegen_1._)`${source}.evaluated.props`);\n            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n          }\n        }\n        if (it.items !== true) {\n          if (schEvaluated && !schEvaluated.dynamicItems) {\n            if (schEvaluated.items !== void 0) {\n              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n            }\n          } else {\n            const items = gen.var(\"items\", (0, codegen_1._)`${source}.evaluated.items`);\n            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n          }\n        }\n      }\n    }\n    exports2.callRef = callRef;\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js\nvar require_core5 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var id_1 = require_id2();\n    var ref_1 = require_ref2();\n    var core = [\n      \"$schema\",\n      \"$id\",\n      \"$defs\",\n      \"$vocabulary\",\n      { keyword: \"$comment\" },\n      \"definitions\",\n      id_1.default,\n      ref_1.default\n    ];\n    exports2.default = core;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js\nvar require_limitNumber2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var ops = codegen_1.operators;\n    var KWDs = {\n      maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n      minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n      exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n      exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE }\n    };\n    var error = {\n      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,\n      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: Object.keys(KWDs),\n      type: \"number\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js\nvar require_multipleOf2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var error = {\n      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,\n      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"multipleOf\",\n      type: \"number\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js\nvar require_ucs2length2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    function ucs2length(str) {\n      const len = str.length;\n      let length = 0;\n      let pos = 0;\n      let value;\n      while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 55296 && value <= 56319 && pos < len) {\n          value = str.charCodeAt(pos);\n          if ((value & 64512) === 56320)\n            pos++;\n        }\n      }\n      return length;\n    }\n    exports2.default = ucs2length;\n    ucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js\nvar require_limitLength2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var ucs2length_1 = require_ucs2length2();\n    var error = {\n      message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;\n      },\n      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: [\"maxLength\", \"minLength\"],\n      type: \"string\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js\nvar require_pattern2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code4();\n    var codegen_1 = require_codegen2();\n    var error = {\n      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern \"${schemaCode}\"`,\n      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"pattern\",\n      type: \"string\",\n      schemaType: \"string\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js\nvar require_limitProperties2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var error = {\n      message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;\n      },\n      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: [\"maxProperties\", \"minProperties\"],\n      type: \"object\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js\nvar require_required2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code4();\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var error = {\n      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,\n      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`\n    };\n    var def = {\n      keyword: \"required\",\n      type: \"object\",\n      schemaType: \"array\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n          return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n          allErrorsMode();\n        else\n          exitOnErrorMode();\n        if (opts.strictRequired) {\n          const props = cxt.parentSchema.properties;\n          const { definedProperties } = cxt.it;\n          for (const requiredKey of schema) {\n            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {\n              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n              const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n            }\n          }\n        }\n        function allErrorsMode() {\n          if (useLoop || $data) {\n            cxt.block$data(codegen_1.nil, loopAllRequired);\n          } else {\n            for (const prop of schema) {\n              (0, code_1.checkReportMissingProp)(cxt, prop);\n            }\n          }\n        }\n        function exitOnErrorMode() {\n          const missing = gen.let(\"missing\");\n          if (useLoop || $data) {\n            const valid = gen.let(\"valid\", true);\n            cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n            cxt.ok(valid);\n          } else {\n            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n          }\n        }\n        function loopAllRequired() {\n          gen.forOf(\"prop\", schemaCode, (prop) => {\n            cxt.setParams({ missingProperty: prop });\n            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n          });\n        }\n        function loopUntilMissing(missing, valid) {\n          cxt.setParams({ missingProperty: missing });\n          gen.forOf(missing, schemaCode, () => {\n            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n            gen.if((0, codegen_1.not)(valid), () => {\n              cxt.error();\n              gen.break();\n            });\n          }, codegen_1.nil);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js\nvar require_limitItems2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var error = {\n      message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;\n      },\n      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`\n    };\n    var def = {\n      keyword: [\"maxItems\", \"minItems\"],\n      type: \"array\",\n      schemaType: \"number\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js\nvar require_equal2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var equal = require_fast_deep_equal();\n    equal.code = 'require(\"ajv/dist/runtime/equal\").default';\n    exports2.default = equal;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\nvar require_uniqueItems2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var dataType_1 = require_dataType2();\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var equal_1 = require_equal2();\n    var error = {\n      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`\n    };\n    var def = {\n      keyword: \"uniqueItems\",\n      type: \"array\",\n      schemaType: \"boolean\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n          return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n          const i = gen.let(\"i\", (0, codegen_1._)`${data}.length`);\n          const j = gen.let(\"j\");\n          cxt.setParams({ i, j });\n          gen.assign(valid, true);\n          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n          return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n          const item = gen.name(\"item\");\n          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n          const indices = gen.const(\"indices\", (0, codegen_1._)`{}`);\n          gen.for((0, codegen_1._)`;${i}--;`, () => {\n            gen.let(item, (0, codegen_1._)`${data}[${i}]`);\n            gen.if(wrongType, (0, codegen_1._)`continue`);\n            if (itemTypes.length > 1)\n              gen.if((0, codegen_1._)`typeof ${item} == \"string\"`, (0, codegen_1._)`${item} += \"_\"`);\n            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == \"number\"`, () => {\n              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);\n              cxt.error();\n              gen.assign(valid, false).break();\n            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);\n          });\n        }\n        function loopN2(i, j) {\n          const eql = (0, util_1.useFunc)(gen, equal_1.default);\n          const outer = gen.name(\"outer\");\n          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error();\n            gen.assign(valid, false).break(outer);\n          })));\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js\nvar require_const2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var equal_1 = require_equal2();\n    var error = {\n      message: \"must be equal to constant\",\n      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"const\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || schema && typeof schema == \"object\") {\n          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        } else {\n          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js\nvar require_enum2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var equal_1 = require_equal2();\n    var error = {\n      message: \"must be equal to one of the allowed values\",\n      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"enum\",\n      schemaType: \"array\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n          throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n        let valid;\n        if (useLoop || $data) {\n          valid = gen.let(\"valid\");\n          cxt.block$data(valid, loopEnum);\n        } else {\n          if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n          const vSchema = gen.const(\"vSchema\", schemaCode);\n          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n          gen.assign(valid, false);\n          gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n          const sch = schema[i];\n          return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js\nvar require_validation2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var limitNumber_1 = require_limitNumber2();\n    var multipleOf_1 = require_multipleOf2();\n    var limitLength_1 = require_limitLength2();\n    var pattern_1 = require_pattern2();\n    var limitProperties_1 = require_limitProperties2();\n    var required_1 = require_required2();\n    var limitItems_1 = require_limitItems2();\n    var uniqueItems_1 = require_uniqueItems2();\n    var const_1 = require_const2();\n    var enum_1 = require_enum2();\n    var validation = [\n      // number\n      limitNumber_1.default,\n      multipleOf_1.default,\n      // string\n      limitLength_1.default,\n      pattern_1.default,\n      // object\n      limitProperties_1.default,\n      required_1.default,\n      // array\n      limitItems_1.default,\n      uniqueItems_1.default,\n      // any\n      { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n      { keyword: \"nullable\", schemaType: \"boolean\" },\n      const_1.default,\n      enum_1.default\n    ];\n    exports2.default = validation;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\nvar require_additionalItems2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateAdditionalItems = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var error = {\n      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,\n      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`\n    };\n    var def = {\n      keyword: \"additionalItems\",\n      type: \"array\",\n      schemaType: [\"boolean\", \"object\"],\n      before: \"uniqueItems\",\n      error,\n      code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n          (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n          return;\n        }\n        validateAdditionalItems(cxt, items);\n      }\n    };\n    function validateAdditionalItems(cxt, items) {\n      const { gen, schema, data, keyword, it } = cxt;\n      it.items = true;\n      const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n      if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);\n      } else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._)`${len} <= ${items.length}`);\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n      }\n      function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n          if (!it.allErrors)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n      }\n    }\n    exports2.validateAdditionalItems = validateAdditionalItems;\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js\nvar require_items2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateTuple = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var code_1 = require_code4();\n    var def = {\n      keyword: \"items\",\n      type: \"array\",\n      schemaType: [\"object\", \"array\", \"boolean\"],\n      before: \"uniqueItems\",\n      code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n          return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n      }\n    };\n    function validateTuple(cxt, extraItems, schArr = cxt.schema) {\n      const { gen, parentSchema, data, keyword, it } = cxt;\n      checkStrictTuple(parentSchema);\n      if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n      }\n      const valid = gen.name(\"valid\");\n      const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n      schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n          return;\n        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({\n          keyword,\n          schemaProp: i,\n          dataProp: i\n        }, valid));\n        cxt.ok(valid);\n      });\n      function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n          const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n      }\n    }\n    exports2.validateTuple = validateTuple;\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\nvar require_prefixItems2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var items_1 = require_items2();\n    var def = {\n      keyword: \"prefixItems\",\n      type: \"array\",\n      schemaType: [\"array\"],\n      before: \"uniqueItems\",\n      code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\")\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js\nvar require_items20202 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var code_1 = require_code4();\n    var additionalItems_1 = require_additionalItems2();\n    var error = {\n      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,\n      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`\n    };\n    var def = {\n      keyword: \"items\",\n      type: \"array\",\n      schemaType: [\"object\", \"boolean\"],\n      before: \"uniqueItems\",\n      error,\n      code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        if (prefixItems)\n          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n          cxt.ok((0, code_1.validateArray)(cxt));\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js\nvar require_contains2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var error = {\n      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,\n      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`\n    };\n    var def = {\n      keyword: \"contains\",\n      type: \"array\",\n      schemaType: [\"object\", \"boolean\"],\n      before: \"uniqueItems\",\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n          min = minContains === void 0 ? 1 : minContains;\n          max = maxContains;\n        } else {\n          min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === void 0 && min === 0) {\n          (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n          return;\n        }\n        if (max !== void 0 && min > max) {\n          (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n          cxt.fail();\n          return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n          let cond = (0, codegen_1._)`${len} >= ${min}`;\n          if (max !== void 0)\n            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;\n          cxt.pass(cond);\n          return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === void 0 && min === 1) {\n          validateItems(valid, () => gen.if(valid, () => gen.break()));\n        } else if (min === 0) {\n          gen.let(valid, true);\n          if (max !== void 0)\n            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);\n        } else {\n          gen.let(valid, false);\n          validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n          const schValid = gen.name(\"_valid\");\n          const count = gen.let(\"count\", 0);\n          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n          gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n              keyword: \"contains\",\n              dataProp: i,\n              dataPropType: util_1.Type.Num,\n              compositeRule: true\n            }, _valid);\n            block();\n          });\n        }\n        function checkLimits(count) {\n          gen.code((0, codegen_1._)`${count}++`);\n          if (max === void 0) {\n            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());\n          } else {\n            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());\n            if (min === 1)\n              gen.assign(valid, true);\n            else\n              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));\n          }\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js\nvar require_dependencies2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var code_1 = require_code4();\n    exports2.error = {\n      message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;\n      },\n      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`\n      // TODO change to reference\n    };\n    var def = {\n      keyword: \"dependencies\",\n      type: \"object\",\n      schemaType: \"object\",\n      error: exports2.error,\n      code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n      }\n    };\n    function splitDependencies({ schema }) {\n      const propertyDeps = {};\n      const schemaDeps = {};\n      for (const key in schema) {\n        if (key === \"__proto__\")\n          continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n      }\n      return [propertyDeps, schemaDeps];\n    }\n    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n      const { gen, data, it } = cxt;\n      if (Object.keys(propertyDeps).length === 0)\n        return;\n      const missing = gen.let(\"missing\");\n      for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n          continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n          property: prop,\n          depsCount: deps.length,\n          deps: deps.join(\", \")\n        });\n        if (it.allErrors) {\n          gen.if(hasProperty, () => {\n            for (const depProp of deps) {\n              (0, code_1.checkReportMissingProp)(cxt, depProp);\n            }\n          });\n        } else {\n          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n          (0, code_1.reportMissingProp)(cxt, missing);\n          gen.else();\n        }\n      }\n    }\n    exports2.validatePropertyDeps = validatePropertyDeps;\n    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n      const { gen, data, keyword, it } = cxt;\n      const valid = gen.name(\"valid\");\n      for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n          continue;\n        gen.if(\n          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),\n          () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n          },\n          () => gen.var(valid, true)\n          // TODO var\n        );\n        cxt.ok(valid);\n      }\n    }\n    exports2.validateSchemaDeps = validateSchemaDeps;\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\nvar require_propertyNames2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var error = {\n      message: \"property name must be valid\",\n      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`\n    };\n    var def = {\n      keyword: \"propertyNames\",\n      type: \"object\",\n      schemaType: [\"object\", \"boolean\"],\n      error,\n      code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n          cxt.setParams({ propertyName: key });\n          cxt.subschema({\n            keyword: \"propertyNames\",\n            data: key,\n            dataTypes: [\"string\"],\n            propertyName: key,\n            compositeRule: true\n          }, valid);\n          gen.if((0, codegen_1.not)(valid), () => {\n            cxt.error(true);\n            if (!it.allErrors)\n              gen.break();\n          });\n        });\n        cxt.ok(valid);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\nvar require_additionalProperties2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code4();\n    var codegen_1 = require_codegen2();\n    var names_1 = require_names2();\n    var util_1 = require_util3();\n    var error = {\n      message: \"must NOT have additional properties\",\n      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`\n    };\n    var def = {\n      keyword: \"additionalProperties\",\n      type: [\"object\"],\n      schemaType: [\"boolean\", \"object\"],\n      allowUndefined: true,\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        if (!errsCount)\n          throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n          return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n          gen.forIn(\"key\", data, (key) => {\n            if (!props.length && !patProps.length)\n              additionalPropertyCode(key);\n            else\n              gen.if(isAdditional(key), () => additionalPropertyCode(key));\n          });\n        }\n        function isAdditional(key) {\n          let definedProp;\n          if (props.length > 8) {\n            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n          } else if (props.length) {\n            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));\n          } else {\n            definedProp = codegen_1.nil;\n          }\n          if (patProps.length) {\n            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n          }\n          return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n          gen.code((0, codegen_1._)`delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n          if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n            deleteAdditional(key);\n            return;\n          }\n          if (schema === false) {\n            cxt.setParams({ additionalProperty: key });\n            cxt.error();\n            if (!allErrors)\n              gen.break();\n            return;\n          }\n          if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n            const valid = gen.name(\"valid\");\n            if (opts.removeAdditional === \"failing\") {\n              applyAdditionalSchema(key, valid, false);\n              gen.if((0, codegen_1.not)(valid), () => {\n                cxt.reset();\n                deleteAdditional(key);\n              });\n            } else {\n              applyAdditionalSchema(key, valid);\n              if (!allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n            }\n          }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n          const subschema = {\n            keyword: \"additionalProperties\",\n            dataProp: key,\n            dataPropType: util_1.Type.Str\n          };\n          if (errors === false) {\n            Object.assign(subschema, {\n              compositeRule: true,\n              createErrors: false,\n              allErrors: false\n            });\n          }\n          cxt.subschema(subschema, valid);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js\nvar require_properties2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var validate_1 = require_validate2();\n    var code_1 = require_code4();\n    var util_1 = require_util3();\n    var additionalProperties_1 = require_additionalProperties2();\n    var def = {\n      keyword: \"properties\",\n      type: \"object\",\n      schemaType: \"object\",\n      code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === void 0) {\n          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n          it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n          return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n          if (hasDefault(prop)) {\n            applyPropertySchema(prop);\n          } else {\n            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n            applyPropertySchema(prop);\n            if (!it.allErrors)\n              gen.else().var(valid, true);\n            gen.endIf();\n          }\n          cxt.it.definedProperties.add(prop);\n          cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;\n        }\n        function applyPropertySchema(prop) {\n          cxt.subschema({\n            keyword: \"properties\",\n            schemaProp: prop,\n            dataProp: prop\n          }, valid);\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\nvar require_patternProperties2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code4();\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var util_2 = require_util3();\n    var def = {\n      keyword: \"patternProperties\",\n      type: \"object\",\n      schemaType: \"object\",\n      code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n          return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n          for (const pat of patterns) {\n            if (checkProperties)\n              checkMatchingProperties(pat);\n            if (it.allErrors) {\n              validateProperties(pat);\n            } else {\n              gen.var(valid, true);\n              validateProperties(pat);\n              gen.if(valid);\n            }\n          }\n        }\n        function checkMatchingProperties(pat) {\n          for (const prop in checkProperties) {\n            if (new RegExp(pat).test(prop)) {\n              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n            }\n          }\n        }\n        function validateProperties(pat) {\n          gen.forIn(\"key\", data, (key) => {\n            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n              const alwaysValid = alwaysValidPatterns.includes(pat);\n              if (!alwaysValid) {\n                cxt.subschema({\n                  keyword: \"patternProperties\",\n                  schemaProp: pat,\n                  dataProp: key,\n                  dataPropType: util_2.Type.Str\n                }, valid);\n              }\n              if (it.opts.unevaluated && props !== true) {\n                gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n              } else if (!alwaysValid && !it.allErrors) {\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n              }\n            });\n          });\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js\nvar require_not2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require_util3();\n    var def = {\n      keyword: \"not\",\n      schemaType: [\"object\", \"boolean\"],\n      trackErrors: true,\n      code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n          cxt.fail();\n          return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n          keyword: \"not\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n      },\n      error: { message: \"must NOT be valid\" }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js\nvar require_anyOf2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var code_1 = require_code4();\n    var def = {\n      keyword: \"anyOf\",\n      schemaType: \"array\",\n      trackErrors: true,\n      code: code_1.validateUnion,\n      error: { message: \"must match a schema in anyOf\" }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js\nvar require_oneOf2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var error = {\n      message: \"must match exactly one schema in oneOf\",\n      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`\n    };\n    var def = {\n      keyword: \"oneOf\",\n      schemaType: \"array\",\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        if (!Array.isArray(schema))\n          throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n          return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n          schArr.forEach((sch, i) => {\n            let schCxt;\n            if ((0, util_1.alwaysValidSchema)(it, sch)) {\n              gen.var(schValid, true);\n            } else {\n              schCxt = cxt.subschema({\n                keyword: \"oneOf\",\n                schemaProp: i,\n                compositeRule: true\n              }, schValid);\n            }\n            if (i > 0) {\n              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();\n            }\n            gen.if(schValid, () => {\n              gen.assign(valid, true);\n              gen.assign(passing, i);\n              if (schCxt)\n                cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            });\n          });\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js\nvar require_allOf2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require_util3();\n    var def = {\n      keyword: \"allOf\",\n      schemaType: \"array\",\n      code(cxt) {\n        const { gen, schema, it } = cxt;\n        if (!Array.isArray(schema))\n          throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n          if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n          const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n          cxt.ok(valid);\n          cxt.mergeEvaluated(schCxt);\n        });\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js\nvar require_if2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var util_1 = require_util3();\n    var error = {\n      message: ({ params }) => (0, codegen_1.str)`must match \"${params.ifClause}\" schema`,\n      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`\n    };\n    var def = {\n      keyword: \"if\",\n      schemaType: [\"object\", \"boolean\"],\n      trackErrors: true,\n      error,\n      code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === void 0 && parentSchema.else === void 0) {\n          (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n          return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n          const ifClause = gen.let(\"ifClause\");\n          cxt.setParams({ ifClause });\n          gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        } else if (hasThen) {\n          gen.if(schValid, validateClause(\"then\"));\n        } else {\n          gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n          const schCxt = cxt.subschema({\n            keyword: \"if\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false\n          }, schValid);\n          cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n          return () => {\n            const schCxt = cxt.subschema({ keyword }, schValid);\n            gen.assign(valid, schValid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n            if (ifClause)\n              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);\n            else\n              cxt.setParams({ ifClause: keyword });\n          };\n        }\n      }\n    };\n    function hasSchema(it, keyword) {\n      const schema = it.schema[keyword];\n      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);\n    }\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js\nvar require_thenElse2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require_util3();\n    var def = {\n      keyword: [\"then\", \"else\"],\n      schemaType: [\"object\", \"boolean\"],\n      code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === void 0)\n          (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js\nvar require_applicator2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var additionalItems_1 = require_additionalItems2();\n    var prefixItems_1 = require_prefixItems2();\n    var items_1 = require_items2();\n    var items2020_1 = require_items20202();\n    var contains_1 = require_contains2();\n    var dependencies_1 = require_dependencies2();\n    var propertyNames_1 = require_propertyNames2();\n    var additionalProperties_1 = require_additionalProperties2();\n    var properties_1 = require_properties2();\n    var patternProperties_1 = require_patternProperties2();\n    var not_1 = require_not2();\n    var anyOf_1 = require_anyOf2();\n    var oneOf_1 = require_oneOf2();\n    var allOf_1 = require_allOf2();\n    var if_1 = require_if2();\n    var thenElse_1 = require_thenElse2();\n    function getApplicator(draft2020 = false) {\n      const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default\n      ];\n      if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n      else\n        applicator.push(additionalItems_1.default, items_1.default);\n      applicator.push(contains_1.default);\n      return applicator;\n    }\n    exports2.default = getApplicator;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js\nvar require_format4 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var error = {\n      message: ({ schemaCode }) => (0, codegen_1.str)`must match format \"${schemaCode}\"`,\n      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`\n    };\n    var def = {\n      keyword: \"format\",\n      type: [\"number\", \"string\"],\n      schemaType: \"string\",\n      $data: true,\n      error,\n      code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;\n        if (!opts.validateFormats)\n          return;\n        if ($data)\n          validate$DataFormat();\n        else\n          validateFormat();\n        function validate$DataFormat() {\n          const fmts = gen.scopeValue(\"formats\", {\n            ref: self2.formats,\n            code: opts.code.formats\n          });\n          const fDef = gen.const(\"fDef\", (0, codegen_1._)`${fmts}[${schemaCode}]`);\n          const fType = gen.let(\"fType\");\n          const format = gen.let(\"format\");\n          gen.if((0, codegen_1._)`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || \"string\"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`\"string\"`).assign(format, fDef));\n          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n          function unknownFmt() {\n            if (opts.strictSchema === false)\n              return codegen_1.nil;\n            return (0, codegen_1._)`${schemaCode} && !${format}`;\n          }\n          function invalidFmt() {\n            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;\n            const validData = (0, codegen_1._)`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n          }\n        }\n        function validateFormat() {\n          const formatDef = self2.formats[schema];\n          if (!formatDef) {\n            unknownFormat();\n            return;\n          }\n          if (formatDef === true)\n            return;\n          const [fmtType, format, fmtRef] = getFormat(formatDef);\n          if (fmtType === ruleType)\n            cxt.pass(validCondition());\n          function unknownFormat() {\n            if (opts.strictSchema === false) {\n              self2.logger.warn(unknownMsg());\n              return;\n            }\n            throw new Error(unknownMsg());\n            function unknownMsg() {\n              return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n            }\n          }\n          function getFormat(fmtDef) {\n            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;\n            const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n            if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n              return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];\n            }\n            return [\"string\", fmtDef, fmt];\n          }\n          function validCondition() {\n            if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n              if (!schemaEnv.$async)\n                throw new Error(\"async format in sync schema\");\n              return (0, codegen_1._)`await ${fmtRef}(${data})`;\n            }\n            return typeof format == \"function\" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;\n          }\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js\nvar require_format5 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var format_1 = require_format4();\n    var format = [format_1.default];\n    exports2.default = format;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js\nvar require_metadata2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;\n    exports2.metadataVocabulary = [\n      \"title\",\n      \"description\",\n      \"default\",\n      \"deprecated\",\n      \"readOnly\",\n      \"writeOnly\",\n      \"examples\"\n    ];\n    exports2.contentVocabulary = [\n      \"contentMediaType\",\n      \"contentEncoding\",\n      \"contentSchema\"\n    ];\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js\nvar require_draft72 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var core_1 = require_core5();\n    var validation_1 = require_validation2();\n    var applicator_1 = require_applicator2();\n    var format_1 = require_format5();\n    var metadata_1 = require_metadata2();\n    var draft7Vocabularies = [\n      core_1.default,\n      validation_1.default,\n      (0, applicator_1.default)(),\n      format_1.default,\n      metadata_1.metadataVocabulary,\n      metadata_1.contentVocabulary\n    ];\n    exports2.default = draft7Vocabularies;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js\nvar require_types3 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.DiscrError = void 0;\n    var DiscrError;\n    (function(DiscrError2) {\n      DiscrError2[\"Tag\"] = \"tag\";\n      DiscrError2[\"Mapping\"] = \"mapping\";\n    })(DiscrError || (exports2.DiscrError = DiscrError = {}));\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js\nvar require_discriminator2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var codegen_1 = require_codegen2();\n    var types_1 = require_types3();\n    var compile_1 = require_compile2();\n    var ref_error_1 = require_ref_error2();\n    var util_1 = require_util3();\n    var error = {\n      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`,\n      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`\n    };\n    var def = {\n      keyword: \"discriminator\",\n      type: \"object\",\n      schemaType: \"object\",\n      error,\n      code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n          throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n          throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n          throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n          throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._)`typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n          const mapping = getMapping();\n          gen.if(false);\n          for (const tagValue in mapping) {\n            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n            gen.assign(valid, applyTagSchema(mapping[tagValue]));\n          }\n          gen.else();\n          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n          gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n          const _valid = gen.name(\"valid\");\n          const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n          cxt.mergeEvaluated(schCxt, codegen_1.Name);\n          return _valid;\n        }\n        function getMapping() {\n          var _a;\n          const oneOfMapping = {};\n          const topRequired = hasRequired(parentSchema);\n          let tagRequired = true;\n          for (let i = 0; i < oneOf.length; i++) {\n            let sch = oneOf[i];\n            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n              const ref = sch.$ref;\n              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n              if (sch instanceof compile_1.SchemaEnv)\n                sch = sch.schema;\n              if (sch === void 0)\n                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n            }\n            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n            if (typeof propSch != \"object\") {\n              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n            }\n            tagRequired = tagRequired && (topRequired || hasRequired(sch));\n            addMappings(propSch, i);\n          }\n          if (!tagRequired)\n            throw new Error(`discriminator: \"${tagName}\" must be required`);\n          return oneOfMapping;\n          function hasRequired({ required }) {\n            return Array.isArray(required) && required.includes(tagName);\n          }\n          function addMappings(sch, i) {\n            if (sch.const) {\n              addMapping(sch.const, i);\n            } else if (sch.enum) {\n              for (const tagValue of sch.enum) {\n                addMapping(tagValue, i);\n              }\n            } else {\n              throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n            }\n          }\n          function addMapping(tagValue, i) {\n            if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n              throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n            }\n            oneOfMapping[tagValue] = i;\n          }\n        }\n      }\n    };\n    exports2.default = def;\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json\nvar require_json_schema_draft_072 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json\"(exports2, module2) {\n    module2.exports = {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      $id: \"http://json-schema.org/draft-07/schema#\",\n      title: \"Core schema meta-schema\",\n      definitions: {\n        schemaArray: {\n          type: \"array\",\n          minItems: 1,\n          items: { $ref: \"#\" }\n        },\n        nonNegativeInteger: {\n          type: \"integer\",\n          minimum: 0\n        },\n        nonNegativeIntegerDefault0: {\n          allOf: [{ $ref: \"#/definitions/nonNegativeInteger\" }, { default: 0 }]\n        },\n        simpleTypes: {\n          enum: [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n        },\n        stringArray: {\n          type: \"array\",\n          items: { type: \"string\" },\n          uniqueItems: true,\n          default: []\n        }\n      },\n      type: [\"object\", \"boolean\"],\n      properties: {\n        $id: {\n          type: \"string\",\n          format: \"uri-reference\"\n        },\n        $schema: {\n          type: \"string\",\n          format: \"uri\"\n        },\n        $ref: {\n          type: \"string\",\n          format: \"uri-reference\"\n        },\n        $comment: {\n          type: \"string\"\n        },\n        title: {\n          type: \"string\"\n        },\n        description: {\n          type: \"string\"\n        },\n        default: true,\n        readOnly: {\n          type: \"boolean\",\n          default: false\n        },\n        examples: {\n          type: \"array\",\n          items: true\n        },\n        multipleOf: {\n          type: \"number\",\n          exclusiveMinimum: 0\n        },\n        maximum: {\n          type: \"number\"\n        },\n        exclusiveMaximum: {\n          type: \"number\"\n        },\n        minimum: {\n          type: \"number\"\n        },\n        exclusiveMinimum: {\n          type: \"number\"\n        },\n        maxLength: { $ref: \"#/definitions/nonNegativeInteger\" },\n        minLength: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n        pattern: {\n          type: \"string\",\n          format: \"regex\"\n        },\n        additionalItems: { $ref: \"#\" },\n        items: {\n          anyOf: [{ $ref: \"#\" }, { $ref: \"#/definitions/schemaArray\" }],\n          default: true\n        },\n        maxItems: { $ref: \"#/definitions/nonNegativeInteger\" },\n        minItems: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n        uniqueItems: {\n          type: \"boolean\",\n          default: false\n        },\n        contains: { $ref: \"#\" },\n        maxProperties: { $ref: \"#/definitions/nonNegativeInteger\" },\n        minProperties: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n        required: { $ref: \"#/definitions/stringArray\" },\n        additionalProperties: { $ref: \"#\" },\n        definitions: {\n          type: \"object\",\n          additionalProperties: { $ref: \"#\" },\n          default: {}\n        },\n        properties: {\n          type: \"object\",\n          additionalProperties: { $ref: \"#\" },\n          default: {}\n        },\n        patternProperties: {\n          type: \"object\",\n          additionalProperties: { $ref: \"#\" },\n          propertyNames: { format: \"regex\" },\n          default: {}\n        },\n        dependencies: {\n          type: \"object\",\n          additionalProperties: {\n            anyOf: [{ $ref: \"#\" }, { $ref: \"#/definitions/stringArray\" }]\n          }\n        },\n        propertyNames: { $ref: \"#\" },\n        const: true,\n        enum: {\n          type: \"array\",\n          items: true,\n          minItems: 1,\n          uniqueItems: true\n        },\n        type: {\n          anyOf: [\n            { $ref: \"#/definitions/simpleTypes\" },\n            {\n              type: \"array\",\n              items: { $ref: \"#/definitions/simpleTypes\" },\n              minItems: 1,\n              uniqueItems: true\n            }\n          ]\n        },\n        format: { type: \"string\" },\n        contentMediaType: { type: \"string\" },\n        contentEncoding: { type: \"string\" },\n        if: { $ref: \"#\" },\n        then: { $ref: \"#\" },\n        else: { $ref: \"#\" },\n        allOf: { $ref: \"#/definitions/schemaArray\" },\n        anyOf: { $ref: \"#/definitions/schemaArray\" },\n        oneOf: { $ref: \"#/definitions/schemaArray\" },\n        not: { $ref: \"#\" }\n      },\n      default: true\n    };\n  }\n});\n\n// node_modules/ajv-formats/node_modules/ajv/dist/ajv.js\nvar require_ajv2 = __commonJS({\n  \"node_modules/ajv-formats/node_modules/ajv/dist/ajv.js\"(exports2, module2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;\n    var core_1 = require_core4();\n    var draft7_1 = require_draft72();\n    var discriminator_1 = require_discriminator2();\n    var draft7MetaSchema = require_json_schema_draft_072();\n    var META_SUPPORT_DATA = [\"/properties\"];\n    var META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\n    var Ajv = class extends core_1.default {\n      _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n          this.addKeyword(discriminator_1.default);\n      }\n      _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n          return;\n        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n      }\n      defaultMeta() {\n        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);\n      }\n    };\n    exports2.Ajv = Ajv;\n    module2.exports = exports2 = Ajv;\n    module2.exports.Ajv = Ajv;\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.default = Ajv;\n    var validate_1 = require_validate2();\n    Object.defineProperty(exports2, \"KeywordCxt\", { enumerable: true, get: function() {\n      return validate_1.KeywordCxt;\n    } });\n    var codegen_1 = require_codegen2();\n    Object.defineProperty(exports2, \"_\", { enumerable: true, get: function() {\n      return codegen_1._;\n    } });\n    Object.defineProperty(exports2, \"str\", { enumerable: true, get: function() {\n      return codegen_1.str;\n    } });\n    Object.defineProperty(exports2, \"stringify\", { enumerable: true, get: function() {\n      return codegen_1.stringify;\n    } });\n    Object.defineProperty(exports2, \"nil\", { enumerable: true, get: function() {\n      return codegen_1.nil;\n    } });\n    Object.defineProperty(exports2, \"Name\", { enumerable: true, get: function() {\n      return codegen_1.Name;\n    } });\n    Object.defineProperty(exports2, \"CodeGen\", { enumerable: true, get: function() {\n      return codegen_1.CodeGen;\n    } });\n    var validation_error_1 = require_validation_error2();\n    Object.defineProperty(exports2, \"ValidationError\", { enumerable: true, get: function() {\n      return validation_error_1.default;\n    } });\n    var ref_error_1 = require_ref_error2();\n    Object.defineProperty(exports2, \"MissingRefError\", { enumerable: true, get: function() {\n      return ref_error_1.default;\n    } });\n  }\n});\n\n// node_modules/ajv-formats/dist/limit.js\nvar require_limit = __commonJS({\n  \"node_modules/ajv-formats/dist/limit.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.formatLimitDefinition = void 0;\n    var ajv_1 = require_ajv2();\n    var codegen_1 = require_codegen2();\n    var ops = codegen_1.operators;\n    var KWDs = {\n      formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n      formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n      formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n      formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE }\n    };\n    var error = {\n      message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,\n      params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`\n    };\n    exports2.formatLimitDefinition = {\n      keyword: Object.keys(KWDs),\n      type: \"string\",\n      schemaType: \"string\",\n      $data: true,\n      error,\n      code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self: self2 } = it;\n        if (!opts.validateFormats)\n          return;\n        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n          validate$DataFormat();\n        else\n          validateFormat();\n        function validate$DataFormat() {\n          const fmts = gen.scopeValue(\"formats\", {\n            ref: self2.formats,\n            code: opts.code.formats\n          });\n          const fmt = gen.const(\"fmt\", codegen_1._`${fmts}[${fCxt.schemaCode}]`);\n          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != \"object\"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n          const format = fCxt.schema;\n          const fmtDef = self2.formats[format];\n          if (!fmtDef || fmtDef === true)\n            return;\n          if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n            throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n          }\n          const fmt = gen.scopeValue(\"formats\", {\n            key: format,\n            ref: fmtDef,\n            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : void 0\n          });\n          cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n      },\n      dependencies: [\"format\"]\n    };\n    var formatLimitPlugin = (ajv) => {\n      ajv.addKeyword(exports2.formatLimitDefinition);\n      return ajv;\n    };\n    exports2.default = formatLimitPlugin;\n  }\n});\n\n// node_modules/ajv-formats/dist/index.js\nvar require_dist2 = __commonJS({\n  \"node_modules/ajv-formats/dist/index.js\"(exports2, module2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var formats_1 = require_formats();\n    var limit_1 = require_limit();\n    var codegen_1 = require_codegen2();\n    var fullName = new codegen_1.Name(\"fullFormats\");\n    var fastName = new codegen_1.Name(\"fastFormats\");\n    var formatsPlugin = (ajv, opts = { keywords: true }) => {\n      if (Array.isArray(opts)) {\n        addFormats(ajv, opts, formats_1.fullFormats, fullName);\n        return ajv;\n      }\n      const [formats, exportName] = opts.mode === \"fast\" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];\n      const list = opts.formats || formats_1.formatNames;\n      addFormats(ajv, list, formats, exportName);\n      if (opts.keywords)\n        limit_1.default(ajv);\n      return ajv;\n    };\n    formatsPlugin.get = (name, mode = \"full\") => {\n      const formats = mode === \"fast\" ? formats_1.fastFormats : formats_1.fullFormats;\n      const f = formats[name];\n      if (!f)\n        throw new Error(`Unknown format \"${name}\"`);\n      return f;\n    };\n    function addFormats(ajv, list, fs4, exportName) {\n      var _a;\n      var _b;\n      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require(\"ajv-formats/dist/formats\").${exportName}`;\n      for (const f of list)\n        ajv.addFormat(f, fs4[f]);\n    }\n    module2.exports = exports2 = formatsPlugin;\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.default = formatsPlugin;\n  }\n});\n\n// node_modules/debounce-fn/node_modules/mimic-fn/index.js\nvar require_mimic_fn = __commonJS({\n  \"node_modules/debounce-fn/node_modules/mimic-fn/index.js\"(exports2, module2) {\n    \"use strict\";\n    var copyProperty = (to, from, property, ignoreNonConfigurable) => {\n      if (property === \"length\" || property === \"prototype\") {\n        return;\n      }\n      if (property === \"arguments\" || property === \"caller\") {\n        return;\n      }\n      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n        return;\n      }\n      Object.defineProperty(to, property, fromDescriptor);\n    };\n    var canCopyProperty = function(toDescriptor, fromDescriptor) {\n      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n    };\n    var changePrototype = (to, from) => {\n      const fromPrototype = Object.getPrototypeOf(from);\n      if (fromPrototype === Object.getPrototypeOf(to)) {\n        return;\n      }\n      Object.setPrototypeOf(to, fromPrototype);\n    };\n    var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\n${fromBody}`;\n    var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, \"toString\");\n    var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, \"name\");\n    var changeToString = (to, from, name) => {\n      const withName = name === \"\" ? \"\" : `with ${name.trim()}() `;\n      const newToString = wrappedToString.bind(null, withName, from.toString());\n      Object.defineProperty(newToString, \"name\", toStringName);\n      Object.defineProperty(to, \"toString\", { ...toStringDescriptor, value: newToString });\n    };\n    var mimicFn = (to, from, { ignoreNonConfigurable = false } = {}) => {\n      const { name } = to;\n      for (const property of Reflect.ownKeys(from)) {\n        copyProperty(to, from, property, ignoreNonConfigurable);\n      }\n      changePrototype(to, from);\n      changeToString(to, from, name);\n      return to;\n    };\n    module2.exports = mimicFn;\n  }\n});\n\n// node_modules/debounce-fn/index.js\nvar require_debounce_fn = __commonJS({\n  \"node_modules/debounce-fn/index.js\"(exports2, module2) {\n    \"use strict\";\n    var mimicFn = require_mimic_fn();\n    module2.exports = (inputFunction, options = {}) => {\n      if (typeof inputFunction !== \"function\") {\n        throw new TypeError(`Expected the first argument to be a function, got \\`${typeof inputFunction}\\``);\n      }\n      const {\n        wait = 0,\n        before = false,\n        after = true\n      } = options;\n      if (!before && !after) {\n        throw new Error(\"Both `before` and `after` are false, function wouldn't be called.\");\n      }\n      let timeout;\n      let result;\n      const debouncedFunction = function(...arguments_) {\n        const context = this;\n        const later = () => {\n          timeout = void 0;\n          if (after) {\n            result = inputFunction.apply(context, arguments_);\n          }\n        };\n        const shouldCallNow = before && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (shouldCallNow) {\n          result = inputFunction.apply(context, arguments_);\n        }\n        return result;\n      };\n      mimicFn(debouncedFunction, inputFunction);\n      debouncedFunction.cancel = () => {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = void 0;\n        }\n      };\n      return debouncedFunction;\n    };\n  }\n});\n\n// node_modules/conf/node_modules/semver/internal/constants.js\nvar require_constants2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/internal/constants.js\"(exports2, module2) {\n    \"use strict\";\n    var SEMVER_SPEC_VERSION = \"2.0.0\";\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */\n    9007199254740991;\n    var MAX_SAFE_COMPONENT_LENGTH = 16;\n    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;\n    var RELEASE_TYPES = [\n      \"major\",\n      \"premajor\",\n      \"minor\",\n      \"preminor\",\n      \"patch\",\n      \"prepatch\",\n      \"prerelease\"\n    ];\n    module2.exports = {\n      MAX_LENGTH,\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_SAFE_INTEGER,\n      RELEASE_TYPES,\n      SEMVER_SPEC_VERSION,\n      FLAG_INCLUDE_PRERELEASE: 1,\n      FLAG_LOOSE: 2\n    };\n  }\n});\n\n// node_modules/conf/node_modules/semver/internal/debug.js\nvar require_debug2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/internal/debug.js\"(exports2, module2) {\n    \"use strict\";\n    var debug = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error(\"SEMVER\", ...args) : () => {\n    };\n    module2.exports = debug;\n  }\n});\n\n// node_modules/conf/node_modules/semver/internal/re.js\nvar require_re2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/internal/re.js\"(exports2, module2) {\n    \"use strict\";\n    var {\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_LENGTH\n    } = require_constants2();\n    var debug = require_debug2();\n    exports2 = module2.exports = {};\n    var re = exports2.re = [];\n    var safeRe = exports2.safeRe = [];\n    var src = exports2.src = [];\n    var safeSrc = exports2.safeSrc = [];\n    var t = exports2.t = {};\n    var R = 0;\n    var LETTERDASHNUMBER = \"[a-zA-Z0-9-]\";\n    var safeRegexReplacements = [\n      [\"\\\\s\", 1],\n      [\"\\\\d\", MAX_LENGTH],\n      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]\n    ];\n    var makeSafeRegex = (value) => {\n      for (const [token, max] of safeRegexReplacements) {\n        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);\n      }\n      return value;\n    };\n    var createToken = (name, value, isGlobal) => {\n      const safe = makeSafeRegex(value);\n      const index = R++;\n      debug(name, index, value);\n      t[name] = index;\n      src[index] = value;\n      safeSrc[index] = safe;\n      re[index] = new RegExp(value, isGlobal ? \"g\" : void 0);\n      safeRe[index] = new RegExp(safe, isGlobal ? \"g\" : void 0);\n    };\n    createToken(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n    createToken(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n    createToken(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n    createToken(\"MAINVERSION\", `(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"MAINVERSIONLOOSE\", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASEIDENTIFIER\", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASE\", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n    createToken(\"PRERELEASELOOSE\", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n    createToken(\"BUILDIDENTIFIER\", `${LETTERDASHNUMBER}+`);\n    createToken(\"BUILD\", `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n    createToken(\"FULLPLAIN\", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n    createToken(\"FULL\", `^${src[t.FULLPLAIN]}$`);\n    createToken(\"LOOSEPLAIN\", `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n    createToken(\"LOOSE\", `^${src[t.LOOSEPLAIN]}$`);\n    createToken(\"GTLT\", \"((?:<|>)?=?)\");\n    createToken(\"XRANGEIDENTIFIERLOOSE\", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n    createToken(\"XRANGEIDENTIFIER\", `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n    createToken(\"XRANGEPLAIN\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n    createToken(\"XRANGELOOSE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COERCEPLAIN\", `${\"(^|[^\\\\d])(\\\\d{1,\"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);\n    createToken(\"COERCE\", `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`);\n    createToken(\"COERCEFULL\", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\\\d])`);\n    createToken(\"COERCERTL\", src[t.COERCE], true);\n    createToken(\"COERCERTLFULL\", src[t.COERCEFULL], true);\n    createToken(\"LONETILDE\", \"(?:~>?)\");\n    createToken(\"TILDETRIM\", `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n    exports2.tildeTrimReplace = \"$1~\";\n    createToken(\"TILDE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"TILDELOOSE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"LONECARET\", \"(?:\\\\^)\");\n    createToken(\"CARETTRIM\", `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n    exports2.caretTrimReplace = \"$1^\";\n    createToken(\"CARET\", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"CARETLOOSE\", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COMPARATORLOOSE\", `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n    createToken(\"COMPARATOR\", `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n    createToken(\"COMPARATORTRIM\", `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n    exports2.comparatorTrimReplace = \"$1$2$3\";\n    createToken(\"HYPHENRANGE\", `^\\\\s*(${src[t.XRANGEPLAIN]})\\\\s+-\\\\s+(${src[t.XRANGEPLAIN]})\\\\s*$`);\n    createToken(\"HYPHENRANGELOOSE\", `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${src[t.XRANGEPLAINLOOSE]})\\\\s*$`);\n    createToken(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n    createToken(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n    createToken(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n  }\n});\n\n// node_modules/conf/node_modules/semver/internal/parse-options.js\nvar require_parse_options2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/internal/parse-options.js\"(exports2, module2) {\n    \"use strict\";\n    var looseOption = Object.freeze({ loose: true });\n    var emptyOpts = Object.freeze({});\n    var parseOptions = (options) => {\n      if (!options) {\n        return emptyOpts;\n      }\n      if (typeof options !== \"object\") {\n        return looseOption;\n      }\n      return options;\n    };\n    module2.exports = parseOptions;\n  }\n});\n\n// node_modules/conf/node_modules/semver/internal/identifiers.js\nvar require_identifiers2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/internal/identifiers.js\"(exports2, module2) {\n    \"use strict\";\n    var numeric = /^[0-9]+$/;\n    var compareIdentifiers = (a, b) => {\n      if (typeof a === \"number\" && typeof b === \"number\") {\n        return a === b ? 0 : a < b ? -1 : 1;\n      }\n      const anum = numeric.test(a);\n      const bnum = numeric.test(b);\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    };\n    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n    module2.exports = {\n      compareIdentifiers,\n      rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/conf/node_modules/semver/classes/semver.js\nvar require_semver3 = __commonJS({\n  \"node_modules/conf/node_modules/semver/classes/semver.js\"(exports2, module2) {\n    \"use strict\";\n    var debug = require_debug2();\n    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();\n    var { safeRe: re, t } = require_re2();\n    var parseOptions = require_parse_options2();\n    var { compareIdentifiers } = require_identifiers2();\n    var SemVer = class _SemVer {\n      constructor(version, options) {\n        options = parseOptions(options);\n        if (version instanceof _SemVer) {\n          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {\n            return version;\n          } else {\n            version = version.version;\n          }\n        } else if (typeof version !== \"string\") {\n          throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`);\n        }\n        if (version.length > MAX_LENGTH) {\n          throw new TypeError(\n            `version is longer than ${MAX_LENGTH} characters`\n          );\n        }\n        debug(\"SemVer\", version, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n        if (!m) {\n          throw new TypeError(`Invalid Version: ${version}`);\n        }\n        this.raw = version;\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError(\"Invalid major version\");\n        }\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError(\"Invalid minor version\");\n        }\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError(\"Invalid patch version\");\n        }\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split(\".\").map((id) => {\n            if (/^[0-9]+$/.test(id)) {\n              const num = +id;\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n            return id;\n          });\n        }\n        this.build = m[5] ? m[5].split(\".\") : [];\n        this.format();\n      }\n      format() {\n        this.version = `${this.major}.${this.minor}.${this.patch}`;\n        if (this.prerelease.length) {\n          this.version += `-${this.prerelease.join(\".\")}`;\n        }\n        return this.version;\n      }\n      toString() {\n        return this.version;\n      }\n      compare(other) {\n        debug(\"SemVer.compare\", this.version, this.options, other);\n        if (!(other instanceof _SemVer)) {\n          if (typeof other === \"string\" && other === this.version) {\n            return 0;\n          }\n          other = new _SemVer(other, this.options);\n        }\n        if (other.version === this.version) {\n          return 0;\n        }\n        return this.compareMain(other) || this.comparePre(other);\n      }\n      compareMain(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.major < other.major) {\n          return -1;\n        }\n        if (this.major > other.major) {\n          return 1;\n        }\n        if (this.minor < other.minor) {\n          return -1;\n        }\n        if (this.minor > other.minor) {\n          return 1;\n        }\n        if (this.patch < other.patch) {\n          return -1;\n        }\n        if (this.patch > other.patch) {\n          return 1;\n        }\n        return 0;\n      }\n      comparePre(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n        let i = 0;\n        do {\n          const a = this.prerelease[i];\n          const b = other.prerelease[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      compareBuild(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        let i = 0;\n        do {\n          const a = this.build[i];\n          const b = other.build[i];\n          debug(\"build compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      // preminor will bump the version up to the next minor release, and immediately\n      // down to pre-release. premajor and prepatch work the same way.\n      inc(release, identifier, identifierBase) {\n        if (release.startsWith(\"pre\")) {\n          if (!identifier && identifierBase === false) {\n            throw new Error(\"invalid increment argument: identifier is empty\");\n          }\n          if (identifier) {\n            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);\n            if (!match || match[1] !== identifier) {\n              throw new Error(`invalid identifier: ${identifier}`);\n            }\n          }\n        }\n        switch (release) {\n          case \"premajor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"preminor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prepatch\":\n            this.prerelease.length = 0;\n            this.inc(\"patch\", identifier, identifierBase);\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          // If the input is a non-prerelease version, this acts the same as\n          // prepatch.\n          case \"prerelease\":\n            if (this.prerelease.length === 0) {\n              this.inc(\"patch\", identifier, identifierBase);\n            }\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"release\":\n            if (this.prerelease.length === 0) {\n              throw new Error(`version ${this.raw} is not a prerelease`);\n            }\n            this.prerelease.length = 0;\n            break;\n          case \"major\":\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"minor\":\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"patch\":\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n            this.prerelease = [];\n            break;\n          // This probably shouldn't be used publicly.\n          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n          case \"pre\": {\n            const base = Number(identifierBase) ? 1 : 0;\n            if (this.prerelease.length === 0) {\n              this.prerelease = [base];\n            } else {\n              let i = this.prerelease.length;\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === \"number\") {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n              if (i === -1) {\n                if (identifier === this.prerelease.join(\".\") && identifierBase === false) {\n                  throw new Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(base);\n              }\n            }\n            if (identifier) {\n              let prerelease = [identifier, base];\n              if (identifierBase === false) {\n                prerelease = [identifier];\n              }\n              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = prerelease;\n                }\n              } else {\n                this.prerelease = prerelease;\n              }\n            }\n            break;\n          }\n          default:\n            throw new Error(`invalid increment argument: ${release}`);\n        }\n        this.raw = this.format();\n        if (this.build.length) {\n          this.raw += `+${this.build.join(\".\")}`;\n        }\n        return this;\n      }\n    };\n    module2.exports = SemVer;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/parse.js\nvar require_parse2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/parse.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var parse = (version, options, throwErrors = false) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      try {\n        return new SemVer(version, options);\n      } catch (er) {\n        if (!throwErrors) {\n          return null;\n        }\n        throw er;\n      }\n    };\n    module2.exports = parse;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/valid.js\nvar require_valid3 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/valid.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse2();\n    var valid = (version, options) => {\n      const v = parse(version, options);\n      return v ? v.version : null;\n    };\n    module2.exports = valid;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/clean.js\nvar require_clean2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/clean.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse2();\n    var clean = (version, options) => {\n      const s = parse(version.trim().replace(/^[=v]+/, \"\"), options);\n      return s ? s.version : null;\n    };\n    module2.exports = clean;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/inc.js\nvar require_inc2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/inc.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var inc = (version, release, options, identifier, identifierBase) => {\n      if (typeof options === \"string\") {\n        identifierBase = identifier;\n        identifier = options;\n        options = void 0;\n      }\n      try {\n        return new SemVer(\n          version instanceof SemVer ? version.version : version,\n          options\n        ).inc(release, identifier, identifierBase).version;\n      } catch (er) {\n        return null;\n      }\n    };\n    module2.exports = inc;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/diff.js\nvar require_diff2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/diff.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse2();\n    var diff = (version1, version2) => {\n      const v1 = parse(version1, null, true);\n      const v2 = parse(version2, null, true);\n      const comparison = v1.compare(v2);\n      if (comparison === 0) {\n        return null;\n      }\n      const v1Higher = comparison > 0;\n      const highVersion = v1Higher ? v1 : v2;\n      const lowVersion = v1Higher ? v2 : v1;\n      const highHasPre = !!highVersion.prerelease.length;\n      const lowHasPre = !!lowVersion.prerelease.length;\n      if (lowHasPre && !highHasPre) {\n        if (!lowVersion.patch && !lowVersion.minor) {\n          return \"major\";\n        }\n        if (lowVersion.compareMain(highVersion) === 0) {\n          if (lowVersion.minor && !lowVersion.patch) {\n            return \"minor\";\n          }\n          return \"patch\";\n        }\n      }\n      const prefix = highHasPre ? \"pre\" : \"\";\n      if (v1.major !== v2.major) {\n        return prefix + \"major\";\n      }\n      if (v1.minor !== v2.minor) {\n        return prefix + \"minor\";\n      }\n      if (v1.patch !== v2.patch) {\n        return prefix + \"patch\";\n      }\n      return \"prerelease\";\n    };\n    module2.exports = diff;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/major.js\nvar require_major2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/major.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var major = (a, loose) => new SemVer(a, loose).major;\n    module2.exports = major;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/minor.js\nvar require_minor2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/minor.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var minor = (a, loose) => new SemVer(a, loose).minor;\n    module2.exports = minor;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/patch.js\nvar require_patch2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/patch.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var patch = (a, loose) => new SemVer(a, loose).patch;\n    module2.exports = patch;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/prerelease.js\nvar require_prerelease2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/prerelease.js\"(exports2, module2) {\n    \"use strict\";\n    var parse = require_parse2();\n    var prerelease = (version, options) => {\n      const parsed = parse(version, options);\n      return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n    };\n    module2.exports = prerelease;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/compare.js\nvar require_compare2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/compare.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));\n    module2.exports = compare;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/rcompare.js\nvar require_rcompare2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/rcompare.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var rcompare = (a, b, loose) => compare(b, a, loose);\n    module2.exports = rcompare;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/compare-loose.js\nvar require_compare_loose2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/compare-loose.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var compareLoose = (a, b) => compare(a, b, true);\n    module2.exports = compareLoose;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/compare-build.js\nvar require_compare_build2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/compare-build.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var compareBuild = (a, b, loose) => {\n      const versionA = new SemVer(a, loose);\n      const versionB = new SemVer(b, loose);\n      return versionA.compare(versionB) || versionA.compareBuild(versionB);\n    };\n    module2.exports = compareBuild;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/sort.js\nvar require_sort2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/sort.js\"(exports2, module2) {\n    \"use strict\";\n    var compareBuild = require_compare_build2();\n    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));\n    module2.exports = sort;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/rsort.js\nvar require_rsort2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/rsort.js\"(exports2, module2) {\n    \"use strict\";\n    var compareBuild = require_compare_build2();\n    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));\n    module2.exports = rsort;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/gt.js\nvar require_gt2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/gt.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var gt = (a, b, loose) => compare(a, b, loose) > 0;\n    module2.exports = gt;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/lt.js\nvar require_lt2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/lt.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var lt = (a, b, loose) => compare(a, b, loose) < 0;\n    module2.exports = lt;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/eq.js\nvar require_eq2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/eq.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var eq = (a, b, loose) => compare(a, b, loose) === 0;\n    module2.exports = eq;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/neq.js\nvar require_neq2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/neq.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var neq = (a, b, loose) => compare(a, b, loose) !== 0;\n    module2.exports = neq;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/gte.js\nvar require_gte2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/gte.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var gte = (a, b, loose) => compare(a, b, loose) >= 0;\n    module2.exports = gte;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/lte.js\nvar require_lte2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/lte.js\"(exports2, module2) {\n    \"use strict\";\n    var compare = require_compare2();\n    var lte = (a, b, loose) => compare(a, b, loose) <= 0;\n    module2.exports = lte;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/cmp.js\nvar require_cmp2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/cmp.js\"(exports2, module2) {\n    \"use strict\";\n    var eq = require_eq2();\n    var neq = require_neq2();\n    var gt = require_gt2();\n    var gte = require_gte2();\n    var lt = require_lt2();\n    var lte = require_lte2();\n    var cmp = (a, op, b, loose) => {\n      switch (op) {\n        case \"===\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a === b;\n        case \"!==\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a !== b;\n        case \"\":\n        case \"=\":\n        case \"==\":\n          return eq(a, b, loose);\n        case \"!=\":\n          return neq(a, b, loose);\n        case \">\":\n          return gt(a, b, loose);\n        case \">=\":\n          return gte(a, b, loose);\n        case \"<\":\n          return lt(a, b, loose);\n        case \"<=\":\n          return lte(a, b, loose);\n        default:\n          throw new TypeError(`Invalid operator: ${op}`);\n      }\n    };\n    module2.exports = cmp;\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/coerce.js\nvar require_coerce2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/coerce.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var parse = require_parse2();\n    var { safeRe: re, t } = require_re2();\n    var coerce = (version, options) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      if (typeof version === \"number\") {\n        version = String(version);\n      }\n      if (typeof version !== \"string\") {\n        return null;\n      }\n      options = options || {};\n      let match = null;\n      if (!options.rtl) {\n        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);\n      } else {\n        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];\n        let next;\n        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n          if (!match || next.index + next[0].length !== match.index + match[0].length) {\n            match = next;\n          }\n          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;\n        }\n        coerceRtlRegex.lastIndex = -1;\n      }\n      if (match === null) {\n        return null;\n      }\n      const major = match[2];\n      const minor = match[3] || \"0\";\n      const patch = match[4] || \"0\";\n      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : \"\";\n      const build = options.includePrerelease && match[6] ? `+${match[6]}` : \"\";\n      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);\n    };\n    module2.exports = coerce;\n  }\n});\n\n// node_modules/conf/node_modules/semver/internal/lrucache.js\nvar require_lrucache2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/internal/lrucache.js\"(exports2, module2) {\n    \"use strict\";\n    var LRUCache = class {\n      constructor() {\n        this.max = 1e3;\n        this.map = /* @__PURE__ */ new Map();\n      }\n      get(key) {\n        const value = this.map.get(key);\n        if (value === void 0) {\n          return void 0;\n        } else {\n          this.map.delete(key);\n          this.map.set(key, value);\n          return value;\n        }\n      }\n      delete(key) {\n        return this.map.delete(key);\n      }\n      set(key, value) {\n        const deleted = this.delete(key);\n        if (!deleted && value !== void 0) {\n          if (this.map.size >= this.max) {\n            const firstKey = this.map.keys().next().value;\n            this.delete(firstKey);\n          }\n          this.map.set(key, value);\n        }\n        return this;\n      }\n    };\n    module2.exports = LRUCache;\n  }\n});\n\n// node_modules/conf/node_modules/semver/classes/range.js\nvar require_range2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/classes/range.js\"(exports2, module2) {\n    \"use strict\";\n    var SPACE_CHARACTERS = /\\s+/g;\n    var Range = class _Range {\n      constructor(range, options) {\n        options = parseOptions(options);\n        if (range instanceof _Range) {\n          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n            return range;\n          } else {\n            return new _Range(range.raw, options);\n          }\n        }\n        if (range instanceof Comparator) {\n          this.raw = range.value;\n          this.set = [[range]];\n          this.formatted = void 0;\n          return this;\n        }\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        this.raw = range.trim().replace(SPACE_CHARACTERS, \" \");\n        this.set = this.raw.split(\"||\").map((r) => this.parseRange(r.trim())).filter((c) => c.length);\n        if (!this.set.length) {\n          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);\n        }\n        if (this.set.length > 1) {\n          const first = this.set[0];\n          this.set = this.set.filter((c) => !isNullSet(c[0]));\n          if (this.set.length === 0) {\n            this.set = [first];\n          } else if (this.set.length > 1) {\n            for (const c of this.set) {\n              if (c.length === 1 && isAny(c[0])) {\n                this.set = [c];\n                break;\n              }\n            }\n          }\n        }\n        this.formatted = void 0;\n      }\n      get range() {\n        if (this.formatted === void 0) {\n          this.formatted = \"\";\n          for (let i = 0; i < this.set.length; i++) {\n            if (i > 0) {\n              this.formatted += \"||\";\n            }\n            const comps = this.set[i];\n            for (let k = 0; k < comps.length; k++) {\n              if (k > 0) {\n                this.formatted += \" \";\n              }\n              this.formatted += comps[k].toString().trim();\n            }\n          }\n        }\n        return this.formatted;\n      }\n      format() {\n        return this.range;\n      }\n      toString() {\n        return this.range;\n      }\n      parseRange(range) {\n        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);\n        const memoKey = memoOpts + \":\" + range;\n        const cached = cache.get(memoKey);\n        if (cached) {\n          return cached;\n        }\n        const loose = this.options.loose;\n        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n        debug(\"hyphen replace\", range);\n        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n        debug(\"comparator trim\", range);\n        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);\n        debug(\"tilde trim\", range);\n        range = range.replace(re[t.CARETTRIM], caretTrimReplace);\n        debug(\"caret trim\", range);\n        let rangeList = range.split(\" \").map((comp) => parseComparator(comp, this.options)).join(\" \").split(/\\s+/).map((comp) => replaceGTE0(comp, this.options));\n        if (loose) {\n          rangeList = rangeList.filter((comp) => {\n            debug(\"loose invalid filter\", comp, this.options);\n            return !!comp.match(re[t.COMPARATORLOOSE]);\n          });\n        }\n        debug(\"range list\", rangeList);\n        const rangeMap = /* @__PURE__ */ new Map();\n        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));\n        for (const comp of comparators) {\n          if (isNullSet(comp)) {\n            return [comp];\n          }\n          rangeMap.set(comp.value, comp);\n        }\n        if (rangeMap.size > 1 && rangeMap.has(\"\")) {\n          rangeMap.delete(\"\");\n        }\n        const result = [...rangeMap.values()];\n        cache.set(memoKey, result);\n        return result;\n      }\n      intersects(range, options) {\n        if (!(range instanceof _Range)) {\n          throw new TypeError(\"a Range is required\");\n        }\n        return this.set.some((thisComparators) => {\n          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {\n            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options);\n              });\n            });\n          });\n        });\n      }\n      // if ANY of the sets match ALL of its comparators, then pass\n      test(version) {\n        if (!version) {\n          return false;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        for (let i = 0; i < this.set.length; i++) {\n          if (testSet(this.set[i], version, this.options)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n    module2.exports = Range;\n    var LRU = require_lrucache2();\n    var cache = new LRU();\n    var parseOptions = require_parse_options2();\n    var Comparator = require_comparator2();\n    var debug = require_debug2();\n    var SemVer = require_semver3();\n    var {\n      safeRe: re,\n      t,\n      comparatorTrimReplace,\n      tildeTrimReplace,\n      caretTrimReplace\n    } = require_re2();\n    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();\n    var isNullSet = (c) => c.value === \"<0.0.0-0\";\n    var isAny = (c) => c.value === \"\";\n    var isSatisfiable = (comparators, options) => {\n      let result = true;\n      const remainingComparators = comparators.slice();\n      let testComparator = remainingComparators.pop();\n      while (result && remainingComparators.length) {\n        result = remainingComparators.every((otherComparator) => {\n          return testComparator.intersects(otherComparator, options);\n        });\n        testComparator = remainingComparators.pop();\n      }\n      return result;\n    };\n    var parseComparator = (comp, options) => {\n      comp = comp.replace(re[t.BUILD], \"\");\n      debug(\"comp\", comp, options);\n      comp = replaceCarets(comp, options);\n      debug(\"caret\", comp);\n      comp = replaceTildes(comp, options);\n      debug(\"tildes\", comp);\n      comp = replaceXRanges(comp, options);\n      debug(\"xrange\", comp);\n      comp = replaceStars(comp, options);\n      debug(\"stars\", comp);\n      return comp;\n    };\n    var isX = (id) => !id || id.toLowerCase() === \"x\" || id === \"*\";\n    var replaceTildes = (comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceTilde(c, options)).join(\" \");\n    };\n    var replaceTilde = (comp, options) => {\n      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"tilde\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n        } else if (pr) {\n          debug(\"replaceTilde pr\", pr);\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n        } else {\n          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"tilde return\", ret);\n        return ret;\n      });\n    };\n    var replaceCarets = (comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceCaret(c, options)).join(\" \");\n    };\n    var replaceCaret = (comp, options) => {\n      debug(\"caret\", comp, options);\n      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n      const z = options.includePrerelease ? \"-0\" : \"\";\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"caret\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          if (M === \"0\") {\n            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n          } else {\n            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n          }\n        } else if (pr) {\n          debug(\"replaceCaret pr\", pr);\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;\n          }\n        } else {\n          debug(\"no pr\");\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;\n          }\n        }\n        debug(\"caret return\", ret);\n        return ret;\n      });\n    };\n    var replaceXRanges = (comp, options) => {\n      debug(\"replaceXRanges\", comp, options);\n      return comp.split(/\\s+/).map((c) => replaceXRange(c, options)).join(\" \");\n    };\n    var replaceXRange = (comp, options) => {\n      comp = comp.trim();\n      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n        debug(\"xRange\", comp, ret, gtlt, M, m, p, pr);\n        const xM = isX(M);\n        const xm = xM || isX(m);\n        const xp = xm || isX(p);\n        const anyX = xp;\n        if (gtlt === \"=\" && anyX) {\n          gtlt = \"\";\n        }\n        pr = options.includePrerelease ? \"-0\" : \"\";\n        if (xM) {\n          if (gtlt === \">\" || gtlt === \"<\") {\n            ret = \"<0.0.0-0\";\n          } else {\n            ret = \"*\";\n          }\n        } else if (gtlt && anyX) {\n          if (xm) {\n            m = 0;\n          }\n          p = 0;\n          if (gtlt === \">\") {\n            gtlt = \">=\";\n            if (xm) {\n              M = +M + 1;\n              m = 0;\n              p = 0;\n            } else {\n              m = +m + 1;\n              p = 0;\n            }\n          } else if (gtlt === \"<=\") {\n            gtlt = \"<\";\n            if (xm) {\n              M = +M + 1;\n            } else {\n              m = +m + 1;\n            }\n          }\n          if (gtlt === \"<\") {\n            pr = \"-0\";\n          }\n          ret = `${gtlt + M}.${m}.${p}${pr}`;\n        } else if (xm) {\n          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n        } else if (xp) {\n          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"xRange return\", ret);\n        return ret;\n      });\n    };\n    var replaceStars = (comp, options) => {\n      debug(\"replaceStars\", comp, options);\n      return comp.trim().replace(re[t.STAR], \"\");\n    };\n    var replaceGTE0 = (comp, options) => {\n      debug(\"replaceGTE0\", comp, options);\n      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], \"\");\n    };\n    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {\n      if (isX(fM)) {\n        from = \"\";\n      } else if (isX(fm)) {\n        from = `>=${fM}.0.0${incPr ? \"-0\" : \"\"}`;\n      } else if (isX(fp)) {\n        from = `>=${fM}.${fm}.0${incPr ? \"-0\" : \"\"}`;\n      } else if (fpr) {\n        from = `>=${from}`;\n      } else {\n        from = `>=${from}${incPr ? \"-0\" : \"\"}`;\n      }\n      if (isX(tM)) {\n        to = \"\";\n      } else if (isX(tm)) {\n        to = `<${+tM + 1}.0.0-0`;\n      } else if (isX(tp)) {\n        to = `<${tM}.${+tm + 1}.0-0`;\n      } else if (tpr) {\n        to = `<=${tM}.${tm}.${tp}-${tpr}`;\n      } else if (incPr) {\n        to = `<${tM}.${tm}.${+tp + 1}-0`;\n      } else {\n        to = `<=${to}`;\n      }\n      return `${from} ${to}`.trim();\n    };\n    var testSet = (set, version, options) => {\n      for (let i = 0; i < set.length; i++) {\n        if (!set[i].test(version)) {\n          return false;\n        }\n      }\n      if (version.prerelease.length && !options.includePrerelease) {\n        for (let i = 0; i < set.length; i++) {\n          debug(set[i].semver);\n          if (set[i].semver === Comparator.ANY) {\n            continue;\n          }\n          if (set[i].semver.prerelease.length > 0) {\n            const allowed = set[i].semver;\n            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/conf/node_modules/semver/classes/comparator.js\nvar require_comparator2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/classes/comparator.js\"(exports2, module2) {\n    \"use strict\";\n    var ANY = /* @__PURE__ */ Symbol(\"SemVer ANY\");\n    var Comparator = class _Comparator {\n      static get ANY() {\n        return ANY;\n      }\n      constructor(comp, options) {\n        options = parseOptions(options);\n        if (comp instanceof _Comparator) {\n          if (comp.loose === !!options.loose) {\n            return comp;\n          } else {\n            comp = comp.value;\n          }\n        }\n        comp = comp.trim().split(/\\s+/).join(\" \");\n        debug(\"comparator\", comp, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.parse(comp);\n        if (this.semver === ANY) {\n          this.value = \"\";\n        } else {\n          this.value = this.operator + this.semver.version;\n        }\n        debug(\"comp\", this);\n      }\n      parse(comp) {\n        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n        const m = comp.match(r);\n        if (!m) {\n          throw new TypeError(`Invalid comparator: ${comp}`);\n        }\n        this.operator = m[1] !== void 0 ? m[1] : \"\";\n        if (this.operator === \"=\") {\n          this.operator = \"\";\n        }\n        if (!m[2]) {\n          this.semver = ANY;\n        } else {\n          this.semver = new SemVer(m[2], this.options.loose);\n        }\n      }\n      toString() {\n        return this.value;\n      }\n      test(version) {\n        debug(\"Comparator.test\", version, this.options.loose);\n        if (this.semver === ANY || version === ANY) {\n          return true;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        return cmp(version, this.operator, this.semver, this.options);\n      }\n      intersects(comp, options) {\n        if (!(comp instanceof _Comparator)) {\n          throw new TypeError(\"a Comparator is required\");\n        }\n        if (this.operator === \"\") {\n          if (this.value === \"\") {\n            return true;\n          }\n          return new Range(comp.value, options).test(this.value);\n        } else if (comp.operator === \"\") {\n          if (comp.value === \"\") {\n            return true;\n          }\n          return new Range(this.value, options).test(comp.semver);\n        }\n        options = parseOptions(options);\n        if (options.includePrerelease && (this.value === \"<0.0.0-0\" || comp.value === \"<0.0.0-0\")) {\n          return false;\n        }\n        if (!options.includePrerelease && (this.value.startsWith(\"<0.0.0\") || comp.value.startsWith(\"<0.0.0\"))) {\n          return false;\n        }\n        if (this.operator.startsWith(\">\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        if (this.operator.startsWith(\"<\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (this.semver.version === comp.semver.version && this.operator.includes(\"=\") && comp.operator.includes(\"=\")) {\n          return true;\n        }\n        if (cmp(this.semver, \"<\", comp.semver, options) && this.operator.startsWith(\">\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (cmp(this.semver, \">\", comp.semver, options) && this.operator.startsWith(\"<\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        return false;\n      }\n    };\n    module2.exports = Comparator;\n    var parseOptions = require_parse_options2();\n    var { safeRe: re, t } = require_re2();\n    var cmp = require_cmp2();\n    var debug = require_debug2();\n    var SemVer = require_semver3();\n    var Range = require_range2();\n  }\n});\n\n// node_modules/conf/node_modules/semver/functions/satisfies.js\nvar require_satisfies2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/functions/satisfies.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range2();\n    var satisfies = (version, range, options) => {\n      try {\n        range = new Range(range, options);\n      } catch (er) {\n        return false;\n      }\n      return range.test(version);\n    };\n    module2.exports = satisfies;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/to-comparators.js\nvar require_to_comparators2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/to-comparators.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range2();\n    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(\" \").trim().split(\" \"));\n    module2.exports = toComparators;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/max-satisfying.js\nvar require_max_satisfying2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/max-satisfying.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var Range = require_range2();\n    var maxSatisfying = (versions, range, options) => {\n      let max = null;\n      let maxSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!max || maxSV.compare(v) === -1) {\n            max = v;\n            maxSV = new SemVer(max, options);\n          }\n        }\n      });\n      return max;\n    };\n    module2.exports = maxSatisfying;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/min-satisfying.js\nvar require_min_satisfying2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/min-satisfying.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var Range = require_range2();\n    var minSatisfying = (versions, range, options) => {\n      let min = null;\n      let minSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!min || minSV.compare(v) === 1) {\n            min = v;\n            minSV = new SemVer(min, options);\n          }\n        }\n      });\n      return min;\n    };\n    module2.exports = minSatisfying;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/min-version.js\nvar require_min_version2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/min-version.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var Range = require_range2();\n    var gt = require_gt2();\n    var minVersion = (range, loose) => {\n      range = new Range(range, loose);\n      let minver = new SemVer(\"0.0.0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = new SemVer(\"0.0.0-0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = null;\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let setMin = null;\n        comparators.forEach((comparator) => {\n          const compver = new SemVer(comparator.semver.version);\n          switch (comparator.operator) {\n            case \">\":\n              if (compver.prerelease.length === 0) {\n                compver.patch++;\n              } else {\n                compver.prerelease.push(0);\n              }\n              compver.raw = compver.format();\n            /* fallthrough */\n            case \"\":\n            case \">=\":\n              if (!setMin || gt(compver, setMin)) {\n                setMin = compver;\n              }\n              break;\n            case \"<\":\n            case \"<=\":\n              break;\n            /* istanbul ignore next */\n            default:\n              throw new Error(`Unexpected operation: ${comparator.operator}`);\n          }\n        });\n        if (setMin && (!minver || gt(minver, setMin))) {\n          minver = setMin;\n        }\n      }\n      if (minver && range.test(minver)) {\n        return minver;\n      }\n      return null;\n    };\n    module2.exports = minVersion;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/valid.js\nvar require_valid4 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/valid.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range2();\n    var validRange = (range, options) => {\n      try {\n        return new Range(range, options).range || \"*\";\n      } catch (er) {\n        return null;\n      }\n    };\n    module2.exports = validRange;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/outside.js\nvar require_outside2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/outside.js\"(exports2, module2) {\n    \"use strict\";\n    var SemVer = require_semver3();\n    var Comparator = require_comparator2();\n    var { ANY } = Comparator;\n    var Range = require_range2();\n    var satisfies = require_satisfies2();\n    var gt = require_gt2();\n    var lt = require_lt2();\n    var lte = require_lte2();\n    var gte = require_gte2();\n    var outside = (version, range, hilo, options) => {\n      version = new SemVer(version, options);\n      range = new Range(range, options);\n      let gtfn, ltefn, ltfn, comp, ecomp;\n      switch (hilo) {\n        case \">\":\n          gtfn = gt;\n          ltefn = lte;\n          ltfn = lt;\n          comp = \">\";\n          ecomp = \">=\";\n          break;\n        case \"<\":\n          gtfn = lt;\n          ltefn = gte;\n          ltfn = gt;\n          comp = \"<\";\n          ecomp = \"<=\";\n          break;\n        default:\n          throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n      }\n      if (satisfies(version, range, options)) {\n        return false;\n      }\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let high = null;\n        let low = null;\n        comparators.forEach((comparator) => {\n          if (comparator.semver === ANY) {\n            comparator = new Comparator(\">=0.0.0\");\n          }\n          high = high || comparator;\n          low = low || comparator;\n          if (gtfn(comparator.semver, high.semver, options)) {\n            high = comparator;\n          } else if (ltfn(comparator.semver, low.semver, options)) {\n            low = comparator;\n          }\n        });\n        if (high.operator === comp || high.operator === ecomp) {\n          return false;\n        }\n        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n          return false;\n        } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    module2.exports = outside;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/gtr.js\nvar require_gtr2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/gtr.js\"(exports2, module2) {\n    \"use strict\";\n    var outside = require_outside2();\n    var gtr = (version, range, options) => outside(version, range, \">\", options);\n    module2.exports = gtr;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/ltr.js\nvar require_ltr2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/ltr.js\"(exports2, module2) {\n    \"use strict\";\n    var outside = require_outside2();\n    var ltr = (version, range, options) => outside(version, range, \"<\", options);\n    module2.exports = ltr;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/intersects.js\nvar require_intersects2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/intersects.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range2();\n    var intersects = (r1, r2, options) => {\n      r1 = new Range(r1, options);\n      r2 = new Range(r2, options);\n      return r1.intersects(r2, options);\n    };\n    module2.exports = intersects;\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/simplify.js\nvar require_simplify2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/simplify.js\"(exports2, module2) {\n    \"use strict\";\n    var satisfies = require_satisfies2();\n    var compare = require_compare2();\n    module2.exports = (versions, range, options) => {\n      const set = [];\n      let first = null;\n      let prev = null;\n      const v = versions.sort((a, b) => compare(a, b, options));\n      for (const version of v) {\n        const included = satisfies(version, range, options);\n        if (included) {\n          prev = version;\n          if (!first) {\n            first = version;\n          }\n        } else {\n          if (prev) {\n            set.push([first, prev]);\n          }\n          prev = null;\n          first = null;\n        }\n      }\n      if (first) {\n        set.push([first, null]);\n      }\n      const ranges = [];\n      for (const [min, max] of set) {\n        if (min === max) {\n          ranges.push(min);\n        } else if (!max && min === v[0]) {\n          ranges.push(\"*\");\n        } else if (!max) {\n          ranges.push(`>=${min}`);\n        } else if (min === v[0]) {\n          ranges.push(`<=${max}`);\n        } else {\n          ranges.push(`${min} - ${max}`);\n        }\n      }\n      const simplified = ranges.join(\" || \");\n      const original = typeof range.raw === \"string\" ? range.raw : String(range);\n      return simplified.length < original.length ? simplified : range;\n    };\n  }\n});\n\n// node_modules/conf/node_modules/semver/ranges/subset.js\nvar require_subset2 = __commonJS({\n  \"node_modules/conf/node_modules/semver/ranges/subset.js\"(exports2, module2) {\n    \"use strict\";\n    var Range = require_range2();\n    var Comparator = require_comparator2();\n    var { ANY } = Comparator;\n    var satisfies = require_satisfies2();\n    var compare = require_compare2();\n    var subset = (sub, dom, options = {}) => {\n      if (sub === dom) {\n        return true;\n      }\n      sub = new Range(sub, options);\n      dom = new Range(dom, options);\n      let sawNonNull = false;\n      OUTER: for (const simpleSub of sub.set) {\n        for (const simpleDom of dom.set) {\n          const isSub = simpleSubset(simpleSub, simpleDom, options);\n          sawNonNull = sawNonNull || isSub !== null;\n          if (isSub) {\n            continue OUTER;\n          }\n        }\n        if (sawNonNull) {\n          return false;\n        }\n      }\n      return true;\n    };\n    var minimumVersionWithPreRelease = [new Comparator(\">=0.0.0-0\")];\n    var minimumVersion = [new Comparator(\">=0.0.0\")];\n    var simpleSubset = (sub, dom, options) => {\n      if (sub === dom) {\n        return true;\n      }\n      if (sub.length === 1 && sub[0].semver === ANY) {\n        if (dom.length === 1 && dom[0].semver === ANY) {\n          return true;\n        } else if (options.includePrerelease) {\n          sub = minimumVersionWithPreRelease;\n        } else {\n          sub = minimumVersion;\n        }\n      }\n      if (dom.length === 1 && dom[0].semver === ANY) {\n        if (options.includePrerelease) {\n          return true;\n        } else {\n          dom = minimumVersion;\n        }\n      }\n      const eqSet = /* @__PURE__ */ new Set();\n      let gt, lt;\n      for (const c of sub) {\n        if (c.operator === \">\" || c.operator === \">=\") {\n          gt = higherGT(gt, c, options);\n        } else if (c.operator === \"<\" || c.operator === \"<=\") {\n          lt = lowerLT(lt, c, options);\n        } else {\n          eqSet.add(c.semver);\n        }\n      }\n      if (eqSet.size > 1) {\n        return null;\n      }\n      let gtltComp;\n      if (gt && lt) {\n        gtltComp = compare(gt.semver, lt.semver, options);\n        if (gtltComp > 0) {\n          return null;\n        } else if (gtltComp === 0 && (gt.operator !== \">=\" || lt.operator !== \"<=\")) {\n          return null;\n        }\n      }\n      for (const eq of eqSet) {\n        if (gt && !satisfies(eq, String(gt), options)) {\n          return null;\n        }\n        if (lt && !satisfies(eq, String(lt), options)) {\n          return null;\n        }\n        for (const c of dom) {\n          if (!satisfies(eq, String(c), options)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      let higher, lower;\n      let hasDomLT, hasDomGT;\n      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;\n      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;\n      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === \"<\" && needDomLTPre.prerelease[0] === 0) {\n        needDomLTPre = false;\n      }\n      for (const c of dom) {\n        hasDomGT = hasDomGT || c.operator === \">\" || c.operator === \">=\";\n        hasDomLT = hasDomLT || c.operator === \"<\" || c.operator === \"<=\";\n        if (gt) {\n          if (needDomGTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {\n              needDomGTPre = false;\n            }\n          }\n          if (c.operator === \">\" || c.operator === \">=\") {\n            higher = higherGT(gt, c, options);\n            if (higher === c && higher !== gt) {\n              return false;\n            }\n          } else if (gt.operator === \">=\" && !satisfies(gt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (lt) {\n          if (needDomLTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {\n              needDomLTPre = false;\n            }\n          }\n          if (c.operator === \"<\" || c.operator === \"<=\") {\n            lower = lowerLT(lt, c, options);\n            if (lower === c && lower !== lt) {\n              return false;\n            }\n          } else if (lt.operator === \"<=\" && !satisfies(lt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (!c.operator && (lt || gt) && gtltComp !== 0) {\n          return false;\n        }\n      }\n      if (gt && hasDomLT && !lt && gtltComp !== 0) {\n        return false;\n      }\n      if (lt && hasDomGT && !gt && gtltComp !== 0) {\n        return false;\n      }\n      if (needDomGTPre || needDomLTPre) {\n        return false;\n      }\n      return true;\n    };\n    var higherGT = (a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare(a.semver, b.semver, options);\n      return comp > 0 ? a : comp < 0 ? b : b.operator === \">\" && a.operator === \">=\" ? b : a;\n    };\n    var lowerLT = (a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare(a.semver, b.semver, options);\n      return comp < 0 ? a : comp > 0 ? b : b.operator === \"<\" && a.operator === \"<=\" ? b : a;\n    };\n    module2.exports = subset;\n  }\n});\n\n// node_modules/conf/node_modules/semver/index.js\nvar require_semver4 = __commonJS({\n  \"node_modules/conf/node_modules/semver/index.js\"(exports2, module2) {\n    \"use strict\";\n    var internalRe = require_re2();\n    var constants = require_constants2();\n    var SemVer = require_semver3();\n    var identifiers = require_identifiers2();\n    var parse = require_parse2();\n    var valid = require_valid3();\n    var clean = require_clean2();\n    var inc = require_inc2();\n    var diff = require_diff2();\n    var major = require_major2();\n    var minor = require_minor2();\n    var patch = require_patch2();\n    var prerelease = require_prerelease2();\n    var compare = require_compare2();\n    var rcompare = require_rcompare2();\n    var compareLoose = require_compare_loose2();\n    var compareBuild = require_compare_build2();\n    var sort = require_sort2();\n    var rsort = require_rsort2();\n    var gt = require_gt2();\n    var lt = require_lt2();\n    var eq = require_eq2();\n    var neq = require_neq2();\n    var gte = require_gte2();\n    var lte = require_lte2();\n    var cmp = require_cmp2();\n    var coerce = require_coerce2();\n    var Comparator = require_comparator2();\n    var Range = require_range2();\n    var satisfies = require_satisfies2();\n    var toComparators = require_to_comparators2();\n    var maxSatisfying = require_max_satisfying2();\n    var minSatisfying = require_min_satisfying2();\n    var minVersion = require_min_version2();\n    var validRange = require_valid4();\n    var outside = require_outside2();\n    var gtr = require_gtr2();\n    var ltr = require_ltr2();\n    var intersects = require_intersects2();\n    var simplifyRange = require_simplify2();\n    var subset = require_subset2();\n    module2.exports = {\n      parse,\n      valid,\n      clean,\n      inc,\n      diff,\n      major,\n      minor,\n      patch,\n      prerelease,\n      compare,\n      rcompare,\n      compareLoose,\n      compareBuild,\n      sort,\n      rsort,\n      gt,\n      lt,\n      eq,\n      neq,\n      gte,\n      lte,\n      cmp,\n      coerce,\n      Comparator,\n      Range,\n      satisfies,\n      toComparators,\n      maxSatisfying,\n      minSatisfying,\n      minVersion,\n      validRange,\n      outside,\n      gtr,\n      ltr,\n      intersects,\n      simplifyRange,\n      subset,\n      SemVer,\n      re: internalRe.re,\n      src: internalRe.src,\n      tokens: internalRe.t,\n      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n      RELEASE_TYPES: constants.RELEASE_TYPES,\n      compareIdentifiers: identifiers.compareIdentifiers,\n      rcompareIdentifiers: identifiers.rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/mimic-fn/index.js\nvar require_mimic_fn2 = __commonJS({\n  \"node_modules/mimic-fn/index.js\"(exports2, module2) {\n    \"use strict\";\n    var mimicFn = (to, from) => {\n      for (const prop of Reflect.ownKeys(from)) {\n        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n      }\n      return to;\n    };\n    module2.exports = mimicFn;\n    module2.exports.default = mimicFn;\n  }\n});\n\n// node_modules/onetime/index.js\nvar require_onetime = __commonJS({\n  \"node_modules/onetime/index.js\"(exports2, module2) {\n    \"use strict\";\n    var mimicFn = require_mimic_fn2();\n    var calledFunctions = /* @__PURE__ */ new WeakMap();\n    var onetime = (function_, options = {}) => {\n      if (typeof function_ !== \"function\") {\n        throw new TypeError(\"Expected a function\");\n      }\n      let returnValue;\n      let callCount = 0;\n      const functionName = function_.displayName || function_.name || \"<anonymous>\";\n      const onetime2 = function(...arguments_) {\n        calledFunctions.set(onetime2, ++callCount);\n        if (callCount === 1) {\n          returnValue = function_.apply(this, arguments_);\n          function_ = null;\n        } else if (options.throw === true) {\n          throw new Error(`Function \\`${functionName}\\` can only be called once`);\n        }\n        return returnValue;\n      };\n      mimicFn(onetime2, function_);\n      calledFunctions.set(onetime2, callCount);\n      return onetime2;\n    };\n    module2.exports = onetime;\n    module2.exports.default = onetime;\n    module2.exports.callCount = (function_) => {\n      if (!calledFunctions.has(function_)) {\n        throw new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n      }\n      return calledFunctions.get(function_);\n    };\n  }\n});\n\n// node_modules/conf/dist/source/index.js\nvar require_source = __commonJS({\n  \"node_modules/conf/dist/source/index.js\"(exports2, module2) {\n    \"use strict\";\n    var __classPrivateFieldSet2 = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n      if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n      return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n    };\n    var __classPrivateFieldGet2 = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n      return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n    };\n    var _a;\n    var _b;\n    var _Conf_validator;\n    var _Conf_encryptionKey;\n    var _Conf_options;\n    var _Conf_defaultValues;\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var util_1 = require(\"util\");\n    var fs4 = require(\"fs\");\n    var path6 = require(\"path\");\n    var crypto = require(\"crypto\");\n    var assert = require(\"assert\");\n    var events_1 = require(\"events\");\n    var dotProp = require_dot_prop();\n    var pkgUp = require_pkg_up();\n    var envPaths = require_env_paths();\n    var atomically = require_dist();\n    var ajv_1 = require_ajv();\n    var ajv_formats_1 = require_dist2();\n    var debounceFn = require_debounce_fn();\n    var semver = require_semver4();\n    var onetime = require_onetime();\n    var encryptionAlgorithm = \"aes-256-cbc\";\n    var createPlainObject = () => {\n      return /* @__PURE__ */ Object.create(null);\n    };\n    var isExist = (data) => {\n      return data !== void 0 && data !== null;\n    };\n    var parentDir = \"\";\n    try {\n      delete require.cache[__filename];\n      parentDir = path6.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : \".\");\n    } catch (_c) {\n    }\n    var checkValueType = (key, value) => {\n      const nonJsonTypes = /* @__PURE__ */ new Set([\n        \"undefined\",\n        \"symbol\",\n        \"function\"\n      ]);\n      const type = typeof value;\n      if (nonJsonTypes.has(type)) {\n        throw new TypeError(`Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`);\n      }\n    };\n    var INTERNAL_KEY = \"__internal__\";\n    var MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;\n    var Conf = class {\n      constructor(partialOptions = {}) {\n        var _a2;\n        _Conf_validator.set(this, void 0);\n        _Conf_encryptionKey.set(this, void 0);\n        _Conf_options.set(this, void 0);\n        _Conf_defaultValues.set(this, {});\n        this._deserialize = (value) => JSON.parse(value);\n        this._serialize = (value) => JSON.stringify(value, void 0, \"\t\");\n        const options = {\n          configName: \"config\",\n          fileExtension: \"json\",\n          projectSuffix: \"nodejs\",\n          clearInvalidConfig: false,\n          accessPropertiesByDotNotation: true,\n          configFileMode: 438,\n          ...partialOptions\n        };\n        const getPackageData = onetime(() => {\n          const packagePath = pkgUp.sync({ cwd: parentDir });\n          const packageData = packagePath && JSON.parse(fs4.readFileSync(packagePath, \"utf8\"));\n          return packageData !== null && packageData !== void 0 ? packageData : {};\n        });\n        if (!options.cwd) {\n          if (!options.projectName) {\n            options.projectName = getPackageData().name;\n          }\n          if (!options.projectName) {\n            throw new Error(\"Project name could not be inferred. Please specify the `projectName` option.\");\n          }\n          options.cwd = envPaths(options.projectName, { suffix: options.projectSuffix }).config;\n        }\n        __classPrivateFieldSet2(this, _Conf_options, options, \"f\");\n        if (options.schema) {\n          if (typeof options.schema !== \"object\") {\n            throw new TypeError(\"The `schema` option must be an object.\");\n          }\n          const ajv = new ajv_1.default({\n            allErrors: true,\n            useDefaults: true\n          });\n          (0, ajv_formats_1.default)(ajv);\n          const schema = {\n            type: \"object\",\n            properties: options.schema\n          };\n          __classPrivateFieldSet2(this, _Conf_validator, ajv.compile(schema), \"f\");\n          for (const [key, value] of Object.entries(options.schema)) {\n            if (value === null || value === void 0 ? void 0 : value.default) {\n              __classPrivateFieldGet2(this, _Conf_defaultValues, \"f\")[key] = value.default;\n            }\n          }\n        }\n        if (options.defaults) {\n          __classPrivateFieldSet2(this, _Conf_defaultValues, {\n            ...__classPrivateFieldGet2(this, _Conf_defaultValues, \"f\"),\n            ...options.defaults\n          }, \"f\");\n        }\n        if (options.serialize) {\n          this._serialize = options.serialize;\n        }\n        if (options.deserialize) {\n          this._deserialize = options.deserialize;\n        }\n        this.events = new events_1.EventEmitter();\n        __classPrivateFieldSet2(this, _Conf_encryptionKey, options.encryptionKey, \"f\");\n        const fileExtension = options.fileExtension ? `.${options.fileExtension}` : \"\";\n        this.path = path6.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : \"config\"}${fileExtension}`);\n        const fileStore = this.store;\n        const store3 = Object.assign(createPlainObject(), options.defaults, fileStore);\n        this._validate(store3);\n        try {\n          assert.deepEqual(fileStore, store3);\n        } catch (_b2) {\n          this.store = store3;\n        }\n        if (options.watch) {\n          this._watch();\n        }\n        if (options.migrations) {\n          if (!options.projectVersion) {\n            options.projectVersion = getPackageData().version;\n          }\n          if (!options.projectVersion) {\n            throw new Error(\"Project version could not be inferred. Please specify the `projectVersion` option.\");\n          }\n          this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);\n        }\n      }\n      get(key, defaultValue) {\n        if (__classPrivateFieldGet2(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n          return this._get(key, defaultValue);\n        }\n        const { store: store3 } = this;\n        return key in store3 ? store3[key] : defaultValue;\n      }\n      set(key, value) {\n        if (typeof key !== \"string\" && typeof key !== \"object\") {\n          throw new TypeError(`Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`);\n        }\n        if (typeof key !== \"object\" && value === void 0) {\n          throw new TypeError(\"Use `delete()` to clear values\");\n        }\n        if (this._containsReservedKey(key)) {\n          throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);\n        }\n        const { store: store3 } = this;\n        const set = (key2, value2) => {\n          checkValueType(key2, value2);\n          if (__classPrivateFieldGet2(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n            dotProp.set(store3, key2, value2);\n          } else {\n            store3[key2] = value2;\n          }\n        };\n        if (typeof key === \"object\") {\n          const object = key;\n          for (const [key2, value2] of Object.entries(object)) {\n            set(key2, value2);\n          }\n        } else {\n          set(key, value);\n        }\n        this.store = store3;\n      }\n      /**\n          Check if an item exists.\n      \n          @param key - The key of the item to check.\n          */\n      has(key) {\n        if (__classPrivateFieldGet2(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n          return dotProp.has(this.store, key);\n        }\n        return key in this.store;\n      }\n      /**\n          Reset items to their default values, as defined by the `defaults` or `schema` option.\n      \n          @see `clear()` to reset all items.\n      \n          @param keys - The keys of the items to reset.\n          */\n      reset(...keys) {\n        for (const key of keys) {\n          if (isExist(__classPrivateFieldGet2(this, _Conf_defaultValues, \"f\")[key])) {\n            this.set(key, __classPrivateFieldGet2(this, _Conf_defaultValues, \"f\")[key]);\n          }\n        }\n      }\n      /**\n          Delete an item.\n      \n          @param key - The key of the item to delete.\n          */\n      delete(key) {\n        const { store: store3 } = this;\n        if (__classPrivateFieldGet2(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n          dotProp.delete(store3, key);\n        } else {\n          delete store3[key];\n        }\n        this.store = store3;\n      }\n      /**\n          Delete all items.\n      \n          This resets known items to their default values, if defined by the `defaults` or `schema` option.\n          */\n      clear() {\n        this.store = createPlainObject();\n        for (const key of Object.keys(__classPrivateFieldGet2(this, _Conf_defaultValues, \"f\"))) {\n          this.reset(key);\n        }\n      }\n      /**\n          Watches the given `key`, calling `callback` on any changes.\n      \n          @param key - The key wo watch.\n          @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n          @returns A function, that when called, will unsubscribe.\n          */\n      onDidChange(key, callback) {\n        if (typeof key !== \"string\") {\n          throw new TypeError(`Expected \\`key\\` to be of type \\`string\\`, got ${typeof key}`);\n        }\n        if (typeof callback !== \"function\") {\n          throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n        }\n        return this._handleChange(() => this.get(key), callback);\n      }\n      /**\n          Watches the whole config object, calling `callback` on any changes.\n      \n          @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n          @returns A function, that when called, will unsubscribe.\n          */\n      onDidAnyChange(callback) {\n        if (typeof callback !== \"function\") {\n          throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n        }\n        return this._handleChange(() => this.store, callback);\n      }\n      get size() {\n        return Object.keys(this.store).length;\n      }\n      get store() {\n        try {\n          const data = fs4.readFileSync(this.path, __classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\") ? null : \"utf8\");\n          const dataString = this._encryptData(data);\n          const deserializedData = this._deserialize(dataString);\n          this._validate(deserializedData);\n          return Object.assign(createPlainObject(), deserializedData);\n        } catch (error) {\n          if ((error === null || error === void 0 ? void 0 : error.code) === \"ENOENT\") {\n            this._ensureDirectory();\n            return createPlainObject();\n          }\n          if (__classPrivateFieldGet2(this, _Conf_options, \"f\").clearInvalidConfig && error.name === \"SyntaxError\") {\n            return createPlainObject();\n          }\n          throw error;\n        }\n      }\n      set store(value) {\n        this._ensureDirectory();\n        this._validate(value);\n        this._write(value);\n        this.events.emit(\"change\");\n      }\n      *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {\n        for (const [key, value] of Object.entries(this.store)) {\n          yield [key, value];\n        }\n      }\n      _encryptData(data) {\n        if (!__classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\")) {\n          return data.toString();\n        }\n        try {\n          if (__classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\")) {\n            try {\n              if (data.slice(16, 17).toString() === \":\") {\n                const initializationVector = data.slice(0, 16);\n                const password = crypto.pbkdf2Sync(__classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\"), initializationVector.toString(), 1e4, 32, \"sha512\");\n                const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);\n                data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString(\"utf8\");\n              } else {\n                const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\"));\n                data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString(\"utf8\");\n              }\n            } catch (_a2) {\n            }\n          }\n        } catch (_b2) {\n        }\n        return data.toString();\n      }\n      _handleChange(getter, callback) {\n        let currentValue = getter();\n        const onChange = () => {\n          const oldValue = currentValue;\n          const newValue = getter();\n          if ((0, util_1.isDeepStrictEqual)(newValue, oldValue)) {\n            return;\n          }\n          currentValue = newValue;\n          callback.call(this, newValue, oldValue);\n        };\n        this.events.on(\"change\", onChange);\n        return () => this.events.removeListener(\"change\", onChange);\n      }\n      _validate(data) {\n        if (!__classPrivateFieldGet2(this, _Conf_validator, \"f\")) {\n          return;\n        }\n        const valid = __classPrivateFieldGet2(this, _Conf_validator, \"f\").call(this, data);\n        if (valid || !__classPrivateFieldGet2(this, _Conf_validator, \"f\").errors) {\n          return;\n        }\n        const errors = __classPrivateFieldGet2(this, _Conf_validator, \"f\").errors.map(({ instancePath, message = \"\" }) => `\\`${instancePath.slice(1)}\\` ${message}`);\n        throw new Error(\"Config schema violation: \" + errors.join(\"; \"));\n      }\n      _ensureDirectory() {\n        fs4.mkdirSync(path6.dirname(this.path), { recursive: true });\n      }\n      _write(value) {\n        let data = this._serialize(value);\n        if (__classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\")) {\n          const initializationVector = crypto.randomBytes(16);\n          const password = crypto.pbkdf2Sync(__classPrivateFieldGet2(this, _Conf_encryptionKey, \"f\"), initializationVector.toString(), 1e4, 32, \"sha512\");\n          const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);\n          data = Buffer.concat([initializationVector, Buffer.from(\":\"), cipher.update(Buffer.from(data)), cipher.final()]);\n        }\n        if (process.env.SNAP) {\n          fs4.writeFileSync(this.path, data, { mode: __classPrivateFieldGet2(this, _Conf_options, \"f\").configFileMode });\n        } else {\n          try {\n            atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet2(this, _Conf_options, \"f\").configFileMode });\n          } catch (error) {\n            if ((error === null || error === void 0 ? void 0 : error.code) === \"EXDEV\") {\n              fs4.writeFileSync(this.path, data, { mode: __classPrivateFieldGet2(this, _Conf_options, \"f\").configFileMode });\n              return;\n            }\n            throw error;\n          }\n        }\n      }\n      _watch() {\n        this._ensureDirectory();\n        if (!fs4.existsSync(this.path)) {\n          this._write(createPlainObject());\n        }\n        if (process.platform === \"win32\") {\n          fs4.watch(this.path, { persistent: false }, debounceFn(() => {\n            this.events.emit(\"change\");\n          }, { wait: 100 }));\n        } else {\n          fs4.watchFile(this.path, { persistent: false }, debounceFn(() => {\n            this.events.emit(\"change\");\n          }, { wait: 5e3 }));\n        }\n      }\n      _migrate(migrations, versionToMigrate, beforeEachMigration) {\n        let previousMigratedVersion = this._get(MIGRATION_KEY, \"0.0.0\");\n        const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));\n        let storeBackup = { ...this.store };\n        for (const version of newerVersions) {\n          try {\n            if (beforeEachMigration) {\n              beforeEachMigration(this, {\n                fromVersion: previousMigratedVersion,\n                toVersion: version,\n                finalVersion: versionToMigrate,\n                versions: newerVersions\n              });\n            }\n            const migration = migrations[version];\n            migration(this);\n            this._set(MIGRATION_KEY, version);\n            previousMigratedVersion = version;\n            storeBackup = { ...this.store };\n          } catch (error) {\n            this.store = storeBackup;\n            throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);\n          }\n        }\n        if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver.eq(previousMigratedVersion, versionToMigrate)) {\n          this._set(MIGRATION_KEY, versionToMigrate);\n        }\n      }\n      _containsReservedKey(key) {\n        if (typeof key === \"object\") {\n          const firsKey = Object.keys(key)[0];\n          if (firsKey === INTERNAL_KEY) {\n            return true;\n          }\n        }\n        if (typeof key !== \"string\") {\n          return false;\n        }\n        if (__classPrivateFieldGet2(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n          if (key.startsWith(`${INTERNAL_KEY}.`)) {\n            return true;\n          }\n          return false;\n        }\n        return false;\n      }\n      _isVersionInRangeFormat(version) {\n        return semver.clean(version) === null;\n      }\n      _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {\n        if (this._isVersionInRangeFormat(candidateVersion)) {\n          if (previousMigratedVersion !== \"0.0.0\" && semver.satisfies(previousMigratedVersion, candidateVersion)) {\n            return false;\n          }\n          return semver.satisfies(versionToMigrate, candidateVersion);\n        }\n        if (semver.lte(candidateVersion, previousMigratedVersion)) {\n          return false;\n        }\n        if (semver.gt(candidateVersion, versionToMigrate)) {\n          return false;\n        }\n        return true;\n      }\n      _get(key, defaultValue) {\n        return dotProp.get(this.store, key, defaultValue);\n      }\n      _set(key, value) {\n        const { store: store3 } = this;\n        dotProp.set(store3, key, value);\n        this.store = store3;\n      }\n    };\n    exports2.default = Conf;\n    module2.exports = Conf;\n    module2.exports.default = Conf;\n  }\n});\n\n// node_modules/electron-store/index.js\nvar require_electron_store = __commonJS({\n  \"node_modules/electron-store/index.js\"(exports2, module2) {\n    \"use strict\";\n    var path6 = require(\"path\");\n    var { app: app6, ipcMain: ipcMain11, ipcRenderer, shell: shell2 } = require(\"electron\");\n    var Conf = require_source();\n    var isInitialized = false;\n    var initDataListener = () => {\n      if (!ipcMain11 || !app6) {\n        throw new Error(\"Electron Store: You need to call `.initRenderer()` from the main process.\");\n      }\n      const appData = {\n        defaultCwd: app6.getPath(\"userData\"),\n        appVersion: app6.getVersion()\n      };\n      if (isInitialized) {\n        return appData;\n      }\n      ipcMain11.on(\"electron-store-get-data\", (event) => {\n        event.returnValue = appData;\n      });\n      isInitialized = true;\n      return appData;\n    };\n    var ElectronStore = class extends Conf {\n      constructor(options) {\n        let defaultCwd;\n        let appVersion;\n        if (ipcRenderer) {\n          const appData = ipcRenderer.sendSync(\"electron-store-get-data\");\n          if (!appData) {\n            throw new Error(\"Electron Store: You need to call `.initRenderer()` from the main process.\");\n          }\n          ({ defaultCwd, appVersion } = appData);\n        } else if (ipcMain11 && app6) {\n          ({ defaultCwd, appVersion } = initDataListener());\n        }\n        options = {\n          name: \"config\",\n          ...options\n        };\n        if (!options.projectVersion) {\n          options.projectVersion = appVersion;\n        }\n        if (options.cwd) {\n          options.cwd = path6.isAbsolute(options.cwd) ? options.cwd : path6.join(defaultCwd, options.cwd);\n        } else {\n          options.cwd = defaultCwd;\n        }\n        options.configName = options.name;\n        delete options.name;\n        super(options);\n      }\n      static initRenderer() {\n        initDataListener();\n      }\n      openInEditor() {\n        shell2.openPath(this.path);\n      }\n    };\n    module2.exports = ElectronStore;\n  }\n});\n\n// node_modules/ws/lib/constants.js\nvar require_constants3 = __commonJS({\n  \"node_modules/ws/lib/constants.js\"(exports2, module2) {\n    \"use strict\";\n    var BINARY_TYPES = [\"nodebuffer\", \"arraybuffer\", \"fragments\"];\n    var hasBlob = typeof Blob !== \"undefined\";\n    if (hasBlob) BINARY_TYPES.push(\"blob\");\n    module2.exports = {\n      BINARY_TYPES,\n      EMPTY_BUFFER: Buffer.alloc(0),\n      GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n      hasBlob,\n      kForOnEventAttribute: /* @__PURE__ */ Symbol(\"kIsForOnEventAttribute\"),\n      kListener: /* @__PURE__ */ Symbol(\"kListener\"),\n      kStatusCode: /* @__PURE__ */ Symbol(\"status-code\"),\n      kWebSocket: /* @__PURE__ */ Symbol(\"websocket\"),\n      NOOP: () => {\n      }\n    };\n  }\n});\n\n// node_modules/ws/lib/buffer-util.js\nvar require_buffer_util = __commonJS({\n  \"node_modules/ws/lib/buffer-util.js\"(exports2, module2) {\n    \"use strict\";\n    var { EMPTY_BUFFER } = require_constants3();\n    var FastBuffer = Buffer[Symbol.species];\n    function concat(list, totalLength) {\n      if (list.length === 0) return EMPTY_BUFFER;\n      if (list.length === 1) return list[0];\n      const target = Buffer.allocUnsafe(totalLength);\n      let offset = 0;\n      for (let i = 0; i < list.length; i++) {\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n      }\n      if (offset < totalLength) {\n        return new FastBuffer(target.buffer, target.byteOffset, offset);\n      }\n      return target;\n    }\n    function _mask(source, mask, output, offset, length) {\n      for (let i = 0; i < length; i++) {\n        output[offset + i] = source[i] ^ mask[i & 3];\n      }\n    }\n    function _unmask(buffer, mask) {\n      for (let i = 0; i < buffer.length; i++) {\n        buffer[i] ^= mask[i & 3];\n      }\n    }\n    function toArrayBuffer(buf) {\n      if (buf.length === buf.buffer.byteLength) {\n        return buf.buffer;\n      }\n      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n    }\n    function toBuffer(data) {\n      toBuffer.readOnly = true;\n      if (Buffer.isBuffer(data)) return data;\n      let buf;\n      if (data instanceof ArrayBuffer) {\n        buf = new FastBuffer(data);\n      } else if (ArrayBuffer.isView(data)) {\n        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n      } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n      }\n      return buf;\n    }\n    module2.exports = {\n      concat,\n      mask: _mask,\n      toArrayBuffer,\n      toBuffer,\n      unmask: _unmask\n    };\n    if (!process.env.WS_NO_BUFFER_UTIL) {\n      try {\n        const bufferUtil = require(\"bufferutil\");\n        module2.exports.mask = function(source, mask, output, offset, length) {\n          if (length < 48) _mask(source, mask, output, offset, length);\n          else bufferUtil.mask(source, mask, output, offset, length);\n        };\n        module2.exports.unmask = function(buffer, mask) {\n          if (buffer.length < 32) _unmask(buffer, mask);\n          else bufferUtil.unmask(buffer, mask);\n        };\n      } catch (e) {\n      }\n    }\n  }\n});\n\n// node_modules/ws/lib/limiter.js\nvar require_limiter = __commonJS({\n  \"node_modules/ws/lib/limiter.js\"(exports2, module2) {\n    \"use strict\";\n    var kDone = /* @__PURE__ */ Symbol(\"kDone\");\n    var kRun = /* @__PURE__ */ Symbol(\"kRun\");\n    var Limiter = class {\n      /**\n       * Creates a new `Limiter`.\n       *\n       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n       *     to run concurrently\n       */\n      constructor(concurrency) {\n        this[kDone] = () => {\n          this.pending--;\n          this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n      }\n      /**\n       * Adds a job to the queue.\n       *\n       * @param {Function} job The job to run\n       * @public\n       */\n      add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n      }\n      /**\n       * Removes a job from the queue and runs it if possible.\n       *\n       * @private\n       */\n      [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n          const job = this.jobs.shift();\n          this.pending++;\n          job(this[kDone]);\n        }\n      }\n    };\n    module2.exports = Limiter;\n  }\n});\n\n// node_modules/ws/lib/permessage-deflate.js\nvar require_permessage_deflate = __commonJS({\n  \"node_modules/ws/lib/permessage-deflate.js\"(exports2, module2) {\n    \"use strict\";\n    var zlib = require(\"zlib\");\n    var bufferUtil = require_buffer_util();\n    var Limiter = require_limiter();\n    var { kStatusCode } = require_constants3();\n    var FastBuffer = Buffer[Symbol.species];\n    var TRAILER = Buffer.from([0, 0, 255, 255]);\n    var kPerMessageDeflate = /* @__PURE__ */ Symbol(\"permessage-deflate\");\n    var kTotalLength = /* @__PURE__ */ Symbol(\"total-length\");\n    var kCallback = /* @__PURE__ */ Symbol(\"callback\");\n    var kBuffers = /* @__PURE__ */ Symbol(\"buffers\");\n    var kError = /* @__PURE__ */ Symbol(\"error\");\n    var zlibLimiter;\n    var PerMessageDeflate = class {\n      /**\n       * Creates a PerMessageDeflate instance.\n       *\n       * @param {Object} [options] Configuration options\n       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n       *     for, or request, a custom client window size\n       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n       *     acknowledge disabling of client context takeover\n       * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n       *     calls to zlib\n       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n       *     use of a custom server window size\n       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n       *     disabling of server context takeover\n       * @param {Number} [options.threshold=1024] Size (in bytes) below which\n       *     messages should not be compressed if context takeover is disabled\n       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n       *     deflate\n       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n       *     inflate\n       * @param {Boolean} [isServer=false] Create the instance in either server or\n       *     client mode\n       * @param {Number} [maxPayload=0] The maximum allowed message length\n       */\n      constructor(options, isServer, maxPayload) {\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n          zlibLimiter = new Limiter(concurrency);\n        }\n      }\n      /**\n       * @type {String}\n       */\n      static get extensionName() {\n        return \"permessage-deflate\";\n      }\n      /**\n       * Create an extension negotiation offer.\n       *\n       * @return {Object} Extension parameters\n       * @public\n       */\n      offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n          params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n          params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n          params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n          params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n          params.client_max_window_bits = true;\n        }\n        return params;\n      }\n      /**\n       * Accept an extension negotiation offer/response.\n       *\n       * @param {Array} configurations The extension negotiation offers/reponse\n       * @return {Object} Accepted configuration\n       * @public\n       */\n      accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n      }\n      /**\n       * Releases all resources used by the extension.\n       *\n       * @public\n       */\n      cleanup() {\n        if (this._inflate) {\n          this._inflate.close();\n          this._inflate = null;\n        }\n        if (this._deflate) {\n          const callback = this._deflate[kCallback];\n          this._deflate.close();\n          this._deflate = null;\n          if (callback) {\n            callback(\n              new Error(\n                \"The deflate stream was closed while data was being processed\"\n              )\n            );\n          }\n        }\n      }\n      /**\n       *  Accept an extension negotiation offer.\n       *\n       * @param {Array} offers The extension negotiation offers\n       * @return {Object} Accepted configuration\n       * @private\n       */\n      acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params) => {\n          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n            return false;\n          }\n          return true;\n        });\n        if (!accepted) {\n          throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n          accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n          accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n          accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n          accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n          delete accepted.client_max_window_bits;\n        }\n        return accepted;\n      }\n      /**\n       * Accept the extension negotiation response.\n       *\n       * @param {Array} response The extension negotiation response\n       * @return {Object} Accepted configuration\n       * @private\n       */\n      acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n          throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n          if (typeof this._options.clientMaxWindowBits === \"number\") {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n          }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n          throw new Error(\n            'Unexpected or invalid parameter \"client_max_window_bits\"'\n          );\n        }\n        return params;\n      }\n      /**\n       * Normalize parameters.\n       *\n       * @param {Array} configurations The extension negotiation offers/reponse\n       * @return {Array} The offers/response with normalized parameters\n       * @private\n       */\n      normalizeParams(configurations) {\n        configurations.forEach((params) => {\n          Object.keys(params).forEach((key) => {\n            let value = params[key];\n            if (value.length > 1) {\n              throw new Error(`Parameter \"${key}\" must have only a single value`);\n            }\n            value = value[0];\n            if (key === \"client_max_window_bits\") {\n              if (value !== true) {\n                const num = +value;\n                if (!Number.isInteger(num) || num < 8 || num > 15) {\n                  throw new TypeError(\n                    `Invalid value for parameter \"${key}\": ${value}`\n                  );\n                }\n                value = num;\n              } else if (!this._isServer) {\n                throw new TypeError(\n                  `Invalid value for parameter \"${key}\": ${value}`\n                );\n              }\n            } else if (key === \"server_max_window_bits\") {\n              const num = +value;\n              if (!Number.isInteger(num) || num < 8 || num > 15) {\n                throw new TypeError(\n                  `Invalid value for parameter \"${key}\": ${value}`\n                );\n              }\n              value = num;\n            } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n              if (value !== true) {\n                throw new TypeError(\n                  `Invalid value for parameter \"${key}\": ${value}`\n                );\n              }\n            } else {\n              throw new Error(`Unknown parameter \"${key}\"`);\n            }\n            params[key] = value;\n          });\n        });\n        return configurations;\n      }\n      /**\n       * Decompress data. Concurrency limited.\n       *\n       * @param {Buffer} data Compressed data\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @public\n       */\n      decompress(data, fin, callback) {\n        zlibLimiter.add((done) => {\n          this._decompress(data, fin, (err, result) => {\n            done();\n            callback(err, result);\n          });\n        });\n      }\n      /**\n       * Compress data. Concurrency limited.\n       *\n       * @param {(Buffer|String)} data Data to compress\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @public\n       */\n      compress(data, fin, callback) {\n        zlibLimiter.add((done) => {\n          this._compress(data, fin, (err, result) => {\n            done();\n            callback(err, result);\n          });\n        });\n      }\n      /**\n       * Decompress data.\n       *\n       * @param {Buffer} data Compressed data\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @private\n       */\n      _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n          const key = `${endpoint}_max_window_bits`;\n          const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n          this._inflate = zlib.createInflateRaw({\n            ...this._options.zlibInflateOptions,\n            windowBits\n          });\n          this._inflate[kPerMessageDeflate] = this;\n          this._inflate[kTotalLength] = 0;\n          this._inflate[kBuffers] = [];\n          this._inflate.on(\"error\", inflateOnError);\n          this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(() => {\n          const err = this._inflate[kError];\n          if (err) {\n            this._inflate.close();\n            this._inflate = null;\n            callback(err);\n            return;\n          }\n          const data2 = bufferUtil.concat(\n            this._inflate[kBuffers],\n            this._inflate[kTotalLength]\n          );\n          if (this._inflate._readableState.endEmitted) {\n            this._inflate.close();\n            this._inflate = null;\n          } else {\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n              this._inflate.reset();\n            }\n          }\n          callback(null, data2);\n        });\n      }\n      /**\n       * Compress data.\n       *\n       * @param {(Buffer|String)} data Data to compress\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @private\n       */\n      _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n          const key = `${endpoint}_max_window_bits`;\n          const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n          this._deflate = zlib.createDeflateRaw({\n            ...this._options.zlibDeflateOptions,\n            windowBits\n          });\n          this._deflate[kTotalLength] = 0;\n          this._deflate[kBuffers] = [];\n          this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n          if (!this._deflate) {\n            return;\n          }\n          let data2 = bufferUtil.concat(\n            this._deflate[kBuffers],\n            this._deflate[kTotalLength]\n          );\n          if (fin) {\n            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);\n          }\n          this._deflate[kCallback] = null;\n          this._deflate[kTotalLength] = 0;\n          this._deflate[kBuffers] = [];\n          if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n            this._deflate.reset();\n          }\n          callback(null, data2);\n        });\n      }\n    };\n    module2.exports = PerMessageDeflate;\n    function deflateOnData(chunk) {\n      this[kBuffers].push(chunk);\n      this[kTotalLength] += chunk.length;\n    }\n    function inflateOnData(chunk) {\n      this[kTotalLength] += chunk.length;\n      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n      }\n      this[kError] = new RangeError(\"Max payload size exceeded\");\n      this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n      this[kError][kStatusCode] = 1009;\n      this.removeListener(\"data\", inflateOnData);\n      this.reset();\n    }\n    function inflateOnError(err) {\n      this[kPerMessageDeflate]._inflate = null;\n      if (this[kError]) {\n        this[kCallback](this[kError]);\n        return;\n      }\n      err[kStatusCode] = 1007;\n      this[kCallback](err);\n    }\n  }\n});\n\n// node_modules/ws/lib/validation.js\nvar require_validation3 = __commonJS({\n  \"node_modules/ws/lib/validation.js\"(exports2, module2) {\n    \"use strict\";\n    var { isUtf8 } = require(\"buffer\");\n    var { hasBlob } = require_constants3();\n    var tokenChars = [\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // 0 - 15\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // 16 - 31\n      0,\n      1,\n      0,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      1,\n      1,\n      0,\n      1,\n      1,\n      0,\n      // 32 - 47\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // 48 - 63\n      0,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      // 64 - 79\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      0,\n      1,\n      1,\n      // 80 - 95\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      // 96 - 111\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0\n      // 112 - 127\n    ];\n    function isValidStatusCode(code) {\n      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n    }\n    function _isValidUTF8(buf) {\n      const len = buf.length;\n      let i = 0;\n      while (i < len) {\n        if ((buf[i] & 128) === 0) {\n          i++;\n        } else if ((buf[i] & 224) === 192) {\n          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n            return false;\n          }\n          i += 2;\n        } else if ((buf[i] & 240) === 224) {\n          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong\n          buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n            return false;\n          }\n          i += 3;\n        } else if ((buf[i] & 248) === 240) {\n          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong\n          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n            return false;\n          }\n          i += 4;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    }\n    function isBlob(value) {\n      return hasBlob && typeof value === \"object\" && typeof value.arrayBuffer === \"function\" && typeof value.type === \"string\" && typeof value.stream === \"function\" && (value[Symbol.toStringTag] === \"Blob\" || value[Symbol.toStringTag] === \"File\");\n    }\n    module2.exports = {\n      isBlob,\n      isValidStatusCode,\n      isValidUTF8: _isValidUTF8,\n      tokenChars\n    };\n    if (isUtf8) {\n      module2.exports.isValidUTF8 = function(buf) {\n        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n      };\n    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n      try {\n        const isValidUTF8 = require(\"utf-8-validate\");\n        module2.exports.isValidUTF8 = function(buf) {\n          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        };\n      } catch (e) {\n      }\n    }\n  }\n});\n\n// node_modules/ws/lib/receiver.js\nvar require_receiver = __commonJS({\n  \"node_modules/ws/lib/receiver.js\"(exports2, module2) {\n    \"use strict\";\n    var { Writable } = require(\"stream\");\n    var PerMessageDeflate = require_permessage_deflate();\n    var {\n      BINARY_TYPES,\n      EMPTY_BUFFER,\n      kStatusCode,\n      kWebSocket\n    } = require_constants3();\n    var { concat, toArrayBuffer, unmask } = require_buffer_util();\n    var { isValidStatusCode, isValidUTF8 } = require_validation3();\n    var FastBuffer = Buffer[Symbol.species];\n    var GET_INFO = 0;\n    var GET_PAYLOAD_LENGTH_16 = 1;\n    var GET_PAYLOAD_LENGTH_64 = 2;\n    var GET_MASK = 3;\n    var GET_DATA = 4;\n    var INFLATING = 5;\n    var DEFER_EVENT = 6;\n    var Receiver2 = class extends Writable {\n      /**\n       * Creates a Receiver instance.\n       *\n       * @param {Object} [options] Options object\n       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n       *     multiple times in the same tick\n       * @param {String} [options.binaryType=nodebuffer] The type for binary data\n       * @param {Object} [options.extensions] An object containing the negotiated\n       *     extensions\n       * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n       *     client or server mode\n       * @param {Number} [options.maxPayload=0] The maximum allowed message length\n       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n       *     not to skip UTF-8 validation for text and close messages\n       */\n      constructor(options = {}) {\n        super();\n        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;\n        this._binaryType = options.binaryType || BINARY_TYPES[0];\n        this._extensions = options.extensions || {};\n        this._isServer = !!options.isServer;\n        this._maxPayload = options.maxPayload | 0;\n        this._skipUTF8Validation = !!options.skipUTF8Validation;\n        this[kWebSocket] = void 0;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = void 0;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._errored = false;\n        this._loop = false;\n        this._state = GET_INFO;\n      }\n      /**\n       * Implements `Writable.prototype._write()`.\n       *\n       * @param {Buffer} chunk The chunk of data to write\n       * @param {String} encoding The character encoding of `chunk`\n       * @param {Function} cb Callback\n       * @private\n       */\n      _write(chunk, encoding, cb) {\n        if (this._opcode === 8 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n      }\n      /**\n       * Consumes `n` bytes from the buffered data.\n       *\n       * @param {Number} n The number of bytes to consume\n       * @return {Buffer} The consumed bytes\n       * @private\n       */\n      consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n          const buf = this._buffers[0];\n          this._buffers[0] = new FastBuffer(\n            buf.buffer,\n            buf.byteOffset + n,\n            buf.length - n\n          );\n          return new FastBuffer(buf.buffer, buf.byteOffset, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n          const buf = this._buffers[0];\n          const offset = dst.length - n;\n          if (n >= buf.length) {\n            dst.set(this._buffers.shift(), offset);\n          } else {\n            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n            this._buffers[0] = new FastBuffer(\n              buf.buffer,\n              buf.byteOffset + n,\n              buf.length - n\n            );\n          }\n          n -= buf.length;\n        } while (n > 0);\n        return dst;\n      }\n      /**\n       * Starts the parsing loop.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      startLoop(cb) {\n        this._loop = true;\n        do {\n          switch (this._state) {\n            case GET_INFO:\n              this.getInfo(cb);\n              break;\n            case GET_PAYLOAD_LENGTH_16:\n              this.getPayloadLength16(cb);\n              break;\n            case GET_PAYLOAD_LENGTH_64:\n              this.getPayloadLength64(cb);\n              break;\n            case GET_MASK:\n              this.getMask();\n              break;\n            case GET_DATA:\n              this.getData(cb);\n              break;\n            case INFLATING:\n            case DEFER_EVENT:\n              this._loop = false;\n              return;\n          }\n        } while (this._loop);\n        if (!this._errored) cb();\n      }\n      /**\n       * Reads the first two bytes of a frame.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getInfo(cb) {\n        if (this._bufferedBytes < 2) {\n          this._loop = false;\n          return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 48) !== 0) {\n          const error = this.createError(\n            RangeError,\n            \"RSV2 and RSV3 must be clear\",\n            true,\n            1002,\n            \"WS_ERR_UNEXPECTED_RSV_2_3\"\n          );\n          cb(error);\n          return;\n        }\n        const compressed = (buf[0] & 64) === 64;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n          const error = this.createError(\n            RangeError,\n            \"RSV1 must be clear\",\n            true,\n            1002,\n            \"WS_ERR_UNEXPECTED_RSV_1\"\n          );\n          cb(error);\n          return;\n        }\n        this._fin = (buf[0] & 128) === 128;\n        this._opcode = buf[0] & 15;\n        this._payloadLength = buf[1] & 127;\n        if (this._opcode === 0) {\n          if (compressed) {\n            const error = this.createError(\n              RangeError,\n              \"RSV1 must be clear\",\n              true,\n              1002,\n              \"WS_ERR_UNEXPECTED_RSV_1\"\n            );\n            cb(error);\n            return;\n          }\n          if (!this._fragmented) {\n            const error = this.createError(\n              RangeError,\n              \"invalid opcode 0\",\n              true,\n              1002,\n              \"WS_ERR_INVALID_OPCODE\"\n            );\n            cb(error);\n            return;\n          }\n          this._opcode = this._fragmented;\n        } else if (this._opcode === 1 || this._opcode === 2) {\n          if (this._fragmented) {\n            const error = this.createError(\n              RangeError,\n              `invalid opcode ${this._opcode}`,\n              true,\n              1002,\n              \"WS_ERR_INVALID_OPCODE\"\n            );\n            cb(error);\n            return;\n          }\n          this._compressed = compressed;\n        } else if (this._opcode > 7 && this._opcode < 11) {\n          if (!this._fin) {\n            const error = this.createError(\n              RangeError,\n              \"FIN must be set\",\n              true,\n              1002,\n              \"WS_ERR_EXPECTED_FIN\"\n            );\n            cb(error);\n            return;\n          }\n          if (compressed) {\n            const error = this.createError(\n              RangeError,\n              \"RSV1 must be clear\",\n              true,\n              1002,\n              \"WS_ERR_UNEXPECTED_RSV_1\"\n            );\n            cb(error);\n            return;\n          }\n          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n            const error = this.createError(\n              RangeError,\n              `invalid payload length ${this._payloadLength}`,\n              true,\n              1002,\n              \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\n            );\n            cb(error);\n            return;\n          }\n        } else {\n          const error = this.createError(\n            RangeError,\n            `invalid opcode ${this._opcode}`,\n            true,\n            1002,\n            \"WS_ERR_INVALID_OPCODE\"\n          );\n          cb(error);\n          return;\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 128) === 128;\n        if (this._isServer) {\n          if (!this._masked) {\n            const error = this.createError(\n              RangeError,\n              \"MASK must be set\",\n              true,\n              1002,\n              \"WS_ERR_EXPECTED_MASK\"\n            );\n            cb(error);\n            return;\n          }\n        } else if (this._masked) {\n          const error = this.createError(\n            RangeError,\n            \"MASK must be clear\",\n            true,\n            1002,\n            \"WS_ERR_UNEXPECTED_MASK\"\n          );\n          cb(error);\n          return;\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else this.haveLength(cb);\n      }\n      /**\n       * Gets extended payload length (7+16).\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getPayloadLength16(cb) {\n        if (this._bufferedBytes < 2) {\n          this._loop = false;\n          return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        this.haveLength(cb);\n      }\n      /**\n       * Gets extended payload length (7+64).\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getPayloadLength64(cb) {\n        if (this._bufferedBytes < 8) {\n          this._loop = false;\n          return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        if (num > Math.pow(2, 53 - 32) - 1) {\n          const error = this.createError(\n            RangeError,\n            \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\n            false,\n            1009,\n            \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\n          );\n          cb(error);\n          return;\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        this.haveLength(cb);\n      }\n      /**\n       * Payload length has been read.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      haveLength(cb) {\n        if (this._payloadLength && this._opcode < 8) {\n          this._totalPayloadLength += this._payloadLength;\n          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n            const error = this.createError(\n              RangeError,\n              \"Max payload size exceeded\",\n              false,\n              1009,\n              \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n            );\n            cb(error);\n            return;\n          }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n      }\n      /**\n       * Reads mask bytes.\n       *\n       * @private\n       */\n      getMask() {\n        if (this._bufferedBytes < 4) {\n          this._loop = false;\n          return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n      }\n      /**\n       * Reads data bytes.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n          if (this._bufferedBytes < this._payloadLength) {\n            this._loop = false;\n            return;\n          }\n          data = this.consume(this._payloadLength);\n          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n            unmask(data, this._mask);\n          }\n        }\n        if (this._opcode > 7) {\n          this.controlMessage(data, cb);\n          return;\n        }\n        if (this._compressed) {\n          this._state = INFLATING;\n          this.decompress(data, cb);\n          return;\n        }\n        if (data.length) {\n          this._messageLength = this._totalPayloadLength;\n          this._fragments.push(data);\n        }\n        this.dataMessage(cb);\n      }\n      /**\n       * Decompresses data.\n       *\n       * @param {Buffer} data Compressed data\n       * @param {Function} cb Callback\n       * @private\n       */\n      decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n          if (err) return cb(err);\n          if (buf.length) {\n            this._messageLength += buf.length;\n            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n              const error = this.createError(\n                RangeError,\n                \"Max payload size exceeded\",\n                false,\n                1009,\n                \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n              );\n              cb(error);\n              return;\n            }\n            this._fragments.push(buf);\n          }\n          this.dataMessage(cb);\n          if (this._state === GET_INFO) this.startLoop(cb);\n        });\n      }\n      /**\n       * Handles a data message.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      dataMessage(cb) {\n        if (!this._fin) {\n          this._state = GET_INFO;\n          return;\n        }\n        const messageLength = this._messageLength;\n        const fragments = this._fragments;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragmented = 0;\n        this._fragments = [];\n        if (this._opcode === 2) {\n          let data;\n          if (this._binaryType === \"nodebuffer\") {\n            data = concat(fragments, messageLength);\n          } else if (this._binaryType === \"arraybuffer\") {\n            data = toArrayBuffer(concat(fragments, messageLength));\n          } else if (this._binaryType === \"blob\") {\n            data = new Blob(fragments);\n          } else {\n            data = fragments;\n          }\n          if (this._allowSynchronousEvents) {\n            this.emit(\"message\", data, true);\n            this._state = GET_INFO;\n          } else {\n            this._state = DEFER_EVENT;\n            setImmediate(() => {\n              this.emit(\"message\", data, true);\n              this._state = GET_INFO;\n              this.startLoop(cb);\n            });\n          }\n        } else {\n          const buf = concat(fragments, messageLength);\n          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n            const error = this.createError(\n              Error,\n              \"invalid UTF-8 sequence\",\n              true,\n              1007,\n              \"WS_ERR_INVALID_UTF8\"\n            );\n            cb(error);\n            return;\n          }\n          if (this._state === INFLATING || this._allowSynchronousEvents) {\n            this.emit(\"message\", buf, false);\n            this._state = GET_INFO;\n          } else {\n            this._state = DEFER_EVENT;\n            setImmediate(() => {\n              this.emit(\"message\", buf, false);\n              this._state = GET_INFO;\n              this.startLoop(cb);\n            });\n          }\n        }\n      }\n      /**\n       * Handles a control message.\n       *\n       * @param {Buffer} data Data to handle\n       * @return {(Error|RangeError|undefined)} A possible error\n       * @private\n       */\n      controlMessage(data, cb) {\n        if (this._opcode === 8) {\n          if (data.length === 0) {\n            this._loop = false;\n            this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n            this.end();\n          } else {\n            const code = data.readUInt16BE(0);\n            if (!isValidStatusCode(code)) {\n              const error = this.createError(\n                RangeError,\n                `invalid status code ${code}`,\n                true,\n                1002,\n                \"WS_ERR_INVALID_CLOSE_CODE\"\n              );\n              cb(error);\n              return;\n            }\n            const buf = new FastBuffer(\n              data.buffer,\n              data.byteOffset + 2,\n              data.length - 2\n            );\n            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n              const error = this.createError(\n                Error,\n                \"invalid UTF-8 sequence\",\n                true,\n                1007,\n                \"WS_ERR_INVALID_UTF8\"\n              );\n              cb(error);\n              return;\n            }\n            this._loop = false;\n            this.emit(\"conclude\", code, buf);\n            this.end();\n          }\n          this._state = GET_INFO;\n          return;\n        }\n        if (this._allowSynchronousEvents) {\n          this.emit(this._opcode === 9 ? \"ping\" : \"pong\", data);\n          this._state = GET_INFO;\n        } else {\n          this._state = DEFER_EVENT;\n          setImmediate(() => {\n            this.emit(this._opcode === 9 ? \"ping\" : \"pong\", data);\n            this._state = GET_INFO;\n            this.startLoop(cb);\n          });\n        }\n      }\n      /**\n       * Builds an error object.\n       *\n       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n       * @param {String} message The error message\n       * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n       *     `message`\n       * @param {Number} statusCode The status code\n       * @param {String} errorCode The exposed error code\n       * @return {(Error|RangeError)} The error\n       * @private\n       */\n      createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n        this._loop = false;\n        this._errored = true;\n        const err = new ErrorCtor(\n          prefix ? `Invalid WebSocket frame: ${message}` : message\n        );\n        Error.captureStackTrace(err, this.createError);\n        err.code = errorCode;\n        err[kStatusCode] = statusCode;\n        return err;\n      }\n    };\n    module2.exports = Receiver2;\n  }\n});\n\n// node_modules/ws/lib/sender.js\nvar require_sender = __commonJS({\n  \"node_modules/ws/lib/sender.js\"(exports2, module2) {\n    \"use strict\";\n    var { Duplex } = require(\"stream\");\n    var { randomFillSync } = require(\"crypto\");\n    var PerMessageDeflate = require_permessage_deflate();\n    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants3();\n    var { isBlob, isValidStatusCode } = require_validation3();\n    var { mask: applyMask, toBuffer } = require_buffer_util();\n    var kByteLength = /* @__PURE__ */ Symbol(\"kByteLength\");\n    var maskBuffer = Buffer.alloc(4);\n    var RANDOM_POOL_SIZE = 8 * 1024;\n    var randomPool;\n    var randomPoolPointer = RANDOM_POOL_SIZE;\n    var DEFAULT = 0;\n    var DEFLATING = 1;\n    var GET_BLOB_DATA = 2;\n    var Sender2 = class _Sender {\n      /**\n       * Creates a Sender instance.\n       *\n       * @param {Duplex} socket The connection socket\n       * @param {Object} [extensions] An object containing the negotiated extensions\n       * @param {Function} [generateMask] The function used to generate the masking\n       *     key\n       */\n      constructor(socket, extensions, generateMask) {\n        this._extensions = extensions || {};\n        if (generateMask) {\n          this._generateMask = generateMask;\n          this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = void 0;\n      }\n      /**\n       * Frames a piece of data according to the HyBi WebSocket protocol.\n       *\n       * @param {(Buffer|String)} data The data to frame\n       * @param {Object} options Options object\n       * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n       *     FIN bit\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n       *     key\n       * @param {Number} options.opcode The opcode\n       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n       *     modified\n       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n       *     RSV1 bit\n       * @return {(Buffer|String)[]} The framed data\n       * @public\n       */\n      static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n          mask = options.maskBuffer || maskBuffer;\n          if (options.generateMask) {\n            options.generateMask(mask);\n          } else {\n            if (randomPoolPointer === RANDOM_POOL_SIZE) {\n              if (randomPool === void 0) {\n                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n              }\n              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n              randomPoolPointer = 0;\n            }\n            mask[0] = randomPool[randomPoolPointer++];\n            mask[1] = randomPool[randomPoolPointer++];\n            mask[2] = randomPool[randomPoolPointer++];\n            mask[3] = randomPool[randomPoolPointer++];\n          }\n          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n          offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n            dataLength = options[kByteLength];\n          } else {\n            data = Buffer.from(data);\n            dataLength = data.length;\n          }\n        } else {\n          dataLength = data.length;\n          merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n          offset += 8;\n          payloadLength = 127;\n        } else if (dataLength > 125) {\n          offset += 2;\n          payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 128 : options.opcode;\n        if (options.rsv1) target[0] |= 64;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n          target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n          target[2] = target[3] = 0;\n          target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [target, data];\n        target[1] |= 128;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [target, data];\n        if (merge) {\n          applyMask(data, mask, target, offset, dataLength);\n          return [target];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [target, data];\n      }\n      /**\n       * Sends a close message to the other peer.\n       *\n       * @param {Number} [code] The status code component of the body\n       * @param {(String|Buffer)} [data] The message component of the body\n       * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      close(code, data, mask, cb) {\n        let buf;\n        if (code === void 0) {\n          buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n          throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === void 0 || !data.length) {\n          buf = Buffer.allocUnsafe(2);\n          buf.writeUInt16BE(code, 0);\n        } else {\n          const length = Buffer.byteLength(data);\n          if (length > 123) {\n            throw new RangeError(\"The message must not be greater than 123 bytes\");\n          }\n          buf = Buffer.allocUnsafe(2 + length);\n          buf.writeUInt16BE(code, 0);\n          if (typeof data === \"string\") {\n            buf.write(data, 2);\n          } else {\n            buf.set(data, 2);\n          }\n        }\n        const options = {\n          [kByteLength]: buf.length,\n          fin: true,\n          generateMask: this._generateMask,\n          mask,\n          maskBuffer: this._maskBuffer,\n          opcode: 8,\n          readOnly: false,\n          rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, buf, false, options, cb]);\n        } else {\n          this.sendFrame(_Sender.frame(buf, options), cb);\n        }\n      }\n      /**\n       * Sends a ping message to the other peer.\n       *\n       * @param {*} data The message to send\n       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n          byteLength = Buffer.byteLength(data);\n          readOnly = false;\n        } else if (isBlob(data)) {\n          byteLength = data.size;\n          readOnly = false;\n        } else {\n          data = toBuffer(data);\n          byteLength = data.length;\n          readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n          throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n          [kByteLength]: byteLength,\n          fin: true,\n          generateMask: this._generateMask,\n          mask,\n          maskBuffer: this._maskBuffer,\n          opcode: 9,\n          readOnly,\n          rsv1: false\n        };\n        if (isBlob(data)) {\n          if (this._state !== DEFAULT) {\n            this.enqueue([this.getBlobData, data, false, options, cb]);\n          } else {\n            this.getBlobData(data, false, options, cb);\n          }\n        } else if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, data, false, options, cb]);\n        } else {\n          this.sendFrame(_Sender.frame(data, options), cb);\n        }\n      }\n      /**\n       * Sends a pong message to the other peer.\n       *\n       * @param {*} data The message to send\n       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n          byteLength = Buffer.byteLength(data);\n          readOnly = false;\n        } else if (isBlob(data)) {\n          byteLength = data.size;\n          readOnly = false;\n        } else {\n          data = toBuffer(data);\n          byteLength = data.length;\n          readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n          throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n          [kByteLength]: byteLength,\n          fin: true,\n          generateMask: this._generateMask,\n          mask,\n          maskBuffer: this._maskBuffer,\n          opcode: 10,\n          readOnly,\n          rsv1: false\n        };\n        if (isBlob(data)) {\n          if (this._state !== DEFAULT) {\n            this.enqueue([this.getBlobData, data, false, options, cb]);\n          } else {\n            this.getBlobData(data, false, options, cb);\n          }\n        } else if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, data, false, options, cb]);\n        } else {\n          this.sendFrame(_Sender.frame(data, options), cb);\n        }\n      }\n      /**\n       * Sends a data message to the other peer.\n       *\n       * @param {*} data The message to send\n       * @param {Object} options Options object\n       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n       *     or text\n       * @param {Boolean} [options.compress=false] Specifies whether or not to\n       *     compress `data`\n       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n       *     last one\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n          byteLength = Buffer.byteLength(data);\n          readOnly = false;\n        } else if (isBlob(data)) {\n          byteLength = data.size;\n          readOnly = false;\n        } else {\n          data = toBuffer(data);\n          byteLength = data.length;\n          readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n          this._firstFragment = false;\n          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n            rsv1 = byteLength >= perMessageDeflate._threshold;\n          }\n          this._compress = rsv1;\n        } else {\n          rsv1 = false;\n          opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1\n        };\n        if (isBlob(data)) {\n          if (this._state !== DEFAULT) {\n            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n          } else {\n            this.getBlobData(data, this._compress, opts, cb);\n          }\n        } else if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n        } else {\n          this.dispatch(data, this._compress, opts, cb);\n        }\n      }\n      /**\n       * Gets the contents of a blob as binary data.\n       *\n       * @param {Blob} blob The blob\n       * @param {Boolean} [compress=false] Specifies whether or not to compress\n       *     the data\n       * @param {Object} options Options object\n       * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n       *     FIN bit\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n       *     key\n       * @param {Number} options.opcode The opcode\n       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n       *     modified\n       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n       *     RSV1 bit\n       * @param {Function} [cb] Callback\n       * @private\n       */\n      getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer) => {\n          if (this._socket.destroyed) {\n            const err = new Error(\n              \"The socket was closed while the blob was being read\"\n            );\n            process.nextTick(callCallbacks, this, err, cb);\n            return;\n          }\n          this._bufferedBytes -= options[kByteLength];\n          const data = toBuffer(arrayBuffer);\n          if (!compress) {\n            this._state = DEFAULT;\n            this.sendFrame(_Sender.frame(data, options), cb);\n            this.dequeue();\n          } else {\n            this.dispatch(data, compress, options, cb);\n          }\n        }).catch((err) => {\n          process.nextTick(onError, this, err, cb);\n        });\n      }\n      /**\n       * Dispatches a message.\n       *\n       * @param {(Buffer|String)} data The message to send\n       * @param {Boolean} [compress=false] Specifies whether or not to compress\n       *     `data`\n       * @param {Object} options Options object\n       * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n       *     FIN bit\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n       *     key\n       * @param {Number} options.opcode The opcode\n       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n       *     modified\n       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n       *     RSV1 bit\n       * @param {Function} [cb] Callback\n       * @private\n       */\n      dispatch(data, compress, options, cb) {\n        if (!compress) {\n          this.sendFrame(_Sender.frame(data, options), cb);\n          return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf) => {\n          if (this._socket.destroyed) {\n            const err = new Error(\n              \"The socket was closed while data was being compressed\"\n            );\n            callCallbacks(this, err, cb);\n            return;\n          }\n          this._bufferedBytes -= options[kByteLength];\n          this._state = DEFAULT;\n          options.readOnly = false;\n          this.sendFrame(_Sender.frame(buf, options), cb);\n          this.dequeue();\n        });\n      }\n      /**\n       * Executes queued send operations.\n       *\n       * @private\n       */\n      dequeue() {\n        while (this._state === DEFAULT && this._queue.length) {\n          const params = this._queue.shift();\n          this._bufferedBytes -= params[3][kByteLength];\n          Reflect.apply(params[0], this, params.slice(1));\n        }\n      }\n      /**\n       * Enqueues a send operation.\n       *\n       * @param {Array} params Send operation parameters.\n       * @private\n       */\n      enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n      }\n      /**\n       * Sends a frame.\n       *\n       * @param {(Buffer | String)[]} list The frame to send\n       * @param {Function} [cb] Callback\n       * @private\n       */\n      sendFrame(list, cb) {\n        if (list.length === 2) {\n          this._socket.cork();\n          this._socket.write(list[0]);\n          this._socket.write(list[1], cb);\n          this._socket.uncork();\n        } else {\n          this._socket.write(list[0], cb);\n        }\n      }\n    };\n    module2.exports = Sender2;\n    function callCallbacks(sender, err, cb) {\n      if (typeof cb === \"function\") cb(err);\n      for (let i = 0; i < sender._queue.length; i++) {\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === \"function\") callback(err);\n      }\n    }\n    function onError(sender, err, cb) {\n      callCallbacks(sender, err, cb);\n      sender.onerror(err);\n    }\n  }\n});\n\n// node_modules/ws/lib/event-target.js\nvar require_event_target = __commonJS({\n  \"node_modules/ws/lib/event-target.js\"(exports2, module2) {\n    \"use strict\";\n    var { kForOnEventAttribute, kListener } = require_constants3();\n    var kCode = /* @__PURE__ */ Symbol(\"kCode\");\n    var kData = /* @__PURE__ */ Symbol(\"kData\");\n    var kError = /* @__PURE__ */ Symbol(\"kError\");\n    var kMessage = /* @__PURE__ */ Symbol(\"kMessage\");\n    var kReason = /* @__PURE__ */ Symbol(\"kReason\");\n    var kTarget = /* @__PURE__ */ Symbol(\"kTarget\");\n    var kType = /* @__PURE__ */ Symbol(\"kType\");\n    var kWasClean = /* @__PURE__ */ Symbol(\"kWasClean\");\n    var Event = class {\n      /**\n       * Create a new `Event`.\n       *\n       * @param {String} type The name of the event\n       * @throws {TypeError} If the `type` argument is not specified\n       */\n      constructor(type) {\n        this[kTarget] = null;\n        this[kType] = type;\n      }\n      /**\n       * @type {*}\n       */\n      get target() {\n        return this[kTarget];\n      }\n      /**\n       * @type {String}\n       */\n      get type() {\n        return this[kType];\n      }\n    };\n    Object.defineProperty(Event.prototype, \"target\", { enumerable: true });\n    Object.defineProperty(Event.prototype, \"type\", { enumerable: true });\n    var CloseEvent = class extends Event {\n      /**\n       * Create a new `CloseEvent`.\n       *\n       * @param {String} type The name of the event\n       * @param {Object} [options] A dictionary object that allows for setting\n       *     attributes via object members of the same name\n       * @param {Number} [options.code=0] The status code explaining why the\n       *     connection was closed\n       * @param {String} [options.reason=''] A human-readable string explaining why\n       *     the connection was closed\n       * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n       *     connection was cleanly closed\n       */\n      constructor(type, options = {}) {\n        super(type);\n        this[kCode] = options.code === void 0 ? 0 : options.code;\n        this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n      }\n      /**\n       * @type {Number}\n       */\n      get code() {\n        return this[kCode];\n      }\n      /**\n       * @type {String}\n       */\n      get reason() {\n        return this[kReason];\n      }\n      /**\n       * @type {Boolean}\n       */\n      get wasClean() {\n        return this[kWasClean];\n      }\n    };\n    Object.defineProperty(CloseEvent.prototype, \"code\", { enumerable: true });\n    Object.defineProperty(CloseEvent.prototype, \"reason\", { enumerable: true });\n    Object.defineProperty(CloseEvent.prototype, \"wasClean\", { enumerable: true });\n    var ErrorEvent = class extends Event {\n      /**\n       * Create a new `ErrorEvent`.\n       *\n       * @param {String} type The name of the event\n       * @param {Object} [options] A dictionary object that allows for setting\n       *     attributes via object members of the same name\n       * @param {*} [options.error=null] The error that generated this event\n       * @param {String} [options.message=''] The error message\n       */\n      constructor(type, options = {}) {\n        super(type);\n        this[kError] = options.error === void 0 ? null : options.error;\n        this[kMessage] = options.message === void 0 ? \"\" : options.message;\n      }\n      /**\n       * @type {*}\n       */\n      get error() {\n        return this[kError];\n      }\n      /**\n       * @type {String}\n       */\n      get message() {\n        return this[kMessage];\n      }\n    };\n    Object.defineProperty(ErrorEvent.prototype, \"error\", { enumerable: true });\n    Object.defineProperty(ErrorEvent.prototype, \"message\", { enumerable: true });\n    var MessageEvent = class extends Event {\n      /**\n       * Create a new `MessageEvent`.\n       *\n       * @param {String} type The name of the event\n       * @param {Object} [options] A dictionary object that allows for setting\n       *     attributes via object members of the same name\n       * @param {*} [options.data=null] The message content\n       */\n      constructor(type, options = {}) {\n        super(type);\n        this[kData] = options.data === void 0 ? null : options.data;\n      }\n      /**\n       * @type {*}\n       */\n      get data() {\n        return this[kData];\n      }\n    };\n    Object.defineProperty(MessageEvent.prototype, \"data\", { enumerable: true });\n    var EventTarget = {\n      /**\n       * Register an event listener.\n       *\n       * @param {String} type A string representing the event type to listen for\n       * @param {(Function|Object)} handler The listener to add\n       * @param {Object} [options] An options object specifies characteristics about\n       *     the event listener\n       * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n       *     listener should be invoked at most once after being added. If `true`,\n       *     the listener would be automatically removed when invoked.\n       * @public\n       */\n      addEventListener(type, handler, options = {}) {\n        for (const listener of this.listeners(type)) {\n          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n            return;\n          }\n        }\n        let wrapper;\n        if (type === \"message\") {\n          wrapper = function onMessage(data, isBinary) {\n            const event = new MessageEvent(\"message\", {\n              data: isBinary ? data : data.toString()\n            });\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else if (type === \"close\") {\n          wrapper = function onClose(code, message) {\n            const event = new CloseEvent(\"close\", {\n              code,\n              reason: message.toString(),\n              wasClean: this._closeFrameReceived && this._closeFrameSent\n            });\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else if (type === \"error\") {\n          wrapper = function onError(error) {\n            const event = new ErrorEvent(\"error\", {\n              error,\n              message: error.message\n            });\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else if (type === \"open\") {\n          wrapper = function onOpen() {\n            const event = new Event(\"open\");\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else {\n          return;\n        }\n        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n        wrapper[kListener] = handler;\n        if (options.once) {\n          this.once(type, wrapper);\n        } else {\n          this.on(type, wrapper);\n        }\n      },\n      /**\n       * Remove an event listener.\n       *\n       * @param {String} type A string representing the event type to remove\n       * @param {(Function|Object)} handler The listener to remove\n       * @public\n       */\n      removeEventListener(type, handler) {\n        for (const listener of this.listeners(type)) {\n          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n            this.removeListener(type, listener);\n            break;\n          }\n        }\n      }\n    };\n    module2.exports = {\n      CloseEvent,\n      ErrorEvent,\n      Event,\n      EventTarget,\n      MessageEvent\n    };\n    function callListener(listener, thisArg, event) {\n      if (typeof listener === \"object\" && listener.handleEvent) {\n        listener.handleEvent.call(listener, event);\n      } else {\n        listener.call(thisArg, event);\n      }\n    }\n  }\n});\n\n// node_modules/ws/lib/extension.js\nvar require_extension = __commonJS({\n  \"node_modules/ws/lib/extension.js\"(exports2, module2) {\n    \"use strict\";\n    var { tokenChars } = require_validation3();\n    function push(dest, name, elem) {\n      if (dest[name] === void 0) dest[name] = [elem];\n      else dest[name].push(elem);\n    }\n    function parse(header) {\n      const offers = /* @__PURE__ */ Object.create(null);\n      let params = /* @__PURE__ */ Object.create(null);\n      let mustUnescape = false;\n      let isEscaping = false;\n      let inQuotes = false;\n      let extensionName;\n      let paramName;\n      let start = -1;\n      let code = -1;\n      let end = -1;\n      let i = 0;\n      for (; i < header.length; i++) {\n        code = header.charCodeAt(i);\n        if (extensionName === void 0) {\n          if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n          } else if (i !== 0 && (code === 32 || code === 9)) {\n            if (end === -1 && start !== -1) end = i;\n          } else if (code === 59 || code === 44) {\n            if (start === -1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            const name = header.slice(start, end);\n            if (code === 44) {\n              push(offers, name, params);\n              params = /* @__PURE__ */ Object.create(null);\n            } else {\n              extensionName = name;\n            }\n            start = end = -1;\n          } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n        } else if (paramName === void 0) {\n          if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n          } else if (code === 32 || code === 9) {\n            if (end === -1 && start !== -1) end = i;\n          } else if (code === 59 || code === 44) {\n            if (start === -1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            push(params, header.slice(start, end), true);\n            if (code === 44) {\n              push(offers, extensionName, params);\n              params = /* @__PURE__ */ Object.create(null);\n              extensionName = void 0;\n            }\n            start = end = -1;\n          } else if (code === 61 && start !== -1 && end === -1) {\n            paramName = header.slice(start, i);\n            start = end = -1;\n          } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n        } else {\n          if (isEscaping) {\n            if (tokenChars[code] !== 1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (start === -1) start = i;\n            else if (!mustUnescape) mustUnescape = true;\n            isEscaping = false;\n          } else if (inQuotes) {\n            if (tokenChars[code] === 1) {\n              if (start === -1) start = i;\n            } else if (code === 34 && start !== -1) {\n              inQuotes = false;\n              end = i;\n            } else if (code === 92) {\n              isEscaping = true;\n            } else {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n            inQuotes = true;\n          } else if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n          } else if (start !== -1 && (code === 32 || code === 9)) {\n            if (end === -1) end = i;\n          } else if (code === 59 || code === 44) {\n            if (start === -1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            let value = header.slice(start, end);\n            if (mustUnescape) {\n              value = value.replace(/\\\\/g, \"\");\n              mustUnescape = false;\n            }\n            push(params, paramName, value);\n            if (code === 44) {\n              push(offers, extensionName, params);\n              params = /* @__PURE__ */ Object.create(null);\n              extensionName = void 0;\n            }\n            paramName = void 0;\n            start = end = -1;\n          } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n        }\n      }\n      if (start === -1 || inQuotes || code === 32 || code === 9) {\n        throw new SyntaxError(\"Unexpected end of input\");\n      }\n      if (end === -1) end = i;\n      const token = header.slice(start, end);\n      if (extensionName === void 0) {\n        push(offers, token, params);\n      } else {\n        if (paramName === void 0) {\n          push(params, token, true);\n        } else if (mustUnescape) {\n          push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n          push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n      }\n      return offers;\n    }\n    function format(extensions) {\n      return Object.keys(extensions).map((extension) => {\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [configurations];\n        return configurations.map((params) => {\n          return [extension].concat(\n            Object.keys(params).map((k) => {\n              let values = params[k];\n              if (!Array.isArray(values)) values = [values];\n              return values.map((v) => v === true ? k : `${k}=${v}`).join(\"; \");\n            })\n          ).join(\"; \");\n        }).join(\", \");\n      }).join(\", \");\n    }\n    module2.exports = { format, parse };\n  }\n});\n\n// node_modules/ws/lib/websocket.js\nvar require_websocket = __commonJS({\n  \"node_modules/ws/lib/websocket.js\"(exports2, module2) {\n    \"use strict\";\n    var EventEmitter2 = require(\"events\");\n    var https = require(\"https\");\n    var http = require(\"http\");\n    var net = require(\"net\");\n    var tls = require(\"tls\");\n    var { randomBytes, createHash } = require(\"crypto\");\n    var { Duplex, Readable } = require(\"stream\");\n    var { URL: URL2 } = require(\"url\");\n    var PerMessageDeflate = require_permessage_deflate();\n    var Receiver2 = require_receiver();\n    var Sender2 = require_sender();\n    var { isBlob } = require_validation3();\n    var {\n      BINARY_TYPES,\n      EMPTY_BUFFER,\n      GUID,\n      kForOnEventAttribute,\n      kListener,\n      kStatusCode,\n      kWebSocket,\n      NOOP\n    } = require_constants3();\n    var {\n      EventTarget: { addEventListener, removeEventListener }\n    } = require_event_target();\n    var { format, parse } = require_extension();\n    var { toBuffer } = require_buffer_util();\n    var closeTimeout = 30 * 1e3;\n    var kAborted = /* @__PURE__ */ Symbol(\"kAborted\");\n    var protocolVersions = [8, 13];\n    var readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\n    var subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n    var WebSocket2 = class _WebSocket extends EventEmitter2 {\n      /**\n       * Create a new `WebSocket`.\n       *\n       * @param {(String|URL)} address The URL to which to connect\n       * @param {(String|String[])} [protocols] The subprotocols\n       * @param {Object} [options] Connection options\n       */\n      constructor(address, protocols, options) {\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = EMPTY_BUFFER;\n        this._closeTimer = null;\n        this._errorEmitted = false;\n        this._extensions = {};\n        this._paused = false;\n        this._protocol = \"\";\n        this._readyState = _WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n          this._bufferedAmount = 0;\n          this._isServer = false;\n          this._redirects = 0;\n          if (protocols === void 0) {\n            protocols = [];\n          } else if (!Array.isArray(protocols)) {\n            if (typeof protocols === \"object\" && protocols !== null) {\n              options = protocols;\n              protocols = [];\n            } else {\n              protocols = [protocols];\n            }\n          }\n          initAsClient(this, address, protocols, options);\n        } else {\n          this._autoPong = options.autoPong;\n          this._isServer = true;\n        }\n      }\n      /**\n       * For historical reasons, the custom \"nodebuffer\" type is used by the default\n       * instead of \"blob\".\n       *\n       * @type {String}\n       */\n      get binaryType() {\n        return this._binaryType;\n      }\n      set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        if (this._receiver) this._receiver._binaryType = type;\n      }\n      /**\n       * @type {Number}\n       */\n      get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n      }\n      /**\n       * @type {String}\n       */\n      get extensions() {\n        return Object.keys(this._extensions).join();\n      }\n      /**\n       * @type {Boolean}\n       */\n      get isPaused() {\n        return this._paused;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onclose() {\n        return null;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onerror() {\n        return null;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onopen() {\n        return null;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onmessage() {\n        return null;\n      }\n      /**\n       * @type {String}\n       */\n      get protocol() {\n        return this._protocol;\n      }\n      /**\n       * @type {Number}\n       */\n      get readyState() {\n        return this._readyState;\n      }\n      /**\n       * @type {String}\n       */\n      get url() {\n        return this._url;\n      }\n      /**\n       * Set up the socket and the internal resources.\n       *\n       * @param {Duplex} socket The network socket between the server and client\n       * @param {Buffer} head The first packet of the upgraded stream\n       * @param {Object} options Options object\n       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n       *     multiple times in the same tick\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Number} [options.maxPayload=0] The maximum allowed message size\n       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n       *     not to skip UTF-8 validation for text and close messages\n       * @private\n       */\n      setSocket(socket, head, options) {\n        const receiver = new Receiver2({\n          allowSynchronousEvents: options.allowSynchronousEvents,\n          binaryType: this.binaryType,\n          extensions: this._extensions,\n          isServer: this._isServer,\n          maxPayload: options.maxPayload,\n          skipUTF8Validation: options.skipUTF8Validation\n        });\n        const sender = new Sender2(socket, this._extensions, options.generateMask);\n        this._receiver = receiver;\n        this._sender = sender;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        sender[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        sender.onerror = senderOnError;\n        if (socket.setTimeout) socket.setTimeout(0);\n        if (socket.setNoDelay) socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = _WebSocket.OPEN;\n        this.emit(\"open\");\n      }\n      /**\n       * Emit the `'close'` event.\n       *\n       * @private\n       */\n      emitClose() {\n        if (!this._socket) {\n          this._readyState = _WebSocket.CLOSED;\n          this.emit(\"close\", this._closeCode, this._closeMessage);\n          return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n          this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = _WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n      }\n      /**\n       * Start a closing handshake.\n       *\n       *          +----------+   +-----------+   +----------+\n       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n       *    |     +----------+   +-----------+   +----------+     |\n       *          +----------+   +-----------+         |\n       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n       *          +----------+   +-----------+   |\n       *    |           |                        |   +---+        |\n       *                +------------------------+-->|fin| - - - -\n       *    |         +---+                      |   +---+\n       *     - - - - -|fin|<---------------------+\n       *              +---+\n       *\n       * @param {Number} [code] Status code explaining why the connection is closing\n       * @param {(String|Buffer)} [data] The reason why the connection is\n       *     closing\n       * @public\n       */\n      close(code, data) {\n        if (this.readyState === _WebSocket.CLOSED) return;\n        if (this.readyState === _WebSocket.CONNECTING) {\n          const msg = \"WebSocket was closed before the connection was established\";\n          abortHandshake(this, this._req, msg);\n          return;\n        }\n        if (this.readyState === _WebSocket.CLOSING) {\n          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n            this._socket.end();\n          }\n          return;\n        }\n        this._readyState = _WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err) => {\n          if (err) return;\n          this._closeFrameSent = true;\n          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n            this._socket.end();\n          }\n        });\n        setCloseTimer(this);\n      }\n      /**\n       * Pause the socket.\n       *\n       * @public\n       */\n      pause() {\n        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {\n          return;\n        }\n        this._paused = true;\n        this._socket.pause();\n      }\n      /**\n       * Send a ping.\n       *\n       * @param {*} [data] The data to send\n       * @param {Boolean} [mask] Indicates whether or not to mask `data`\n       * @param {Function} [cb] Callback which is executed when the ping is sent\n       * @public\n       */\n      ping(data, mask, cb) {\n        if (this.readyState === _WebSocket.CONNECTING) {\n          throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n          cb = data;\n          data = mask = void 0;\n        } else if (typeof mask === \"function\") {\n          cb = mask;\n          mask = void 0;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== _WebSocket.OPEN) {\n          sendAfterClose(this, data, cb);\n          return;\n        }\n        if (mask === void 0) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n      }\n      /**\n       * Send a pong.\n       *\n       * @param {*} [data] The data to send\n       * @param {Boolean} [mask] Indicates whether or not to mask `data`\n       * @param {Function} [cb] Callback which is executed when the pong is sent\n       * @public\n       */\n      pong(data, mask, cb) {\n        if (this.readyState === _WebSocket.CONNECTING) {\n          throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n          cb = data;\n          data = mask = void 0;\n        } else if (typeof mask === \"function\") {\n          cb = mask;\n          mask = void 0;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== _WebSocket.OPEN) {\n          sendAfterClose(this, data, cb);\n          return;\n        }\n        if (mask === void 0) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n      }\n      /**\n       * Resume the socket.\n       *\n       * @public\n       */\n      resume() {\n        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {\n          return;\n        }\n        this._paused = false;\n        if (!this._receiver._writableState.needDrain) this._socket.resume();\n      }\n      /**\n       * Send a data message.\n       *\n       * @param {*} data The message to send\n       * @param {Object} [options] Options object\n       * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n       *     text\n       * @param {Boolean} [options.compress] Specifies whether or not to compress\n       *     `data`\n       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n       *     last one\n       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n       * @param {Function} [cb] Callback which is executed when data is written out\n       * @public\n       */\n      send(data, options, cb) {\n        if (this.readyState === _WebSocket.CONNECTING) {\n          throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n          cb = options;\n          options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== _WebSocket.OPEN) {\n          sendAfterClose(this, data, cb);\n          return;\n        }\n        const opts = {\n          binary: typeof data !== \"string\",\n          mask: !this._isServer,\n          compress: true,\n          fin: true,\n          ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n          opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n      }\n      /**\n       * Forcibly close the connection.\n       *\n       * @public\n       */\n      terminate() {\n        if (this.readyState === _WebSocket.CLOSED) return;\n        if (this.readyState === _WebSocket.CONNECTING) {\n          const msg = \"WebSocket was closed before the connection was established\";\n          abortHandshake(this, this._req, msg);\n          return;\n        }\n        if (this._socket) {\n          this._readyState = _WebSocket.CLOSING;\n          this._socket.destroy();\n        }\n      }\n    };\n    Object.defineProperty(WebSocket2, \"CONNECTING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CONNECTING\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"CONNECTING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CONNECTING\")\n    });\n    Object.defineProperty(WebSocket2, \"OPEN\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"OPEN\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"OPEN\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"OPEN\")\n    });\n    Object.defineProperty(WebSocket2, \"CLOSING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSING\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"CLOSING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSING\")\n    });\n    Object.defineProperty(WebSocket2, \"CLOSED\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSED\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"CLOSED\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSED\")\n    });\n    [\n      \"binaryType\",\n      \"bufferedAmount\",\n      \"extensions\",\n      \"isPaused\",\n      \"protocol\",\n      \"readyState\",\n      \"url\"\n    ].forEach((property) => {\n      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });\n    });\n    [\"open\", \"error\", \"close\", \"message\"].forEach((method) => {\n      Object.defineProperty(WebSocket2.prototype, `on${method}`, {\n        enumerable: true,\n        get() {\n          for (const listener of this.listeners(method)) {\n            if (listener[kForOnEventAttribute]) return listener[kListener];\n          }\n          return null;\n        },\n        set(handler) {\n          for (const listener of this.listeners(method)) {\n            if (listener[kForOnEventAttribute]) {\n              this.removeListener(method, listener);\n              break;\n            }\n          }\n          if (typeof handler !== \"function\") return;\n          this.addEventListener(method, handler, {\n            [kForOnEventAttribute]: true\n          });\n        }\n      });\n    });\n    WebSocket2.prototype.addEventListener = addEventListener;\n    WebSocket2.prototype.removeEventListener = removeEventListener;\n    module2.exports = WebSocket2;\n    function initAsClient(websocket, address, protocols, options) {\n      const opts = {\n        allowSynchronousEvents: true,\n        autoPong: true,\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        skipUTF8Validation: false,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        socketPath: void 0,\n        hostname: void 0,\n        protocol: void 0,\n        timeout: void 0,\n        method: \"GET\",\n        host: void 0,\n        path: void 0,\n        port: void 0\n      };\n      websocket._autoPong = opts.autoPong;\n      if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(\n          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`\n        );\n      }\n      let parsedUrl;\n      if (address instanceof URL2) {\n        parsedUrl = address;\n      } else {\n        try {\n          parsedUrl = new URL2(address);\n        } catch (e) {\n          throw new SyntaxError(`Invalid URL: ${address}`);\n        }\n      }\n      if (parsedUrl.protocol === \"http:\") {\n        parsedUrl.protocol = \"ws:\";\n      } else if (parsedUrl.protocol === \"https:\") {\n        parsedUrl.protocol = \"wss:\";\n      }\n      websocket._url = parsedUrl.href;\n      const isSecure = parsedUrl.protocol === \"wss:\";\n      const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n      let invalidUrlMessage;\n      if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n        invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"`;\n      } else if (isIpcUrl && !parsedUrl.pathname) {\n        invalidUrlMessage = \"The URL's pathname is empty\";\n      } else if (parsedUrl.hash) {\n        invalidUrlMessage = \"The URL contains a fragment identifier\";\n      }\n      if (invalidUrlMessage) {\n        const err = new SyntaxError(invalidUrlMessage);\n        if (websocket._redirects === 0) {\n          throw err;\n        } else {\n          emitErrorAndClose(websocket, err);\n          return;\n        }\n      }\n      const defaultPort = isSecure ? 443 : 80;\n      const key = randomBytes(16).toString(\"base64\");\n      const request = isSecure ? https.request : http.request;\n      const protocolSet = /* @__PURE__ */ new Set();\n      let perMessageDeflate;\n      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n      opts.defaultPort = opts.defaultPort || defaultPort;\n      opts.port = parsedUrl.port || defaultPort;\n      opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n      opts.headers = {\n        ...opts.headers,\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\"\n      };\n      opts.path = parsedUrl.pathname + parsedUrl.search;\n      opts.timeout = opts.handshakeTimeout;\n      if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(\n          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n          false,\n          opts.maxPayload\n        );\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n      }\n      if (protocols.length) {\n        for (const protocol of protocols) {\n          if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n            throw new SyntaxError(\n              \"An invalid or duplicated subprotocol was specified\"\n            );\n          }\n          protocolSet.add(protocol);\n        }\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n      }\n      if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n          opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n          opts.headers.Origin = opts.origin;\n        }\n      }\n      if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n      }\n      if (isIpcUrl) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n      }\n      let req;\n      if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n          websocket._originalIpc = isIpcUrl;\n          websocket._originalSecure = isSecure;\n          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n          const headers = options && options.headers;\n          options = { ...options, headers: {} };\n          if (headers) {\n            for (const [key2, value] of Object.entries(headers)) {\n              options.headers[key2.toLowerCase()] = value;\n            }\n          }\n        } else if (websocket.listenerCount(\"redirect\") === 0) {\n          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n          if (!isSameHost || websocket._originalSecure && !isSecure) {\n            delete opts.headers.authorization;\n            delete opts.headers.cookie;\n            if (!isSameHost) delete opts.headers.host;\n            opts.auth = void 0;\n          }\n        }\n        if (opts.auth && !options.headers.authorization) {\n          options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n        req = websocket._req = request(opts);\n        if (websocket._redirects) {\n          websocket.emit(\"redirect\", websocket.url, req);\n        }\n      } else {\n        req = websocket._req = request(opts);\n      }\n      if (opts.timeout) {\n        req.on(\"timeout\", () => {\n          abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n      }\n      req.on(\"error\", (err) => {\n        if (req === null || req[kAborted]) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n      });\n      req.on(\"response\", (res) => {\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n          if (++websocket._redirects > opts.maxRedirects) {\n            abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n            return;\n          }\n          req.abort();\n          let addr;\n          try {\n            addr = new URL2(location, address);\n          } catch (e) {\n            const err = new SyntaxError(`Invalid URL: ${location}`);\n            emitErrorAndClose(websocket, err);\n            return;\n          }\n          initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n          abortHandshake(\n            websocket,\n            req,\n            `Unexpected server response: ${res.statusCode}`\n          );\n        }\n      });\n      req.on(\"upgrade\", (res, socket, head) => {\n        websocket.emit(\"upgrade\", res);\n        if (websocket.readyState !== WebSocket2.CONNECTING) return;\n        req = websocket._req = null;\n        const upgrade = res.headers.upgrade;\n        if (upgrade === void 0 || upgrade.toLowerCase() !== \"websocket\") {\n          abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n          return;\n        }\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n          abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n          return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        let protError;\n        if (serverProt !== void 0) {\n          if (!protocolSet.size) {\n            protError = \"Server sent a subprotocol but none was requested\";\n          } else if (!protocolSet.has(serverProt)) {\n            protError = \"Server sent an invalid subprotocol\";\n          }\n        } else if (protocolSet.size) {\n          protError = \"Server sent no subprotocol\";\n        }\n        if (protError) {\n          abortHandshake(websocket, socket, protError);\n          return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== void 0) {\n          if (!perMessageDeflate) {\n            const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          let extensions;\n          try {\n            extensions = parse(secWebSocketExtensions);\n          } catch (err) {\n            const message = \"Invalid Sec-WebSocket-Extensions header\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          const extensionNames = Object.keys(extensions);\n          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n            const message = \"Server indicated an extension that was not requested\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          try {\n            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          } catch (err) {\n            const message = \"Invalid Sec-WebSocket-Extensions header\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n        websocket.setSocket(socket, head, {\n          allowSynchronousEvents: opts.allowSynchronousEvents,\n          generateMask: opts.generateMask,\n          maxPayload: opts.maxPayload,\n          skipUTF8Validation: opts.skipUTF8Validation\n        });\n      });\n      if (opts.finishRequest) {\n        opts.finishRequest(req, websocket);\n      } else {\n        req.end();\n      }\n    }\n    function emitErrorAndClose(websocket, err) {\n      websocket._readyState = WebSocket2.CLOSING;\n      websocket._errorEmitted = true;\n      websocket.emit(\"error\", err);\n      websocket.emitClose();\n    }\n    function netConnect(options) {\n      options.path = options.socketPath;\n      return net.connect(options);\n    }\n    function tlsConnect(options) {\n      options.path = void 0;\n      if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n      }\n      return tls.connect(options);\n    }\n    function abortHandshake(websocket, stream, message) {\n      websocket._readyState = WebSocket2.CLOSING;\n      const err = new Error(message);\n      Error.captureStackTrace(err, abortHandshake);\n      if (stream.setHeader) {\n        stream[kAborted] = true;\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n          stream.socket.destroy();\n        }\n        process.nextTick(emitErrorAndClose, websocket, err);\n      } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n      }\n    }\n    function sendAfterClose(websocket, data, cb) {\n      if (data) {\n        const length = isBlob(data) ? data.size : toBuffer(data).length;\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n      }\n      if (cb) {\n        const err = new Error(\n          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`\n        );\n        process.nextTick(cb, err);\n      }\n    }\n    function receiverOnConclude(code, reason) {\n      const websocket = this[kWebSocket];\n      websocket._closeFrameReceived = true;\n      websocket._closeMessage = reason;\n      websocket._closeCode = code;\n      if (websocket._socket[kWebSocket] === void 0) return;\n      websocket._socket.removeListener(\"data\", socketOnData);\n      process.nextTick(resume, websocket._socket);\n      if (code === 1005) websocket.close();\n      else websocket.close(code, reason);\n    }\n    function receiverOnDrain() {\n      const websocket = this[kWebSocket];\n      if (!websocket.isPaused) websocket._socket.resume();\n    }\n    function receiverOnError(err) {\n      const websocket = this[kWebSocket];\n      if (websocket._socket[kWebSocket] !== void 0) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n      }\n      if (!websocket._errorEmitted) {\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n      }\n    }\n    function receiverOnFinish() {\n      this[kWebSocket].emitClose();\n    }\n    function receiverOnMessage(data, isBinary) {\n      this[kWebSocket].emit(\"message\", data, isBinary);\n    }\n    function receiverOnPing(data) {\n      const websocket = this[kWebSocket];\n      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n      websocket.emit(\"ping\", data);\n    }\n    function receiverOnPong(data) {\n      this[kWebSocket].emit(\"pong\", data);\n    }\n    function resume(stream) {\n      stream.resume();\n    }\n    function senderOnError(err) {\n      const websocket = this[kWebSocket];\n      if (websocket.readyState === WebSocket2.CLOSED) return;\n      if (websocket.readyState === WebSocket2.OPEN) {\n        websocket._readyState = WebSocket2.CLOSING;\n        setCloseTimer(websocket);\n      }\n      this._socket.end();\n      if (!websocket._errorEmitted) {\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n      }\n    }\n    function setCloseTimer(websocket) {\n      websocket._closeTimer = setTimeout(\n        websocket._socket.destroy.bind(websocket._socket),\n        closeTimeout\n      );\n    }\n    function socketOnClose() {\n      const websocket = this[kWebSocket];\n      this.removeListener(\"close\", socketOnClose);\n      this.removeListener(\"data\", socketOnData);\n      this.removeListener(\"end\", socketOnEnd);\n      websocket._readyState = WebSocket2.CLOSING;\n      let chunk;\n      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n        websocket._receiver.write(chunk);\n      }\n      websocket._receiver.end();\n      this[kWebSocket] = void 0;\n      clearTimeout(websocket._closeTimer);\n      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n      } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n      }\n    }\n    function socketOnData(chunk) {\n      if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n      }\n    }\n    function socketOnEnd() {\n      const websocket = this[kWebSocket];\n      websocket._readyState = WebSocket2.CLOSING;\n      websocket._receiver.end();\n      this.end();\n    }\n    function socketOnError() {\n      const websocket = this[kWebSocket];\n      this.removeListener(\"error\", socketOnError);\n      this.on(\"error\", NOOP);\n      if (websocket) {\n        websocket._readyState = WebSocket2.CLOSING;\n        this.destroy();\n      }\n    }\n  }\n});\n\n// node_modules/ws/lib/stream.js\nvar require_stream = __commonJS({\n  \"node_modules/ws/lib/stream.js\"(exports2, module2) {\n    \"use strict\";\n    var WebSocket2 = require_websocket();\n    var { Duplex } = require(\"stream\");\n    function emitClose(stream) {\n      stream.emit(\"close\");\n    }\n    function duplexOnEnd() {\n      if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n      }\n    }\n    function duplexOnError(err) {\n      this.removeListener(\"error\", duplexOnError);\n      this.destroy();\n      if (this.listenerCount(\"error\") === 0) {\n        this.emit(\"error\", err);\n      }\n    }\n    function createWebSocketStream2(ws, options) {\n      let terminateOnDestroy = true;\n      const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n      });\n      ws.on(\"message\", function message(msg, isBinary) {\n        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n        if (!duplex.push(data)) ws.pause();\n      });\n      ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n      });\n      ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n      });\n      duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n          callback(err);\n          process.nextTick(emitClose, duplex);\n          return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err2) {\n          called = true;\n          callback(err2);\n        });\n        ws.once(\"close\", function close() {\n          if (!called) callback(err);\n          process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n      };\n      duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n          ws.once(\"open\", function open() {\n            duplex._final(callback);\n          });\n          return;\n        }\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n          callback();\n          if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n          ws._socket.once(\"finish\", function finish() {\n            callback();\n          });\n          ws.close();\n        }\n      };\n      duplex._read = function() {\n        if (ws.isPaused) ws.resume();\n      };\n      duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n          ws.once(\"open\", function open() {\n            duplex._write(chunk, encoding, callback);\n          });\n          return;\n        }\n        ws.send(chunk, callback);\n      };\n      duplex.on(\"end\", duplexOnEnd);\n      duplex.on(\"error\", duplexOnError);\n      return duplex;\n    }\n    module2.exports = createWebSocketStream2;\n  }\n});\n\n// node_modules/ws/lib/subprotocol.js\nvar require_subprotocol = __commonJS({\n  \"node_modules/ws/lib/subprotocol.js\"(exports2, module2) {\n    \"use strict\";\n    var { tokenChars } = require_validation3();\n    function parse(header) {\n      const protocols = /* @__PURE__ */ new Set();\n      let start = -1;\n      let end = -1;\n      let i = 0;\n      for (i; i < header.length; i++) {\n        const code = header.charCodeAt(i);\n        if (end === -1 && tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (i !== 0 && (code === 32 || code === 9)) {\n          if (end === -1 && start !== -1) end = i;\n        } else if (code === 44) {\n          if (start === -1) {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n          if (end === -1) end = i;\n          const protocol2 = header.slice(start, end);\n          if (protocols.has(protocol2)) {\n            throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n          }\n          protocols.add(protocol2);\n          start = end = -1;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      }\n      if (start === -1 || end !== -1) {\n        throw new SyntaxError(\"Unexpected end of input\");\n      }\n      const protocol = header.slice(start, i);\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol);\n      return protocols;\n    }\n    module2.exports = { parse };\n  }\n});\n\n// node_modules/ws/lib/websocket-server.js\nvar require_websocket_server = __commonJS({\n  \"node_modules/ws/lib/websocket-server.js\"(exports2, module2) {\n    \"use strict\";\n    var EventEmitter2 = require(\"events\");\n    var http = require(\"http\");\n    var { Duplex } = require(\"stream\");\n    var { createHash } = require(\"crypto\");\n    var extension = require_extension();\n    var PerMessageDeflate = require_permessage_deflate();\n    var subprotocol = require_subprotocol();\n    var WebSocket2 = require_websocket();\n    var { GUID, kWebSocket } = require_constants3();\n    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n    var RUNNING = 0;\n    var CLOSING = 1;\n    var CLOSED = 2;\n    var WebSocketServer2 = class extends EventEmitter2 {\n      /**\n       * Create a `WebSocketServer` instance.\n       *\n       * @param {Object} options Configuration options\n       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n       *     multiple times in the same tick\n       * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n       *     automatically send a pong in response to a ping\n       * @param {Number} [options.backlog=511] The maximum length of the queue of\n       *     pending connections\n       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n       *     track clients\n       * @param {Function} [options.handleProtocols] A hook to handle protocols\n       * @param {String} [options.host] The hostname where to bind the server\n       * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n       *     size\n       * @param {Boolean} [options.noServer=false] Enable no server mode\n       * @param {String} [options.path] Accept only connections matching this path\n       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n       *     permessage-deflate\n       * @param {Number} [options.port] The port where to bind the server\n       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n       *     server to use\n       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n       *     not to skip UTF-8 validation for text and close messages\n       * @param {Function} [options.verifyClient] A hook to reject connections\n       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n       *     class to use. It must be the `WebSocket` class or class that extends it\n       * @param {Function} [callback] A listener for the `listening` event\n       */\n      constructor(options, callback) {\n        super();\n        options = {\n          allowSynchronousEvents: true,\n          autoPong: true,\n          maxPayload: 100 * 1024 * 1024,\n          skipUTF8Validation: false,\n          perMessageDeflate: false,\n          handleProtocols: null,\n          clientTracking: true,\n          verifyClient: null,\n          noServer: false,\n          backlog: null,\n          // use default (511 as implemented in net.js)\n          server: null,\n          host: null,\n          path: null,\n          port: null,\n          WebSocket: WebSocket2,\n          ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n          throw new TypeError(\n            'One and only one of the \"port\", \"server\", or \"noServer\" options must be specified'\n          );\n        }\n        if (options.port != null) {\n          this._server = http.createServer((req, res) => {\n            const body = http.STATUS_CODES[426];\n            res.writeHead(426, {\n              \"Content-Length\": body.length,\n              \"Content-Type\": \"text/plain\"\n            });\n            res.end(body);\n          });\n          this._server.listen(\n            options.port,\n            options.host,\n            options.backlog,\n            callback\n          );\n        } else if (options.server) {\n          this._server = options.server;\n        }\n        if (this._server) {\n          const emitConnection = this.emit.bind(this, \"connection\");\n          this._removeListeners = addListeners(this._server, {\n            listening: this.emit.bind(this, \"listening\"),\n            error: this.emit.bind(this, \"error\"),\n            upgrade: (req, socket, head) => {\n              this.handleUpgrade(req, socket, head, emitConnection);\n            }\n          });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) {\n          this.clients = /* @__PURE__ */ new Set();\n          this._shouldEmitClose = false;\n        }\n        this.options = options;\n        this._state = RUNNING;\n      }\n      /**\n       * Returns the bound address, the address family name, and port of the server\n       * as reported by the operating system if listening on an IP socket.\n       * If the server is listening on a pipe or UNIX domain socket, the name is\n       * returned as a string.\n       *\n       * @return {(Object|String|null)} The address of the server\n       * @public\n       */\n      address() {\n        if (this.options.noServer) {\n          throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n      }\n      /**\n       * Stop the server from accepting new connections and emit the `'close'` event\n       * when all existing connections are closed.\n       *\n       * @param {Function} [cb] A one-time listener for the `'close'` event\n       * @public\n       */\n      close(cb) {\n        if (this._state === CLOSED) {\n          if (cb) {\n            this.once(\"close\", () => {\n              cb(new Error(\"The server is not running\"));\n            });\n          }\n          process.nextTick(emitClose, this);\n          return;\n        }\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        if (this.options.noServer || this.options.server) {\n          if (this._server) {\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n          }\n          if (this.clients) {\n            if (!this.clients.size) {\n              process.nextTick(emitClose, this);\n            } else {\n              this._shouldEmitClose = true;\n            }\n          } else {\n            process.nextTick(emitClose, this);\n          }\n        } else {\n          const server = this._server;\n          this._removeListeners();\n          this._removeListeners = this._server = null;\n          server.close(() => {\n            emitClose(this);\n          });\n        }\n      }\n      /**\n       * See if a given request should be handled by this server instance.\n       *\n       * @param {http.IncomingMessage} req Request object to inspect\n       * @return {Boolean} `true` if the request is valid, else `false`\n       * @public\n       */\n      shouldHandle(req) {\n        if (this.options.path) {\n          const index = req.url.indexOf(\"?\");\n          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n          if (pathname !== this.options.path) return false;\n        }\n        return true;\n      }\n      /**\n       * Handle a HTTP Upgrade request.\n       *\n       * @param {http.IncomingMessage} req The request object\n       * @param {Duplex} socket The network socket between the server and client\n       * @param {Buffer} head The first packet of the upgraded stream\n       * @param {Function} cb Callback\n       * @public\n       */\n      handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"];\n        const upgrade = req.headers.upgrade;\n        const version = +req.headers[\"sec-websocket-version\"];\n        if (req.method !== \"GET\") {\n          const message = \"Invalid HTTP method\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n          return;\n        }\n        if (upgrade === void 0 || upgrade.toLowerCase() !== \"websocket\") {\n          const message = \"Invalid Upgrade header\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n          return;\n        }\n        if (key === void 0 || !keyRegex.test(key)) {\n          const message = \"Missing or invalid Sec-WebSocket-Key header\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n          return;\n        }\n        if (version !== 13 && version !== 8) {\n          const message = \"Missing or invalid Sec-WebSocket-Version header\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {\n            \"Sec-WebSocket-Version\": \"13, 8\"\n          });\n          return;\n        }\n        if (!this.shouldHandle(req)) {\n          abortHandshake(socket, 400);\n          return;\n        }\n        const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n        let protocols = /* @__PURE__ */ new Set();\n        if (secWebSocketProtocol !== void 0) {\n          try {\n            protocols = subprotocol.parse(secWebSocketProtocol);\n          } catch (err) {\n            const message = \"Invalid Sec-WebSocket-Protocol header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n          }\n        }\n        const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n        const extensions = {};\n        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n          const perMessageDeflate = new PerMessageDeflate(\n            this.options.perMessageDeflate,\n            true,\n            this.options.maxPayload\n          );\n          try {\n            const offers = extension.parse(secWebSocketExtensions);\n            if (offers[PerMessageDeflate.extensionName]) {\n              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n            }\n          } catch (err) {\n            const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n          }\n        }\n        if (this.options.verifyClient) {\n          const info = {\n            origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n            secure: !!(req.socket.authorized || req.socket.encrypted),\n            req\n          };\n          if (this.options.verifyClient.length === 2) {\n            this.options.verifyClient(info, (verified, code, message, headers) => {\n              if (!verified) {\n                return abortHandshake(socket, code || 401, message, headers);\n              }\n              this.completeUpgrade(\n                extensions,\n                key,\n                protocols,\n                req,\n                socket,\n                head,\n                cb\n              );\n            });\n            return;\n          }\n          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n      }\n      /**\n       * Upgrade the connection to WebSocket.\n       *\n       * @param {Object} extensions The accepted extensions\n       * @param {String} key The value of the `Sec-WebSocket-Key` header\n       * @param {Set} protocols The subprotocols\n       * @param {http.IncomingMessage} req The request object\n       * @param {Duplex} socket The network socket between the server and client\n       * @param {Buffer} head The first packet of the upgraded stream\n       * @param {Function} cb Callback\n       * @throws {Error} If called more than once with the same socket\n       * @private\n       */\n      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n          throw new Error(\n            \"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\"\n          );\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n          \"HTTP/1.1 101 Switching Protocols\",\n          \"Upgrade: websocket\",\n          \"Connection: Upgrade\",\n          `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new this.options.WebSocket(null, void 0, this.options);\n        if (protocols.size) {\n          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n          if (protocol) {\n            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n            ws._protocol = protocol;\n          }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n          const params = extensions[PerMessageDeflate.extensionName].params;\n          const value = extension.format({\n            [PerMessageDeflate.extensionName]: [params]\n          });\n          headers.push(`Sec-WebSocket-Extensions: ${value}`);\n          ws._extensions = extensions;\n        }\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, {\n          allowSynchronousEvents: this.options.allowSynchronousEvents,\n          maxPayload: this.options.maxPayload,\n          skipUTF8Validation: this.options.skipUTF8Validation\n        });\n        if (this.clients) {\n          this.clients.add(ws);\n          ws.on(\"close\", () => {\n            this.clients.delete(ws);\n            if (this._shouldEmitClose && !this.clients.size) {\n              process.nextTick(emitClose, this);\n            }\n          });\n        }\n        cb(ws, req);\n      }\n    };\n    module2.exports = WebSocketServer2;\n    function addListeners(server, map) {\n      for (const event of Object.keys(map)) server.on(event, map[event]);\n      return function removeListeners() {\n        for (const event of Object.keys(map)) {\n          server.removeListener(event, map[event]);\n        }\n      };\n    }\n    function emitClose(server) {\n      server._state = CLOSED;\n      server.emit(\"close\");\n    }\n    function socketOnError() {\n      this.destroy();\n    }\n    function abortHandshake(socket, code, message, headers) {\n      message = message || http.STATUS_CODES[code];\n      headers = {\n        Connection: \"close\",\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": Buffer.byteLength(message),\n        ...headers\n      };\n      socket.once(\"finish\", socket.destroy);\n      socket.end(\n        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message\n      );\n    }\n    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {\n      if (server.listenerCount(\"wsClientError\")) {\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n        server.emit(\"wsClientError\", err, socket, req);\n      } else {\n        abortHandshake(socket, code, message, headers);\n      }\n    }\n  }\n});\n\n// node_modules/@keyv/serialize/dist/index.cjs\nvar require_dist3 = __commonJS({\n  \"node_modules/@keyv/serialize/dist/index.cjs\"(exports2, module2) {\n    \"use strict\";\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export2 = (target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps2 = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n    var index_exports = {};\n    __export2(index_exports, {\n      defaultDeserialize: () => defaultDeserialize,\n      defaultSerialize: () => defaultSerialize\n    });\n    module2.exports = __toCommonJS2(index_exports);\n    var import_node_buffer = require(\"buffer\");\n    var _serialize = (data, escapeColonStrings = true) => {\n      if (data === void 0 || data === null) {\n        return \"null\";\n      }\n      if (typeof data === \"string\") {\n        return JSON.stringify(\n          escapeColonStrings && data.startsWith(\":\") ? `:${data}` : data\n        );\n      }\n      if (import_node_buffer.Buffer.isBuffer(data)) {\n        return JSON.stringify(`:base64:${data.toString(\"base64\")}`);\n      }\n      if (data?.toJSON) {\n        data = data.toJSON();\n      }\n      if (typeof data === \"object\") {\n        let s = \"\";\n        const array = Array.isArray(data);\n        s = array ? \"[\" : \"{\";\n        let first = true;\n        for (const k in data) {\n          const ignore = typeof data[k] === \"function\" || !array && data[k] === void 0;\n          if (!Object.hasOwn(data, k) || ignore) {\n            continue;\n          }\n          if (!first) {\n            s += \",\";\n          }\n          first = false;\n          if (array) {\n            s += _serialize(data[k], escapeColonStrings);\n          } else if (data[k] !== void 0) {\n            s += `${_serialize(k, false)}:${_serialize(data[k], escapeColonStrings)}`;\n          }\n        }\n        s += array ? \"]\" : \"}\";\n        return s;\n      }\n      return JSON.stringify(data);\n    };\n    var defaultSerialize = (data) => {\n      return _serialize(data, true);\n    };\n    var defaultDeserialize = (data) => JSON.parse(data, (_, value) => {\n      if (typeof value === \"string\") {\n        if (value.startsWith(\":base64:\")) {\n          return import_node_buffer.Buffer.from(value.slice(8), \"base64\");\n        }\n        return value.startsWith(\":\") ? value.slice(1) : value;\n      }\n      return value;\n    });\n  }\n});\n\n// node_modules/keyv/dist/index.cjs\nvar require_dist4 = __commonJS({\n  \"node_modules/keyv/dist/index.cjs\"(exports2, module2) {\n    \"use strict\";\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export2 = (target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps2 = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n    var index_exports = {};\n    __export2(index_exports, {\n      Keyv: () => Keyv2,\n      KeyvHooks: () => KeyvHooks,\n      default: () => index_default\n    });\n    module2.exports = __toCommonJS2(index_exports);\n    var import_serialize = require_dist3();\n    var EventManager = class {\n      _eventListeners;\n      _maxListeners;\n      constructor() {\n        this._eventListeners = /* @__PURE__ */ new Map();\n        this._maxListeners = 100;\n      }\n      maxListeners() {\n        return this._maxListeners;\n      }\n      // Add an event listener\n      addListener(event, listener) {\n        this.on(event, listener);\n      }\n      on(event, listener) {\n        if (!this._eventListeners.has(event)) {\n          this._eventListeners.set(event, []);\n        }\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n          if (listeners.length >= this._maxListeners) {\n            console.warn(\n              `MaxListenersExceededWarning: Possible event memory leak detected. ${listeners.length + 1} ${event} listeners added. Use setMaxListeners() to increase limit.`\n            );\n          }\n          listeners.push(listener);\n        }\n        return this;\n      }\n      // Remove an event listener\n      removeListener(event, listener) {\n        this.off(event, listener);\n      }\n      off(event, listener) {\n        const listeners = this._eventListeners.get(event) ?? [];\n        const index = listeners.indexOf(listener);\n        if (index !== -1) {\n          listeners.splice(index, 1);\n        }\n        if (listeners.length === 0) {\n          this._eventListeners.delete(event);\n        }\n      }\n      once(event, listener) {\n        const onceListener = (...arguments_) => {\n          listener(...arguments_);\n          this.off(event, onceListener);\n        };\n        this.on(event, onceListener);\n      }\n      // Emit an event\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      emit(event, ...arguments_) {\n        const listeners = this._eventListeners.get(event);\n        if (listeners && listeners.length > 0) {\n          for (const listener of listeners) {\n            listener(...arguments_);\n          }\n        }\n      }\n      // Get all listeners for a specific event\n      listeners(event) {\n        return this._eventListeners.get(event) ?? [];\n      }\n      // Remove all listeners for a specific event\n      removeAllListeners(event) {\n        if (event) {\n          this._eventListeners.delete(event);\n        } else {\n          this._eventListeners.clear();\n        }\n      }\n      // Set the maximum number of listeners for a single event\n      setMaxListeners(n) {\n        this._maxListeners = n;\n      }\n    };\n    var event_manager_default = EventManager;\n    var HooksManager = class extends event_manager_default {\n      _hookHandlers;\n      constructor() {\n        super();\n        this._hookHandlers = /* @__PURE__ */ new Map();\n      }\n      // Adds a handler function for a specific event\n      addHandler(event, handler) {\n        const eventHandlers = this._hookHandlers.get(event);\n        if (eventHandlers) {\n          eventHandlers.push(handler);\n        } else {\n          this._hookHandlers.set(event, [handler]);\n        }\n      }\n      // Removes a specific handler function for a specific event\n      removeHandler(event, handler) {\n        const eventHandlers = this._hookHandlers.get(event);\n        if (eventHandlers) {\n          const index = eventHandlers.indexOf(handler);\n          if (index !== -1) {\n            eventHandlers.splice(index, 1);\n          }\n        }\n      }\n      // Triggers all handlers for a specific event with provided data\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      trigger(event, data) {\n        const eventHandlers = this._hookHandlers.get(event);\n        if (eventHandlers) {\n          for (const handler of eventHandlers) {\n            try {\n              handler(data);\n            } catch (error) {\n              this.emit(\n                \"error\",\n                new Error(\n                  `Error in hook handler for event \"${event}\": ${error.message}`\n                )\n              );\n            }\n          }\n        }\n      }\n      // Provides read-only access to the current handlers\n      get handlers() {\n        return new Map(this._hookHandlers);\n      }\n    };\n    var hooks_manager_default = HooksManager;\n    var StatsManager = class extends event_manager_default {\n      enabled = true;\n      hits = 0;\n      misses = 0;\n      sets = 0;\n      deletes = 0;\n      errors = 0;\n      constructor(enabled) {\n        super();\n        if (enabled !== void 0) {\n          this.enabled = enabled;\n        }\n        this.reset();\n      }\n      hit() {\n        if (this.enabled) {\n          this.hits++;\n        }\n      }\n      miss() {\n        if (this.enabled) {\n          this.misses++;\n        }\n      }\n      set() {\n        if (this.enabled) {\n          this.sets++;\n        }\n      }\n      delete() {\n        if (this.enabled) {\n          this.deletes++;\n        }\n      }\n      hitsOrMisses(array) {\n        for (const item of array) {\n          if (item === void 0) {\n            this.miss();\n          } else {\n            this.hit();\n          }\n        }\n      }\n      reset() {\n        this.hits = 0;\n        this.misses = 0;\n        this.sets = 0;\n        this.deletes = 0;\n        this.errors = 0;\n      }\n    };\n    var stats_manager_default = StatsManager;\n    var KeyvHooks = /* @__PURE__ */ ((KeyvHooks2) => {\n      KeyvHooks2[\"PRE_SET\"] = \"preSet\";\n      KeyvHooks2[\"POST_SET\"] = \"postSet\";\n      KeyvHooks2[\"PRE_GET\"] = \"preGet\";\n      KeyvHooks2[\"POST_GET\"] = \"postGet\";\n      KeyvHooks2[\"PRE_GET_MANY\"] = \"preGetMany\";\n      KeyvHooks2[\"POST_GET_MANY\"] = \"postGetMany\";\n      KeyvHooks2[\"PRE_GET_RAW\"] = \"preGetRaw\";\n      KeyvHooks2[\"POST_GET_RAW\"] = \"postGetRaw\";\n      KeyvHooks2[\"PRE_GET_MANY_RAW\"] = \"preGetManyRaw\";\n      KeyvHooks2[\"POST_GET_MANY_RAW\"] = \"postGetManyRaw\";\n      KeyvHooks2[\"PRE_DELETE\"] = \"preDelete\";\n      KeyvHooks2[\"POST_DELETE\"] = \"postDelete\";\n      return KeyvHooks2;\n    })(KeyvHooks || {});\n    var iterableAdapters = [\n      \"sqlite\",\n      \"postgres\",\n      \"mysql\",\n      \"mongo\",\n      \"redis\",\n      \"valkey\",\n      \"etcd\"\n    ];\n    var Keyv2 = class extends event_manager_default {\n      opts;\n      iterator;\n      hooks = new hooks_manager_default();\n      stats = new stats_manager_default(false);\n      /**\n       * Time to live in milliseconds\n       */\n      _ttl;\n      /**\n       * Namespace\n       */\n      _namespace;\n      /**\n       * Store\n       */\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      _store = /* @__PURE__ */ new Map();\n      _serialize = import_serialize.defaultSerialize;\n      _deserialize = import_serialize.defaultDeserialize;\n      _compression;\n      _useKeyPrefix = true;\n      _throwOnErrors = false;\n      /**\n       * Keyv Constructor\n       * @param {KeyvStoreAdapter | KeyvOptions} store\n       * @param {Omit<KeyvOptions, 'store'>} [options] if you provide the store you can then provide the Keyv Options\n       */\n      constructor(store3, options) {\n        super();\n        options ??= {};\n        store3 ??= {};\n        this.opts = {\n          namespace: \"keyv\",\n          serialize: import_serialize.defaultSerialize,\n          deserialize: import_serialize.defaultDeserialize,\n          emitErrors: true,\n          // @ts-expect-error - Map is not a KeyvStoreAdapter\n          store: /* @__PURE__ */ new Map(),\n          ...options\n        };\n        if (store3 && store3.get) {\n          this.opts.store = store3;\n        } else {\n          this.opts = {\n            ...this.opts,\n            ...store3\n          };\n        }\n        this._store = this.opts.store ?? /* @__PURE__ */ new Map();\n        this._compression = this.opts.compression;\n        this._serialize = this.opts.serialize;\n        this._deserialize = this.opts.deserialize;\n        if (this.opts.namespace) {\n          this._namespace = this.opts.namespace;\n        }\n        if (this._store) {\n          if (!this._isValidStorageAdapter(this._store)) {\n            throw new Error(\"Invalid storage adapter\");\n          }\n          if (typeof this._store.on === \"function\") {\n            this._store.on(\"error\", (error) => this.emit(\"error\", error));\n          }\n          this._store.namespace = this._namespace;\n          if (typeof this._store[Symbol.iterator] === \"function\" && this._store instanceof Map) {\n            this.iterator = this.generateIterator(\n              this._store\n            );\n          } else if (\"iterator\" in this._store && this._store.opts && this._checkIterableAdapter()) {\n            this.iterator = this.generateIterator(\n              // biome-ignore lint/style/noNonNullAssertion: need to fix\n              this._store.iterator.bind(this._store)\n            );\n          }\n        }\n        if (this.opts.stats) {\n          this.stats.enabled = this.opts.stats;\n        }\n        if (this.opts.ttl) {\n          this._ttl = this.opts.ttl;\n        }\n        if (this.opts.useKeyPrefix !== void 0) {\n          this._useKeyPrefix = this.opts.useKeyPrefix;\n        }\n        if (this.opts.throwOnErrors !== void 0) {\n          this._throwOnErrors = this.opts.throwOnErrors;\n        }\n      }\n      /**\n       * Get the current store\n       */\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      get store() {\n        return this._store;\n      }\n      /**\n       * Set the current store. This will also set the namespace, event error handler, and generate the iterator. If the store is not valid it will throw an error.\n       * @param {KeyvStoreAdapter | Map<any, any> | any} store the store to set\n       */\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      set store(store3) {\n        if (this._isValidStorageAdapter(store3)) {\n          this._store = store3;\n          this.opts.store = store3;\n          if (typeof store3.on === \"function\") {\n            store3.on(\"error\", (error) => this.emit(\"error\", error));\n          }\n          if (this._namespace) {\n            this._store.namespace = this._namespace;\n          }\n          if (typeof store3[Symbol.iterator] === \"function\" && store3 instanceof Map) {\n            this.iterator = this.generateIterator(\n              store3\n            );\n          } else if (\"iterator\" in store3 && store3.opts && this._checkIterableAdapter()) {\n            this.iterator = this.generateIterator(store3.iterator?.bind(store3));\n          }\n        } else {\n          throw new Error(\"Invalid storage adapter\");\n        }\n      }\n      /**\n       * Get the current compression function\n       * @returns {CompressionAdapter} The current compression function\n       */\n      get compression() {\n        return this._compression;\n      }\n      /**\n       * Set the current compression function\n       * @param {CompressionAdapter} compress The compression function to set\n       */\n      set compression(compress) {\n        this._compression = compress;\n      }\n      /**\n       * Get the current namespace.\n       * @returns {string | undefined} The current namespace.\n       */\n      get namespace() {\n        return this._namespace;\n      }\n      /**\n       * Set the current namespace.\n       * @param {string | undefined} namespace The namespace to set.\n       */\n      set namespace(namespace) {\n        this._namespace = namespace;\n        this.opts.namespace = namespace;\n        this._store.namespace = namespace;\n        if (this.opts.store) {\n          this.opts.store.namespace = namespace;\n        }\n      }\n      /**\n       * Get the current TTL.\n       * @returns {number} The current TTL in milliseconds.\n       */\n      get ttl() {\n        return this._ttl;\n      }\n      /**\n       * Set the current TTL.\n       * @param {number} ttl The TTL to set in milliseconds.\n       */\n      set ttl(ttl) {\n        this.opts.ttl = ttl;\n        this._ttl = ttl;\n      }\n      /**\n       * Get the current serialize function.\n       * @returns {Serialize} The current serialize function.\n       */\n      get serialize() {\n        return this._serialize;\n      }\n      /**\n       * Set the current serialize function.\n       * @param {Serialize} serialize The serialize function to set.\n       */\n      set serialize(serialize) {\n        this.opts.serialize = serialize;\n        this._serialize = serialize;\n      }\n      /**\n       * Get the current deserialize function.\n       * @returns {Deserialize} The current deserialize function.\n       */\n      get deserialize() {\n        return this._deserialize;\n      }\n      /**\n       * Set the current deserialize function.\n       * @param {Deserialize} deserialize The deserialize function to set.\n       */\n      set deserialize(deserialize) {\n        this.opts.deserialize = deserialize;\n        this._deserialize = deserialize;\n      }\n      /**\n       * Get the current useKeyPrefix value. This will enable or disable key prefixing.\n       * @returns {boolean} The current useKeyPrefix value.\n       * @default true\n       */\n      get useKeyPrefix() {\n        return this._useKeyPrefix;\n      }\n      /**\n       * Set the current useKeyPrefix value. This will enable or disable key prefixing.\n       * @param {boolean} value The useKeyPrefix value to set.\n       */\n      set useKeyPrefix(value) {\n        this._useKeyPrefix = value;\n        this.opts.useKeyPrefix = value;\n      }\n      /**\n       * Get the current throwErrors value. This will enable or disable throwing errors on methods in addition to emitting them.\n       * @return {boolean} The current throwOnErrors value.\n       */\n      get throwOnErrors() {\n        return this._throwOnErrors;\n      }\n      /**\n       * Set the current throwOnErrors value. This will enable or disable throwing errors on methods in addition to emitting them.\n       * @param {boolean} value The throwOnErrors value to set.\n       */\n      set throwOnErrors(value) {\n        this._throwOnErrors = value;\n        this.opts.throwOnErrors = value;\n      }\n      generateIterator(iterator) {\n        const function_ = async function* () {\n          for await (const [key, raw] of typeof iterator === \"function\" ? iterator(this._store.namespace) : iterator) {\n            const data = await this.deserializeData(raw);\n            if (this._useKeyPrefix && this._store.namespace && !key.includes(this._store.namespace)) {\n              continue;\n            }\n            if (typeof data.expires === \"number\" && Date.now() > data.expires) {\n              this.delete(key);\n              continue;\n            }\n            yield [this._getKeyUnprefix(key), data.value];\n          }\n        };\n        return function_.bind(this);\n      }\n      _checkIterableAdapter() {\n        return iterableAdapters.includes(this._store.opts.dialect) || iterableAdapters.some(\n          (element) => this._store.opts.url.includes(element)\n        );\n      }\n      _getKeyPrefix(key) {\n        if (!this._useKeyPrefix) {\n          return key;\n        }\n        if (!this._namespace) {\n          return key;\n        }\n        return `${this._namespace}:${key}`;\n      }\n      _getKeyPrefixArray(keys) {\n        if (!this._useKeyPrefix) {\n          return keys;\n        }\n        if (!this._namespace) {\n          return keys;\n        }\n        return keys.map((key) => `${this._namespace}:${key}`);\n      }\n      _getKeyUnprefix(key) {\n        if (!this._useKeyPrefix) {\n          return key;\n        }\n        return key.split(\":\").splice(1).join(\":\");\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      _isValidStorageAdapter(store3) {\n        return store3 instanceof Map || typeof store3.get === \"function\" && typeof store3.set === \"function\" && typeof store3.delete === \"function\" && typeof store3.clear === \"function\";\n      }\n      // eslint-disable-next-line @stylistic/max-len\n      async get(key, options) {\n        const { store: store3 } = this.opts;\n        const isArray = Array.isArray(key);\n        const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);\n        const isDataExpired = (data) => typeof data.expires === \"number\" && Date.now() > data.expires;\n        if (isArray) {\n          if (options?.raw === true) {\n            return this.getMany(key, { raw: true });\n          }\n          return this.getMany(key, { raw: false });\n        }\n        this.hooks.trigger(\"preGet\", { key: keyPrefixed });\n        let rawData;\n        try {\n          rawData = await store3.get(keyPrefixed);\n        } catch (error) {\n          if (this.throwOnErrors) {\n            throw error;\n          }\n        }\n        const deserializedData = typeof rawData === \"string\" || this.opts.compression ? await this.deserializeData(rawData) : rawData;\n        if (deserializedData === void 0 || deserializedData === null) {\n          this.hooks.trigger(\"postGet\", {\n            key: keyPrefixed,\n            value: void 0\n          });\n          this.stats.miss();\n          return void 0;\n        }\n        if (isDataExpired(deserializedData)) {\n          await this.delete(key);\n          this.hooks.trigger(\"postGet\", {\n            key: keyPrefixed,\n            value: void 0\n          });\n          this.stats.miss();\n          return void 0;\n        }\n        this.hooks.trigger(\"postGet\", {\n          key: keyPrefixed,\n          value: deserializedData\n        });\n        this.stats.hit();\n        return options?.raw ? deserializedData : deserializedData.value;\n      }\n      async getMany(keys, options) {\n        const { store: store3 } = this.opts;\n        const keyPrefixed = this._getKeyPrefixArray(keys);\n        const isDataExpired = (data) => typeof data.expires === \"number\" && Date.now() > data.expires;\n        this.hooks.trigger(\"preGetMany\", { keys: keyPrefixed });\n        if (store3.getMany === void 0) {\n          const promises = keyPrefixed.map(async (key) => {\n            const rawData2 = await store3.get(key);\n            const deserializedRow = typeof rawData2 === \"string\" || this.opts.compression ? await this.deserializeData(rawData2) : rawData2;\n            if (deserializedRow === void 0 || deserializedRow === null) {\n              return void 0;\n            }\n            if (isDataExpired(deserializedRow)) {\n              await this.delete(key);\n              return void 0;\n            }\n            return options?.raw ? deserializedRow : deserializedRow.value;\n          });\n          const deserializedRows = await Promise.allSettled(promises);\n          const result2 = deserializedRows.map(\n            // biome-ignore lint/suspicious/noExplicitAny: type format\n            (row) => row.value\n          );\n          this.hooks.trigger(\"postGetMany\", result2);\n          if (result2.length > 0) {\n            this.stats.hit();\n          }\n          return result2;\n        }\n        const rawData = await store3.getMany(keyPrefixed);\n        const result = [];\n        const expiredKeys = [];\n        for (const index in rawData) {\n          let row = rawData[index];\n          if (typeof row === \"string\") {\n            row = await this.deserializeData(row);\n          }\n          if (row === void 0 || row === null) {\n            result.push(void 0);\n            continue;\n          }\n          if (isDataExpired(row)) {\n            expiredKeys.push(keys[index]);\n            result.push(void 0);\n            continue;\n          }\n          const value = options?.raw ? row : row.value;\n          result.push(value);\n        }\n        if (expiredKeys.length > 0) {\n          await this.deleteMany(expiredKeys);\n        }\n        this.hooks.trigger(\"postGetMany\", result);\n        if (result.length > 0) {\n          this.stats.hit();\n        }\n        return result;\n      }\n      /**\n       * Get the raw value of a key. This is the replacement for setting raw to true in the get() method.\n       * @param {string} key the key to get\n       * @returns {Promise<StoredDataRaw<Value> | undefined>} will return a StoredDataRaw<Value> or undefined if the key does not exist or is expired.\n       */\n      async getRaw(key) {\n        const { store: store3 } = this.opts;\n        const keyPrefixed = this._getKeyPrefix(key);\n        this.hooks.trigger(\"preGetRaw\", { key: keyPrefixed });\n        const rawData = await store3.get(keyPrefixed);\n        if (rawData === void 0 || rawData === null) {\n          this.hooks.trigger(\"postGetRaw\", {\n            key: keyPrefixed,\n            value: void 0\n          });\n          this.stats.miss();\n          return void 0;\n        }\n        const deserializedData = typeof rawData === \"string\" || this.opts.compression ? await this.deserializeData(rawData) : rawData;\n        if (deserializedData !== void 0 && deserializedData.expires !== void 0 && deserializedData.expires !== null && // biome-ignore lint/style/noNonNullAssertion: need to fix\n        deserializedData.expires < Date.now()) {\n          this.hooks.trigger(\"postGetRaw\", {\n            key: keyPrefixed,\n            value: void 0\n          });\n          this.stats.miss();\n          await this.delete(key);\n          return void 0;\n        }\n        this.stats.hit();\n        this.hooks.trigger(\"postGetRaw\", {\n          key: keyPrefixed,\n          value: deserializedData\n        });\n        return deserializedData;\n      }\n      /**\n       * Get the raw values of many keys. This is the replacement for setting raw to true in the getMany() method.\n       * @param {string[]} keys the keys to get\n       * @returns {Promise<Array<StoredDataRaw<Value>>>} will return an array of StoredDataRaw<Value> or undefined if the key does not exist or is expired.\n       */\n      async getManyRaw(keys) {\n        const { store: store3 } = this.opts;\n        const keyPrefixed = this._getKeyPrefixArray(keys);\n        if (keys.length === 0) {\n          const result2 = Array.from({ length: keys.length }).fill(\n            void 0\n          );\n          this.stats.misses += keys.length;\n          this.hooks.trigger(\"postGetManyRaw\", {\n            keys: keyPrefixed,\n            values: result2\n          });\n          return result2;\n        }\n        let result = [];\n        if (store3.getMany === void 0) {\n          const promises = keyPrefixed.map(async (key) => {\n            const rawData = await store3.get(key);\n            if (rawData !== void 0 && rawData !== null) {\n              return this.deserializeData(rawData);\n            }\n            return void 0;\n          });\n          const deserializedRows = await Promise.allSettled(promises);\n          result = deserializedRows.map(\n            // biome-ignore lint/suspicious/noExplicitAny: type format\n            (row) => row.value\n          );\n        } else {\n          const rawData = await store3.getMany(keyPrefixed);\n          for (const row of rawData) {\n            if (row !== void 0 && row !== null) {\n              result.push(await this.deserializeData(row));\n            } else {\n              result.push(void 0);\n            }\n          }\n        }\n        const expiredKeys = [];\n        const isDataExpired = (data) => typeof data.expires === \"number\" && Date.now() > data.expires;\n        for (const [index, row] of result.entries()) {\n          if (row !== void 0 && isDataExpired(row)) {\n            expiredKeys.push(keyPrefixed[index]);\n            result[index] = void 0;\n          }\n        }\n        if (expiredKeys.length > 0) {\n          await this.deleteMany(expiredKeys);\n        }\n        this.stats.hitsOrMisses(result);\n        this.hooks.trigger(\"postGetManyRaw\", {\n          keys: keyPrefixed,\n          values: result\n        });\n        return result;\n      }\n      /**\n       * Set an item to the store\n       * @param {string | Array<KeyvEntry>} key the key to use. If you pass in an array of KeyvEntry it will set many items\n       * @param {Value} value the value of the key\n       * @param {number} [ttl] time to live in milliseconds\n       * @returns {boolean} if it sets then it will return a true. On failure will return false.\n       */\n      async set(key, value, ttl) {\n        const data = { key, value, ttl };\n        this.hooks.trigger(\"preSet\", data);\n        const keyPrefixed = this._getKeyPrefix(data.key);\n        data.ttl ??= this._ttl;\n        if (data.ttl === 0) {\n          data.ttl = void 0;\n        }\n        const { store: store3 } = this.opts;\n        const expires = typeof data.ttl === \"number\" ? Date.now() + data.ttl : void 0;\n        if (typeof data.value === \"symbol\") {\n          this.emit(\"error\", \"symbol cannot be serialized\");\n          throw new Error(\"symbol cannot be serialized\");\n        }\n        const formattedValue = { value: data.value, expires };\n        const serializedValue = await this.serializeData(formattedValue);\n        let result = true;\n        try {\n          const value2 = await store3.set(keyPrefixed, serializedValue, data.ttl);\n          if (typeof value2 === \"boolean\") {\n            result = value2;\n          }\n        } catch (error) {\n          result = false;\n          this.emit(\"error\", error);\n          if (this._throwOnErrors) {\n            throw error;\n          }\n        }\n        this.hooks.trigger(\"postSet\", {\n          key: keyPrefixed,\n          value: serializedValue,\n          ttl\n        });\n        this.stats.set();\n        return result;\n      }\n      /**\n       * Set many items to the store\n       * @param {Array<KeyvEntry>} entries the entries to set\n       * @returns {boolean[]} will return an array of booleans if it sets then it will return a true. On failure will return false.\n       */\n      // biome-ignore lint/correctness/noUnusedVariables: type format\n      async setMany(entries) {\n        let results = [];\n        try {\n          if (this._store.setMany === void 0) {\n            const promises = [];\n            for (const entry of entries) {\n              promises.push(this.set(entry.key, entry.value, entry.ttl));\n            }\n            const promiseResults = await Promise.all(promises);\n            results = promiseResults;\n          } else {\n            const serializedEntries = await Promise.all(\n              entries.map(async ({ key, value, ttl }) => {\n                ttl ??= this._ttl;\n                if (ttl === 0) {\n                  ttl = void 0;\n                }\n                const expires = typeof ttl === \"number\" ? Date.now() + ttl : void 0;\n                if (typeof value === \"symbol\") {\n                  this.emit(\"error\", \"symbol cannot be serialized\");\n                  throw new Error(\"symbol cannot be serialized\");\n                }\n                const formattedValue = { value, expires };\n                const serializedValue = await this.serializeData(formattedValue);\n                const keyPrefixed = this._getKeyPrefix(key);\n                return { key: keyPrefixed, value: serializedValue, ttl };\n              })\n            );\n            results = await this._store.setMany(serializedEntries);\n          }\n        } catch (error) {\n          this.emit(\"error\", error);\n          if (this._throwOnErrors) {\n            throw error;\n          }\n          results = entries.map(() => false);\n        }\n        return results;\n      }\n      /**\n       * Delete an Entry\n       * @param {string | string[]} key the key to be deleted. if an array it will delete many items\n       * @returns {boolean} will return true if item or items are deleted. false if there is an error\n       */\n      async delete(key) {\n        const { store: store3 } = this.opts;\n        if (Array.isArray(key)) {\n          return this.deleteMany(key);\n        }\n        const keyPrefixed = this._getKeyPrefix(key);\n        this.hooks.trigger(\"preDelete\", { key: keyPrefixed });\n        let result = true;\n        try {\n          const value = await store3.delete(keyPrefixed);\n          if (typeof value === \"boolean\") {\n            result = value;\n          }\n        } catch (error) {\n          result = false;\n          this.emit(\"error\", error);\n          if (this._throwOnErrors) {\n            throw error;\n          }\n        }\n        this.hooks.trigger(\"postDelete\", {\n          key: keyPrefixed,\n          value: result\n        });\n        this.stats.delete();\n        return result;\n      }\n      /**\n       * Delete many items from the store\n       * @param {string[]} keys the keys to be deleted\n       * @returns {boolean} will return true if item or items are deleted. false if there is an error\n       */\n      async deleteMany(keys) {\n        try {\n          const { store: store3 } = this.opts;\n          const keyPrefixed = this._getKeyPrefixArray(keys);\n          this.hooks.trigger(\"preDelete\", { key: keyPrefixed });\n          if (store3.deleteMany !== void 0) {\n            return await store3.deleteMany(keyPrefixed);\n          }\n          const promises = keyPrefixed.map(async (key) => store3.delete(key));\n          const results = await Promise.all(promises);\n          const returnResult = results.every(Boolean);\n          this.hooks.trigger(\"postDelete\", {\n            key: keyPrefixed,\n            value: returnResult\n          });\n          return returnResult;\n        } catch (error) {\n          this.emit(\"error\", error);\n          if (this._throwOnErrors) {\n            throw error;\n          }\n          return false;\n        }\n      }\n      /**\n       * Clear the store\n       * @returns {void}\n       */\n      async clear() {\n        this.emit(\"clear\");\n        const { store: store3 } = this.opts;\n        try {\n          await store3.clear();\n        } catch (error) {\n          this.emit(\"error\", error);\n          if (this._throwOnErrors) {\n            throw error;\n          }\n        }\n      }\n      async has(key) {\n        if (Array.isArray(key)) {\n          return this.hasMany(key);\n        }\n        const keyPrefixed = this._getKeyPrefix(key);\n        const { store: store3 } = this.opts;\n        if (store3.has !== void 0 && !(store3 instanceof Map)) {\n          return store3.has(keyPrefixed);\n        }\n        let rawData;\n        try {\n          rawData = await store3.get(keyPrefixed);\n        } catch (error) {\n          this.emit(\"error\", error);\n          if (this._throwOnErrors) {\n            throw error;\n          }\n          return false;\n        }\n        if (rawData) {\n          const data = await this.deserializeData(rawData);\n          if (data) {\n            if (data.expires === void 0 || data.expires === null) {\n              return true;\n            }\n            return data.expires > Date.now();\n          }\n        }\n        return false;\n      }\n      /**\n       * Check if many keys exist\n       * @param {string[]} keys the keys to check\n       * @returns {boolean[]} will return an array of booleans if the keys exist\n       */\n      async hasMany(keys) {\n        const keyPrefixed = this._getKeyPrefixArray(keys);\n        const { store: store3 } = this.opts;\n        if (store3.hasMany !== void 0) {\n          return store3.hasMany(keyPrefixed);\n        }\n        const results = [];\n        for (const key of keys) {\n          results.push(await this.has(key));\n        }\n        return results;\n      }\n      /**\n       * Will disconnect the store. This is only available if the store has a disconnect method\n       * @returns {Promise<void>}\n       */\n      async disconnect() {\n        const { store: store3 } = this.opts;\n        this.emit(\"disconnect\");\n        if (typeof store3.disconnect === \"function\") {\n          return store3.disconnect();\n        }\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: type format\n      emit(event, ...arguments_) {\n        if (event === \"error\" && !this.opts.emitErrors) {\n          return;\n        }\n        super.emit(event, ...arguments_);\n      }\n      async serializeData(data) {\n        if (!this._serialize) {\n          return data;\n        }\n        if (this._compression?.compress) {\n          return this._serialize({\n            value: await this._compression.compress(data.value),\n            expires: data.expires\n          });\n        }\n        return this._serialize(data);\n      }\n      async deserializeData(data) {\n        if (!this._deserialize) {\n          return data;\n        }\n        if (this._compression?.decompress && typeof data === \"string\") {\n          const result = await this._deserialize(data);\n          return {\n            value: await this._compression.decompress(result?.value),\n            expires: result?.expires\n          };\n        }\n        if (typeof data === \"string\") {\n          return this._deserialize(data);\n        }\n        return void 0;\n      }\n    };\n    var index_default = Keyv2;\n  }\n});\n\n// node_modules/keyv-file/node_modules/tslib/tslib.es6.js\nvar tslib_es6_exports = {};\n__export(tslib_es6_exports, {\n  __assign: () => __assign,\n  __asyncDelegator: () => __asyncDelegator,\n  __asyncGenerator: () => __asyncGenerator,\n  __asyncValues: () => __asyncValues,\n  __await: () => __await,\n  __awaiter: () => __awaiter,\n  __classPrivateFieldGet: () => __classPrivateFieldGet,\n  __classPrivateFieldSet: () => __classPrivateFieldSet,\n  __createBinding: () => __createBinding,\n  __decorate: () => __decorate,\n  __exportStar: () => __exportStar,\n  __extends: () => __extends,\n  __generator: () => __generator,\n  __importDefault: () => __importDefault,\n  __importStar: () => __importStar,\n  __makeTemplateObject: () => __makeTemplateObject,\n  __metadata: () => __metadata,\n  __param: () => __param,\n  __read: () => __read,\n  __rest: () => __rest,\n  __spread: () => __spread,\n  __spreadArrays: () => __spreadArrays,\n  __values: () => __values\n});\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n    t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function(target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1) throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return { value: op[1], done: false };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nfunction __createBinding(o, m, k, k2) {\n  if (k2 === void 0) k2 = k;\n  o[k2] = m[k];\n}\nfunction __exportStar(m, exports2) {\n  for (var p in m) if (p !== \"default\" && !exports2.hasOwnProperty(p)) exports2[p] = m[p];\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function() {\n      if (o && i >= o.length) o = void 0;\n      return { value: o && o[i++], done: !o };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n      r[k] = a[j];\n  return r;\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n]) i[n] = function(v) {\n      return new Promise(function(a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v) {\n      return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({ value: v2, done: d });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", { value: raw });\n  } else {\n    cooked.raw = raw;\n  }\n  return cooked;\n}\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) {\n    for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result.default = mod;\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : { default: mod };\n}\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n  privateMap.set(receiver, value);\n  return value;\n}\nvar extendStatics, __assign;\nvar init_tslib_es6 = __esm({\n  \"node_modules/keyv-file/node_modules/tslib/tslib.es6.js\"() {\n    extendStatics = function(d, b) {\n      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];\n      };\n      return extendStatics(d, b);\n    };\n    __assign = function() {\n      __assign = Object.assign || function __assign2(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign.apply(this, arguments);\n    };\n  }\n});\n\n// node_modules/keyv-file/lib/safe-encoder.js\nvar require_safe_encoder = __commonJS({\n  \"node_modules/keyv-file/lib/safe-encoder.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.SafeFilenameEncoder = void 0;\n    exports2.SafeFilenameEncoder = {\n      // τ╝ûτáü∩╝Üσ░åτë╣µ«èσ¡ùτ¼ªΦ╜¼µìóΣ╕║σ«ëσà¿τÜäµûçΣ╗╢σÉì\n      encode(str) {\n        return str.replace(/[^0-9a-zA-Z]/g, (_) => {\n          const code = _.charCodeAt(0);\n          if (code < 0 || code > 126) {\n            return _;\n          }\n          return \"%\" + _.charCodeAt(0).toString(16).padStart(2, \"0\");\n        }).replace(/%/g, \"_\");\n      },\n      // Φºúτáü∩╝ÜΦ┐ÿσÄƒσÄƒσºïσ¡ùτ¼ªΣ╕▓\n      decode(str) {\n        return decodeURIComponent(str.replace(/_/g, \"%\"));\n      }\n    };\n  }\n});\n\n// node_modules/keyv-file/lib/separated-file-store.js\nvar require_separated_file_store = __commonJS({\n  \"node_modules/keyv-file/lib/separated-file-store.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.SeparatedFileHelper = void 0;\n    exports2.handleIOError = handleIOError;\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    var path_1 = tslib_1.__importDefault(require(\"path\"));\n    var fs4 = tslib_1.__importStar(require(\"fs\"));\n    var fsp = tslib_1.__importStar(require(\"fs/promises\"));\n    var safe_encoder_1 = require_safe_encoder();\n    function handleIOError(e) {\n      if (e.code === \"ENOENT\") {\n        return;\n      } else {\n        console.error(e);\n      }\n    }\n    var SeparatedFileHelper = class {\n      opts;\n      get lockFile() {\n        return path_1.default.join(this.opts.filename, \".lock\");\n      }\n      get _lastExpireFile() {\n        return path_1.default.join(this.opts.filename, \".lastExpire\");\n      }\n      constructor(opts) {\n        this.opts = opts;\n      }\n      getLastExpire() {\n        try {\n          return Number(fs4.readFileSync(this._lastExpireFile, \"utf8\"));\n        } catch (error) {\n          handleIOError(error);\n        }\n        return 0;\n      }\n      setLastExpire(expire) {\n        try {\n          fsp.writeFile(this._lastExpireFile, expire.toString());\n        } catch (error) {\n          handleIOError(error);\n        }\n      }\n      async get(key) {\n        try {\n          let rawData = await fsp.readFile(this._getKey(key));\n          let data = this.opts.deserialize(rawData);\n          return data;\n        } catch (error) {\n          handleIOError(error);\n        }\n      }\n      /**\n       * µá╣µì«Θö«ΦÄ╖σÅûµûçΣ╗╢σåàσ«╣\n       * @param key - µûçΣ╗╢Θö«σÉì∩╝îσÉîµù╢Σ╣ƒµÿ»µûçΣ╗╢σÉì\n       * @returns Φ┐öσ¢₧Σ╕ÇΣ╕¬Promise∩╝îΦºúµ₧ÉΣ╕║µûçΣ╗╢σåàσ«╣\n       */\n      getSync(key) {\n        try {\n          let rawData = fs4.readFileSync(this._getKey(key));\n          let data = this.opts.deserialize(rawData);\n          return data;\n        } catch (error) {\n          handleIOError(error);\n        }\n      }\n      _getKey(key) {\n        return path_1.default.join(this.opts.filename, safe_encoder_1.SafeFilenameEncoder.encode(key));\n      }\n      async set(key, value) {\n        try {\n          let rawData = this.opts.serialize(value);\n          await fsp.mkdir(this.opts.filename, {\n            recursive: true\n          });\n          await fsp.writeFile(this._getKey(key), rawData);\n        } catch (e) {\n          handleIOError(e);\n        }\n      }\n      async delete(key) {\n        try {\n          await fsp.unlink(this._getKey(key));\n          return true;\n        } catch (e) {\n          handleIOError(e);\n          return false;\n        }\n      }\n      async clear() {\n        await fsp.rm(this.opts.filename, {\n          recursive: true,\n          force: true\n        });\n      }\n      async clearExpire(clearExpire) {\n        try {\n          let keys = await fsp.readdir(this.opts.filename);\n          for (const key of keys) {\n            clearExpire(key);\n          }\n          await fsp.writeFile(this._lastExpireFile, Date.now().toString());\n        } catch (error) {\n          handleIOError(error);\n        }\n      }\n      async entries() {\n        return fsp.readdir(this.opts.filename).then((keys) => {\n          return Promise.all(keys.map(async (key) => {\n            key = safe_encoder_1.SafeFilenameEncoder.decode(key);\n            return [key, await this.get(key)];\n          }));\n        });\n      }\n    };\n    exports2.SeparatedFileHelper = SeparatedFileHelper;\n  }\n});\n\n// node_modules/keyv-file/lib/make-field.js\nvar require_make_field = __commonJS({\n  \"node_modules/keyv-file/lib/make-field.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.Field = void 0;\n    exports2.makeField = makeField;\n    var Field = class {\n      kv;\n      key;\n      defaults;\n      constructor(kv, key, defaults) {\n        this.kv = kv;\n        this.key = key;\n        this.defaults = defaults;\n      }\n      async get(def = this.defaults) {\n        return await this.kv.get(this.key) ?? def;\n      }\n      getSync(def = this.defaults) {\n        if (this.kv instanceof Map) {\n          return this.kv.get(this.key) ?? def;\n        } else if (\"getSync\" in this.kv) {\n          return this.kv.getSync(this.key) ?? def;\n        }\n        throw new Error(\"kv does not support getSync\");\n      }\n      // setSync(def:T) {\n      //   if ('setSync' in this.kv) {\n      //     return this.kv.setSync(this.key, def) ?? def\n      //   }\n      //   throw new Error('kv does not support getSync')\n      // }\n      /**\n       * Note: `await kv.someFiled.set()` will wait <options.writeDelay> millseconds to save to disk, it would be slow. Please remove `await` if you find performance issues.\n       * @param value\n       * @param ttl\n       * @returns\n       */\n      set(val, ttl) {\n        return this.kv.set(this.key, val, ttl);\n      }\n      delete() {\n        return this.kv.delete(this.key);\n      }\n    };\n    exports2.Field = Field;\n    function makeField(kv, key, defaults) {\n      return new Field(kv, key, defaults);\n    }\n  }\n});\n\n// node_modules/keyv-file/lib/index.js\nvar require_lib2 = __commonJS({\n  \"node_modules/keyv-file/lib/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.KeyvFile = exports2.defaultOpts = void 0;\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    var os = tslib_1.__importStar(require(\"os\"));\n    var fs4 = tslib_1.__importStar(require(\"fs\"));\n    var fsp = tslib_1.__importStar(require(\"fs/promises\"));\n    var events_1 = tslib_1.__importDefault(require(\"events\"));\n    var serialize_1 = require_dist3();\n    var path_1 = tslib_1.__importDefault(require(\"path\"));\n    var separated_file_store_1 = require_separated_file_store();\n    tslib_1.__exportStar(require_make_field(), exports2);\n    exports2.defaultOpts = {\n      deserialize: (val) => (0, serialize_1.defaultDeserialize)(val.toString()),\n      dialect: \"redis\",\n      expiredCheckDelay: 24 * 3600 * 1e3,\n      // ms\n      filename: `${os.tmpdir()}/keyv-file/default.json`,\n      serialize: serialize_1.defaultSerialize,\n      writeDelay: 100,\n      // ms\n      checkFileLock: false,\n      separatedFile: false\n    };\n    function isNumber(val) {\n      return typeof val === \"number\";\n    }\n    var KeyvFile2 = class extends events_1.default {\n      ttlSupport = true;\n      namespace;\n      opts;\n      _data = /* @__PURE__ */ new Map();\n      _lastExpire = 0;\n      _separated;\n      constructor(options) {\n        super();\n        this.opts = Object.assign({}, exports2.defaultOpts, options);\n        this._separated = new separated_file_store_1.SeparatedFileHelper(this.opts);\n        if (this.opts.checkFileLock) {\n          this.acquireFileLock();\n        }\n        if (this.opts.separatedFile) {\n          fs4.mkdirSync(this.opts.filename, { recursive: true });\n          this._lastExpire = this._separated.getLastExpire();\n        } else {\n          this._loadDataSync();\n        }\n      }\n      _loadDataSync() {\n        try {\n          const data = this.opts.deserialize(fs4.readFileSync(this.opts.filename));\n          if (!Array.isArray(data.cache)) {\n            const _cache = data.cache;\n            data.cache = [];\n            for (const key in _cache) {\n              if (_cache.hasOwnProperty(key)) {\n                data.cache.push([key, _cache[key]]);\n              }\n            }\n          }\n          this._data = new Map(data.cache);\n          this._lastExpire = data.lastExpire;\n        } catch (e) {\n          (0, separated_file_store_1.handleIOError)(e);\n          this._data = /* @__PURE__ */ new Map();\n          this._lastExpire = Date.now();\n        }\n      }\n      get _lockFile() {\n        if (this.opts.separatedFile) {\n          return this._separated.lockFile;\n        }\n        return this.opts.filename + \".lock\";\n      }\n      acquireFileLock() {\n        try {\n          let fd = fs4.openSync(this._lockFile, \"wx\");\n          fs4.closeSync(fd);\n          process.on(\"SIGINT\", () => {\n            this.releaseFileLock();\n            process.exit(0);\n          });\n          process.on(\"exit\", () => {\n            this.releaseFileLock();\n          });\n        } catch (error) {\n          console.error(`[keyv-file] There is another process using this file`);\n          throw error;\n        }\n      }\n      releaseFileLock() {\n        try {\n          fs4.unlinkSync(this._lockFile);\n        } catch (e) {\n          (0, separated_file_store_1.handleIOError)(e);\n        }\n      }\n      async get(key) {\n        if (this.opts.separatedFile) {\n          let data = await this._separated.get(key);\n          return this._getWithExpire(key, data);\n        }\n        return this.getSync(key);\n      }\n      getSync(key) {\n        if (this.opts.separatedFile) {\n          let data = this._separated.getSync(key);\n          return this._getWithExpire(key, data);\n        }\n        let ret = void 0;\n        try {\n          const data = this._data.get(key);\n          return this._getWithExpire(key, data);\n        } catch (error) {\n          (0, separated_file_store_1.handleIOError)(error);\n        }\n        return ret;\n      }\n      async getMany(keys) {\n        if (this.opts.separatedFile) {\n          return Promise.all(keys.map((key) => this.get(key)));\n        }\n        return keys.map((key) => this.getSync(key));\n      }\n      /**\n       * Note: `await kv.set()` will wait <options.writeDelay> millseconds to save to disk, it would be slow. Please remove `await` if you find performance issues.\n       * @param key\n       * @param value\n       * @param ttl\n       * @returns\n       */\n      async set(key, value, ttl) {\n        if (ttl === 0) {\n          ttl = void 0;\n        }\n        value = {\n          expire: isNumber(ttl) ? Date.now() + ttl : void 0,\n          value\n        };\n        this.clearExpire();\n        if (this.opts.separatedFile) {\n          return this._separated.set(key, value);\n        }\n        this._data.set(key, value);\n        return this.save();\n      }\n      async delete(key) {\n        if (this.opts.separatedFile) {\n          return this._separated.delete(key);\n        }\n        const ret = this._data.delete(key);\n        await this.save();\n        return ret;\n      }\n      async deleteMany(keys) {\n        if (this.opts.separatedFile) {\n          let ret = await Promise.all(keys.map((key) => this.delete(key)));\n          return ret.every((r) => r);\n        }\n        let res = keys.every((key) => this._data.delete(key));\n        await this.save();\n        return res;\n      }\n      async clear() {\n        if (this.opts.separatedFile) {\n          await this._separated.clear();\n          this._lastExpire = 0;\n          return true;\n        }\n        this._data = /* @__PURE__ */ new Map();\n        this._lastExpire = Date.now();\n        return this.save();\n      }\n      async has(key) {\n        const value = await this.get(key);\n        return value !== void 0;\n      }\n      isExpired(data) {\n        return isNumber(data.expire) && data.expire <= Date.now();\n      }\n      _getWithExpire(key, data) {\n        if (!data) {\n          return;\n        }\n        if (this.isExpired(data)) {\n          this.delete(key);\n          return;\n        }\n        return data.value;\n      }\n      clearExpire() {\n        const now = Date.now();\n        if (now - this._lastExpire <= this.opts.expiredCheckDelay) {\n          return;\n        }\n        this._lastExpire = now;\n        if (this.opts.separatedFile) {\n          this._separated.clearExpire((key) => this.get(key));\n          return;\n        }\n        for (const key of this._data.keys()) {\n          const data = this._data.get(key);\n          this._getWithExpire(key, data);\n        }\n      }\n      async saveToDisk() {\n        const cache = [];\n        for (const [key, val] of this._data) {\n          cache.push([key, val]);\n        }\n        const data = this.opts.serialize({\n          cache,\n          lastExpire: this._lastExpire\n        });\n        await fsp.mkdir(path_1.default.dirname(this.opts.filename), {\n          recursive: true\n        });\n        return fsp.writeFile(this.opts.filename, data);\n      }\n      _savePromise;\n      save() {\n        this.clearExpire();\n        if (this._savePromise) {\n          return this._savePromise;\n        }\n        this._savePromise = new Promise((resolve, reject) => {\n          setTimeout(() => {\n            this.saveToDisk().then(resolve, reject).finally(() => {\n              this._savePromise = void 0;\n            });\n          }, this.opts.writeDelay);\n        });\n        return this._savePromise;\n      }\n      disconnect() {\n        return Promise.resolve();\n      }\n      async *iterator(namespace) {\n        let entries = this.opts.separatedFile ? await this._separated.entries() : this._data.entries();\n        for (const [key, data] of entries) {\n          if (key === void 0 || data === void 0) {\n            continue;\n          }\n          if (!namespace || key.includes(namespace)) {\n            yield [key, data.value];\n          }\n        }\n      }\n    };\n    exports2.KeyvFile = KeyvFile2;\n    exports2.default = KeyvFile2;\n  }\n});\n\n// electron/services/LogWatcherService.ts\nfunction setupLogWatcherHandlers() {\n  import_electron5.ipcMain.handle(\"log-watcher:start\", (event) => {\n    const win = import_electron5.BrowserWindow.fromWebContents(event.sender);\n    logWatcherService.start(win || void 0);\n    return { success: true };\n  });\n  import_electron5.ipcMain.handle(\"log-watcher:stop\", () => {\n    logWatcherService.stop();\n    return { success: true };\n  });\n}\nvar import_electron5, import_electron_log5, import_fs2, import_path3, import_events, logger5, LogWatcherService, logWatcherService;\nvar init_LogWatcherService = __esm({\n  \"electron/services/LogWatcherService.ts\"() {\n    \"use strict\";\n    import_electron5 = require(\"electron\");\n    import_electron_log5 = __toESM(require_src2(), 1);\n    import_fs2 = __toESM(require(\"fs\"), 1);\n    import_path3 = __toESM(require(\"path\"), 1);\n    import_events = require(\"events\");\n    logger5 = import_electron_log5.default.scope(\"LogWatcher\");\n    LogWatcherService = class extends import_events.EventEmitter {\n      constructor() {\n        super(...arguments);\n        this.currentLogPath = null;\n        this.currentFileSize = 0;\n        this.watcherInterval = null;\n        this.isWatching = false;\n        // State for late joiners\n        this.state = {\n          currentWorldId: null,\n          currentWorldName: null,\n          currentLocation: null,\n          players: /* @__PURE__ */ new Map()\n        };\n      }\n      /**\n       * Start watching. Validates directory, finds latest log, and starts trailing.\n       * If callerWindow is provided, syncs current state to it immediately.\n       */\n      start(callerWindow) {\n        if (callerWindow && !callerWindow.isDestroyed()) {\n          this.emitStateToWindow(callerWindow);\n        }\n        if (this.isWatching) {\n          import_electron_log5.default.info(\"[LogWatcher] Service already running, synced state to requestor.\");\n          return;\n        }\n        this.isWatching = true;\n        import_electron_log5.default.info(\"[LogWatcher] Starting service...\");\n        this.findLatestLog();\n        this.watcherInterval = setInterval(() => {\n          this.checkLogPath();\n          this.readNewContent();\n        }, 1e3);\n      }\n      stop() {\n        this.isWatching = false;\n        if (this.watcherInterval) {\n          clearInterval(this.watcherInterval);\n          this.watcherInterval = null;\n        }\n        import_electron_log5.default.info(\"[LogWatcher] Service stopped\");\n      }\n      emitStateToWindow(window2) {\n        import_electron_log5.default.info(\"[LogWatcher] Syncing state to renderer...\");\n        const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(\"T\", \" \").substring(0, 19).replace(/-/g, \".\");\n        if (this.state.currentWorldName) {\n          window2.webContents.send(\"log:world-name\", { name: this.state.currentWorldName, timestamp });\n        }\n        if (this.state.currentWorldId) {\n          window2.webContents.send(\"log:location\", { worldId: this.state.currentWorldId, timestamp });\n        }\n        for (const player of this.state.players.values()) {\n          window2.webContents.send(\"log:player-joined\", player);\n        }\n      }\n      getLogDirectory() {\n        const appData = import_electron5.app.getPath(\"appData\");\n        const localLow = import_path3.default.join(appData, \"..\", \"LocalLow\");\n        return import_path3.default.join(localLow, \"VRChat\", \"VRChat\");\n      }\n      findLatestLog() {\n        try {\n          const logDir = this.getLogDirectory();\n          if (!import_fs2.default.existsSync(logDir)) {\n            import_electron_log5.default.warn(`[LogWatcher] VRChat log directory not found: ${logDir}`);\n            return;\n          }\n          const files = import_fs2.default.readdirSync(logDir).filter((f) => f.startsWith(\"output_log_\") && f.endsWith(\".txt\")).map((f) => {\n            const fullPath = import_path3.default.join(logDir, f);\n            return {\n              name: f,\n              path: fullPath,\n              stat: import_fs2.default.statSync(fullPath)\n            };\n          }).sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());\n          if (files.length > 0) {\n            const latest = files[0];\n            if (latest.path !== this.currentLogPath) {\n              import_electron_log5.default.info(`[LogWatcher] Found new log file: ${latest.name}`);\n              this.currentLogPath = latest.path;\n              this.currentFileSize = 0;\n              this.state = { currentWorldId: null, currentWorldName: null, currentLocation: null, players: /* @__PURE__ */ new Map() };\n            }\n          }\n        } catch (error) {\n          import_electron_log5.default.error(\"[LogWatcher] Error searching for logs:\", error);\n        }\n      }\n      checkLogPath() {\n        this.findLatestLog();\n      }\n      readNewContent() {\n        if (!this.currentLogPath) return;\n        try {\n          if (!import_fs2.default.existsSync(this.currentLogPath)) return;\n          const stat = import_fs2.default.statSync(this.currentLogPath);\n          if (stat.size > this.currentFileSize) {\n            const stream = import_fs2.default.createReadStream(this.currentLogPath, {\n              start: this.currentFileSize,\n              end: stat.size\n            });\n            let buffer = \"\";\n            stream.on(\"data\", (chunk) => {\n              buffer += chunk.toString();\n            });\n            stream.on(\"end\", () => {\n              this.currentFileSize = stat.size;\n              const lines = buffer.split(\"\\n\");\n              for (const line of lines) {\n                if (line.trim()) this.parseLine(line.trim());\n              }\n            });\n          }\n        } catch (err) {\n          import_electron_log5.default.error(\"[LogWatcher] Error reading log:\", err);\n        }\n      }\n      parseLine(line) {\n        const timestamp = line.substring(0, 19);\n        const reJoining = /Joining\\s+(wrld_[a-zA-Z0-9-]+):([^\\s]+)/;\n        const rePlayerJoined = /OnPlayerJoined\\s+(?:\\[[^\\]]+\\]\\s*)?([^\\r\\n(]+?)\\s*\\((usr_[a-f0-9-]{36})\\)/;\n        const rePlayerLeft = /OnPlayerLeft\\s+([^\\r\\n(]+?)\\s*\\((usr_[a-f0-9-]{36})\\)/;\n        const reEntering = /\\[Behaviour\\] Entering Room: (.+)/;\n        const reAvatar = /\\[Avatar\\] Loading Avatar:\\s+(avtr_[a-f0-9-]{36})/;\n        const joinMatch = line.match(reJoining);\n        if (joinMatch) {\n          const worldId = joinMatch[1];\n          const fullInstanceString = joinMatch[2];\n          const instanceId = fullInstanceString;\n          const location = `${worldId}:${fullInstanceString}`;\n          import_electron_log5.default.info(`[LogWatcher] MATCH Joining: ${location}`);\n          if (this.state.currentLocation !== location) {\n            import_electron_log5.default.info(`[LogWatcher] Location CHANGED from ${this.state.currentLocation} to ${location}`);\n            if (this.state.currentWorldId !== worldId) {\n              this.state.players.clear();\n            }\n            this.state.currentWorldId = worldId;\n            this.state.currentLocation = location;\n            this.emitToRenderer(\"log:location\", { worldId, instanceId, location, timestamp });\n            this.emit(\"location\", { worldId, instanceId, location, timestamp });\n          }\n        }\n        const avatarMatch = line.match(reAvatar);\n        if (avatarMatch) {\n          const avatarId = avatarMatch[1];\n          import_electron_log5.default.info(`[LogWatcher] MATCH Avatar: ${avatarId}`);\n          this.emitToRenderer(\"log:avatar\", { avatarId, timestamp });\n          this.emit(\"avatar\", { avatarId, timestamp });\n        }\n        const enterMatch = line.match(reEntering);\n        if (enterMatch) {\n          const worldName = enterMatch[1].trim();\n          import_electron_log5.default.info(`[LogWatcher] MATCH Entering Room: ${worldName}`);\n          this.state.currentWorldName = worldName;\n          this.emitToRenderer(\"log:world-name\", { name: worldName, timestamp });\n          this.emit(\"world-name\", { name: worldName, timestamp });\n        }\n        const playerJoinMatch = line.match(rePlayerJoined);\n        if (playerJoinMatch) {\n          const displayName = playerJoinMatch[1].trim();\n          const userId = playerJoinMatch[2];\n          import_electron_log5.default.info(`[LogWatcher] MATCH Player Joined: ${displayName} (${userId})`);\n          const playerEvent = { displayName, userId, timestamp };\n          this.state.players.set(displayName, playerEvent);\n          this.emitToRenderer(\"log:player-joined\", playerEvent);\n          this.emit(\"player-joined\", playerEvent);\n        }\n        const playerLeftMatch = line.match(rePlayerLeft);\n        if (playerLeftMatch) {\n          const displayName = playerLeftMatch[1].trim();\n          const userId = playerLeftMatch[2];\n          import_electron_log5.default.info(`[LogWatcher] MATCH Player Left: ${displayName} (${userId})`);\n          this.state.players.delete(displayName);\n          this.emitToRenderer(\"log:player-left\", { displayName, userId, timestamp });\n          this.emit(\"player-left\", { displayName, userId, timestamp });\n        }\n      }\n      emitToRenderer(channel, data) {\n        const windows = import_electron5.BrowserWindow.getAllWindows();\n        for (const win of windows) {\n          if (!win.isDestroyed()) {\n            win.webContents.send(channel, data);\n          }\n        }\n      }\n      getPlayers() {\n        return Array.from(this.state.players.values());\n      }\n    };\n    logWatcherService = new LogWatcherService();\n  }\n});\n\n// electron/services/InstanceLoggerService.ts\nvar InstanceLoggerService_exports = {};\n__export(InstanceLoggerService_exports, {\n  instanceLoggerService: () => instanceLoggerService\n});\nvar import_electron6, import_electron_log6, import_fs3, import_path4, import_electron7, logger6, InstanceLoggerService, instanceLoggerService;\nvar init_InstanceLoggerService = __esm({\n  \"electron/services/InstanceLoggerService.ts\"() {\n    \"use strict\";\n    import_electron6 = require(\"electron\");\n    init_LogWatcherService();\n    import_electron_log6 = __toESM(require_src2(), 1);\n    import_fs3 = __toESM(require(\"fs\"), 1);\n    import_path4 = __toESM(require(\"path\"), 1);\n    import_electron7 = require(\"electron\");\n    logger6 = import_electron_log6.default.scope(\"InstanceLogger\");\n    InstanceLoggerService = class {\n      constructor() {\n        this.currentSessionId = null;\n        this.currentLogFilePath = null;\n        this.currentWorldId = null;\n        this.currentInstanceId = null;\n        this.currentLocationString = null;\n        this.currentWorldName = null;\n        // Stored for live display\n        this.currentGroupId = null;\n        this.allowedGroupIds = null;\n        this.setupListeners();\n      }\n      setupListeners() {\n        logWatcherService.on(\"location\", (event) => this.handleLocationChange(event));\n        logWatcherService.on(\"world-name\", (event) => this.handleWorldNameChange(event));\n        logWatcherService.on(\"player-joined\", (event) => this.logEvent(\"PLAYER_JOIN\", event));\n        logWatcherService.on(\"player-left\", (event) => this.logEvent(\"PLAYER_LEFT\", event));\n      }\n      // ...\n      getCurrentWorldId() {\n        return this.currentWorldId;\n      }\n      getCurrentWorldName() {\n        return this.currentWorldName;\n      }\n      getCurrentInstanceId() {\n        return this.currentInstanceId;\n      }\n      getCurrentLocation() {\n        return this.currentLocationString;\n      }\n      handleLocationChange(event) {\n        try {\n          this.currentLocationString = event.location;\n          this.currentWorldName = null;\n          const previousLocation = this.currentLogFilePath;\n          this.currentWorldId = event.worldId;\n          this.currentInstanceId = event.instanceId;\n          const groupMatch = event.location.match(/~group\\((grp_[a-f0-9-]+)\\)/);\n          const groupId = groupMatch ? groupMatch[1] : null;\n          if (this.currentGroupId !== groupId) {\n            this.currentGroupId = groupId;\n            import_electron6.BrowserWindow.getAllWindows().forEach((w) => {\n              w.webContents.send(\"instance:group-changed\", groupId);\n            });\n          }\n          if (!groupId) {\n            logger6.info(\"Skipping non-group instance:\", event.location);\n            if (previousLocation && this.currentSessionId) {\n              this.appendToFile({\n                type: \"SESSION_END\",\n                timestamp: event.timestamp,\n                reason: \"LEFT_GROUP_INSTANCE\"\n              });\n            }\n            this.cleanupCurrentSession();\n            return;\n          }\n          if (this.allowedGroupIds && !this.allowedGroupIds.has(groupId)) {\n            import_electron_log6.default.info(`[InstanceLogger] Skipping group ${groupId} - not in moderated list`);\n            if (previousLocation && this.currentSessionId) {\n              this.appendToFile({\n                type: \"SESSION_END\",\n                timestamp: event.timestamp,\n                reason: \"LEFT_MODERATED_GROUP\"\n              });\n            }\n            this.cleanupCurrentSession();\n            return;\n          }\n          const existingSession = this.findExistingSessionForInstance(event.location);\n          if (existingSession) {\n            import_electron_log6.default.info(`[InstanceLogger] Rejoining existing session: ${existingSession.filename}`);\n            this.currentSessionId = existingSession.sessionId;\n            this.currentLogFilePath = import_path4.default.join(this.getSessionsDir(), existingSession.filename);\n            this.appendToFile({\n              type: \"SESSION_REJOIN\",\n              timestamp: event.timestamp,\n              actorDisplayName: \"System\",\n              details: { location: event.location }\n            });\n          } else {\n            this.currentSessionId = `sess_${Date.now()}`;\n            const safeLocation = event.location.replace(/[^a-zA-Z0-9_\\-.]/g, \"_\");\n            const filename = `${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, \"-\")}_${safeLocation}.jsonl`;\n            this.currentLogFilePath = import_path4.default.join(this.getSessionsDir(), filename);\n            const metadata = {\n              meta: true,\n              sessionId: this.currentSessionId,\n              worldId: event.worldId,\n              instanceId: event.instanceId,\n              location: event.location,\n              groupId,\n              startTime: event.timestamp,\n              worldName: null\n            };\n            import_fs3.default.writeFileSync(this.currentLogFilePath, JSON.stringify(metadata) + \"\\n\");\n            import_electron_log6.default.info(`[InstanceLogger] Started new session log: ${filename}`);\n            this.appendToFile({\n              type: \"LOCATION_CHANGE\",\n              timestamp: event.timestamp,\n              actorDisplayName: \"System\",\n              details: { location: event.location }\n            });\n          }\n        } catch (error) {\n          import_electron_log6.default.error(\"[InstanceLogger] Failed to handle location change:\", error);\n        }\n      }\n      /** Find an existing session file for the same instance location */\n      findExistingSessionForInstance(location) {\n        try {\n          const sessionsDir = this.getSessionsDir();\n          if (!import_fs3.default.existsSync(sessionsDir)) return null;\n          const files = import_fs3.default.readdirSync(sessionsDir).filter((f) => f.endsWith(\".jsonl\"));\n          for (const file of files) {\n            const filePath = import_path4.default.join(sessionsDir, file);\n            try {\n              const fd = import_fs3.default.openSync(filePath, \"r\");\n              const buffer = Buffer.alloc(2048);\n              import_fs3.default.readSync(fd, buffer, 0, 2048, 0);\n              import_fs3.default.closeSync(fd);\n              const firstLine = buffer.toString(\"utf-8\").split(\"\\n\")[0];\n              const meta = JSON.parse(firstLine);\n              if (meta.meta && meta.location === location) {\n                return { sessionId: meta.sessionId, filename: file };\n              }\n            } catch {\n            }\n          }\n        } catch (error) {\n          import_electron_log6.default.warn(\"[InstanceLogger] Error searching for existing session:\", error);\n        }\n        return null;\n      }\n      cleanupCurrentSession() {\n        this.currentSessionId = null;\n        this.currentLogFilePath = null;\n      }\n      handleWorldNameChange(event) {\n        this.currentWorldName = event.name;\n        if (!this.currentSessionId || !this.currentLogFilePath) return;\n        this.appendToFile({\n          type: \"WORLD_NAME_UPDATE\",\n          timestamp: event.timestamp,\n          worldName: event.name\n        });\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      logEvent(type, event) {\n        if (!this.currentSessionId || !this.currentLogFilePath) return;\n        const logEntry = {\n          type,\n          timestamp: event.timestamp,\n          actorDisplayName: event.displayName || \"Self\",\n          actorUserId: event.userId,\n          details: event.avatarId ? { avatarId: event.avatarId } : void 0\n        };\n        this.appendToFile(logEntry);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      appendToFile(data) {\n        if (!this.currentLogFilePath) return;\n        try {\n          import_fs3.default.appendFileSync(this.currentLogFilePath, JSON.stringify(data) + \"\\n\");\n        } catch (error) {\n          import_electron_log6.default.error(\"[InstanceLogger] Failed to write to log file:\", error);\n        }\n      }\n      getSessions(groupIdFilter) {\n        try {\n          const files = import_fs3.default.readdirSync(this.getSessionsDir()).filter((f) => f.endsWith(\".jsonl\"));\n          const sessions = [];\n          for (const file of files) {\n            const filePath = import_path4.default.join(this.getSessionsDir(), file);\n            const fd = import_fs3.default.openSync(filePath, \"r\");\n            const buffer = Buffer.alloc(4096);\n            import_fs3.default.readSync(fd, buffer, 0, 4096, 0);\n            import_fs3.default.closeSync(fd);\n            const firstLine = buffer.toString(\"utf-8\").split(\"\\n\")[0];\n            try {\n              const meta = JSON.parse(firstLine);\n              if (meta.meta) {\n                if (groupIdFilter && meta.groupId !== groupIdFilter) {\n                  continue;\n                }\n                if (!meta.worldName) {\n                  try {\n                    const content = import_fs3.default.readFileSync(filePath, \"utf-8\");\n                    const nameUpdate = content.split(\"\\n\").map((line) => {\n                      try {\n                        return JSON.parse(line);\n                      } catch {\n                        return null;\n                      }\n                    }).find((e) => e && e.type === \"WORLD_NAME_UPDATE\");\n                    if (nameUpdate && nameUpdate.worldName) {\n                      meta.worldName = nameUpdate.worldName;\n                    }\n                  } catch {\n                  }\n                }\n                sessions.push({ ...meta, filename: file });\n              }\n            } catch {\n            }\n          }\n          return sessions.sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());\n        } catch (error) {\n          import_electron_log6.default.error(\"[InstanceLogger] Failed to get sessions:\", error);\n          return [];\n        }\n      }\n      getSessionEvents(filename) {\n        try {\n          const filePath = import_path4.default.join(this.getSessionsDir(), filename);\n          if (!import_fs3.default.existsSync(filePath)) return null;\n          const content = import_fs3.default.readFileSync(filePath, \"utf-8\");\n          const lines = content.split(\"\\n\").filter((l) => l.trim());\n          const events = lines.map((l) => {\n            try {\n              return JSON.parse(l);\n            } catch {\n              return null;\n            }\n          }).filter((e) => e !== null && !e.meta);\n          return events;\n        } catch (error) {\n          import_electron_log6.default.error(\"[InstanceLogger] Failed to get session events:\", error);\n          return null;\n        }\n      }\n      clearSessions() {\n        try {\n          const dir = this.getSessionsDir();\n          if (import_fs3.default.existsSync(dir)) {\n            const files = import_fs3.default.readdirSync(dir).filter((f) => f.endsWith(\".jsonl\"));\n            for (const file of files) {\n              import_fs3.default.unlinkSync(import_path4.default.join(dir, file));\n            }\n          }\n          return true;\n        } catch (error) {\n          import_electron_log6.default.error(\"[InstanceLogger] Failed to clear sessions:\", error);\n          return false;\n        }\n      }\n      getCurrentGroupId() {\n        return this.currentGroupId;\n      }\n      getSessionsDir() {\n        const userData = import_electron6.app.getPath(\"userData\");\n        const sessionsDir = import_path4.default.join(userData, \"sessions\");\n        if (!import_fs3.default.existsSync(sessionsDir)) {\n          import_fs3.default.mkdirSync(sessionsDir, { recursive: true });\n        }\n        return sessionsDir;\n      }\n    };\n    instanceLoggerService = new InstanceLoggerService();\n    import_electron7.ipcMain.handle(\"database:get-sessions\", async (_, groupId) => {\n      return instanceLoggerService.getSessions(groupId);\n    });\n    import_electron7.ipcMain.handle(\"database:get-session-events\", async (_, filename) => {\n      return instanceLoggerService.getSessionEvents(filename);\n    });\n    import_electron7.ipcMain.handle(\"database:clear-sessions\", async () => {\n      return instanceLoggerService.clearSessions();\n    });\n    import_electron7.ipcMain.handle(\"instance:get-current-group\", async () => {\n      return instanceLoggerService.getCurrentGroupId();\n    });\n  }\n});\n\n// electron/main.ts\nvar import_electron12 = require(\"electron\");\nvar import_path5 = __toESM(require(\"path\"), 1);\nvar import_electron_updater = __toESM(require_main2(), 1);\nvar import_electron_log11 = __toESM(require_src2(), 1);\n\n// electron/services/AuthService.ts\nvar import_electron4 = require(\"electron\");\nvar import_electron_log4 = __toESM(require_src2(), 1);\nvar import_path2 = __toESM(require(\"path\"), 1);\n\n// electron/services/CredentialsService.ts\nvar import_electron = require(\"electron\");\nvar import_electron_log = __toESM(require_src2(), 1);\nvar logger = import_electron_log.default.scope(\"CredentialsService\");\nvar Store = require_electron_store();\nvar store = new Store({\n  name: \"group-guard-credentials\",\n  encryptionKey: \"group-guard-secure-storage-v1\",\n  // Additional layer of encryption\n  defaults: {\n    rememberMe: false\n  }\n});\nfunction saveCredentials(username, password, authCookie) {\n  try {\n    let encryptedPassword;\n    if (import_electron.safeStorage.isEncryptionAvailable()) {\n      const encrypted = import_electron.safeStorage.encryptString(password);\n      encryptedPassword = encrypted.toString(\"base64\");\n    } else {\n      encryptedPassword = Buffer.from(password).toString(\"base64\");\n      import_electron_log.default.warn(\"safeStorage not available, using fallback encryption\");\n    }\n    const credentials = {\n      username,\n      encryptedPassword,\n      authCookie\n    };\n    store.set(\"savedCredentials\", credentials);\n    store.set(\"rememberMe\", true);\n    import_electron_log.default.info(\"Credentials saved securely\");\n    return true;\n  } catch (error) {\n    import_electron_log.default.error(\"Failed to save credentials:\", error);\n    return false;\n  }\n}\nfunction loadCredentials() {\n  try {\n    const saved = store.get(\"savedCredentials\");\n    if (!saved) {\n      return null;\n    }\n    let password;\n    if (import_electron.safeStorage.isEncryptionAvailable()) {\n      try {\n        const encrypted = Buffer.from(saved.encryptedPassword, \"base64\");\n        password = import_electron.safeStorage.decryptString(encrypted);\n      } catch {\n        password = Buffer.from(saved.encryptedPassword, \"base64\").toString(\"utf-8\");\n      }\n    } else {\n      password = Buffer.from(saved.encryptedPassword, \"base64\").toString(\"utf-8\");\n    }\n    return {\n      username: saved.username,\n      password,\n      authCookie: saved.authCookie\n    };\n  } catch (error) {\n    import_electron_log.default.error(\"Failed to load credentials:\", error);\n    return null;\n  }\n}\nfunction clearCredentials() {\n  try {\n    store.delete(\"savedCredentials\");\n    store.set(\"rememberMe\", false);\n    import_electron_log.default.info(\"Credentials cleared\");\n  } catch (error) {\n    import_electron_log.default.error(\"Failed to clear credentials:\", error);\n  }\n}\nfunction hasSavedCredentials() {\n  return store.has(\"savedCredentials\") && store.get(\"rememberMe\", false);\n}\nfunction getRememberMe() {\n  return store.get(\"rememberMe\", false);\n}\nfunction setupCredentialsHandlers() {\n  import_electron.ipcMain.handle(\"credentials:has-saved\", () => {\n    return hasSavedCredentials();\n  });\n  import_electron.ipcMain.handle(\"credentials:get-remember-me\", () => {\n    return getRememberMe();\n  });\n  import_electron.ipcMain.handle(\"credentials:save\", (_event, { username, password, authCookie }) => {\n    return saveCredentials(username, password, authCookie);\n  });\n  import_electron.ipcMain.handle(\"credentials:clear\", () => {\n    clearCredentials();\n    return true;\n  });\n  import_electron.ipcMain.handle(\"credentials:load\", () => {\n    return loadCredentials();\n  });\n  import_electron_log.default.info(\"Credentials handlers initialized\");\n}\n\n// electron/services/PipelineService.ts\nvar import_electron2 = require(\"electron\");\nvar import_electron_log2 = __toESM(require_src2(), 1);\n\n// node_modules/ws/wrapper.mjs\nvar import_stream = __toESM(require_stream(), 1);\nvar import_receiver = __toESM(require_receiver(), 1);\nvar import_sender = __toESM(require_sender(), 1);\nvar import_websocket = __toESM(require_websocket(), 1);\nvar import_websocket_server = __toESM(require_websocket_server(), 1);\nvar wrapper_default = import_websocket.default;\n\n// electron/services/PipelineService.ts\nvar logger2 = import_electron_log2.default.scope(\"PipelineService\");\nvar PIPELINE_URL = \"wss://pipeline.vrchat.cloud\";\nvar RECONNECT_DELAY_MS = 5e3;\nvar MAX_RECONNECT_ATTEMPTS = 10;\nvar webSocket = null;\nvar reconnectAttempts = 0;\nvar reconnectTimeout = null;\nvar lastMessageData = \"\";\nvar isConnecting = false;\nvar isManualDisconnect = false;\nasync function fetchAuthToken() {\n  try {\n    const client = getVRChatClient();\n    if (!client) {\n      import_electron_log2.default.warn(\"[Pipeline] No VRChat client available for auth token fetch\");\n      return null;\n    }\n    const clientAny = client;\n    if (typeof clientAny.getAuth === \"function\") {\n      import_electron_log2.default.debug(\"[Pipeline] Using getAuth method\");\n      const response = await clientAny.getAuth();\n      const data = response?.data;\n      if (data?.ok && data?.token) {\n        import_electron_log2.default.info(\"[Pipeline] Got auth token via getAuth\");\n        return data.token;\n      }\n    }\n    if (typeof clientAny.get === \"function\") {\n      import_electron_log2.default.debug(\"[Pipeline] Using client.get for auth endpoint\");\n      const response = await clientAny.get(\"auth\");\n      const data = response?.data;\n      if (data?.ok && data?.token) {\n        import_electron_log2.default.info(\"[Pipeline] Got auth token via client.get\");\n        return data.token;\n      }\n    }\n    if (clientAny.jar || clientAny.cookieJar) {\n      import_electron_log2.default.debug(\"[Pipeline] Attempting to extract token from cookie jar\");\n      const jar = clientAny.jar || clientAny.cookieJar;\n      let cookies = [];\n      if (typeof jar.getCookiesSync === \"function\") {\n        cookies = jar.getCookiesSync(\"https://api.vrchat.cloud\");\n      } else if (jar._jar && typeof jar._jar.getCookiesSync === \"function\") {\n        cookies = jar._jar.getCookiesSync(\"https://api.vrchat.cloud\");\n      }\n      const authCookie = cookies.find((c) => (c.key || c.name) === \"auth\");\n      if (authCookie?.value) {\n        import_electron_log2.default.info(\"[Pipeline] Got auth token from cookie jar\");\n        return `authcookie_${authCookie.value}`;\n      }\n    }\n    import_electron_log2.default.debug(\"[Pipeline] Fallback: Making direct HTTP request to /auth\");\n    import_electron_log2.default.warn(\"[Pipeline] Could not obtain auth token - all strategies exhausted\");\n    return null;\n  } catch (error) {\n    const err = error;\n    import_electron_log2.default.error(\"[Pipeline] Failed to fetch auth token:\", err.message);\n    return null;\n  }\n}\nasync function connectWebSocket() {\n  if (webSocket !== null || isConnecting) {\n    import_electron_log2.default.debug(\"[Pipeline] Already connected or connecting\");\n    return false;\n  }\n  if (!isAuthenticated()) {\n    import_electron_log2.default.warn(\"[Pipeline] Cannot connect - not authenticated\");\n    return false;\n  }\n  isConnecting = true;\n  isManualDisconnect = false;\n  try {\n    const token = await fetchAuthToken();\n    if (!token) {\n      import_electron_log2.default.error(\"[Pipeline] Cannot connect - no auth token available\");\n      isConnecting = false;\n      return false;\n    }\n    const url = `${PIPELINE_URL}/?authToken=${token}`;\n    import_electron_log2.default.info(\"[Pipeline] Connecting to VRChat Pipeline WebSocket...\");\n    const socket = new wrapper_default(url, {\n      headers: {\n        \"User-Agent\": \"VRChatGroupGuard/1.0.0 (admin@groupguard.app)\"\n      }\n    });\n    socket.onopen = () => {\n      import_electron_log2.default.info(\"[Pipeline] WebSocket connected successfully\");\n      isConnecting = false;\n      reconnectAttempts = 0;\n      webSocket = socket;\n      emitToRenderer(\"pipeline:connected\", { connected: true });\n    };\n    socket.onclose = (event) => {\n      import_electron_log2.default.info(`[Pipeline] WebSocket closed: code=${event.code}, reason=${event.reason}`);\n      if (webSocket === socket) {\n        webSocket = null;\n      }\n      isConnecting = false;\n      emitToRenderer(\"pipeline:disconnected\", {\n        code: event.code,\n        reason: event.reason,\n        willReconnect: !isManualDisconnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS\n      });\n      if (!isManualDisconnect && isAuthenticated()) {\n        scheduleReconnect();\n      }\n    };\n    socket.onerror = (error) => {\n      import_electron_log2.default.error(\"[Pipeline] WebSocket error:\", error.message || \"Unknown error\");\n      emitToRenderer(\"pipeline:error\", { message: error.message || \"WebSocket error\" });\n    };\n    socket.onmessage = (event) => {\n      try {\n        handleMessage(event.data.toString());\n      } catch (err) {\n        const error = err;\n        import_electron_log2.default.error(\"[Pipeline] Error handling message:\", error.message);\n      }\n    };\n    return true;\n  } catch (error) {\n    const err = error;\n    import_electron_log2.default.error(\"[Pipeline] Connection error:\", err.message);\n    isConnecting = false;\n    scheduleReconnect();\n    return false;\n  }\n}\nfunction scheduleReconnect() {\n  if (reconnectTimeout !== null) {\n    clearTimeout(reconnectTimeout);\n  }\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    import_electron_log2.default.warn(\"[Pipeline] Max reconnect attempts reached, giving up\");\n    emitToRenderer(\"pipeline:reconnect-failed\", {\n      attempts: reconnectAttempts\n    });\n    return;\n  }\n  reconnectAttempts++;\n  const delay = RECONNECT_DELAY_MS * Math.min(reconnectAttempts, 5);\n  import_electron_log2.default.info(`[Pipeline] Scheduling reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n  reconnectTimeout = setTimeout(() => {\n    reconnectTimeout = null;\n    if (isAuthenticated() && !webSocket && !isConnecting && !isManualDisconnect) {\n      connectWebSocket();\n    }\n  }, delay);\n}\nfunction disconnectWebSocket() {\n  isManualDisconnect = true;\n  if (reconnectTimeout !== null) {\n    clearTimeout(reconnectTimeout);\n    reconnectTimeout = null;\n  }\n  if (webSocket !== null) {\n    import_electron_log2.default.info(\"[Pipeline] Disconnecting WebSocket...\");\n    try {\n      webSocket.close(1e3, \"Manual disconnect\");\n    } catch (err) {\n      import_electron_log2.default.warn(\"[Pipeline] Error closing WebSocket:\", err);\n    }\n    webSocket = null;\n  }\n  reconnectAttempts = 0;\n  isConnecting = false;\n}\nfunction handleMessage(data) {\n  if (lastMessageData === data) {\n    return;\n  }\n  lastMessageData = data;\n  let message;\n  try {\n    message = JSON.parse(data);\n    if (typeof message.content === \"string\") {\n      try {\n        message.content = JSON.parse(message.content);\n      } catch {\n      }\n    }\n  } catch {\n    import_electron_log2.default.warn(\"[Pipeline] Failed to parse message:\", data.substring(0, 100));\n    return;\n  }\n  if (message.err) {\n    import_electron_log2.default.error(\"[Pipeline] Server error:\", message.err);\n    emitToRenderer(\"pipeline:server-error\", { error: message.err });\n    return;\n  }\n  import_electron_log2.default.debug(`[Pipeline] Event: ${message.type}`, JSON.stringify(message.content).substring(0, 200));\n  const event = {\n    type: message.type,\n    content: message.content,\n    timestamp: (/* @__PURE__ */ new Date()).toISOString()\n  };\n  emitToRenderer(\"pipeline:event\", event);\n  handleSpecificEvent(event);\n}\nfunction handleSpecificEvent(event) {\n  switch (event.type) {\n    case \"group-member-updated\":\n      import_electron_log2.default.info(\"[Pipeline] Group member updated:\", event.content);\n      break;\n    case \"group-role-updated\":\n      import_electron_log2.default.info(\"[Pipeline] Group role updated:\", event.content);\n      break;\n    case \"group-joined\":\n    case \"group-left\":\n      import_electron_log2.default.info(`[Pipeline] Group ${event.type}:`, event.content);\n      break;\n    case \"notification\":\n    case \"notification-v2\":\n      import_electron_log2.default.info(\"[Pipeline] Notification received:\", event.content);\n      break;\n    case \"friend-online\":\n    case \"friend-offline\":\n    case \"friend-location\":\n      import_electron_log2.default.debug(`[Pipeline] Friend ${event.type}:`, event.content);\n      break;\n    case \"user-update\":\n      import_electron_log2.default.info(\"[Pipeline] Current user updated:\", event.content);\n      break;\n    default:\n      break;\n  }\n}\nfunction emitToRenderer(channel, data) {\n  const windows = import_electron2.BrowserWindow.getAllWindows();\n  for (const window2 of windows) {\n    if (!window2.isDestroyed()) {\n      window2.webContents.send(channel, data);\n    }\n  }\n}\nfunction setupPipelineHandlers() {\n  import_electron2.ipcMain.handle(\"pipeline:connect\", async () => {\n    import_electron_log2.default.info(\"[Pipeline] Connect requested\");\n    const success = await connectWebSocket();\n    return { success, connected: webSocket !== null };\n  });\n  import_electron2.ipcMain.handle(\"pipeline:disconnect\", () => {\n    import_electron_log2.default.info(\"[Pipeline] Disconnect requested\");\n    disconnectWebSocket();\n    return { success: true };\n  });\n  import_electron2.ipcMain.handle(\"pipeline:status\", () => {\n    return {\n      connected: webSocket !== null && webSocket.readyState === wrapper_default.OPEN,\n      connecting: isConnecting,\n      reconnectAttempts\n    };\n  });\n  import_electron2.ipcMain.handle(\"pipeline:reconnect\", async () => {\n    import_electron_log2.default.info(\"[Pipeline] Reconnect requested\");\n    disconnectWebSocket();\n    isManualDisconnect = false;\n    reconnectAttempts = 0;\n    const success = await connectWebSocket();\n    return { success };\n  });\n}\nfunction onUserLoggedIn() {\n  import_electron_log2.default.info(\"[Pipeline] User logged in, connecting to pipeline...\");\n  setTimeout(() => {\n    connectWebSocket();\n  }, 1e3);\n}\nfunction onUserLoggedOut() {\n  import_electron_log2.default.info(\"[Pipeline] User logged out, disconnecting from pipeline\");\n  disconnectWebSocket();\n}\n\n// electron/services/StorageService.ts\nvar import_electron3 = require(\"electron\");\nvar import_fs = __toESM(require(\"fs\"), 1);\nvar import_path = __toESM(require(\"path\"), 1);\nvar import_electron_log3 = __toESM(require_src2(), 1);\nvar logger3 = import_electron_log3.default.scope(\"StorageService\");\nvar StorageService = class {\n  constructor() {\n    this.dataDir = null;\n    this.defaultDataDirName = \"VRC_Group_Guard\";\n    this.configPath = import_path.default.join(import_electron3.app.getPath(\"userData\"), \"storage-config.json\");\n  }\n  initialize() {\n    try {\n      if (import_fs.default.existsSync(this.configPath)) {\n        const config = JSON.parse(import_fs.default.readFileSync(this.configPath, \"utf-8\"));\n        if (config.dataDir && import_fs.default.existsSync(config.dataDir)) {\n          this.dataDir = config.dataDir;\n          logger3.info(`Loaded data directory: ${this.dataDir}`);\n        } else {\n          logger3.warn(`Configured data dir not found: ${config.dataDir}`);\n          this.dataDir = null;\n        }\n      } else {\n        logger3.info(\"No storage config found. Waiting for user setup.\");\n      }\n    } catch (error) {\n      logger3.error(\"Failed to initialize:\", error);\n    }\n  }\n  isConfigured() {\n    return this.dataDir !== null;\n  }\n  getDataDir() {\n    return this.dataDir || import_electron3.app.getPath(\"userData\");\n  }\n  getUnconfiguredDefaultPath() {\n    return import_path.default.join(import_electron3.app.getPath(\"documents\"), this.defaultDataDirName);\n  }\n  async selectDirectory(window2) {\n    const result = await import_electron3.dialog.showOpenDialog(window2, {\n      properties: [\"openDirectory\", \"createDirectory\", \"showHiddenFiles\"],\n      title: \"Select Data Storage Folder\",\n      buttonLabel: \"Select Folder\",\n      defaultPath: import_electron3.app.getPath(\"documents\")\n    });\n    if (result.canceled || result.filePaths.length === 0) {\n      return null;\n    }\n    return result.filePaths[0];\n  }\n  setLocation(dirPath) {\n    if (!import_fs.default.existsSync(dirPath)) {\n      import_fs.default.mkdirSync(dirPath, { recursive: true });\n    }\n    const config = { dataDir: dirPath };\n    import_fs.default.writeFileSync(this.configPath, JSON.stringify(config));\n    this.dataDir = dirPath;\n    logger3.info(`Storage location set to: ${dirPath}`);\n    return true;\n  }\n};\nvar storageService = new StorageService();\n\n// electron/services/AuthService.ts\nvar logger4 = import_electron_log4.default.scope(\"AuthService\");\nvar { VRChat } = require(\"vrchat\");\nvar Keyv = require_dist4().default;\nvar KeyvFile = require_lib2().default;\nvar vrchatClient = null;\nvar currentUser = null;\nvar pendingLoginCredentials = null;\nvar sessionStore = null;\nfunction getSessionStore() {\n  if (!sessionStore) {\n    const userDataPath = storageService.getDataDir();\n    const filePath = import_path2.default.join(userDataPath, \"vrchat-session.json\");\n    logger4.info(`Session store path: ${filePath}`);\n    const store3 = new KeyvFile({ filename: filePath });\n    if (!store3.opts) store3.opts = {};\n    if (!store3.opts.url) store3.opts.url = \"file://\";\n    sessionStore = new Keyv({ store: store3, namespace: \"vrchat\" });\n    if (sessionStore.opts) {\n      sessionStore.opts.url = \"file://\";\n    } else {\n      sessionStore.opts = { url: \"file://\" };\n    }\n    sessionStore.on(\"error\", (err) => {\n      logger4.error(\"Session store error:\", err);\n    });\n  }\n  return sessionStore;\n}\nvar APP_INFO = {\n  name: \"VRChatGroupGuard\",\n  version: \"1.0.0\",\n  contact: \"admin@groupguard.app\"\n};\nvar VRCHAT_API_BASE = \"https://api.vrchat.cloud/api/1\";\nfunction extractAuthCookie(client) {\n  try {\n    const jar = client.jar || client.cookieJar || client.cookies;\n    if (!jar) {\n      logger4.debug(\"No cookie jar found on client\");\n      return void 0;\n    }\n    let cookies = [];\n    try {\n      if (jar && typeof jar.getCookiesSync === \"function\") {\n        cookies = jar.getCookiesSync(VRCHAT_API_BASE);\n      } else if (Array.isArray(jar)) {\n        cookies = jar;\n      } else if (jar._jar && typeof jar._jar.getCookiesSync === \"function\") {\n        cookies = jar._jar.getCookiesSync(VRCHAT_API_BASE);\n      }\n    } catch (jarError) {\n      logger4.warn(\"Error accessing cookie jar:\", jarError);\n      return void 0;\n    }\n    if (!Array.isArray(cookies)) {\n      logger4.warn(\"Cookies is not an array:\", typeof cookies);\n      return void 0;\n    }\n    const authCookie = cookies.find((c) => {\n      if (!c) return false;\n      const key = c.key || c.name;\n      if (!key) return false;\n      return key === \"auth\" || typeof key === \"string\" && key.includes(\"auth\");\n    });\n    if (authCookie) {\n      logger4.debug(\"Found auth cookie\");\n      const key = authCookie.key || authCookie.name;\n      const value = authCookie.value;\n      return `${key}=${value}`;\n    }\n  } catch (err) {\n    logger4.warn(\"Failed to extract auth cookie:\", err);\n  }\n  return void 0;\n}\nasync function tryRestoreSession() {\n  try {\n    logger4.info(\"Attempting to restore session from persistent store...\");\n    const clientOptions = {\n      baseUrl: VRCHAT_API_BASE,\n      application: APP_INFO,\n      keyv: getSessionStore()\n    };\n    logger4.info(\"Creating VRChat client for session check...\");\n    const client = new VRChat(clientOptions);\n    try {\n      logger4.info(\"Checking for existing session...\");\n      const userResponse = await client.getCurrentUser({ throwOnError: true });\n      const user = userResponse?.data;\n      if (user && user.id) {\n        logger4.info(`Session restored successfully for: ${user.displayName}`);\n        vrchatClient = client;\n        if (user.id && typeof user.id === \"string\") {\n          user.id = user.id.trim();\n        }\n        currentUser = user;\n        return { success: true, user: currentUser };\n      }\n      logger4.info(\"No user data returned, session invalid\");\n      return { success: false, error: \"No user data\" };\n    } catch (err) {\n      const error = err;\n      if (error.response?.status === 401) {\n        logger4.info(\"No valid session found (401), will need to authenticate\");\n        return { success: false, error: \"No valid session\" };\n      }\n      logger4.warn(\"Session check failed with error:\", error.message || String(err));\n      return { success: false, error: error.message || \"Session check failed\" };\n    }\n  } catch (error) {\n    const err = error;\n    logger4.error(\"Session restoration error:\", err.message || String(error));\n    return { success: false, error: err.message || \"Session restoration failed\" };\n  }\n}\nasync function performLogin(username, password, twoFactorCode) {\n  try {\n    logger4.info(\"Attempting VRChat login...\");\n    logger4.debug(`performLogin called for user ${username}`);\n    let client = vrchatClient;\n    if (!client || !twoFactorCode) {\n      const clientOptions = {\n        baseUrl: VRCHAT_API_BASE,\n        application: APP_INFO,\n        // Use Keyv for persistent session storage (cookies persist across restarts!)\n        keyv: getSessionStore()\n      };\n      logger4.info(\"Creating VRChat client with persistent session store for login...\");\n      client = new VRChat(clientOptions);\n    }\n    logger4.info(\"VRChat client created (or reused), attempting login...\");\n    try {\n      const user = await client.login({ username, password, twoFactorCode });\n      logger4.debug(\"Login successful. Inspecting client for cookies...\");\n      const newAuthCookie = extractAuthCookie(client);\n      if (newAuthCookie) {\n        if (pendingLoginCredentials) {\n          pendingLoginCredentials.authCookie = newAuthCookie;\n        } else {\n        }\n      }\n      let validUser = user;\n      if (!validUser.id && validUser.data && validUser.data.id) {\n        validUser = validUser.data;\n      }\n      if (validUser.error) {\n        throw new Error(validUser.error.message || \"Login returned an error\");\n      }\n      if (!validUser || !validUser.id) {\n        logger4.error(\"Login response missing ID:\", validUser);\n        throw new Error(\"Login failed: Invalid user object received\");\n      }\n      if (validUser.id && typeof validUser.id === \"string\") {\n        validUser.id = validUser.id.trim();\n      }\n      vrchatClient = client;\n      currentUser = validUser;\n      const userId = validUser.id;\n      const displayName = validUser.displayName;\n      logger4.info(`User logged in successfully: ${displayName} (${userId})`);\n      logger4.debug(\"Login successful\", { id: userId, name: displayName });\n      logger4.info(`Global vrchatClient set: ${!!vrchatClient}`);\n      onUserLoggedIn();\n      return { success: true, user: currentUser, authCookie: newAuthCookie };\n    } catch (loginError) {\n      const err = loginError;\n      const errorMsg = err?.message || \"Unknown login error\";\n      const errorMsgSafe = typeof errorMsg === \"string\" ? errorMsg : String(errorMsg);\n      const errorMsgLower = errorMsgSafe.toLowerCase();\n      logger4.info(\"Login error details:\", {\n        message: errorMsgSafe,\n        twoFactorMethods: err?.twoFactorMethods,\n        code: err?.code\n      });\n      if (err?.twoFactorMethods && Array.isArray(err.twoFactorMethods) && err.twoFactorMethods.length > 0) {\n        logger4.info(\"2FA required, methods:\", err.twoFactorMethods);\n        logger4.debug(\"2FA required\");\n        vrchatClient = client;\n        return {\n          success: false,\n          requires2FA: true,\n          twoFactorMethods: err.twoFactorMethods\n        };\n      }\n      if (errorMsgSafe.includes(\"Cannot read properties of undefined (reading 'includes')\")) {\n        logger4.warn(\"Caught library crash compatible with 2FA response bug. Assuming 2FA required.\");\n        logger4.debug(\"Stack trace:\", err?.stack);\n        vrchatClient = client;\n        return { success: false, requires2FA: true };\n      }\n      if (errorMsgLower.includes(\"two-factor\") || errorMsgLower.includes(\"2fa\") || errorMsgSafe.includes(\"TOTP\") || errorMsgSafe.includes(\"emailotp\") || errorMsgLower.includes(\"totp\") || errorMsgLower.includes(\"otp\")) {\n        vrchatClient = client;\n        logger4.debug(\"2FA required (text check)\");\n        return { success: false, requires2FA: true };\n      }\n      throw loginError;\n    }\n  } catch (error) {\n    const err = error;\n    logger4.error(\"Login Failed (Outer Catch):\", error);\n    if (err && err.stack) {\n      logger4.error(\"Stack Trace:\", err.stack);\n    }\n    let errorMessage = \"Unknown login error\";\n    if (err?.response?.data?.error?.message) {\n      errorMessage = err.response.data.error.message;\n    } else if (err?.message) {\n      errorMessage = err.message;\n    }\n    if (typeof errorMessage !== \"string\") {\n      errorMessage = String(errorMessage);\n    }\n    if (err?.stack) {\n      errorMessage += `\n\nStack:\n${err.stack}`;\n    }\n    return { success: false, error: errorMessage };\n  }\n}\nfunction setupAuthHandlers() {\n  import_electron4.ipcMain.handle(\"auth:login\", async (_event, { username, password, rememberMe = false }) => {\n    const saved = loadCredentials();\n    const isSavedUser = saved && saved.username === username;\n    if (isSavedUser) {\n      logger4.info(\"Login matches saved user, attempting session restoration to bypass 2FA...\");\n      const restoreResult = await tryRestoreSession();\n      if (restoreResult.success && restoreResult.user) {\n        const restoredUser = restoreResult.user;\n        logger4.info(\"Session restored successfully during manual login!\");\n        return { success: true, user: restoreResult.user };\n      }\n    }\n    const result = await performLogin(username, password);\n    if (result.success && rememberMe) {\n      saveCredentials(username, password, result.authCookie);\n      logger4.info(\"Credentials saved for auto-login\");\n      logger4.debug(\"Credentials saved manually\");\n    } else if (result.requires2FA) {\n      pendingLoginCredentials = { username, password, rememberMe };\n    }\n    return result;\n  });\n  import_electron4.ipcMain.handle(\"auth:verify2fa\", async (_event, { code }) => {\n    if (!vrchatClient || !pendingLoginCredentials) {\n      return { success: false, error: \"No pending login session. Please try logging in again.\" };\n    }\n    try {\n      logger4.info(\"Verifying 2FA code...\");\n      const result = await performLogin(\n        pendingLoginCredentials.username,\n        pendingLoginCredentials.password,\n        code\n      );\n      if (!result.success || !result.user) {\n        throw new Error(result.error || \"2FA verification failed\");\n      }\n      if (pendingLoginCredentials.rememberMe) {\n        saveCredentials(pendingLoginCredentials.username, pendingLoginCredentials.password, result.authCookie);\n        logger4.info(\"Credentials saved for auto-login after 2FA\");\n        logger4.debug(\"Credentials saved after 2FA\");\n      }\n      pendingLoginCredentials = null;\n      return { success: true, user: currentUser };\n    } catch (error) {\n      const err = error;\n      logger4.error(\"2FA Verification Error:\", error);\n      const errorMessage = err.message || \"Invalid 2FA code\";\n      if (errorMessage.toLowerCase().includes(\"invalid\") || errorMessage.toLowerCase().includes(\"incorrect\")) {\n        return { success: false, error: \"Invalid 2FA code. Please try again.\" };\n      }\n      return { success: false, error: errorMessage };\n    }\n  });\n  import_electron4.ipcMain.handle(\"auth:auto-login\", async () => {\n    logger4.info(\"Checking for saved credentials for auto-login...\");\n    if (!hasSavedCredentials()) {\n      logger4.info(\"No saved credentials found\");\n      return { success: false, noCredentials: true };\n    }\n    const credentials = loadCredentials();\n    if (!credentials) {\n      logger4.info(\"Failed to load credentials\");\n      return { success: false, error: \"Failed to load saved credentials\" };\n    }\n    logger4.info(\"Found saved credentials, attempting session restoration...\");\n    const sessionResult = await tryRestoreSession();\n    if (sessionResult.success && sessionResult.user) {\n      logger4.info(\"Session restored successfully without re-authentication!\");\n      return { success: true, user: sessionResult.user };\n    }\n    logger4.info(\"Session restoration failed, falling back to full login...\");\n    logger4.info(`Attempting full login for ${credentials.username}...`);\n    const result = await performLogin(credentials.username, credentials.password);\n    if (result.success) {\n      if (result.authCookie && result.authCookie !== credentials.authCookie) {\n        saveCredentials(credentials.username, credentials.password, result.authCookie);\n        logger4.debug(\"Auth cookie updated after auto-login\");\n      }\n    }\n    if (result.requires2FA) {\n      pendingLoginCredentials = {\n        username: credentials.username,\n        password: credentials.password,\n        rememberMe: true,\n        authCookie: credentials.authCookie\n      };\n    }\n    return result;\n  });\n  import_electron4.ipcMain.handle(\"auth:check-session\", () => {\n    if (currentUser && vrchatClient) {\n      return { isLoggedIn: true, user: currentUser };\n    }\n    return { isLoggedIn: false };\n  });\n  import_electron4.ipcMain.handle(\"auth:has-saved-credentials\", () => {\n    return hasSavedCredentials();\n  });\n  import_electron4.ipcMain.handle(\"auth:logout\", async (_event, { clearSaved = false } = {}) => {\n    try {\n      logger4.info(\"Logging out user...\");\n      logger4.debug(\"Logging out\");\n      if (clearSaved) {\n        clearCredentials();\n        logger4.info(\"Saved credentials cleared\");\n        logger4.debug(\"Saved credentials cleared\");\n      }\n    } catch (e) {\n      logger4.warn(\"Logout cleanup:\", e);\n    }\n    vrchatClient = null;\n    currentUser = null;\n    pendingLoginCredentials = null;\n    onUserLoggedOut();\n    return { success: true };\n  });\n}\nfunction getVRChatClient() {\n  logger4.debug(`getVRChatClient called. Result exists: ${!!vrchatClient}`);\n  return vrchatClient;\n}\nfunction isAuthenticated() {\n  return vrchatClient !== null && currentUser !== null;\n}\nfunction getCurrentUserId() {\n  logger4.debug(`getCurrentUserId called. ID: ${currentUser?.id}`);\n  logger4.debug(\"Full currentUser keys:\", Object.keys(currentUser || {}));\n  return currentUser?.id;\n}\n\n// electron/services/GroupService.ts\nvar import_electron8 = require(\"electron\");\nvar import_electron_log7 = __toESM(require_src2(), 1);\nvar logger7 = import_electron_log7.default.scope(\"GroupService\");\nfunction setupGroupHandlers() {\n  import_electron8.ipcMain.handle(\"groups:get-my-groups\", async () => {\n    try {\n      const client = getVRChatClient();\n      const userId = getCurrentUserId();\n      logger7.debug(\"groups:get-my-groups called\", { hasClient: !!client, userId });\n      if (!client || !userId) {\n        logger7.warn(\"Auth check failed in GroupService\");\n        throw new Error(\"Not authenticated. Please log in first.\");\n      }\n      logger7.info(`Fetching user groups for user ID: \"${userId}\" (type: ${typeof userId})`);\n      const safeUserId = userId.trim();\n      if (!safeUserId.startsWith(\"usr_\")) {\n        logger7.error(`Invalid User ID format: ${safeUserId}`);\n        throw new Error(`Invalid User ID: ${safeUserId}`);\n      }\n      const response = await client.getUserGroups({\n        path: { userId: safeUserId },\n        query: { n: 100, offset: 0 }\n      });\n      if (response.error) {\n        logger7.error(\"getUserGroups returned error:\", response.error);\n        throw new Error(response.error.message || \"Failed to fetch groups\");\n      }\n      const groups = response.data || [];\n      const moderatableGroups = groups.filter((g) => {\n        const isOwner = g.ownerId === safeUserId;\n        const hasPermissions = g.myMember?.permissions && Array.isArray(g.myMember.permissions) && g.myMember.permissions.length > 0;\n        return isOwner || hasPermissions;\n      });\n      const mappedGroups = moderatableGroups.map((g) => {\n        if (g.groupId && typeof g.groupId === \"string\" && g.groupId.startsWith(\"grp_\")) {\n          return {\n            ...g,\n            id: g.groupId,\n            // helper for frontend\n            _memberId: g.id\n            // preserve original membership ID\n          };\n        }\n        return g;\n      });\n      logger7.info(`Fetched ${groups.length} total groups. Filtered to ${mappedGroups.length} moderatable groups.`);\n      try {\n        const { instanceLoggerService: instanceLoggerService2 } = (init_InstanceLoggerService(), __toCommonJS(InstanceLoggerService_exports));\n        instanceLoggerService2.setAllowedGroups(mappedGroups.map((g) => g.id));\n      } catch (e) {\n        logger7.error(\"Failed to update instance logger allowed groups\", e);\n      }\n      return { success: true, groups: mappedGroups };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch groups:\", { message: err.message, stack: err.stack });\n      if (err.response?.status === 401) return { success: false, error: \"Session expired. Please log in again.\" };\n      return { success: false, error: err.message || \"Failed to fetch groups\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"groups:get-details\", async (_event, { groupId }) => {\n    try {\n      const client = getVRChatClient();\n      if (!client) throw new Error(\"Not authenticated\");\n      const response = await client.getGroup({ path: { groupId } });\n      if (response.error) throw response.error;\n      return { success: true, group: response.data };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch group details:\", error);\n      return { success: false, error: err.message || \"Failed to fetch group\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"worlds:get-details\", async (_event, { worldId }) => {\n    try {\n      const client = getVRChatClient();\n      if (!client) throw new Error(\"Not authenticated\");\n      const response = await client.getWorld({ path: { worldId } });\n      if (response.error) throw response.error;\n      return { success: true, world: response.data };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch world details:\", error);\n      return { success: false, error: err.message || \"Failed to fetch world\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"groups:get-members\", async (_event, { groupId, n = 100, offset = 0 }) => {\n    try {\n      const client = getVRChatClient();\n      if (!client) throw new Error(\"Not authenticated\");\n      const response = await client.getGroupMembers({\n        path: { groupId },\n        query: { n, offset }\n      });\n      if (response.error) throw response.error;\n      return { success: true, members: response.data ?? [] };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch group members:\", error);\n      return { success: false, error: err.message || \"Failed to fetch members\" };\n    }\n  });\n  const extractArray = (data) => {\n    if (Array.isArray(data)) return data;\n    const obj = data;\n    if (obj && Array.isArray(obj.results)) return obj.results;\n    if (obj && Array.isArray(obj.instances)) return obj.instances;\n    return [];\n  };\n  import_electron8.ipcMain.handle(\"groups:get-requests\", async (_event, { groupId }) => {\n    try {\n      const client = getVRChatClient();\n      logger7.info(`Fetching requests for group ${groupId}`);\n      if (!client) throw new Error(\"Not authenticated\");\n      const response = await client.getGroupRequests({\n        path: { groupId },\n        query: { n: 100, offset: 0 }\n      });\n      const requests = extractArray(response.data);\n      logger7.info(`Requests fetch detected ${requests.length} items for ${groupId}`);\n      if (response.error) {\n        logger7.error(\"API Error in getGroupRequests:\", response.error);\n        throw response.error;\n      }\n      return { success: true, requests };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch join requests:\", error);\n      return { success: false, error: err.message || \"Failed to fetch requests\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"groups:get-bans\", async (_event, { groupId }) => {\n    try {\n      const client = getVRChatClient();\n      logger7.info(`Fetching bans for group ${groupId}`);\n      if (!client) throw new Error(\"Not authenticated\");\n      const response = await client.getGroupBans({\n        path: { groupId },\n        query: { n: 100, offset: 0 }\n      });\n      const bans = extractArray(response.data);\n      logger7.info(`Bans fetch detected ${bans.length} items for ${groupId}`);\n      if (response.error) {\n        logger7.error(\"API Error in getGroupBans:\", response.error);\n        throw response.error;\n      }\n      return { success: true, bans };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch bans:\", error);\n      return { success: false, error: err.message || \"Failed to fetch bans\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"groups:get-audit-logs\", async (_event, { groupId }) => {\n    try {\n      const client = getVRChatClient();\n      if (!client) throw new Error(\"Not authenticated\");\n      const response = await client.getGroupAuditLogs({\n        path: { groupId },\n        query: { n: 100, offset: 0 }\n      });\n      if (response.error) throw response.error;\n      const logs = extractArray(response.data);\n      return { success: true, logs };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"Failed to fetch audit logs:\", error);\n      return { success: false, error: err.message || \"Failed to fetch audit logs\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"groups:get-instances\", async (_event, { groupId }) => {\n    const safeStringify = (obj) => {\n      try {\n        return JSON.stringify(\n          obj,\n          (_key, value) => typeof value === \"bigint\" ? value.toString() : value\n        );\n      } catch {\n        return String(obj);\n      }\n    };\n    try {\n      const client = getVRChatClient();\n      if (!client) throw new Error(\"Not authenticated\");\n      const userId = getCurrentUserId();\n      if (!userId) throw new Error(\"No user ID found\");\n      logger7.info(`[INSTANCES] Fetching for group: ${groupId}, user: ${userId}`);\n      let instances = [];\n      try {\n        const clientAny = client;\n        if (typeof clientAny.getUserGroupInstancesForGroup === \"function\") {\n          logger7.info(\"[INSTANCES] Trying SDK method: getUserGroupInstancesForGroup\");\n          const response = await clientAny.getUserGroupInstancesForGroup({\n            path: { userId, groupId }\n          });\n          const data = response?.data ?? response;\n          logger7.info(\"[INSTANCES] SDK Response:\", safeStringify(data));\n          instances = extractArray(data);\n        } else {\n          logger7.warn(\"[INSTANCES] SDK method getUserGroupInstancesForGroup not available\");\n        }\n      } catch (e) {\n        const err = e;\n        logger7.warn(\"[INSTANCES] SDK getUserGroupInstancesForGroup failed:\", err.message);\n      }\n      if (instances.length === 0) {\n        try {\n          const clientAny = client;\n          if (typeof clientAny.getUserGroupInstances === \"function\") {\n            logger7.info(\"[INSTANCES] Trying SDK method: getUserGroupInstances (all groups)\");\n            const response = await clientAny.getUserGroupInstances({\n              path: { userId }\n            });\n            const data = response?.data ?? response;\n            const allInstances = extractArray(data);\n            logger7.info(`[INSTANCES] getUserGroupInstances returned ${allInstances.length} total instances`);\n            if (allInstances.length > 0) {\n              logger7.info(\"[INSTANCES] First instance keys:\", Object.keys(allInstances[0]));\n              logger7.info(\"[INSTANCES] First instance data:\", safeStringify(allInstances[0]));\n              instances = allInstances.filter((inst) => {\n                const i = inst;\n                const matchGroupId = i.groupId === groupId;\n                const matchGroupObj = i.group?.id === groupId;\n                const matchOwnerId = String(i.ownerId || \"\").includes(groupId);\n                return matchGroupId || matchGroupObj || matchOwnerId;\n              });\n              logger7.info(`[INSTANCES] After filtering: ${instances.length} instances for this group`);\n            }\n          }\n        } catch (e) {\n          const err = e;\n          logger7.warn(\"[INSTANCES] SDK getUserGroupInstances failed:\", err.message);\n        }\n      }\n      if (instances.length === 0) {\n        try {\n          const clientAny = client;\n          if (typeof clientAny.get === \"function\") {\n            logger7.info(\"[INSTANCES] Trying client.get fallback\");\n            const url = `users/${userId}/instances/groups/${groupId}`;\n            logger7.info(\"[INSTANCES] Calling:\", url);\n            const response = await clientAny.get(url);\n            const data = response?.data ?? response;\n            logger7.info(\"[INSTANCES] client.get response:\", safeStringify(data));\n            instances = extractArray(data);\n          }\n        } catch (e) {\n          const err = e;\n          logger7.warn(\"[INSTANCES] client.get failed:\", err.message);\n        }\n      }\n      if (instances.length === 0) {\n        try {\n          const clientAny = client;\n          if (typeof clientAny.getGroupInstances === \"function\") {\n            logger7.info(\"[INSTANCES] Trying SDK method: getGroupInstances\");\n            const response = await clientAny.getGroupInstances({\n              path: { groupId }\n            });\n            const data = response?.data ?? response;\n            logger7.info(\"[INSTANCES] getGroupInstances response:\", safeStringify(data));\n            instances = extractArray(data);\n          }\n        } catch (e) {\n          const err = e;\n          logger7.warn(\"[INSTANCES] SDK getGroupInstances failed:\", err.message);\n        }\n      }\n      logger7.info(`[INSTANCES] Final result: ${instances.length} instances for group ${groupId}`);\n      if (instances.length > 0) {\n        logger7.info(\"[INSTANCES] Sample instance:\", safeStringify(instances[0]));\n      }\n      return { success: true, instances };\n    } catch (error) {\n      const err = error;\n      logger7.error(\"[INSTANCES] Fatal error:\", err.message);\n      logger7.error(\"[INSTANCES] Stack:\", err.stack);\n      return { success: false, error: err.message || \"Failed to fetch instances\" };\n    }\n  });\n  import_electron8.ipcMain.handle(\"groups:ban-user\", async (_event, { groupId, userId }) => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      logger7.info(`[GroupService] Banning user ${userId} from group ${groupId}`);\n      const response = await client.banGroupMember({\n        path: { groupId },\n        body: { userId }\n      });\n      if (response.error) {\n        logger7.error(`[GroupService] Ban API returned error:`, response.error);\n        const errorMessage = response.error.message || \"Ban failed\";\n        return { success: false, error: errorMessage };\n      }\n      logger7.info(`[GroupService] Successfully banned user ${userId} from group ${groupId}`);\n      return { success: true };\n    } catch (e) {\n      const err = e;\n      logger7.error(`[GroupService] Failed to ban user ${userId} from group ${groupId}:`, e);\n      const msg = err.response?.data?.error?.message || err.message || \"Unknown error\";\n      return { success: false, error: msg };\n    }\n  });\n}\n\n// electron/services/UserService.ts\nvar import_electron9 = require(\"electron\");\nvar import_electron_log8 = __toESM(require_src2(), 1);\nvar logger8 = import_electron_log8.default.scope(\"UserService\");\nvar userCache = /* @__PURE__ */ new Map();\nvar CACHE_TTL = 5 * 60 * 1e3;\nfunction setupUserHandlers() {\n  import_electron9.ipcMain.handle(\"users:get\", async (_event, { userId }) => {\n    try {\n      if (!userId) throw new Error(\"User ID is required\");\n      const client = getVRChatClient();\n      if (!client) throw new Error(\"Not authenticated\");\n      const cached = userCache.get(userId);\n      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n        logger8.debug(`Serving user ${userId} from cache`);\n        return { success: true, user: cached.data };\n      }\n      import_electron_log8.default.info(`Fetching user ${userId} from API`);\n      const response = await client.getUser({ path: { userId } });\n      if (response.error) {\n        import_electron_log8.default.error(\"getUser returned error:\", response.error);\n        throw response.error;\n      }\n      if (response.data) {\n        userCache.set(userId, { data: response.data, timestamp: Date.now() });\n      }\n      return { success: true, user: response.data };\n    } catch (error) {\n      import_electron_log8.default.error(`Failed to fetch user ${userId}:`, error);\n      return { success: false, error: error.message || \"Failed to fetch user\" };\n    }\n  });\n  import_electron9.ipcMain.handle(\"users:clear-cache\", async (_event, { userId }) => {\n    if (userId) {\n      userCache.delete(userId);\n    } else {\n      userCache.clear();\n    }\n    return { success: true };\n  });\n}\n\n// electron/main.ts\ninit_LogWatcherService();\n\n// electron/services/AutoModService.ts\nvar import_electron_store = __toESM(require_electron_store(), 1);\nvar import_electron10 = require(\"electron\");\nvar import_electron_log9 = __toESM(require_src2(), 1);\nvar logger9 = import_electron_log9.default.scope(\"AutoModService\");\nvar store2 = new import_electron_store.default({\n  name: \"automod-rules\",\n  defaults: {\n    rules: []\n  }\n});\nvar checkJoinRequest = (_user) => {\n  return { action: \"ALLOW\" };\n};\nvar setupAutoModHandlers = () => {\n  logger9.info(\"Initializing handlers (Reset State)...\");\n  import_electron10.ipcMain.handle(\"automod:get-rules\", () => {\n    return store2.get(\"rules\");\n  });\n  import_electron10.ipcMain.handle(\"automod:save-rule\", (_e, rule) => {\n    const rules = store2.get(\"rules\");\n    if (rule.id) {\n      const index = rules.findIndex((r) => r.id === rule.id);\n      if (index !== -1) {\n        rules[index] = { ...rules[index], ...rule };\n      } else {\n        rules.push(rule);\n      }\n    } else {\n      rule.id = Date.now();\n      rule.createdAt = (/* @__PURE__ */ new Date()).toISOString();\n      rules.push(rule);\n    }\n    store2.set(\"rules\", rules);\n    return rule;\n  });\n  import_electron10.ipcMain.handle(\"automod:delete-rule\", (_e, ruleId) => {\n    const rules = store2.get(\"rules\");\n    const newRules = rules.filter((r) => r.id !== ruleId);\n    store2.set(\"rules\", newRules);\n    return true;\n  });\n  import_electron10.ipcMain.handle(\"automod:check-user\", (_e, user) => {\n    return checkJoinRequest(user);\n  });\n};\n\n// electron/services/InstanceService.ts\nvar import_electron11 = require(\"electron\");\nvar import_electron_log10 = __toESM(require_src2(), 1);\ninit_InstanceLoggerService();\ninit_LogWatcherService();\nvar logger10 = import_electron_log10.default.scope(\"InstanceService\");\nvar entityCache = /* @__PURE__ */ new Map();\nvar sleep = (ms) => new Promise((r) => setTimeout(r, ms));\nvar fetchQueue = [];\nvar isFetching = false;\nasync function processFetchQueue(groupId) {\n  if (isFetching || fetchQueue.length === 0) return;\n  isFetching = true;\n  const client = getVRChatClient();\n  if (!client) {\n    isFetching = false;\n    return;\n  }\n  try {\n    while (fetchQueue.length > 0) {\n      const userId = fetchQueue.shift();\n      if (!userId) continue;\n      const cacheKey = groupId ? `${groupId}:${userId}` : `roam:${userId}`;\n      if (entityCache.has(cacheKey) && entityCache.get(cacheKey).rank !== \"Unknown\") {\n        continue;\n      }\n      logger10.info(`[InstanceService] Fetching details for ${userId} (Context: ${groupId || \"Roaming\"})...`);\n      try {\n        const userRes = await client.getUser({ path: { userId } });\n        const userData = userRes.data;\n        let isMember = false;\n        if (groupId) {\n          try {\n            await client.getGroupMember({ path: { groupId, userId } });\n            isMember = true;\n          } catch {\n            isMember = false;\n          }\n        }\n        const displayName = userData?.displayName || \"Unknown\";\n        let rank = \"User\";\n        const tags = userData?.tags || [];\n        if (tags.includes(\"system_trust_legend\")) rank = \"Legend\";\n        else if (tags.includes(\"system_trust_veteran\")) rank = \"Veteran\";\n        else if (tags.includes(\"system_trust_trusted\")) rank = \"Trusted\";\n        else if (tags.includes(\"system_trust_known\")) rank = \"Known\";\n        else if (tags.includes(\"system_trust_basic\")) rank = \"User\";\n        else if (tags.includes(\"system_trust_visitor\")) rank = \"Visitor\";\n        const entity = {\n          id: userId,\n          displayName,\n          rank,\n          isGroupMember: isMember,\n          status: \"active\",\n          // Prioritize persistent profile pictures (userIcon via VRC+) over current avatar thumbnail\n          avatarUrl: userData?.userIcon || userData?.profilePicOverride || userData?.currentAvatarThumbnailImageUrl || \"\",\n          lastUpdated: Date.now()\n        };\n        entityCache.set(cacheKey, entity);\n        const windows = import_electron11.BrowserWindow.getAllWindows();\n        for (const win of windows) {\n          win.webContents.send(\"instance:entity-update\", entity);\n        }\n      } catch (err) {\n        logger10.warn(`[InstanceService] Failed to fetch data for ${userId}`, err);\n      }\n      await sleep(2e3);\n    }\n  } catch (e) {\n    logger10.error(\"[InstanceService] Queue processor fatal error\", e);\n  } finally {\n    isFetching = false;\n    if (fetchQueue.length > 0) processFetchQueue(groupId);\n  }\n}\nfunction setupInstanceHandlers() {\n  import_electron11.ipcMain.handle(\"instance:scan-sector\", async (_event, { groupId }) => {\n    try {\n      const players = logWatcherService.getPlayers();\n      const results = [];\n      for (const p of players) {\n        if (!p.userId) {\n          results.push({\n            id: \"unknown\",\n            displayName: p.displayName,\n            rank: \"Unknown\",\n            isGroupMember: false,\n            status: \"active\",\n            lastUpdated: 0\n          });\n          continue;\n        }\n        const cacheKey = groupId ? `${groupId}:${p.userId}` : `roam:${p.userId}`;\n        if (entityCache.has(cacheKey)) {\n          results.push(entityCache.get(cacheKey));\n        } else {\n          const placeholder = {\n            id: p.userId,\n            displayName: p.displayName,\n            rank: \"Loading...\",\n            isGroupMember: false,\n            status: \"active\",\n            lastUpdated: 0\n          };\n          results.push(placeholder);\n          if (!fetchQueue.includes(p.userId)) {\n            fetchQueue.push(p.userId);\n          }\n        }\n      }\n      processFetchQueue(groupId);\n      return results;\n    } catch (error) {\n      logger10.error(\"Failed to scan sector:\", error);\n      return [];\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:recruit-user\", async (_event, { groupId, userId }) => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      logger10.info(`[InstanceService] Inviting ${userId} to group ${groupId}...`);\n      const result = await client.createGroupInvite({\n        path: { groupId },\n        body: { userId }\n      });\n      logger10.info(`[InstanceService] Recruitment result for ${userId}:`, result.data || result);\n      return { success: true };\n    } catch (e) {\n      if (e.response && e.response.status === 429) {\n        logger10.warn(`[InstanceService] Rate limited (429) recruiting ${userId}`);\n        return { success: false, error: \"RATE_LIMIT\" };\n      }\n      const msg = e.response?.data?.error?.message || e.message;\n      logger10.warn(`[InstanceService] Failed to recruit ${userId}: ${msg}`);\n      return { success: false, error: msg };\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:kick-user\", async (_event, { groupId, userId }) => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      logger10.info(`[InstanceService] Kicking (Banning) ${userId} from group ${groupId}`);\n      await client.banGroupMember({\n        path: { groupId, userId }\n      });\n      return { success: true };\n    } catch (e) {\n      logger10.error(`[InstanceService] Failed to kick ${userId}`, e);\n      return { success: false, error: e.message };\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:get-rally-targets\", async (_event, { groupId }) => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      const memRes = await client.getGroupMembers({\n        path: { groupId },\n        query: { n: 50, offset: 0, sort: \"joinedAt:desc\" }\n      });\n      const members = memRes.data || [];\n      const currentUserId = getCurrentUserId();\n      const targets = members.map((m) => ({\n        id: m.user?.id,\n        displayName: m.user?.displayName,\n        thumbnailUrl: m.user?.thumbnailUrl\n      })).filter((t) => {\n        if (!t.id) return false;\n        if (t.id === currentUserId) return true;\n        const players = logWatcherService.getPlayers();\n        const isHere = players.some(\n          (p) => p.userId && p.userId === t.id || p.displayName && p.displayName === t.displayName\n        );\n        return !isHere;\n      });\n      return { success: true, targets };\n    } catch (e) {\n      logger10.error(`[InstanceService] Failed to fetch rally targets`, e);\n      return { success: false, error: e.message };\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:invite-to-current\", async (_event, { userId }) => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      const worldId = instanceLoggerService.getCurrentWorldId();\n      const instanceId = instanceLoggerService.getCurrentInstanceId();\n      if (!worldId || !instanceId) {\n        return { success: false, error: \"No active instance\" };\n      }\n      const fullId = `${worldId}:${instanceId}`;\n      await client.inviteUser({\n        path: { userId },\n        body: { instanceId: fullId }\n      });\n      return { success: true };\n    } catch (e) {\n      if (e.response && e.response.status === 429) {\n        return { success: false, error: \"RATE_LIMIT\" };\n      }\n      const msg = e.response?.data?.error?.message || e.message;\n      return { success: false, error: msg };\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:rally-from-session\", async (_event, { filename }) => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      const currentWorldId = instanceLoggerService.getCurrentWorldId();\n      const currentInstanceId = instanceLoggerService.getCurrentInstanceId();\n      if (!currentWorldId || !currentInstanceId) {\n        return { success: false, error: \"You must be in an instance to rally users\" };\n      }\n      const currentLocation = `${currentWorldId}:${currentInstanceId}`;\n      logger10.info(`[InstanceService] Rally from session ${filename} to ${currentLocation}`);\n      const events = instanceLoggerService.getSessionEvents(filename);\n      if (!events || events.length === 0) {\n        return { success: false, error: \"No events found in session\" };\n      }\n      const userIds = /* @__PURE__ */ new Set();\n      events.forEach((e) => {\n        if ((e.type === \"PLAYER_JOIN\" || e.type === \"JOIN\") && e.actorUserId && e.actorUserId.startsWith(\"usr_\")) {\n          userIds.add(e.actorUserId);\n        }\n      });\n      if (userIds.size === 0) {\n        return { success: false, error: \"No users with valid IDs found in this session\" };\n      }\n      const currentPlayers = logWatcherService.getPlayers();\n      const currentUserIds = new Set(currentPlayers.map((p) => p.userId).filter(Boolean));\n      const currentUserId = getCurrentUserId();\n      const targetsToInvite = Array.from(userIds).filter(\n        (uid) => uid !== currentUserId && !currentUserIds.has(uid)\n      );\n      if (targetsToInvite.length === 0) {\n        return { success: false, error: \"All users from that session are already here or unavailable\" };\n      }\n      logger10.info(`[InstanceService] Inviting ${targetsToInvite.length} users from previous session`);\n      const emitProgress = (data) => {\n        import_electron11.BrowserWindow.getAllWindows().forEach((win) => {\n          if (!win.isDestroyed()) {\n            win.webContents.send(\"rally:progress\", data);\n          }\n        });\n      };\n      let successCount = 0;\n      let failCount = 0;\n      const errors = [];\n      const total = targetsToInvite.length;\n      emitProgress({ sent: 0, failed: 0, total, done: false });\n      for (const userId of targetsToInvite) {\n        try {\n          logger10.info(`[InstanceService] Sending invite to ${userId}...`);\n          await client.inviteUser({\n            path: { userId },\n            body: { instanceId: currentLocation }\n          });\n          successCount++;\n          logger10.info(`[InstanceService] \\u2713 Invite sent to ${userId} (${successCount}/${total})`);\n          emitProgress({ sent: successCount, failed: failCount, total, current: userId });\n          await sleep(350);\n        } catch (inviteErr) {\n          failCount++;\n          const errMsg = inviteErr.response?.data?.error?.message || inviteErr.message;\n          logger10.warn(`[InstanceService] \\u2717 Failed to invite ${userId}: ${errMsg}`);\n          emitProgress({ sent: successCount, failed: failCount, total });\n          if (inviteErr.response?.status === 429) {\n            errors.push(`Rate limited after ${successCount} invites`);\n            break;\n          }\n        }\n      }\n      emitProgress({ sent: successCount, failed: failCount, total, done: true });\n      return {\n        success: true,\n        invited: successCount,\n        failed: failCount,\n        total: targetsToInvite.length,\n        errors: errors.length > 0 ? errors : void 0\n      };\n    } catch (e) {\n      logger10.error(`[InstanceService] Rally from session failed`, e);\n      return { success: false, error: e.message };\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:close-instance\", async () => {\n    const client = getVRChatClient();\n    if (!client) throw new Error(\"Not authenticated\");\n    try {\n      const worldId = instanceLoggerService.getCurrentWorldId();\n      const instanceId = instanceLoggerService.getCurrentInstanceId();\n      if (!worldId || !instanceId) {\n        return { success: false, error: \"No active instance to close\" };\n      }\n      logger10.warn(`[InstanceService] Closing instance - worldId: ${worldId}, instanceId: ${instanceId}`);\n      const response = await client.closeInstance({\n        path: { worldId, instanceId },\n        query: { hardClose: true }\n      });\n      const safeStringify = (obj) => JSON.stringify(obj, (_k, v) => typeof v === \"bigint\" ? v.toString() : v, 2);\n      logger10.info(`[InstanceService] closeInstance raw response:`, safeStringify(response));\n      if (response?.error) {\n        const errorMsg = response.error?.message || safeStringify(response.error);\n        logger10.error(`[InstanceService] API returned error:`, errorMsg);\n        return { success: false, error: errorMsg };\n      }\n      logger10.info(`[InstanceService] Instance closed successfully. Data:`, safeStringify(response?.data));\n      return { success: true };\n    } catch (e) {\n      logger10.error(`[InstanceService] Exception closing instance:`, e);\n      logger10.error(`[InstanceService] Error details:`, {\n        message: e.message,\n        name: e.name,\n        stack: e.stack?.split(\"\\n\").slice(0, 5).join(\"\\n\")\n      });\n      const msg = e.response?.data?.error?.message || e.message || \"Unknown error\";\n      return { success: false, error: msg };\n    }\n  });\n  import_electron11.ipcMain.handle(\"instance:get-instance-info\", async () => {\n    const worldId = instanceLoggerService.getCurrentWorldId();\n    const instanceId = instanceLoggerService.getCurrentInstanceId();\n    const worldName = instanceLoggerService.getCurrentWorldName();\n    if (!worldId) return { success: false };\n    let imageUrl = null;\n    let apiName = null;\n    const client = getVRChatClient();\n    if (client) {\n      try {\n        const wRes = await client.getWorld({ path: { worldId } });\n        imageUrl = wRes.data?.thumbnailImageUrl || wRes.data?.imageUrl;\n        apiName = wRes.data?.name;\n      } catch {\n      }\n    }\n    return {\n      success: true,\n      worldId,\n      instanceId,\n      name: apiName || worldName || \"Unknown World\",\n      imageUrl\n    };\n  });\n}\n\n// electron/main.ts\ninit_InstanceLoggerService();\nvar logger11 = import_electron_log11.default.scope(\"App\");\nimport_electron_log11.default.initialize();\nimport_electron_log11.default.transports.file.level = \"info\";\nimport_electron_log11.default.transports.console.level = process.env.NODE_ENV === \"development\" ? \"info\" : \"warn\";\nlogger11.info(\"========================================\");\nlogger11.info(`VRChat Group Guard v${import_electron12.app.getVersion()} starting...`);\nlogger11.info(`Electron: ${process.versions.electron}`);\nlogger11.info(`Chrome: ${process.versions.chrome}`);\nlogger11.info(`Node: ${process.versions.node}`);\nlogger11.info(`Platform: ${process.platform} ${process.arch}`);\nlogger11.info(\"========================================\");\nprocess.on(\"uncaughtException\", (error) => {\n  logger11.error(\"Uncaught Exception:\", error);\n  if (error.message && error.message.includes('\"verified\":false')) {\n    logger11.warn('Ignored \"verified:false\" error to prevent crash.');\n    return;\n  }\n  import_electron12.dialog.showErrorBox(\"Critical Error\", `An unexpected error occurred:\n\n${error.message}\n\nThe application will attempt to continue, but you may need to restart if features break.`);\n});\nprocess.on(\"unhandledRejection\", (reason, promise) => {\n  logger11.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n});\nvar mainWindow = null;\nvar createWindow = () => {\n  const windowConfig = {\n    width: 1280,\n    height: 800,\n    minWidth: 1e3,\n    minHeight: 800,\n    frame: false,\n    // Custom UI requires frameless\n    backgroundColor: \"#030014\",\n    // Match app background to avoid white flash\n    webPreferences: {\n      preload: import_path5.default.join(__dirname, \"preload.cjs\"),\n      nodeIntegration: false,\n      contextIsolation: true,\n      sandbox: false,\n      // Required for some native modules\n      webSecurity: true,\n      // Enable web security in production\n      allowRunningInsecureContent: false\n    },\n    title: \"VRChat Group Guard\",\n    titleBarStyle: \"hidden\",\n    show: false\n    // Don't show until ready\n  };\n  mainWindow = new import_electron12.BrowserWindow(windowConfig);\n  mainWindow.once(\"ready-to-show\", () => {\n    mainWindow?.show();\n  });\n  mainWindow.webContents.setWindowOpenHandler(({ url }) => {\n    if (url.startsWith(\"https:\")) {\n      import_electron12.shell.openExternal(url);\n    } else {\n      logger11.warn(`Blocked non-https external URL: ${url}`);\n    }\n    return { action: \"deny\" };\n  });\n  mainWindow.webContents.on(\"will-navigate\", (event, navigationUrl) => {\n    const parsedUrl = new URL(navigationUrl);\n    if (parsedUrl.origin !== \"http://localhost:5173\" && parsedUrl.protocol !== \"file:\") {\n      event.preventDefault();\n      logger11.warn(`Blocked navigation to external URL: ${navigationUrl}`);\n    }\n  });\n  if (process.env.NODE_ENV === \"development\") {\n    mainWindow.loadURL(\"http://localhost:5173\");\n    logger11.info(\"Loading development server at http://localhost:5173\");\n  } else {\n    mainWindow.loadFile(import_path5.default.join(__dirname, \"../dist/index.html\"));\n    logger11.info(\"Loading production build\");\n  }\n  mainWindow.on(\"closed\", () => {\n    mainWindow = null;\n  });\n};\nimport_electron12.ipcMain.on(\"log\", (_event, level, message) => {\n  const validLevels = [\"info\", \"warn\", \"error\", \"debug\"];\n  if (validLevels.includes(level) && typeof import_electron_log11.default[level] === \"function\") {\n    import_electron_log11.default[level](message);\n  }\n});\nimport_electron12.ipcMain.handle(\"storage:get-status\", () => {\n  return {\n    configured: storageService.isConfigured(),\n    path: storageService.getDataDir(),\n    defaultPath: storageService.getUnconfiguredDefaultPath()\n  };\n});\nimport_electron12.ipcMain.handle(\"storage:select-folder\", () => {\n  return storageService.selectDirectory(mainWindow);\n});\nimport_electron12.ipcMain.handle(\"storage:set-path\", (_event, path6) => {\n  return storageService.setLocation(path6);\n});\nstorageService.initialize();\nsetupAuthHandlers();\nsetupGroupHandlers();\nsetupUserHandlers();\nsetupCredentialsHandlers();\nsetupPipelineHandlers();\nsetupLogWatcherHandlers();\nsetupAutoModHandlers();\nsetupInstanceHandlers();\nimport_electron12.ipcMain.handle(\"window:minimize\", () => {\n  mainWindow?.minimize();\n});\nimport_electron12.ipcMain.handle(\"window:maximize\", () => {\n  if (mainWindow?.isMaximized()) {\n    mainWindow.unmaximize();\n  } else {\n    mainWindow?.maximize();\n  }\n});\nimport_electron12.ipcMain.handle(\"window:close\", () => {\n  mainWindow?.close();\n});\nimport_electron12.app.whenReady().then(async () => {\n  logger11.info(\"App ready, creating window...\");\n  createWindow();\n  if (process.env.NODE_ENV === \"development\") {\n    mainWindow?.webContents.openDevTools();\n  }\n  if (process.env.NODE_ENV !== \"development\") {\n    try {\n      import_electron_updater.autoUpdater.logger = import_electron_log11.default;\n      import_electron_updater.autoUpdater.logger.transports.file.level = \"info\";\n      logger11.info(\"Initializing auto-updater...\");\n      import_electron_updater.autoUpdater.on(\"checking-for-update\", () => {\n        logger11.info(\"Checking for updates...\");\n      });\n      import_electron_updater.autoUpdater.on(\"update-available\", (info) => {\n        logger11.info(\"Update available:\", info);\n      });\n      import_electron_updater.autoUpdater.on(\"update-not-available\", (info) => {\n        logger11.info(\"Update not available:\", info);\n      });\n      import_electron_updater.autoUpdater.on(\"error\", (err) => {\n        logger11.error(\"Error in auto-updater:\", err);\n      });\n      import_electron_updater.autoUpdater.on(\"download-progress\", (progressObj) => {\n        logger11.info(`Download speed: ${progressObj.bytesPerSecond} - Downloaded ${progressObj.percent}%`);\n      });\n      import_electron_updater.autoUpdater.checkForUpdatesAndNotify();\n      import_electron_updater.autoUpdater.on(\"update-downloaded\", (info) => {\n        logger11.info(\"Update downloaded:\", info);\n        setTimeout(() => {\n          mainWindow?.webContents.send(\"updater:update-downloaded\");\n        }, 2e3);\n      });\n    } catch (err) {\n      logger11.error(\"Failed to check for updates:\", err);\n    }\n  }\n  import_electron12.ipcMain.handle(\"updater:quit-and-install\", () => {\n    import_electron_updater.autoUpdater.quitAndInstall();\n  });\n  import_electron12.ipcMain.handle(\"updater:check-status\", async () => {\n    return updateDownloaded;\n  });\n  let updateDownloaded = false;\n  import_electron_updater.autoUpdater.on(\"update-downloaded\", () => {\n    updateDownloaded = true;\n  });\n  import_electron12.app.on(\"activate\", () => {\n    if (import_electron12.BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n});\nimport_electron12.app.on(\"window-all-closed\", () => {\n  logger11.info(\"All windows closed\");\n  if (process.platform !== \"darwin\") {\n    import_electron12.app.quit();\n  }\n});\nimport_electron12.app.on(\"before-quit\", () => {\n  logger11.info(\"Application quitting...\");\n});\n/*! Bundled license information:\n\nsax/lib/sax.js:\n  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)\n\nkeyv/dist/index.cjs:\n  (* v8 ignore next -- @preserve *)\n\ntslib/tslib.es6.js:\n  (*! *****************************************************************************\n  Copyright (c) Microsoft Corporation.\n  \n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** *)\n*/\n//# sourceMappingURL=main.cjs.map\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\dist-electron\\preload.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\preload.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8535,8538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8535,8538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8628,8631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8628,8631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { contextBridge, ipcRenderer } from 'electron';\r\n \r\n // Expose protected methods that allow the renderer process to use\r\n // the ipcRenderer without exposing the entire object\r\n contextBridge.exposeInMainWorld('electron', {\r\n     log: (level: string, message: string) => ipcRenderer.send('log', level, message),\r\n     getVersion: () => process.versions.electron,\r\n     \r\n     // Auth API\r\n     login: (credentials: { username: string; password: string; rememberMe?: boolean }) => \r\n       ipcRenderer.invoke('auth:login', credentials),\r\n     verify2fa: (data: { code: string }) => ipcRenderer.invoke('auth:verify2fa', data),\r\n     checkSession: () => ipcRenderer.invoke('auth:check-session'),\r\n     autoLogin: () => ipcRenderer.invoke('auth:auto-login'),\r\n     hasSavedCredentials: () => ipcRenderer.invoke('credentials:has-saved'),\r\n     loadSavedCredentials: () => ipcRenderer.invoke('credentials:load'),\r\n     logout: (options?: { clearSaved?: boolean }) => ipcRenderer.invoke('auth:logout', options || {}),\r\n     clearCredentials: () => ipcRenderer.invoke('credentials:clear'),\r\n     \r\n     // Groups API\r\n     getMyGroups: () => ipcRenderer.invoke('groups:get-my-groups'),\r\n     getGroupDetails: (groupId: string) => ipcRenderer.invoke('groups:get-details', { groupId }),\r\n     getGroupMembers: (groupId: string, offset = 0, n = 100) => ipcRenderer.invoke('groups:get-members', { groupId, offset, n }),\r\n     getGroupRequests: (groupId: string) => ipcRenderer.invoke('groups:get-requests', { groupId }),\r\n     getGroupBans: (groupId: string) => ipcRenderer.invoke('groups:get-bans', { groupId }),\r\n     getGroupInstances: (groupId: string) => ipcRenderer.invoke('groups:get-instances', { groupId }),\r\n     banUser: (groupId: string, userId: string) => ipcRenderer.invoke('groups:ban-user', { groupId, userId }),\r\n     \r\n     // Audit API\r\n     getGroupAuditLogs: (groupId: string) => ipcRenderer.invoke('groups:get-audit-logs', { groupId }),\r\n\r\n     // Worlds API\r\n     getWorld: (worldId: string) => ipcRenderer.invoke('worlds:get-details', { worldId }),\r\n\r\n     // Users API\r\n     getUser: (userId: string) => ipcRenderer.invoke('users:get', { userId }),\r\n     clearUserCache: (userId?: string) => ipcRenderer.invoke('users:clear-cache', { userId }),\r\n     \r\n     // Pipeline (WebSocket) API\r\n     pipeline: {\r\n       connect: () => ipcRenderer.invoke('pipeline:connect'),\r\n       disconnect: () => ipcRenderer.invoke('pipeline:disconnect'),\r\n       status: () => ipcRenderer.invoke('pipeline:status'),\r\n       reconnect: () => ipcRenderer.invoke('pipeline:reconnect'),\r\n       \r\n       // Event listeners for real-time updates\r\n       onEvent: (callback: (event: unknown) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: unknown) => callback(data);\r\n         ipcRenderer.on('pipeline:event', handler);\r\n         return () => ipcRenderer.removeListener('pipeline:event', handler);\r\n       },\r\n       onConnected: (callback: (data: { connected: boolean }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { connected: boolean }) => callback(data);\r\n         ipcRenderer.on('pipeline:connected', handler);\r\n         return () => ipcRenderer.removeListener('pipeline:connected', handler);\r\n       },\r\n       onDisconnected: (callback: (data: { code: number; reason: string; willReconnect: boolean }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { code: number; reason: string; willReconnect: boolean }) => callback(data);\r\n         ipcRenderer.on('pipeline:disconnected', handler);\r\n         return () => ipcRenderer.removeListener('pipeline:disconnected', handler);\r\n       },\r\n       onError: (callback: (data: { message: string }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { message: string }) => callback(data);\r\n         ipcRenderer.on('pipeline:error', handler);\r\n         return () => ipcRenderer.removeListener('pipeline:error', handler);\r\n       },\r\n     },\r\n\r\n     // Log Watcher API\r\n     logWatcher: {\r\n       start: () => ipcRenderer.invoke('log-watcher:start'),\r\n       stop: () => ipcRenderer.invoke('log-watcher:stop'),\r\n       onPlayerJoined: (callback: (event: { displayName: string; userId?: string; timestamp: string }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { displayName: string; userId?: string; timestamp: string }) => callback(data);\r\n         ipcRenderer.on('log:player-joined', handler);\r\n         return () => ipcRenderer.removeListener('log:player-joined', handler);\r\n       },\r\n       onPlayerLeft: (callback: (event: { displayName: string; userId?: string; timestamp: string }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { displayName: string; userId?: string; timestamp: string }) => callback(data);\r\n         ipcRenderer.on('log:player-left', handler);\r\n         return () => ipcRenderer.removeListener('log:player-left', handler);\r\n       },\r\n       onLocation: (callback: (event: { worldId: string; timestamp: string }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { worldId: string; timestamp: string }) => callback(data);\r\n         ipcRenderer.on('log:location', handler);\r\n         return () => ipcRenderer.removeListener('log:location', handler);\r\n       },\r\n       onWorldName: (callback: (event: { name: string; timestamp: string }) => void) => {\r\n         const handler = (_event: Electron.IpcRendererEvent, data: { name: string; timestamp: string }) => callback(data);\r\n         ipcRenderer.on('log:world-name', handler);\r\n         return () => ipcRenderer.removeListener('log:world-name', handler);\r\n       },\r\n     },\r\n     \r\n     database: {\r\n         getSessions: (groupId?: string) => ipcRenderer.invoke('database:get-sessions', groupId),\r\n         getSessionEvents: (filename: string) => ipcRenderer.invoke('database:get-session-events', filename),\r\n         clearSessions: () => ipcRenderer.invoke('database:clear-sessions'),\r\n         rallyFromSession: (filename: string) => ipcRenderer.invoke('instance:rally-from-session', { filename }),\r\n         onRallyProgress: (callback: (data: { sent: number; failed: number; total: number; done?: boolean }) => void) => {\r\n             const handler = (_event: Electron.IpcRendererEvent, data: { sent: number; failed: number; total: number; done?: boolean }) => callback(data);\r\n             ipcRenderer.on('rally:progress', handler);\r\n             return () => ipcRenderer.removeListener('rally:progress', handler);\r\n         },\r\n     },\r\n     \r\n     // Window Controls\r\n     minimize: () => ipcRenderer.invoke('window:minimize'),\r\n     maximize: () => ipcRenderer.invoke('window:maximize'),\r\n     close: () => ipcRenderer.invoke('window:close'),\r\n\r\n     // Storage API\r\n     storage: {\r\n         getStatus: () => ipcRenderer.invoke('storage:get-status'),\r\n         selectFolder: () => ipcRenderer.invoke('storage:select-folder'),\r\n         setPath: (path: string) => ipcRenderer.invoke('storage:set-path', path),\r\n     },\r\n\r\n     // Instance Presence API\r\n     instance: {\r\n         getCurrentGroup: () => ipcRenderer.invoke('instance:get-current-group'),\r\n         onGroupChanged: (callback: (groupId: string | null) => void) => {\r\n             const handler = (_event: Electron.IpcRendererEvent, groupId: string | null) => callback(groupId);\r\n             ipcRenderer.on('instance:group-changed', handler);\r\n             return () => ipcRenderer.removeListener('instance:group-changed', handler);\r\n         },\r\n         // NEW LIVE OPS API\r\n         scanSector: (groupId: string) => ipcRenderer.invoke('instance:scan-sector', { groupId }),\r\n         recruitUser: (groupId: string, userId: string) => ipcRenderer.invoke('instance:recruit-user', { groupId, userId }),\r\n         kickUser: (groupId: string, userId: string) => ipcRenderer.invoke('instance:kick-user', { groupId, userId }),\r\n         // rallyForces: (groupId: string) => ipcRenderer.invoke('instance:rally-forces', { groupId }), // Deprecated but keeping for safety if needed\r\n         getRallyTargets: (groupId: string) => ipcRenderer.invoke('instance:get-rally-targets', { groupId }),\r\n         inviteToCurrent: (userId: string) => ipcRenderer.invoke('instance:invite-to-current', { userId }),\r\n         closeInstance: () => ipcRenderer.invoke('instance:close-instance'),\r\n         getInstanceInfo: () => ipcRenderer.invoke('instance:get-instance-info'),\r\n         onEntityUpdate: (callback: (entity: any) => void) => {\r\n             const handler = (_event: Electron.IpcRendererEvent, entity: any) => callback(entity);\r\n             ipcRenderer.on('instance:entity-update', handler);\r\n             return () => ipcRenderer.removeListener('instance:entity-update', handler);\r\n         }\r\n     },\r\n\r\n     // Updater API\r\n     updater: {\r\n         onUpdateAvailable: (callback: () => void) => {\r\n             const handler = () => callback();\r\n             ipcRenderer.on('updater:update-available', handler);\r\n             return () => ipcRenderer.removeListener('updater:update-available', handler);\r\n         },\r\n         onUpdateDownloaded: (callback: () => void) => {\r\n             const handler = () => callback();\r\n             ipcRenderer.on('updater:update-downloaded', handler);\r\n             return () => ipcRenderer.removeListener('updater:update-downloaded', handler);\r\n         },\r\n         quitAndInstall: () => ipcRenderer.invoke('updater:quit-and-install'),\r\n         checkStatus: () => ipcRenderer.invoke('updater:check-status')\r\n     },\r\n     \r\n     // AutoMod API\r\n     automod: {\r\n         getRules: () => ipcRenderer.invoke('automod:get-rules'),\r\n         saveRule: (rule: unknown) => ipcRenderer.invoke('automod:save-rule', rule),\r\n         deleteRule: (ruleId: number) => ipcRenderer.invoke('automod:delete-rule', ruleId),\r\n         checkUser: (user: unknown) => ipcRenderer.invoke('automod:check-user', user),\r\n     }\r\n });\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\AuditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\AuthService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'app' is defined but never used.","line":1,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2792,2795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2792,2795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3088,3091],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3088,3091],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3216,3219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3216,3219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3281,3284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3281,3284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3433,3436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3433,3436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3536,3539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3536,3539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3935,3938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3935,3938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'restoredUser' is assigned a value but never used.","line":414,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":414,"endColumn":32}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":14,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":14,"endColumn":38,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, app } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('AuthService');\r\nimport path from 'path';\r\nimport { saveCredentials, clearCredentials, loadCredentials, hasSavedCredentials } from './CredentialsService';\r\nimport { onUserLoggedIn, onUserLoggedOut } from './PipelineService';\r\n\r\n// Import the VRChat SDK and Keyv for session persistence\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst { VRChat } = require('vrchat');\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst Keyv = require('keyv').default;\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst KeyvFile = require('keyv-file').default;\r\n\r\n// Store the VRChat SDK instance in memory (Main Process)\r\nlet vrchatClient: InstanceType<typeof VRChat> | null = null;\r\nlet currentUser: Record<string, unknown> | null = null;\r\nlet pendingLoginCredentials: { username: string; password: string; rememberMe?: boolean; authCookie?: string } | null = null;\r\n\r\n// Persistent session storage using Keyv with SQLite\r\nlet sessionStore: InstanceType<typeof Keyv> | null = null;\r\n\r\nimport { storageService } from './StorageService';\r\n\r\n// ...\r\n\r\nfunction getSessionStore(): InstanceType<typeof Keyv> {\r\n  if (!sessionStore) {\r\n    // Store sessions in the configured data directory\r\n    const userDataPath = storageService.getDataDir();\r\n    const filePath = path.join(userDataPath, 'vrchat-session.json');\r\n    logger.info(`Session store path: ${filePath}`);\r\n    \r\n    const store = new KeyvFile({ filename: filePath });\r\n    \r\n    // WORKAROUND: Keyv v5+ crashes if store.opts.url is undefined during _checkIterableAdapter\r\n    // We patch the store to satisfy Keyv's internal check\r\n    if (!store.opts) store.opts = {};\r\n    if (!store.opts.url) store.opts.url = 'file://';\r\n    \r\n    sessionStore = new Keyv({ store, namespace: 'vrchat' });\r\n    \r\n    // WORKAROUND 2: VRChat library might re-wrap our Keyv instance if it detects a version/instance mismatch.\r\n    // This wrapper will check our instance's .opts.url, so we must ensure it exists.\r\n    if (sessionStore.opts) {\r\n        sessionStore.opts.url = 'file://';\r\n    } else {\r\n        // @ts-expect-error - forcing opts if missing\r\n        sessionStore.opts = { url: 'file://' };\r\n    }\r\n    \r\n    sessionStore.on('error', (err: Error) => {\r\n      logger.error('Session store error:', err);\r\n    });\r\n  }\r\n  return sessionStore;\r\n}\r\n\r\n// Application info for VRChat API User-Agent requirement\r\nconst APP_INFO = {\r\n  name: 'VRChatGroupGuard',\r\n  version: '1.0.0',\r\n  contact: 'admin@groupguard.app'\r\n};\r\n\r\n// VRChat API base URL\r\nconst VRCHAT_API_BASE = 'https://api.vrchat.cloud/api/1';\r\n\r\n// Helper to extract auth cookie from client\r\nfunction extractAuthCookie(client: any): string | undefined {\r\n  try {\r\n    // Check various common places for cookies in HTTP clients\r\n    const jar = client.jar || client.cookieJar || client.cookies;\r\n    \r\n    if (!jar) {\r\n      logger.debug('No cookie jar found on client');\r\n      return undefined;\r\n    }\r\n\r\n    let cookies: any[] = [];\r\n    \r\n    // If it's a tough-cookie jar or similar with getCookiesSync\r\n    try {\r\n      if (jar && typeof (jar as any).getCookiesSync === 'function') {\r\n        cookies = (jar as any).getCookiesSync(VRCHAT_API_BASE);\r\n      } else if (Array.isArray(jar)) {\r\n        cookies = jar;\r\n      } else if (jar._jar && typeof (jar._jar as any).getCookiesSync === 'function') {\r\n        // tough-cookie wrapped\r\n        cookies = (jar._jar as any).getCookiesSync(VRCHAT_API_BASE);\r\n      }\r\n    } catch (jarError) {\r\n      logger.warn('Error accessing cookie jar:', jarError);\r\n      return undefined;\r\n    }\r\n\r\n    if (!Array.isArray(cookies)) {\r\n      logger.warn('Cookies is not an array:', typeof cookies);\r\n      return undefined;\r\n    }\r\n\r\n    // Find the 'auth' cookie - be extremely defensive\r\n    const authCookie = cookies.find((c: any) => {\r\n      if (!c) return false;\r\n      // Handle various cookie shapes (tough-cookie, electron cookie, simple object)\r\n      const key = c.key || c.name; \r\n      if (!key) return false;\r\n      \r\n      // Safe check for 'auth'\r\n      return key === 'auth' || (typeof key === 'string' && key.includes('auth'));\r\n    });\r\n    \r\n    if (authCookie) {\r\n      logger.debug('Found auth cookie');\r\n      // Return in format key=value\r\n      const key = authCookie.key || authCookie.name;\r\n      const value = authCookie.value;\r\n      return `${key}=${value}`;\r\n    }\r\n    \r\n  } catch (err) {\r\n    logger.warn('Failed to extract auth cookie:', err);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Try to restore a session using the persisted Keyv session store\r\n * Returns the user if successful, null if the session is invalid/expired\r\n */\r\nasync function tryRestoreSession(): Promise<{\r\n  success: boolean;\r\n  user?: Record<string, unknown>;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    logger.info('Attempting to restore session from persistent store...');\r\n    \r\n    // Create a client with the persistent session store\r\n    // The SDK will automatically load any saved cookies from the Keyv store\r\n    const clientOptions = {\r\n      baseUrl: VRCHAT_API_BASE,\r\n      application: APP_INFO,\r\n      keyv: getSessionStore()\r\n    };\r\n    \r\n    logger.info('Creating VRChat client for session check...');\r\n    const client = new VRChat(clientOptions);\r\n    \r\n    // Try to get the current user - this will work if there's a valid session\r\n    try {\r\n      logger.info('Checking for existing session...');\r\n      const userResponse = await client.getCurrentUser({ throwOnError: true });\r\n      const user = userResponse?.data;\r\n      \r\n      if (user && user.id) {\r\n        logger.info(`Session restored successfully for: ${user.displayName}`);\r\n        \r\n        // Store the client and user globally\r\n        vrchatClient = client;\r\n        \r\n        // Sanitize ID\r\n        if (user.id && typeof user.id === 'string') {\r\n            user.id = user.id.trim();\r\n        }\r\n        \r\n        currentUser = user as Record<string, unknown>;\r\n        \r\n        return { success: true, user: currentUser };\r\n      }\r\n      \r\n      logger.info('No user data returned, session invalid');\r\n      return { success: false, error: 'No user data' };\r\n      \r\n    } catch (err: unknown) {\r\n      const error = err as { response?: { status?: number }; message?: string };\r\n      \r\n      // 401 = no valid session, this is expected on first launch\r\n      if (error.response?.status === 401) {\r\n        logger.info('No valid session found (401), will need to authenticate');\r\n        return { success: false, error: 'No valid session' };\r\n      }\r\n      \r\n      // Log and handle any other errors gracefully\r\n      logger.warn('Session check failed with error:', error.message || String(err));\r\n      return { success: false, error: error.message || 'Session check failed' };\r\n    }\r\n    \r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string };\r\n    logger.error('Session restoration error:', err.message || String(error));\r\n    return { success: false, error: err.message || 'Session restoration failed' };\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Internal login function - shared between manual and auto-login\r\n */\r\nasync function performLogin(username: string, password: string, twoFactorCode?: string): Promise<{\r\n  success: boolean;\r\n  user?: Record<string, unknown>;\r\n  requires2FA?: boolean;\r\n  twoFactorMethods?: string[];\r\n  error?: string;\r\n  authCookie?: string;\r\n}> {\r\n  try {\r\n    logger.info('Attempting VRChat login...');\r\n    logger.debug(`performLogin called for user ${username}`);\r\n\r\n    // Create a fresh VRChat client instance\r\n    let client = vrchatClient;\r\n    \r\n    // Create new client if needed\r\n    if (!client || !twoFactorCode) {\r\n         const clientOptions = {\r\n            baseUrl: VRCHAT_API_BASE,\r\n            application: APP_INFO,\r\n            // Use Keyv for persistent session storage (cookies persist across restarts!)\r\n            keyv: getSessionStore()\r\n         };\r\n         \r\n         logger.info('Creating VRChat client with persistent session store for login...');\r\n         client = new VRChat(clientOptions);\r\n    }\r\n\r\n    logger.info('VRChat client created (or reused), attempting login...');\r\n    \r\n    // Attempt login - the SDK's login method handles the authentication flow\r\n    try {\r\n      // If we have a cookie, we might strictly speaking purely verify credentials, \r\n      // but calling login ensure we get the user object and refresh session.\r\n      // If the cookie is valid, login() should succeed without 2FA even if 2FA is enabled.\r\n      \r\n      const user = await client.login({ username, password, twoFactorCode });\r\n      \r\n      // ... User validation logic ...\r\n      \r\n      logger.debug('Login successful. Inspecting client for cookies...');\r\n      \r\n      // Extract and save new auth cookie\r\n      const newAuthCookie = extractAuthCookie(client);\r\n      if (newAuthCookie) {\r\n         // Update the current credentials with the new cookie\r\n         if (pendingLoginCredentials) {\r\n            pendingLoginCredentials.authCookie = newAuthCookie;\r\n         } else {\r\n             // If manual login, we will save it in the auth:login handler\r\n             // If auto-login, we should update the store\r\n             // We can return it in the result or update global state? \r\n             // Best to just update the storage directly if we know who we are?\r\n             // Actually, saveCredentials handles it.\r\n         }\r\n      }\r\n      \r\n      // ... (validation logic continues from previous file content)\r\n\r\n      \r\n      // Check if we got a valid user object\r\n      let validUser: Record<string, unknown> = user;\r\n      \r\n      // ... (rest of validation) - REMOVED\r\n      \r\n      // Handle case where user is wrapped in data property\r\n      // @ts-expect-error - Checking for data wrapper\r\n      if (!validUser.id && validUser.data && validUser.data.id) {\r\n         // @ts-expect-error - Unwrap data\r\n         validUser = validUser.data;\r\n      }\r\n      \r\n      // Check if it's an error response\r\n      if (validUser.error) {\r\n        // @ts-expect-error - Accessing error message\r\n        throw new Error(validUser.error.message || 'Login returned an error');\r\n      }\r\n      \r\n      // Validate we have an ID\r\n      if (!validUser || !validUser.id) {\r\n        logger.error('Login response missing ID:', validUser);\r\n        throw new Error('Login failed: Invalid user object received');\r\n      }\r\n\r\n      // Success - store the client and user with Sanitized ID\r\n      if (validUser.id && typeof validUser.id === 'string') {\r\n          validUser.id = validUser.id.trim();\r\n      }\r\n      vrchatClient = client;\r\n      currentUser = validUser;\r\n      \r\n      const userId = validUser.id as string;\r\n      const displayName = validUser.displayName as string;\r\n      \r\n      logger.info(`User logged in successfully: ${displayName} (${userId})`);\r\n      logger.debug('Login successful', { id: userId, name: displayName });\r\n      \r\n      logger.info(`Global vrchatClient set: ${!!vrchatClient}`);\r\n\r\n      // Connect to Pipeline WebSocket for real-time events\r\n      onUserLoggedIn();\r\n\r\n      return { success: true, user: currentUser, authCookie: newAuthCookie };\r\n      \r\n    } catch (loginError: unknown) {\r\n      // Check if this is a 2FA requirement\r\n      const err = loginError as { message?: string; stack?: string; twoFactorMethods?: string[]; code?: string };\r\n      \r\n      const errorMsg = err?.message || 'Unknown login error';\r\n      // Ensure errorMsg is a string before using string methods\r\n      const errorMsgSafe = typeof errorMsg === 'string' ? errorMsg : String(errorMsg);\r\n      const errorMsgLower = errorMsgSafe.toLowerCase();\r\n      \r\n      logger.info('Login error details:', {\r\n        message: errorMsgSafe,\r\n        twoFactorMethods: err?.twoFactorMethods,\r\n        code: err?.code\r\n      });\r\n      \r\n      // The SDK throws with twoFactorMethods array when 2FA is required\r\n      if (err?.twoFactorMethods && Array.isArray(err.twoFactorMethods) && err.twoFactorMethods.length > 0) {\r\n        logger.info('2FA required, methods:', err.twoFactorMethods);\r\n        logger.debug('2FA required');\r\n        \r\n        // Store credentials and client for 2FA verification\r\n        vrchatClient = client;\r\n        \r\n        return { \r\n          success: false, \r\n          requires2FA: true,\r\n          twoFactorMethods: err.twoFactorMethods\r\n        };\r\n      }\r\n      \r\n      // WORKAROUND: If the library crashes with \"Cannot read properties of undefined (reading 'includes')\",\r\n      // it is often due to a bug in handling the 2FA response (missing headers/cookies handling).\r\n      // We assume this means 2FA is required if we haven't sent a code yet.\r\n      if (errorMsgSafe.includes(\"Cannot read properties of undefined (reading 'includes')\")) {\r\n        logger.warn(\"Caught library crash compatible with 2FA response bug. Assuming 2FA required.\");\r\n        logger.debug(\"Stack trace:\", err?.stack);\r\n        \r\n        vrchatClient = client;\r\n        return { success: false, requires2FA: true };\r\n      }\r\n\r\n      // Check for common 2FA indicators in error message\r\n      if (\r\n        errorMsgLower.includes('two-factor') ||\r\n        errorMsgLower.includes('2fa') ||\r\n        errorMsgSafe.includes('TOTP') ||\r\n        errorMsgSafe.includes('emailotp') ||\r\n        errorMsgLower.includes('totp') ||\r\n        errorMsgLower.includes('otp')\r\n      ) {\r\n        vrchatClient = client;\r\n        logger.debug('2FA required (text check)');\r\n        return { success: false, requires2FA: true };\r\n      }\r\n      \r\n      \r\n      // Re-throw for general error handling\r\n      throw loginError;\r\n    }\r\n\r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string; stack?: string; response?: { data?: { error?: { message?: string } } } };\r\n    logger.error('Login Failed (Outer Catch):', error);\r\n    if (err && err.stack) {\r\n        logger.error('Stack Trace:', err.stack);\r\n    }\r\n    \r\n    // Extract meaningful error message\r\n    let errorMessage = 'Unknown login error';\r\n    \r\n    if (err?.response?.data?.error?.message) {\r\n      errorMessage = err.response.data.error.message;\r\n    } else if (err?.message) {\r\n      errorMessage = err.message;\r\n    }\r\n    \r\n    if (typeof errorMessage !== 'string') {\r\n        errorMessage = String(errorMessage);\r\n    }\r\n    \r\n    // Append stack trace for debugging if available\r\n    if (err?.stack) {\r\n        errorMessage += `\\n\\nStack:\\n${err.stack}`;\r\n    }\r\n    \r\n    return { success: false, error: errorMessage };\r\n  }\r\n}\r\n\r\nexport function setupAuthHandlers() {\r\n  \r\n  // LOGIN Handler - accepts rememberMe flag\r\n  ipcMain.handle('auth:login', async (_event, { username, password, rememberMe = false }: { \r\n    username: string; \r\n    password: string;\r\n    rememberMe?: boolean;\r\n  }) => {\r\n    // Check if we have saved credentials that match these inputs\r\n    const saved = loadCredentials();\r\n    const isSavedUser = saved && saved.username === username;\r\n    \r\n    // If we have saved credentials for this user, try to restore session first to skip 2FA\r\n    if (isSavedUser) {\r\n        logger.info('Login matches saved user, attempting session restoration to bypass 2FA...');\r\n        const restoreResult = await tryRestoreSession();\r\n        \r\n        // If restoration worked, we are logged in!\r\n        // We do strictly verify the user ID to ensure we aren't using a stale cookie for the wrong account (though username check helps)\r\n        if (restoreResult.success && restoreResult.user) {\r\n             const restoredUser = restoreResult.user as { username?: string; displayName?: string };\r\n             // Basic check to ensure it's the same person if possible (though API returns current user)\r\n             logger.info('Session restored successfully during manual login!');\r\n             return { success: true, user: restoreResult.user };\r\n        }\r\n    }\r\n    \r\n    // Fallback to standard login\r\n    const result = await performLogin(username, password);\r\n    \r\n    if (result.success && rememberMe) {\r\n      // Save credentials on successful direct login (no 2FA)\r\n      // Save authCookie if we got one\r\n      saveCredentials(username, password, result.authCookie);\r\n      logger.info('Credentials saved for auto-login');\r\n      logger.debug('Credentials saved manually');\r\n    } else if (result.requires2FA) {\r\n      // Store credentials for 2FA completion (will save after 2FA if rememberMe is set)\r\n      // NOTE: We don't have authCookie yet usually for 2FA flow, but if we did we could store it\r\n      pendingLoginCredentials = { username, password, rememberMe };\r\n    }\r\n    \r\n    return result;\r\n  });\r\n\r\n  // 2FA Verification Handler\r\n  ipcMain.handle('auth:verify2fa', async (_event, { code }: { code: string }) => {\r\n    if (!vrchatClient || !pendingLoginCredentials) {\r\n      return { success: false, error: \"No pending login session. Please try logging in again.\" };\r\n    }\r\n    \r\n    try {\r\n      logger.info('Verifying 2FA code...');\r\n      \r\n      const result = await performLogin(\r\n        pendingLoginCredentials.username,\r\n        pendingLoginCredentials.password,\r\n        code\r\n      );\r\n\r\n      if (!result.success || !result.user) {\r\n        throw new Error(result.error || '2FA verification failed');\r\n      }\r\n\r\n      // Save credentials if rememberMe was set during initial login\r\n      if (pendingLoginCredentials.rememberMe) {\r\n        // Save with the new authCookie from the result\r\n        saveCredentials(pendingLoginCredentials.username, pendingLoginCredentials.password, result.authCookie);\r\n        logger.info('Credentials saved for auto-login after 2FA');\r\n        logger.debug('Credentials saved after 2FA');\r\n      }\r\n      \r\n      pendingLoginCredentials = null; // Clear pending credentials\r\n      \r\n      // Note: performLogin sets currentUser and vrchatClient already\r\n      \r\n      return { success: true, user: currentUser };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error(\"2FA Verification Error:\", error);\r\n      \r\n      const errorMessage = err.message || 'Invalid 2FA code';\r\n      \r\n      // Check for specific error types\r\n      if (errorMessage.toLowerCase().includes('invalid') || errorMessage.toLowerCase().includes('incorrect')) {\r\n        return { success: false, error: 'Invalid 2FA code. Please try again.' };\r\n      }\r\n      \r\n      return { success: false, error: errorMessage };\r\n    }\r\n  });\r\n\r\n  // AUTO-LOGIN Handler - attempts login with saved credentials\r\n  ipcMain.handle('auth:auto-login', async () => {\r\n    logger.info('Checking for saved credentials for auto-login...');\r\n    \r\n    if (!hasSavedCredentials()) {\r\n      logger.info('No saved credentials found');\r\n      return { success: false, noCredentials: true };\r\n    }\r\n    \r\n    const credentials = loadCredentials();\r\n    if (!credentials) {\r\n      logger.info('Failed to load credentials');\r\n      return { success: false, error: 'Failed to load saved credentials' };\r\n    }\r\n    \r\n    logger.info('Found saved credentials, attempting session restoration...');\r\n    \r\n    // FIRST: Try to restore session from Keyv store (no 2FA required!)\r\n    const sessionResult = await tryRestoreSession();\r\n    \r\n    if (sessionResult.success && sessionResult.user) {\r\n      logger.info('Session restored successfully without re-authentication!');\r\n      return { success: true, user: sessionResult.user };\r\n    }\r\n    \r\n    logger.info('Session restoration failed, falling back to full login...');\r\n    \r\n    // FALLBACK: Full login (will require 2FA if enabled)\r\n    logger.info(`Attempting full login for ${credentials.username}...`);\r\n    const result = await performLogin(credentials.username, credentials.password);\r\n    \r\n    if (result.success) {\r\n       // Update the cookie if it changed\r\n       if (result.authCookie && result.authCookie !== credentials.authCookie) {\r\n          saveCredentials(credentials.username, credentials.password, result.authCookie);\r\n          logger.debug('Auth cookie updated after auto-login');\r\n       }\r\n    }\r\n    \r\n    if (result.requires2FA) {\r\n      // Store pending credentials with rememberMe for 2FA\r\n      pendingLoginCredentials = { \r\n        username: credentials.username, \r\n        password: credentials.password, \r\n        rememberMe: true,\r\n        authCookie: credentials.authCookie\r\n      };\r\n    }\r\n    \r\n    return result;\r\n  });\r\n\r\n  // Check Session - returns current user if logged in\r\n  ipcMain.handle('auth:check-session', () => {\r\n    if (currentUser && vrchatClient) {\r\n      return { isLoggedIn: true, user: currentUser };\r\n    }\r\n    return { isLoggedIn: false };\r\n  });\r\n  \r\n  // Check if saved credentials exist\r\n  ipcMain.handle('auth:has-saved-credentials', () => {\r\n    return hasSavedCredentials();\r\n  });\r\n\r\n  // Logout Handler - optionally clears saved credentials\r\n  ipcMain.handle('auth:logout', async (_event, { clearSaved = false }: { clearSaved?: boolean } = {}) => {\r\n    try {\r\n      // The SDK may have a logout method, but we mainly need to clear local state\r\n      // VRChat doesn't have a traditional logout endpoint - sessions are cookie-based\r\n      logger.info('Logging out user...');\r\n      logger.debug('Logging out');\r\n      \r\n      if (clearSaved) {\r\n        clearCredentials();\r\n        logger.info('Saved credentials cleared');\r\n        logger.debug('Saved credentials cleared');\r\n      }\r\n    } catch (e) {\r\n      logger.warn('Logout cleanup:', e);\r\n    }\r\n    \r\n    vrchatClient = null;\r\n    currentUser = null;\r\n    pendingLoginCredentials = null;\r\n    \r\n    // Disconnect from Pipeline WebSocket\r\n    onUserLoggedOut();\r\n    \r\n    return { success: true };\r\n  });\r\n}\r\n\r\n// Helper to share client with other services (Groups, Audit, etc.)\r\nexport function getVRChatClient() {\r\n  logger.debug(`getVRChatClient called. Result exists: ${!!vrchatClient}`);\r\n  return vrchatClient;\r\n}\r\n\r\n// Helper to check if authenticated\r\nexport function isAuthenticated(): boolean {\r\n  return vrchatClient !== null && currentUser !== null;\r\n}\r\n\r\n// Helper to get current user's ID\r\nexport function getCurrentUserId(): string | null {\r\n  logger.debug(`getCurrentUserId called. ID: ${currentUser?.id}`);\r\n  logger.debug('Full currentUser keys:', Object.keys(currentUser || {}));\r\n  return currentUser?.id as string | null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\AutoModService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_user' is defined but never used.","line":35,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\CredentialsService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":3,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":13}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":7,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":7,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[775,778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[775,778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, safeStorage } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('CredentialsService');\r\n\r\n// electron-store is ESM in v9+, we need to use dynamic import or require\r\n// eslint-disable-next-line @typescript-eslint/no-require-imports\r\nconst Store = require('electron-store');\r\n\r\n// Schema for our stored data\r\ninterface StoredCredentials {\r\n  username: string;\r\n  // Password is encrypted using Electron's safeStorage\r\n  encryptedPassword: string;\r\n  // Auth cookie from VRChat for session restoration\r\n  authCookie?: string;\r\n}\r\n\r\n// Initialize electron-store with encryption\r\n// Using any type since electron-store types are complex with ESM/CJS interop\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst store: any = new Store({\r\n  name: 'group-guard-credentials',\r\n  encryptionKey: 'group-guard-secure-storage-v1', // Additional layer of encryption\r\n  defaults: {\r\n    rememberMe: false\r\n  }\r\n});\r\n\r\n/**\r\n * Save credentials securely\r\n * Uses Electron's safeStorage for password encryption when available\r\n */\r\nexport function saveCredentials(username: string, password: string, authCookie?: string): boolean {\r\n  try {\r\n    let encryptedPassword: string;\r\n    \r\n    // Use safeStorage if available (uses OS keychain/credential manager)\r\n    if (safeStorage.isEncryptionAvailable()) {\r\n      const encrypted = safeStorage.encryptString(password);\r\n      encryptedPassword = encrypted.toString('base64');\r\n    } else {\r\n      // Fallback to base64 (less secure, but electron-store already encrypts)\r\n      encryptedPassword = Buffer.from(password).toString('base64');\r\n      log.warn('safeStorage not available, using fallback encryption');\r\n    }\r\n    \r\n    const credentials: StoredCredentials = {\r\n      username,\r\n      encryptedPassword,\r\n      authCookie\r\n    };\r\n    \r\n    store.set('savedCredentials', credentials);\r\n    store.set('rememberMe', true);\r\n    \r\n    log.info('Credentials saved securely');\r\n    return true;\r\n  } catch (error) {\r\n    log.error('Failed to save credentials:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Load saved credentials\r\n */\r\nexport function loadCredentials(): { username: string; password: string; authCookie?: string } | null {\r\n  try {\r\n    const saved = store.get('savedCredentials') as StoredCredentials | undefined;\r\n    if (!saved) {\r\n      return null;\r\n    }\r\n    \r\n    let password: string;\r\n    \r\n    // Decrypt using safeStorage if available\r\n    if (safeStorage.isEncryptionAvailable()) {\r\n      try {\r\n        const encrypted = Buffer.from(saved.encryptedPassword, 'base64');\r\n        password = safeStorage.decryptString(encrypted);\r\n      } catch {\r\n        // If decryption fails (e.g., different machine), try base64 fallback\r\n        password = Buffer.from(saved.encryptedPassword, 'base64').toString('utf-8');\r\n      }\r\n    } else {\r\n      // Fallback from base64\r\n      password = Buffer.from(saved.encryptedPassword, 'base64').toString('utf-8');\r\n    }\r\n    \r\n    return {\r\n      username: saved.username,\r\n      password,\r\n      authCookie: saved.authCookie\r\n    };\r\n  } catch (error) {\r\n    log.error('Failed to load credentials:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update the auth cookie for saved credentials\r\n */\r\nexport function updateAuthCookie(authCookie: string): boolean {\r\n  try {\r\n    const saved = store.get('savedCredentials') as StoredCredentials | undefined;\r\n    if (!saved) {\r\n      return false;\r\n    }\r\n    \r\n    store.set('savedCredentials', {\r\n      ...saved,\r\n      authCookie\r\n    });\r\n    \r\n    log.info('Auth cookie updated');\r\n    return true;\r\n  } catch (error) {\r\n    log.error('Failed to update auth cookie:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear all saved credentials\r\n */\r\nexport function clearCredentials(): void {\r\n  try {\r\n    store.delete('savedCredentials');\r\n    store.set('rememberMe', false);\r\n    log.info('Credentials cleared');\r\n  } catch (error) {\r\n    log.error('Failed to clear credentials:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Check if credentials are saved\r\n */\r\nexport function hasSavedCredentials(): boolean {\r\n  return store.has('savedCredentials') && store.get('rememberMe', false);\r\n}\r\n\r\n/**\r\n * Get the remember me preference\r\n */\r\nexport function getRememberMe(): boolean {\r\n  return store.get('rememberMe', false);\r\n}\r\n\r\n/**\r\n * Setup IPC handlers for credentials\r\n */\r\nexport function setupCredentialsHandlers() {\r\n  // Check if credentials are saved\r\n  ipcMain.handle('credentials:has-saved', () => {\r\n    return hasSavedCredentials();\r\n  });\r\n  \r\n  // Get remember me state\r\n  ipcMain.handle('credentials:get-remember-me', () => {\r\n    return getRememberMe();\r\n  });\r\n  \r\n  // Save credentials (called after successful login)\r\n  ipcMain.handle('credentials:save', (_event, { username, password, authCookie }: { \r\n    username: string; \r\n    password: string; \r\n    authCookie?: string \r\n  }) => {\r\n    return saveCredentials(username, password, authCookie);\r\n  });\r\n  \r\n  // Clear credentials\r\n  ipcMain.handle('credentials:clear', () => {\r\n    clearCredentials();\r\n    return true;\r\n  });\r\n  \r\n  // Load credentials for auto-login\r\n  ipcMain.handle('credentials:load', () => {\r\n    return loadCredentials();\r\n  });\r\n  \r\n  log.info('Credentials handlers initialized');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\GroupService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1659,1662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1659,1662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2055,2058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2055,2058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":70,"column":45,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":70,"endColumn":79}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('GroupService');\r\nimport { getVRChatClient, getCurrentUserId } from './AuthService';\r\n\r\nexport function setupGroupHandlers() {\r\n\r\n  // Get user's groups (groups where user is a member)\r\n  ipcMain.handle('groups:get-my-groups', async () => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      const userId = getCurrentUserId();\r\n      \r\n      logger.debug('groups:get-my-groups called', { hasClient: !!client, userId });\r\n      \r\n      if (!client || !userId) {\r\n        logger.warn('Auth check failed in GroupService');\r\n        throw new Error(\"Not authenticated. Please log in first.\");\r\n      }\r\n\r\n      logger.info(`Fetching user groups for user ID: \"${userId}\" (type: ${typeof userId})`);\r\n      \r\n      // Sanitize userId\r\n      const safeUserId = userId.trim();\r\n      if (!safeUserId.startsWith('usr_')) {\r\n          logger.error(`Invalid User ID format: ${safeUserId}`);\r\n          throw new Error(`Invalid User ID: ${safeUserId}`);\r\n      }\r\n      \r\n      // Reverting to Object Syntax as positional caused \"malformed url\"\r\n      const response = await client.getUserGroups({ \r\n        path: { userId: safeUserId },\r\n        query: { n: 100, offset: 0 }\r\n      });\r\n\r\n      if (response.error) {\r\n        logger.error('getUserGroups returned error:', response.error);\r\n        throw new Error((response.error as { message?: string }).message || 'Failed to fetch groups');\r\n      }\r\n\r\n      const groups = response.data || [];\r\n      \r\n      // Filter for groups where user has moderation powers\r\n      const moderatableGroups = groups.filter((g: any) => {\r\n        const isOwner = g.ownerId === safeUserId;\r\n        const hasPermissions = g.myMember?.permissions && Array.isArray(g.myMember.permissions) && g.myMember.permissions.length > 0;\r\n        return isOwner || hasPermissions;\r\n      });\r\n\r\n      // map the groups to ensure 'id' is the Group ID (grp_), not the Member ID (gmem_)\r\n      const mappedGroups = moderatableGroups.map((g: any) => {\r\n        // VRChat API getUserGroups returns membership objects.\r\n        // g.id is the Membership ID (gmem_...)\r\n        // g.groupId is the actual Group ID (grp_...)\r\n        // We want the frontend to see 'id' as the Group ID.\r\n        if (g.groupId && typeof g.groupId === 'string' && g.groupId.startsWith('grp_')) {\r\n            return {\r\n                ...g,\r\n                id: g.groupId,      // helper for frontend\r\n                _memberId: g.id     // preserve original membership ID\r\n            };\r\n        }\r\n        return g;\r\n      });\r\n\r\n      logger.info(`Fetched ${groups.length} total groups. Filtered to ${mappedGroups.length} moderatable groups.`);\r\n      \r\n      // Update InstanceLoggerService with allowed groups\r\n      try {\r\n          const { instanceLoggerService } = require('./InstanceLoggerService');\r\n          instanceLoggerService.setAllowedGroups(mappedGroups.map(g => g.id));\r\n      } catch (e) {\r\n          logger.error('Failed to update instance logger allowed groups', e);\r\n      }\r\n\r\n      return { success: true, groups: mappedGroups };\r\n\r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string; response?: { status?: number }; stack?: string; config?: unknown };\r\n      logger.error('Failed to fetch groups:', { message: err.message, stack: err.stack });\r\n      if (err.response?.status === 401) return { success: false, error: 'Session expired. Please log in again.' };\r\n      return { success: false, error: err.message || 'Failed to fetch groups' };\r\n    }\r\n  });\r\n\r\n  // Get specific group details\r\n  ipcMain.handle('groups:get-details', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroup({ path: { groupId } });\r\n      \r\n      if (response.error) throw response.error;\r\n      return { success: true, group: response.data };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch group details:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch group' };\r\n    }\r\n  });\r\n\r\n  // Get world details\r\n  ipcMain.handle('worlds:get-details', async (_event, { worldId }: { worldId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getWorld({ path: { worldId } });\r\n      \r\n      if (response.error) throw response.error;\r\n      return { success: true, world: response.data };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch world details:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch world' };\r\n    }\r\n  });\r\n\r\n  // Get group members\r\n  ipcMain.handle('groups:get-members', async (_event, { groupId, n = 100, offset = 0 }: { groupId: string; n?: number; offset?: number }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupMembers({ \r\n        path: { groupId },\r\n        query: { n, offset }\r\n      });\r\n      \r\n      if (response.error) throw response.error;\r\n      return { success: true, members: response.data ?? [] };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch group members:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch members' };\r\n    }\r\n  });\r\n\r\n  // Helper to extract array from VRChat API response\r\n  // Some endpoints return Array, others return { results: Array } or { instances: Array }\r\n  const extractArray = (data: unknown): unknown[] => {\r\n      if (Array.isArray(data)) return data;\r\n      const obj = data as Record<string, unknown> | null;\r\n      if (obj && Array.isArray(obj.results)) return obj.results;\r\n      if (obj && Array.isArray(obj.instances)) return obj.instances;\r\n      return [];\r\n  };\r\n\r\n  // Get group join requests\r\n  ipcMain.handle('groups:get-requests', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      logger.info(`Fetching requests for group ${groupId}`);\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupRequests({ \r\n          path: { groupId },\r\n          query: { n: 100, offset: 0 }\r\n      });\r\n      \r\n      const requests = extractArray(response.data);\r\n      logger.info(`Requests fetch detected ${requests.length} items for ${groupId}`);\r\n      \r\n      if (response.error) {\r\n        logger.error('API Error in getGroupRequests:', response.error);\r\n        throw response.error;\r\n      }\r\n      return { success: true, requests };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch join requests:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch requests' };\r\n    }\r\n  });\r\n\r\n  // Get group bans\r\n  ipcMain.handle('groups:get-bans', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      logger.info(`Fetching bans for group ${groupId}`);\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n  \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupBans({ \r\n        path: { groupId },\r\n        query: { n: 100, offset: 0 }\r\n      });\r\n      \r\n      const bans = extractArray(response.data);\r\n      logger.info(`Bans fetch detected ${bans.length} items for ${groupId}`);\r\n\r\n      if (response.error) {\r\n         logger.error('API Error in getGroupBans:', response.error);\r\n         throw response.error;\r\n      }\r\n      return { success: true, bans };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch bans:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch bans' };\r\n    }\r\n  });\r\n\r\n  // Get group audit logs\r\n  ipcMain.handle('groups:get-audit-logs', async (_event, { groupId }: { groupId: string }) => {\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n      \r\n      // Revert to Object Syntax\r\n      const response = await client.getGroupAuditLogs({ \r\n          path: { groupId },\r\n          query: { n: 100, offset: 0 }\r\n      });\r\n      \r\n      if (response.error) throw response.error;\r\n      const logs = extractArray(response.data);\r\n      return { success: true, logs };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string };\r\n      logger.error('Failed to fetch audit logs:', error);\r\n      return { success: false, error: err.message || 'Failed to fetch audit logs' };\r\n    }\r\n  });\r\n\r\n  // Get active group instances - using direct HTTP to bypass SDK quirks\r\n  ipcMain.handle('groups:get-instances', async (_event, { groupId }: { groupId: string }) => {\r\n    // Helper to safely stringify objects with BigInt values\r\n    const safeStringify = (obj: unknown): string => {\r\n      try {\r\n        return JSON.stringify(obj, (_key, value) => \r\n          typeof value === 'bigint' ? value.toString() : value\r\n        );\r\n      } catch {\r\n        return String(obj);\r\n      }\r\n    };\r\n\r\n    try {\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n      \r\n      const userId = getCurrentUserId();\r\n      if (!userId) throw new Error(\"No user ID found\");\r\n\r\n      logger.info(`[INSTANCES] Fetching for group: ${groupId}, user: ${userId}`);\r\n\r\n      // Strategy 1: Try the SDK method getUserGroupInstancesForGroup\r\n      let instances: unknown[] = [];\r\n      \r\n      try {\r\n        const clientAny = client as Record<string, unknown>;\r\n        if (typeof clientAny.getUserGroupInstancesForGroup === 'function') {\r\n          logger.info('[INSTANCES] Trying SDK method: getUserGroupInstancesForGroup');\r\n          const response = await (clientAny.getUserGroupInstancesForGroup as CallableFunction)({ \r\n            path: { userId, groupId } \r\n          });\r\n          const data = (response as { data?: unknown })?.data ?? response;\r\n          logger.info('[INSTANCES] SDK Response:', safeStringify(data));\r\n          instances = extractArray(data);\r\n        } else {\r\n          logger.warn('[INSTANCES] SDK method getUserGroupInstancesForGroup not available');\r\n        }\r\n      } catch (e: unknown) {\r\n        const err = e as { message?: string };\r\n        logger.warn('[INSTANCES] SDK getUserGroupInstancesForGroup failed:', err.message);\r\n      }\r\n\r\n      // Strategy 2: Try getUserGroupInstances (all groups) and filter\r\n      if (instances.length === 0) {\r\n        try {\r\n          const clientAny = client as Record<string, unknown>;\r\n          if (typeof clientAny.getUserGroupInstances === 'function') {\r\n            logger.info('[INSTANCES] Trying SDK method: getUserGroupInstances (all groups)');\r\n            const response = await (clientAny.getUserGroupInstances as CallableFunction)({ \r\n              path: { userId } \r\n            });\r\n            const data = (response as { data?: unknown })?.data ?? response;\r\n            const allInstances = extractArray(data);\r\n            logger.info(`[INSTANCES] getUserGroupInstances returned ${allInstances.length} total instances`);\r\n            \r\n            if (allInstances.length > 0) {\r\n              logger.info('[INSTANCES] First instance keys:', Object.keys(allInstances[0] as object));\r\n              logger.info('[INSTANCES] First instance data:', safeStringify(allInstances[0]));\r\n              \r\n              // Try multiple filter strategies\r\n              instances = allInstances.filter((inst: unknown) => {\r\n                const i = inst as Record<string, unknown>;\r\n                const matchGroupId = i.groupId === groupId;\r\n                const matchGroupObj = (i.group as Record<string, unknown>)?.id === groupId;\r\n                const matchOwnerId = String(i.ownerId || '').includes(groupId);\r\n                return matchGroupId || matchGroupObj || matchOwnerId;\r\n              });\r\n              logger.info(`[INSTANCES] After filtering: ${instances.length} instances for this group`);\r\n            }\r\n          }\r\n        } catch (e: unknown) {\r\n          const err = e as { message?: string };\r\n          logger.warn('[INSTANCES] SDK getUserGroupInstances failed:', err.message);\r\n        }\r\n      }\r\n\r\n      // Strategy 3: Use client.get if available  \r\n      if (instances.length === 0) {\r\n        try {\r\n          const clientAny = client as Record<string, unknown>;\r\n          if (typeof clientAny.get === 'function') {\r\n            logger.info('[INSTANCES] Trying client.get fallback');\r\n            \r\n            // Try specific group endpoint first\r\n            const url = `users/${userId}/instances/groups/${groupId}`;\r\n            logger.info('[INSTANCES] Calling:', url);\r\n            const response = await (clientAny.get as CallableFunction)(url);\r\n            const data = (response as { data?: unknown })?.data ?? response;\r\n            logger.info('[INSTANCES] client.get response:', safeStringify(data));\r\n            instances = extractArray(data);\r\n          }\r\n        } catch (e: unknown) {\r\n          const err = e as { message?: string };\r\n          logger.warn('[INSTANCES] client.get failed:', err.message);\r\n        }\r\n      }\r\n\r\n      // Strategy 4: Try the getGroupInstances method (different from user-specific)\r\n      if (instances.length === 0) {\r\n        try {\r\n          const clientAny = client as Record<string, unknown>;\r\n          if (typeof clientAny.getGroupInstances === 'function') {\r\n            logger.info('[INSTANCES] Trying SDK method: getGroupInstances');\r\n            const response = await (clientAny.getGroupInstances as CallableFunction)({ \r\n              path: { groupId } \r\n            });\r\n            const data = (response as { data?: unknown })?.data ?? response;\r\n            logger.info('[INSTANCES] getGroupInstances response:', safeStringify(data));\r\n            instances = extractArray(data);\r\n          }\r\n        } catch (e: unknown) {\r\n          const err = e as { message?: string };\r\n          logger.warn('[INSTANCES] SDK getGroupInstances failed:', err.message);\r\n        }\r\n      }\r\n\r\n      logger.info(`[INSTANCES] Final result: ${instances.length} instances for group ${groupId}`);\r\n      \r\n      if (instances.length > 0) {\r\n        logger.info('[INSTANCES] Sample instance:', safeStringify(instances[0]));\r\n      }\r\n      \r\n      return { success: true, instances };\r\n      \r\n    } catch (error: unknown) {\r\n      const err = error as { message?: string; stack?: string };\r\n      logger.error('[INSTANCES] Fatal error:', err.message);\r\n      logger.error('[INSTANCES] Stack:', err.stack);\r\n      return { success: false, error: err.message || 'Failed to fetch instances' };\r\n    }\r\n  });\r\n\r\n  // Ban a user from a group\r\n  ipcMain.handle('groups:ban-user', async (_event, { groupId, userId }: { groupId: string; userId: string }) => {\r\n    const client = getVRChatClient();\r\n    if (!client) throw new Error(\"Not authenticated\");\r\n\r\n    try {\r\n      logger.info(`[GroupService] Banning user ${userId} from group ${groupId}`);\r\n      \r\n      // Use correct SDK syntax with path and body parameters\r\n      const response = await client.banGroupMember({ \r\n        path: { groupId }, \r\n        body: { userId } \r\n      });\r\n      \r\n      if (response.error) {\r\n        logger.error(`[GroupService] Ban API returned error:`, response.error);\r\n        const errorMessage = (response.error as { message?: string }).message || 'Ban failed';\r\n        return { success: false, error: errorMessage };\r\n      }\r\n      \r\n      logger.info(`[GroupService] Successfully banned user ${userId} from group ${groupId}`);\r\n      return { success: true };\r\n    } catch (e: unknown) {\r\n      const err = e as { message?: string; response?: { data?: { error?: { message?: string } } } };\r\n      logger.error(`[GroupService] Failed to ban user ${userId} from group ${groupId}:`, e);\r\n      const msg = err.response?.data?.error?.message || err.message || 'Unknown error';\r\n      return { success: false, error: msg };\r\n    }\r\n  });\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\InstanceLoggerService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8268,8271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8268,8271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8783,8786],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8783,8786],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\InstanceService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2113,2116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2113,2116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2500,2503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2500,2503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7747,7750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7747,7750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":206,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8032,8035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8032,8035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9632,9635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9632,9635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10040,10043],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10040,10043],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10919,10922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10919,10922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11435,11438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11435,11438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":278,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11724,11727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11724,11727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12451,12454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12451,12454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13465,13468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13465,13468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":323,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13662,13665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13662,13665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":359,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15461,15464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15461,15464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":407,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":407,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17791,17794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17791,17794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":419,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18434,18437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18434,18437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":446,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":446,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19673,19676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19673,19676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":473,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":473,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21014,21017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21014,21017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":494,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22092,22095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22092,22095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":522,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":522,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23342,23345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23342,23345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\LogWatcherService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":4,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { app, ipcMain, BrowserWindow } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('LogWatcher');\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { EventEmitter } from 'events';\r\n\r\n// ============================================\r\n// TYPES\r\n// ============================================\r\n\r\nexport interface LogEvent {\r\n  type: 'player-joined' | 'player-left' | 'location' | 'world-name' | 'destination';\r\n  timestamp: string;\r\n  data: Record<string, string>;\r\n}\r\n\r\nexport interface PlayerJoinedEvent {\r\n  displayName: string;\r\n  userId?: string; \r\n  timestamp: string;\r\n}\r\n\r\nexport interface LocationEvent {\r\n  worldId: string;\r\n  worldName?: string;\r\n  timestamp: string;\r\n}\r\n\r\n// ============================================\r\n// STATE CACHE\r\n// ============================================\r\n\r\ninterface WatcherState {\r\n  currentWorldId: string | null;\r\n  currentWorldName: string | null;\r\n  currentLocation: string | null; // Full location string for proper tracking\r\n  players: Map<string, PlayerJoinedEvent>; // keyed by displayName\r\n}\r\n\r\n// ============================================\r\n// SERVICE\r\n// ============================================\r\n\r\nclass LogWatcherService extends EventEmitter {\r\n  private currentLogPath: string | null = null;\r\n  private currentFileSize = 0;\r\n  private watcherInterval: NodeJS.Timeout | null = null;\r\n  private isWatching = false;\r\n  \r\n  // State for late joiners\r\n  private state: WatcherState = {\r\n    currentWorldId: null,\r\n    currentWorldName: null,\r\n    currentLocation: null,\r\n    players: new Map()\r\n  };\r\n\r\n  /**\r\n   * Start watching. Validates directory, finds latest log, and starts trailing.\r\n   * If callerWindow is provided, syncs current state to it immediately.\r\n   */\r\n  start(callerWindow?: BrowserWindow) {\r\n    // If requested by a specific window, send it the current state immediately\r\n    if (callerWindow && !callerWindow.isDestroyed()) {\r\n        this.emitStateToWindow(callerWindow);\r\n    }\r\n\r\n    if (this.isWatching) {\r\n        log.info('[LogWatcher] Service already running, synced state to requestor.');\r\n        return;\r\n    }\r\n\r\n    this.isWatching = true;\r\n    log.info('[LogWatcher] Starting service...');\r\n    \r\n    this.findLatestLog();\r\n    \r\n    this.watcherInterval = setInterval(() => {\r\n      this.checkLogPath();\r\n      this.readNewContent();\r\n    }, 1000);\r\n  }\r\n\r\n  stop() {\r\n    this.isWatching = false;\r\n    if (this.watcherInterval) {\r\n      clearInterval(this.watcherInterval);\r\n      this.watcherInterval = null;\r\n    }\r\n    log.info('[LogWatcher] Service stopped');\r\n  }\r\n\r\n  private emitStateToWindow(window: BrowserWindow) {\r\n     log.info('[LogWatcher] Syncing state to renderer...');\r\n     const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19).replace(/-/g, '.');\r\n\r\n     if (this.state.currentWorldName) {\r\n         window.webContents.send('log:world-name', { name: this.state.currentWorldName, timestamp });\r\n     }\r\n     if (this.state.currentWorldId) {\r\n         window.webContents.send('log:location', { worldId: this.state.currentWorldId, timestamp });\r\n     }\r\n     \r\n     // Send all known players\r\n     for (const player of this.state.players.values()) {\r\n         window.webContents.send('log:player-joined', player);\r\n     }\r\n  }\r\n\r\n  private getLogDirectory(): string {\r\n    const appData = app.getPath('appData');\r\n    const localLow = path.join(appData, '..', 'LocalLow');\r\n    return path.join(localLow, 'VRChat', 'VRChat');\r\n  }\r\n\r\n  private findLatestLog() {\r\n    try {\r\n      const logDir = this.getLogDirectory();\r\n      if (!fs.existsSync(logDir)) {\r\n        log.warn(`[LogWatcher] VRChat log directory not found: ${logDir}`);\r\n        return;\r\n      }\r\n\r\n      const files = fs.readdirSync(logDir)\r\n        .filter(f => f.startsWith('output_log_') && f.endsWith('.txt'))\r\n        .map(f => {\r\n          const fullPath = path.join(logDir, f);\r\n          return {\r\n            name: f,\r\n            path: fullPath,\r\n            stat: fs.statSync(fullPath)\r\n          };\r\n        })\r\n        .sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());\r\n\r\n      if (files.length > 0) {\r\n        const latest = files[0];\r\n        if (latest.path !== this.currentLogPath) {\r\n          log.info(`[LogWatcher] Found new log file: ${latest.name}`);\r\n          this.currentLogPath = latest.path;\r\n          // Always read from 0 on new file detection to build state\r\n          this.currentFileSize = 0; \r\n          // Reset state for new log (new session)\r\n          this.state = { currentWorldId: null, currentWorldName: null, currentLocation: null, players: new Map() };\r\n        }\r\n      }\r\n    } catch (error) {\r\n      log.error('[LogWatcher] Error searching for logs:', error);\r\n    }\r\n  }\r\n\r\n  private checkLogPath() {\r\n    this.findLatestLog();\r\n  }\r\n\r\n  private readNewContent() {\r\n    if (!this.currentLogPath) return;\r\n\r\n    try {\r\n      if (!fs.existsSync(this.currentLogPath)) return;\r\n\r\n      const stat = fs.statSync(this.currentLogPath);\r\n      if (stat.size > this.currentFileSize) {\r\n        const stream = fs.createReadStream(this.currentLogPath, {\r\n          start: this.currentFileSize,\r\n          end: stat.size\r\n        });\r\n\r\n        let buffer = '';\r\n        stream.on('data', (chunk) => { buffer += chunk.toString(); });\r\n\r\n        stream.on('end', () => {\r\n          this.currentFileSize = stat.size;\r\n          const lines = buffer.split('\\n');\r\n          for (const line of lines) {\r\n            if (line.trim()) this.parseLine(line.trim());\r\n          }\r\n        });\r\n      }\r\n    } catch (err) {\r\n      log.error('[LogWatcher] Error reading log:', err);\r\n    }\r\n  }\r\n\r\n  private parseLine(line: string) {\r\n    // Timestamp check: yyyy.MM.dd HH:mm:ss\r\n    const timestamp = line.substring(0, 19);\r\n    \r\n    // Regex Definitions (based on FCH / VRCX)\r\n    // 1. Joining World: \"Joining wrld_...\"\r\n    // Matches \"Joining wrld_ID:instanceId~tag(val)...\"\r\n    // Use non-greedy for instance ID until next space or end of line?\r\n    // Actually, VRChat log lines look like: \"[Always] Joining wrld_xxx:12345~group(grp_xxx)\"\r\n    const reJoining = /Joining\\s+(wrld_[a-zA-Z0-9-]+):([^\\s]+)/;\r\n\r\n    // 2. Player Joined: \"OnPlayerJoined Name (usr_...)\" - handles prefixes\r\n    const rePlayerJoined = /OnPlayerJoined\\s+(?:\\[[^\\]]+\\]\\s*)?([^\\r\\n(]+?)\\s*\\((usr_[a-f0-9-]{36})\\)/;\r\n    // 3. Player Left: \"OnPlayerLeft Name (usr_...)\"\r\n    const rePlayerLeft = /OnPlayerLeft\\s+([^\\r\\n(]+?)\\s*\\((usr_[a-f0-9-]{36})\\)/;\r\n    // 4. Entering Room (World Name) - usually has [Behaviour]\r\n    const reEntering = /\\[Behaviour\\] Entering Room: (.+)/;\r\n\r\n    // 5. Avatar Change\r\n    const reAvatar = /\\[Avatar\\] Loading Avatar:\\s+(avtr_[a-f0-9-]{36})/;\r\n\r\n    // ...\r\n\r\n    // 1. World Location (Joining wrld_...)\r\n    const joinMatch = line.match(reJoining);\r\n    if (joinMatch) {\r\n         const worldId = joinMatch[1];\r\n        const fullInstanceString = joinMatch[2]; // Includes tags like 12345~group(...)\r\n        // IMPORTANT: Use the FULL instance string for API calls (includes ~group, ~region, etc.)\r\n        // The API needs this to identify group instances for permissions\r\n        const instanceId = fullInstanceString; // Keep the full string!\r\n        const location = `${worldId}:${fullInstanceString}`;\r\n        \r\n        log.info(`[LogWatcher] MATCH Joining: ${location}`);\r\n        \r\n        // CRITICAL: Check if FULL LOCATION changed (not just worldId!)\r\n        // This ensures we track instance changes even within the same world\r\n        if (this.state.currentLocation !== location) {\r\n            log.info(`[LogWatcher] Location CHANGED from ${this.state.currentLocation} to ${location}`);\r\n            \r\n            // Clear players only if world changed (same world, different instance = keep players briefly)\r\n            if (this.state.currentWorldId !== worldId) {\r\n                this.state.players.clear();\r\n            }\r\n            \r\n            this.state.currentWorldId = worldId;\r\n            this.state.currentLocation = location;\r\n            \r\n            // Emit full location info - instanceId now includes all tags\r\n            this.emitToRenderer('log:location', { worldId, instanceId, location, timestamp });\r\n            this.emit('location', { worldId, instanceId, location, timestamp });\r\n        }\r\n    }\r\n\r\n    // 5. Avatar Change\r\n    const avatarMatch = line.match(reAvatar);\r\n    if (avatarMatch) {\r\n       const avatarId = avatarMatch[1];\r\n       log.info(`[LogWatcher] MATCH Avatar: ${avatarId}`);\r\n       this.emitToRenderer('log:avatar', { avatarId, timestamp });\r\n       this.emit('avatar', { avatarId, timestamp });\r\n    }\r\n\r\n    // 2. World Name (Entering Room: ...)\r\n    const enterMatch = line.match(reEntering);\r\n    if (enterMatch) {\r\n        const worldName = enterMatch[1].trim();\r\n        log.info(`[LogWatcher] MATCH Entering Room: ${worldName}`);\r\n        this.state.currentWorldName = worldName;\r\n        this.emitToRenderer('log:world-name', { name: worldName, timestamp });\r\n        this.emit('world-name', { name: worldName, timestamp });\r\n    }\r\n\r\n    // 3. Player Joined\r\n    const playerJoinMatch = line.match(rePlayerJoined);\r\n    if (playerJoinMatch) {\r\n        const displayName = playerJoinMatch[1].trim();\r\n        const userId = playerJoinMatch[2];\r\n        \r\n        log.info(`[LogWatcher] MATCH Player Joined: ${displayName} (${userId})`);\r\n        \r\n        const playerEvent: PlayerJoinedEvent = { displayName, userId, timestamp };\r\n        this.state.players.set(displayName, playerEvent);\r\n        this.emitToRenderer('log:player-joined', playerEvent);\r\n        this.emit('player-joined', playerEvent);\r\n    }\r\n\r\n    // 4. Player Left\r\n    const playerLeftMatch = line.match(rePlayerLeft);\r\n    if (playerLeftMatch) {\r\n        const displayName = playerLeftMatch[1].trim();\r\n        const userId = playerLeftMatch[2];\r\n        \r\n        log.info(`[LogWatcher] MATCH Player Left: ${displayName} (${userId})`);\r\n        \r\n        this.state.players.delete(displayName);\r\n        this.emitToRenderer('log:player-left', { displayName, userId, timestamp });\r\n        this.emit('player-left', { displayName, userId, timestamp });\r\n    }\r\n  }\r\n\r\n  private emitToRenderer(channel: string, data: unknown) {\r\n    const windows = BrowserWindow.getAllWindows();\r\n    for (const win of windows) {\r\n      if (!win.isDestroyed()) {\r\n        win.webContents.send(channel, data);\r\n      }\r\n    }\r\n  }\r\n  public getPlayers(): PlayerJoinedEvent[] {\r\n      return Array.from(this.state.players.values());\r\n  }\r\n}\r\n\r\nexport const logWatcherService = new LogWatcherService();\r\n\r\nexport function setupLogWatcherHandlers() {\r\n  ipcMain.handle('log-watcher:start', (event) => {\r\n    // Pass the sender window so we can sync state specifically to it\r\n    const win = BrowserWindow.fromWebContents(event.sender);\r\n    logWatcherService.start(win || undefined);\r\n    return { success: true };\r\n  });\r\n\r\n  ipcMain.handle('log-watcher:stop', () => {\r\n    logWatcherService.stop();\r\n    return { success: true };\r\n  });\r\n  \r\n  // Removed global auto-start to ensure we sync on request\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\PipelineService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":17,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * VRChat Pipeline WebSocket Service\r\n * \r\n * Connects to VRChat's real-time WebSocket API for live event streaming.\r\n * Based on: https://vrchat.community/websocket\r\n * Reference: VRCX implementation (reference repos/VRCX/src/service/websocket.js)\r\n * \r\n * Events supported:\r\n * - Notifications (invites, friend requests)\r\n * - Friend status changes (online, offline, location)\r\n * - User updates (current user profile changes)\r\n * - Group events (member updates, role changes, join/leave)\r\n */\r\n\r\nimport { ipcMain, BrowserWindow } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('PipelineService');\r\nimport WebSocket from 'ws';\r\nimport { getVRChatClient, isAuthenticated } from './AuthService';\r\n\r\n// ============================================\r\n// CONSTANTS\r\n// ============================================\r\n\r\nconst PIPELINE_URL = 'wss://pipeline.vrchat.cloud';\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst MAX_RECONNECT_ATTEMPTS = 10;\r\n\r\n// ============================================\r\n// STATE\r\n// ============================================\r\n\r\nlet webSocket: WebSocket | null = null;\r\nlet reconnectAttempts = 0;\r\nlet reconnectTimeout: ReturnType<typeof setTimeout> | null = null;\r\nlet lastMessageData = '';\r\nlet isConnecting = false;\r\nlet isManualDisconnect = false;\r\n\r\n// ============================================\r\n// TYPES\r\n// ============================================\r\n\r\n/** Pipeline event types from VRChat WebSocket API */\r\nexport type PipelineEventType =\r\n  // Notification Events\r\n  | 'notification'\r\n  | 'notification-v2'\r\n  | 'notification-v2-update'\r\n  | 'notification-v2-delete'\r\n  | 'see-notification'\r\n  | 'hide-notification'\r\n  | 'response-notification'\r\n  | 'clear-notification'\r\n  // Friend Events\r\n  | 'friend-add'\r\n  | 'friend-delete'\r\n  | 'friend-online'\r\n  | 'friend-active'\r\n  | 'friend-offline'\r\n  | 'friend-update'\r\n  | 'friend-location'\r\n  // User Events\r\n  | 'user-update'\r\n  | 'user-location'\r\n  | 'user-badge-assigned'\r\n  | 'user-badge-unassigned'\r\n  | 'content-refresh'\r\n  // Group Events\r\n  | 'group-joined'\r\n  | 'group-left'\r\n  | 'group-member-updated'\r\n  | 'group-role-updated';\r\n\r\ninterface PipelineMessage {\r\n  type: PipelineEventType;\r\n  content: unknown;\r\n  err?: string;\r\n}\r\n\r\ninterface PipelineEvent {\r\n  type: PipelineEventType;\r\n  content: Record<string, unknown>;\r\n  timestamp: string;\r\n}\r\n\r\n// ============================================\r\n// AUTH TOKEN FETCHING\r\n// ============================================\r\n\r\n/**\r\n * Fetches the auth token required for WebSocket connection.\r\n * VRChat requires a call to GET /auth to retrieve the WebSocket token.\r\n */\r\nasync function fetchAuthToken(): Promise<string | null> {\r\n  try {\r\n    const client = getVRChatClient();\r\n    if (!client) {\r\n      log.warn('[Pipeline] No VRChat client available for auth token fetch');\r\n      return null;\r\n    }\r\n\r\n    // The VRChat SDK should have a method to get auth info\r\n    // Looking at VRCX, they call: request('auth', { method: 'GET' })\r\n    // which returns { ok: true, token: \"authcookie_...\" }\r\n    \r\n    // Try using the SDK's internal methods\r\n    const clientAny = client as Record<string, unknown>;\r\n    \r\n    // Strategy 1: Try getAuth if available\r\n    if (typeof clientAny.getAuth === 'function') {\r\n      log.debug('[Pipeline] Using getAuth method');\r\n      const response = await (clientAny.getAuth as () => Promise<{ data?: { ok?: boolean; token?: string } }>)();\r\n      const data = response?.data;\r\n      if (data?.ok && data?.token) {\r\n        log.info('[Pipeline] Got auth token via getAuth');\r\n        return data.token;\r\n      }\r\n    }\r\n\r\n    // Strategy 2: Try direct API call if client supports it\r\n    if (typeof clientAny.get === 'function') {\r\n      log.debug('[Pipeline] Using client.get for auth endpoint');\r\n      const response = await (clientAny.get as (path: string) => Promise<{ data?: { ok?: boolean; token?: string } }>)('auth');\r\n      const data = response?.data;\r\n      if (data?.ok && data?.token) {\r\n        log.info('[Pipeline] Got auth token via client.get');\r\n        return data.token;\r\n      }\r\n    }\r\n\r\n    // Strategy 3: Try to extract from the client's cookie jar\r\n    // The auth token for WebSocket is the same as the auth cookie value\r\n    if (clientAny.jar || clientAny.cookieJar) {\r\n      log.debug('[Pipeline] Attempting to extract token from cookie jar');\r\n      const jar = (clientAny.jar || clientAny.cookieJar) as { \r\n        getCookiesSync?: (url: string) => Array<{ key?: string; name?: string; value?: string }>;\r\n        _jar?: { getCookiesSync?: (url: string) => Array<{ key?: string; name?: string; value?: string }> };\r\n      };\r\n      \r\n      let cookies: Array<{ key?: string; name?: string; value?: string }> = [];\r\n      \r\n      if (typeof jar.getCookiesSync === 'function') {\r\n        cookies = jar.getCookiesSync('https://api.vrchat.cloud');\r\n      } else if (jar._jar && typeof jar._jar.getCookiesSync === 'function') {\r\n        cookies = jar._jar.getCookiesSync('https://api.vrchat.cloud');\r\n      }\r\n      \r\n      const authCookie = cookies.find(c => (c.key || c.name) === 'auth');\r\n      if (authCookie?.value) {\r\n        // The token format is \"authcookie_...\" which is the cookie value\r\n        log.info('[Pipeline] Got auth token from cookie jar');\r\n        return `authcookie_${authCookie.value}`;\r\n      }\r\n    }\r\n\r\n    // Strategy 4: Manual fetch using node-fetch or similar\r\n    // This is a fallback - we make a direct HTTP request to the auth endpoint\r\n    log.debug('[Pipeline] Fallback: Making direct HTTP request to /auth');\r\n    \r\n    // Get cookies from the client to include in the request\r\n    // This requires the client to expose its cookie handling\r\n    \r\n    log.warn('[Pipeline] Could not obtain auth token - all strategies exhausted');\r\n    return null;\r\n\r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string };\r\n    log.error('[Pipeline] Failed to fetch auth token:', err.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// WEBSOCKET CONNECTION\r\n// ============================================\r\n\r\n/**\r\n * Connects to the VRChat Pipeline WebSocket.\r\n */\r\nasync function connectWebSocket(): Promise<boolean> {\r\n  if (webSocket !== null || isConnecting) {\r\n    log.debug('[Pipeline] Already connected or connecting');\r\n    return false;\r\n  }\r\n\r\n  if (!isAuthenticated()) {\r\n    log.warn('[Pipeline] Cannot connect - not authenticated');\r\n    return false;\r\n  }\r\n\r\n  isConnecting = true;\r\n  isManualDisconnect = false;\r\n\r\n  try {\r\n    const token = await fetchAuthToken();\r\n    \r\n    if (!token) {\r\n      log.error('[Pipeline] Cannot connect - no auth token available');\r\n      isConnecting = false;\r\n      return false;\r\n    }\r\n\r\n    const url = `${PIPELINE_URL}/?authToken=${token}`;\r\n    log.info('[Pipeline] Connecting to VRChat Pipeline WebSocket...');\r\n\r\n    const socket = new WebSocket(url, {\r\n      headers: {\r\n        'User-Agent': 'VRChatGroupGuard/1.0.0 (admin@groupguard.app)'\r\n      }\r\n    });\r\n\r\n    socket.onopen = () => {\r\n      log.info('[Pipeline] WebSocket connected successfully');\r\n      isConnecting = false;\r\n      reconnectAttempts = 0;\r\n      webSocket = socket;\r\n      \r\n      // Notify renderer that pipeline is connected\r\n      emitToRenderer('pipeline:connected', { connected: true });\r\n    };\r\n\r\n    socket.onclose = (event: WebSocket.CloseEvent) => {\r\n      log.info(`[Pipeline] WebSocket closed: code=${event.code}, reason=${event.reason}`);\r\n      \r\n      if (webSocket === socket) {\r\n        webSocket = null;\r\n      }\r\n      \r\n      isConnecting = false;\r\n      \r\n      // Notify renderer\r\n      emitToRenderer('pipeline:disconnected', { \r\n        code: event.code, \r\n        reason: event.reason,\r\n        willReconnect: !isManualDisconnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS\r\n      });\r\n\r\n      // Auto-reconnect if not manually disconnected\r\n      if (!isManualDisconnect && isAuthenticated()) {\r\n        scheduleReconnect();\r\n      }\r\n    };\r\n\r\n    socket.onerror = (error: WebSocket.ErrorEvent) => {\r\n      log.error('[Pipeline] WebSocket error:', error.message || 'Unknown error');\r\n      emitToRenderer('pipeline:error', { message: error.message || 'WebSocket error' });\r\n    };\r\n\r\n    socket.onmessage = (event: WebSocket.MessageEvent) => {\r\n      try {\r\n        handleMessage(event.data.toString());\r\n      } catch (err: unknown) {\r\n        const error = err as { message?: string };\r\n        log.error('[Pipeline] Error handling message:', error.message);\r\n      }\r\n    };\r\n\r\n    return true;\r\n\r\n  } catch (error: unknown) {\r\n    const err = error as { message?: string };\r\n    log.error('[Pipeline] Connection error:', err.message);\r\n    isConnecting = false;\r\n    scheduleReconnect();\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Schedules a reconnection attempt with exponential backoff.\r\n */\r\nfunction scheduleReconnect(): void {\r\n  if (reconnectTimeout !== null) {\r\n    clearTimeout(reconnectTimeout);\r\n  }\r\n\r\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\r\n    log.warn('[Pipeline] Max reconnect attempts reached, giving up');\r\n    emitToRenderer('pipeline:reconnect-failed', { \r\n      attempts: reconnectAttempts \r\n    });\r\n    return;\r\n  }\r\n\r\n  reconnectAttempts++;\r\n  const delay = RECONNECT_DELAY_MS * Math.min(reconnectAttempts, 5); // Cap at 25s\r\n  \r\n  log.info(`[Pipeline] Scheduling reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\r\n  \r\n  reconnectTimeout = setTimeout(() => {\r\n    reconnectTimeout = null;\r\n    if (isAuthenticated() && !webSocket && !isConnecting && !isManualDisconnect) {\r\n      connectWebSocket();\r\n    }\r\n  }, delay);\r\n}\r\n\r\n/**\r\n * Disconnects the WebSocket.\r\n */\r\nfunction disconnectWebSocket(): void {\r\n  isManualDisconnect = true;\r\n  \r\n  if (reconnectTimeout !== null) {\r\n    clearTimeout(reconnectTimeout);\r\n    reconnectTimeout = null;\r\n  }\r\n\r\n  if (webSocket !== null) {\r\n    log.info('[Pipeline] Disconnecting WebSocket...');\r\n    try {\r\n      webSocket.close(1000, 'Manual disconnect');\r\n    } catch (err) {\r\n      log.warn('[Pipeline] Error closing WebSocket:', err);\r\n    }\r\n    webSocket = null;\r\n  }\r\n  \r\n  reconnectAttempts = 0;\r\n  isConnecting = false;\r\n}\r\n\r\n// ============================================\r\n// MESSAGE HANDLING\r\n// ============================================\r\n\r\n/**\r\n * Handles incoming WebSocket messages.\r\n */\r\nfunction handleMessage(data: string): void {\r\n  // Dedupe identical messages (VRChat sometimes sends duplicates)\r\n  if (lastMessageData === data) {\r\n    return;\r\n  }\r\n  lastMessageData = data;\r\n\r\n  let message: PipelineMessage;\r\n  \r\n  try {\r\n    message = JSON.parse(data);\r\n    \r\n    // VRChat double-encodes content as a JSON string\r\n    if (typeof message.content === 'string') {\r\n      try {\r\n        message.content = JSON.parse(message.content);\r\n      } catch {\r\n        // Content is not JSON, keep as string\r\n      }\r\n    }\r\n  } catch {\r\n    log.warn('[Pipeline] Failed to parse message:', data.substring(0, 100));\r\n    return;\r\n  }\r\n\r\n  // Handle errors from the pipeline\r\n  if (message.err) {\r\n    log.error('[Pipeline] Server error:', message.err);\r\n    emitToRenderer('pipeline:server-error', { error: message.err });\r\n    return;\r\n  }\r\n\r\n  // Log the event\r\n  log.debug(`[Pipeline] Event: ${message.type}`, JSON.stringify(message.content).substring(0, 200));\r\n\r\n  // Create a standardized event\r\n  const event: PipelineEvent = {\r\n    type: message.type,\r\n    content: message.content as Record<string, unknown>,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Emit to renderer\r\n  emitToRenderer('pipeline:event', event);\r\n\r\n  // Handle specific event types that may need additional processing\r\n  handleSpecificEvent(event);\r\n}\r\n\r\n/**\r\n * Handles specific event types that may need server-side processing.\r\n */\r\nfunction handleSpecificEvent(event: PipelineEvent): void {\r\n  switch (event.type) {\r\n    case 'group-member-updated':\r\n      log.info('[Pipeline] Group member updated:', event.content);\r\n      break;\r\n      \r\n    case 'group-role-updated':\r\n      log.info('[Pipeline] Group role updated:', event.content);\r\n      break;\r\n      \r\n    case 'group-joined':\r\n    case 'group-left':\r\n      log.info(`[Pipeline] Group ${event.type}:`, event.content);\r\n      break;\r\n\r\n    case 'notification':\r\n    case 'notification-v2':\r\n      log.info('[Pipeline] Notification received:', event.content);\r\n      break;\r\n\r\n    case 'friend-online':\r\n    case 'friend-offline':\r\n    case 'friend-location':\r\n      log.debug(`[Pipeline] Friend ${event.type}:`, event.content);\r\n      break;\r\n\r\n    case 'user-update':\r\n      log.info('[Pipeline] Current user updated:', event.content);\r\n      break;\r\n\r\n    default:\r\n      // Other events are just forwarded to renderer\r\n      break;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// IPC BRIDGE\r\n// ============================================\r\n\r\n/**\r\n * Emits an event to all renderer windows.\r\n */\r\nfunction emitToRenderer(channel: string, data: unknown): void {\r\n  const windows = BrowserWindow.getAllWindows();\r\n  for (const window of windows) {\r\n    if (!window.isDestroyed()) {\r\n      window.webContents.send(channel, data);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sets up IPC handlers for the Pipeline service.\r\n */\r\nexport function setupPipelineHandlers(): void {\r\n  // Connect to pipeline\r\n  ipcMain.handle('pipeline:connect', async () => {\r\n    log.info('[Pipeline] Connect requested');\r\n    const success = await connectWebSocket();\r\n    return { success, connected: webSocket !== null };\r\n  });\r\n\r\n  // Disconnect from pipeline\r\n  ipcMain.handle('pipeline:disconnect', () => {\r\n    log.info('[Pipeline] Disconnect requested');\r\n    disconnectWebSocket();\r\n    return { success: true };\r\n  });\r\n\r\n  // Get connection status\r\n  ipcMain.handle('pipeline:status', () => {\r\n    return {\r\n      connected: webSocket !== null && webSocket.readyState === WebSocket.OPEN,\r\n      connecting: isConnecting,\r\n      reconnectAttempts\r\n    };\r\n  });\r\n\r\n  // Force reconnect\r\n  ipcMain.handle('pipeline:reconnect', async () => {\r\n    log.info('[Pipeline] Reconnect requested');\r\n    disconnectWebSocket();\r\n    isManualDisconnect = false;\r\n    reconnectAttempts = 0;\r\n    const success = await connectWebSocket();\r\n    return { success };\r\n  });\r\n}\r\n\r\n// ============================================\r\n// LIFECYCLE\r\n// ============================================\r\n\r\n/**\r\n * Call this when the user logs in to auto-connect to the pipeline.\r\n */\r\nexport function onUserLoggedIn(): void {\r\n  log.info('[Pipeline] User logged in, connecting to pipeline...');\r\n  // Small delay to ensure auth is fully set up\r\n  setTimeout(() => {\r\n    connectWebSocket();\r\n  }, 1000);\r\n}\r\n\r\n/**\r\n * Call this when the user logs out to disconnect from the pipeline.\r\n */\r\nexport function onUserLoggedOut(): void {\r\n  log.info('[Pipeline] User logged out, disconnecting from pipeline');\r\n  disconnectWebSocket();\r\n}\r\n\r\n/**\r\n * Check if the pipeline is currently connected.\r\n */\r\nexport function isPipelineConnected(): boolean {\r\n  return webSocket !== null && webSocket.readyState === WebSocket.OPEN;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\StorageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\electron\\services\\UserService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[288,291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[288,291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1505,1508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1505,1508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from 'electron';\r\nimport log from 'electron-log';\r\nconst logger = log.scope('UserService');\r\nimport { getVRChatClient } from './AuthService';\r\n\r\n// Simple in-memory cache\r\n// Map<userId, { data: UserData, timestamp: number }>\r\nconst userCache = new Map<string, { data: any; timestamp: number }>();\r\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\nexport function setupUserHandlers() {\r\n  \r\n  // Get User Profile\r\n  ipcMain.handle('users:get', async (_event, { userId }: { userId: string }) => {\r\n    try {\r\n      if (!userId) throw new Error(\"User ID is required\");\r\n\r\n      const client = getVRChatClient();\r\n      if (!client) throw new Error(\"Not authenticated\");\r\n\r\n      // Check cache\r\n      const cached = userCache.get(userId);\r\n      if (cached && (Date.now() - cached.timestamp < CACHE_TTL)) {\r\n        logger.debug(`Serving user ${userId} from cache`);\r\n        return { success: true, user: cached.data };\r\n      }\r\n\r\n      log.info(`Fetching user ${userId} from API`);\r\n      // Use Object syntax as verified in GroupService fixes\r\n      const response = await client.getUser({ path: { userId } });\r\n      \r\n      if (response.error) {\r\n          log.error('getUser returned error:', response.error);\r\n          throw response.error;\r\n      }\r\n      \r\n      // Update cache\r\n      if (response.data) {\r\n          userCache.set(userId, { data: response.data, timestamp: Date.now() });\r\n      }\r\n\r\n      return { success: true, user: response.data };\r\n\r\n    } catch (error: any) {\r\n      log.error(`Failed to fetch user ${userId}:`, error);\r\n      return { success: false, error: error.message || 'Failed to fetch user' };\r\n    }\r\n  });\r\n\r\n  // Clear cache for a user (useful if we get an update via WS)\r\n  ipcMain.handle('users:clear-cache', async (_event, { userId }: { userId: string }) => {\r\n      if (userId) {\r\n          userCache.delete(userId);\r\n      } else {\r\n          userCache.clear();\r\n      }\r\n      return { success: true };\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\inspect_lib.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\read_logs.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\src\\lib\\liveViewReady.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\src\\lib\\stores\\apiChecks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\src\\lib\\stores\\debugLog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\src\\lib\\stores\\mediaCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\src\\routes\\+layout.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\svelte.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\FCH-Toolkit-App\\vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\InteropApi.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\download-dotnet-runtime.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\offscreen-preload.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\patch-node-api-dotnet.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\patch-package-version.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\preload.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\rename-builds.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src-electron\\utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\avatar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\avatarModeration.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\favorite.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\friend.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\group.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\image.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\instance.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\inventory.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\inviteMessages.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\misc.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\notification.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\playerModeration.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\prop.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\user.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\vrcPlusIcon.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\vrcPlusImage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\api\\world.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\app.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\ipc-electron\\interopApi.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\localization\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\components.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\dayjs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\i18n.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\interopApi.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\noty.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\router.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\sentry.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\plugin\\ui.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\appConfig.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\confusables.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\avatarFavorites.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\feed.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\friendLogCurrent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\friendLogHistory.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\gameLog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\memos.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\moderation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\mutualGraph.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\notifications.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\tableAlter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\tableFixes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\tableSize.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\database\\worldFavorites.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\gamelog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\jsonStorage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\request.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\security.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\sqlite.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\watchState.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\webapi.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\service\\websocket.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\discord.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\emoji.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\feedFilters.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\group.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\instance.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\language.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\link.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\moderation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\ossLicenses.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\photon.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\settings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\themes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\ui.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\user.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\constants\\world.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\__tests__\\compare.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\__tests__\\friend.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\__tests__\\gallery.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\__tests__\\location.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\_utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\avatar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\__tests__\\array.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\__tests__\\format.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\__tests__\\string.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\array.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\date.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\devtool.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\format.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\string.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\base\\ui.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\chart.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\common.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\compare.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\friend.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\gallery.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\group.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\imageUpload.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\instance.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\invite.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\localizationHelperCLI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\location.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\memos.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\retry.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\setting.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\throttle.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\user.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\shared\\utils\\world.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\avatar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\avatarProvider.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\charts.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\favorite.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\feed.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\friend.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\gallery.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\game.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\gameLog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\group.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\instance.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\invite.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\launch.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\location.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\moderation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\notification.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\photon.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\search.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\settings\\advanced.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\settings\\appearance.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\settings\\discordPresence.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\settings\\general.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\settings\\notifications.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\settings\\wristOverlay.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\sharedFeed.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\ui.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\updateLoop.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\user.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\vr.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\vrcStatus.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\vrcx.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\vrcxUpdater.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\stores\\world.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\auth.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[102,105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[102,105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[222,225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[222,225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[346,349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[346,349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1162,1165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1162,1165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2074,2077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2074,2077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Exported API functions\r\nexport type VerifyOTP = (params: { code: string }) => Promise<{\r\n    json: any;\r\n    params: { code: string };\r\n}>;\r\n\r\nexport type VerifyTOTP = (params: { code: string }) => Promise<{\r\n    json: any;\r\n    params: { code: string };\r\n}>;\r\n\r\nexport type VerifyEmailOTP = (params: { code: string }) => Promise<{\r\n    json: any;\r\n    params: { code: string };\r\n}>;\r\n\r\nexport type GetConfig = () => Promise<{\r\n    json: ConfigResponse;\r\n}>;\r\n\r\n// Exported interfaces\r\nexport interface ConfigResponse {\r\n    CampaignStatus: string;\r\n    DisableBackgroundPreloads: boolean;\r\n    VoiceEnableDegradation: boolean;\r\n    VoiceEnableReceiverLimiting: boolean;\r\n    accessLogsUrls: {\r\n        Default: string;\r\n        Pico: string;\r\n        Quest: string;\r\n        XRElite: string;\r\n    };\r\n    activeDatagramUdpQueue: number;\r\n    address: string;\r\n    ageVerificationInviteVisible: boolean;\r\n    ageVerificationP: boolean;\r\n    ageVerificationStatusVisible: boolean;\r\n    analysisMaxRetries: number;\r\n    analysisRetryInterval: number;\r\n    analyticsSegment_NewUI_PctOfUsers: number;\r\n    analyticsSegment_NewUI_Salt: string;\r\n    announcements: any[];\r\n    availableLanguageCodes: string[];\r\n    availableLanguages: string[];\r\n    avatarPerfLimiter: {\r\n        AndroidMobile: { maxSeats: number };\r\n        PC: { maxSeats: number };\r\n        Pico: { maxSeats: number };\r\n        Quest: { maxSeats: number };\r\n        XRElite: { maxSeats: number };\r\n        iOSMobile: { maxSeats: number };\r\n    };\r\n    behaviourFormat: number;\r\n    bodyHistoryCommunityRelaadventureInternal: number;\r\n    cdnIpv6WhereOauth: string;\r\n    chatboxLogBufferSeconds: number;\r\n    clientApiKey: string;\r\n    clientBPSCeiling: number;\r\n    clientDisconnectTimeout: number;\r\n    clientNetDispatchThread: boolean;\r\n    clientNetDispatchThreadMobile: boolean;\r\n    clientQR: number;\r\n    clientReservedPlayerBPS: number;\r\n    clientSentCountAllowance: number;\r\n    commitHookResponseHeadFeed: {\r\n        alignmentDisplayVideo: number;\r\n        timeoutFarClothRotationTracker: null | any;\r\n    };\r\n    constants: {\r\n        GROUPS: {\r\n            CAPACITY: number;\r\n            GROUP_TRANSFER_REQUIREMENTS: string[];\r\n            MAX_INVITES_REQUESTS: number;\r\n            MAX_JOINED: number;\r\n            MAX_JOINED_PLUS: number;\r\n            MAX_LANGUAGES: number;\r\n            MAX_LINKS: number;\r\n            MAX_MANAGEMENT_ROLES: number;\r\n            MAX_OWNED: number;\r\n            MAX_ROLES: number;\r\n        };\r\n        INSTANCE: {\r\n            POPULATION_BRACKETS: {\r\n                CROWDED: { max: number; min: number };\r\n                FEW: { max: number; min: number };\r\n                MANY: { max: number; min: number };\r\n            };\r\n        };\r\n        LANGUAGE: {\r\n            SPOKEN_LANGUAGE_OPTIONS: {\r\n                [key: string]: string;\r\n            };\r\n        };\r\n    };\r\n    contactEmail: string;\r\n    copyrightEmail: string;\r\n    copyrightFormUrl: string;\r\n    currentPrivacyVersion: number;\r\n    currentTOSVersion: number;\r\n    daemonSignatureHeadpatChumpOffline: boolean;\r\n    defaultAvatar: string;\r\n    defaultStickerSet: string;\r\n    devLanguageCodes: string[];\r\n    devSdkUrl: string;\r\n    devSdkVersion: string;\r\n    'dis-countdown': string;\r\n    disableAVProInProton: boolean;\r\n    disableAvatarCopying: boolean;\r\n    disableAvatarGating: boolean;\r\n    disableCaptcha: boolean;\r\n    disableCommunityLabs: boolean;\r\n    disableCommunityLabsPromotion: boolean;\r\n    disableEmail: boolean;\r\n    disableEventStream: boolean;\r\n    disableFeedbackGating: boolean;\r\n    disableFrontendBuilds: boolean;\r\n    disableGiftDrops: boolean;\r\n    disableHello: boolean;\r\n    disableOculusSubs: boolean;\r\n    disableRegistration: boolean;\r\n    disableSteamNetworking: boolean;\r\n    disableTwoFactorAuth: boolean;\r\n    disableUdon: boolean;\r\n    disableUpgradeAccount: boolean;\r\n    downloadLinkWindows: string;\r\n    downloadUrls: {\r\n        bootstrap: string;\r\n        sdk2: string;\r\n        'sdk3-avatars': string;\r\n        'sdk3-worlds': string;\r\n        vcc: string;\r\n    };\r\n    dynamicWorldRows: Array<{\r\n        index: number;\r\n        name: string;\r\n        platform: string;\r\n        sortHeading: string;\r\n        sortOrder: string;\r\n        sortOwnership: string;\r\n        tag?: string;\r\n    }>;\r\n    economyLedgerBackfill: boolean;\r\n    economyLedgerMode: string;\r\n    economyPauseEnd: string;\r\n    economyPauseStart: string;\r\n    economyState: number;\r\n    events: {\r\n        distanceClose: number;\r\n        distanceFactor: number;\r\n        distanceFar: number;\r\n        groupDistance: number;\r\n        maximumBunchSize: number;\r\n        notVisibleFactor: number;\r\n        playerOrderBucketSize: number;\r\n        playerOrderFactor: number;\r\n        slowUpdateFactorThreshold: number;\r\n        useDirectPlayerSerialization: boolean;\r\n        viewSegmentLength: number;\r\n    };\r\n    forceUseLatestWorld: boolean;\r\n    giftDisplayType: string;\r\n    globalCacheVersion: number;\r\n    globalCacheVersionDefault: number;\r\n    googleApiClientId: string;\r\n    homeWorldId: string;\r\n    homepageRedirectTarget: string;\r\n    hubWorldId: string;\r\n    imageHostUrlList: string[];\r\n    iosAppVersion: string[];\r\n    iosVersion: {\r\n        major: number;\r\n        minor: number;\r\n    };\r\n    jobsEmail: string;\r\n    localizationDeploymentRollback: number;\r\n    managerDynamicSendKernel: number;\r\n    maxUserEmoji: number;\r\n    maxUserStickers: number;\r\n    minSupportedClientBuildNumber: {\r\n        AppStore: MinBuildInfo;\r\n        Default: { minBuildNumber: number };\r\n        Firebase: MinBuildInfo;\r\n        FirebaseiOS: MinBuildInfo;\r\n        GooglePlay: MinBuildInfo;\r\n        PC: MinBuildInfo;\r\n        PicoStore: MinBuildInfo;\r\n        QuestAppLab: MinBuildInfo;\r\n        QuestStore: MinBuildInfo;\r\n        TestFlight: MinBuildInfo;\r\n        XRElite: MinBuildInfo;\r\n    };\r\n    minimumUnityVersionForUploads: string;\r\n    moderationEmail: string;\r\n    moderationTimestampToolboxSoap: number;\r\n    multigrainTokenThrottleEmbed: number;\r\n    ninkilim: boolean;\r\n    notAllowedToSelectAvatarInPrivateWorldMessage: string;\r\n    offlineAnalysis: {\r\n        android: boolean;\r\n        standalonewindows: boolean;\r\n    };\r\n    onlyFpsStringGraphContent: string;\r\n    photonNameserverOverrides: string[];\r\n    photonPublicKeys: string[];\r\n    'player-url-resolver-sha1': string;\r\n    'player-url-resolver-version': string;\r\n    pluginSamlSandwich: boolean;\r\n    propComponentList: string[];\r\n    publicKey: string;\r\n    questMinimumLowMemoryThreshold: {\r\n        [key: string]: number;\r\n    };\r\n    reportCategories: {\r\n        [key: string]: {\r\n            description?: string;\r\n            groupOrder?: number;\r\n            text: string;\r\n            title?: string;\r\n            tooltip: string;\r\n        };\r\n    };\r\n    reportFormUrl: string;\r\n    reportOptions: {\r\n        [key: string]: {\r\n            [key: string]: string[];\r\n        };\r\n    };\r\n    reportReasons: {\r\n        [key: string]: {\r\n            text: string;\r\n            tooltip: string;\r\n        };\r\n    };\r\n    requireAgeVerificationBetaTag: boolean;\r\n    scrollAppend: boolean;\r\n    sdkDeveloperFaqUrl: string;\r\n    sdkDiscordUrl: string;\r\n    sdkNotAllowedToPublishMessage: string;\r\n    sdkUnityVersion: string;\r\n    sessionEthernetPlusStack: number;\r\n    stringHostUrlList: string[];\r\n    supportEmail: string;\r\n    supportFormUrl: string;\r\n    timeOutWorldId: string;\r\n    timekeeping: boolean;\r\n    timestampTagging: boolean;\r\n    tutorialWorldId: string;\r\n    updateRateMsMaximum: number;\r\n    updateRateMsMinimum: number;\r\n    updateRateMsNormal: number;\r\n    updateRateMsUdonManual: number;\r\n    uploadAnalysisPercent: number;\r\n    urlList: string[];\r\n    useReliableUdpForVoice: boolean;\r\n    use_void_requiem_core: boolean;\r\n    virtualFriendDocs: string;\r\n    viveWindowsUrl: string;\r\n    websocketMaxFriendsRefreshDelay: number;\r\n    websocketQuickReconnectTime: number;\r\n    websocketReconnectMaxDelay: number;\r\n    whiteListedAssetUrls: string[];\r\n}\r\n\r\n// Internal response types\r\ninterface MinBuildInfo {\r\n    minBuildNumber: number;\r\n    redirectionAddress?: string;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\avatar.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[591,594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[591,594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[609,612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[609,612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1071,1074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1071,1074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1089,1092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1089,1092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAvatar } from '../common';\r\n\r\n// Exported API functions\r\nexport type GetAvatar = (params: { avatarId: string }) => Promise<{\r\n    json: GetAvatarResponse;\r\n    params: { avatarId: string };\r\n}>;\r\n\r\nexport type GetAvatars = (params: {\r\n    n: number;\r\n    offset: number;\r\n    search?: string;\r\n    userId?: string;\r\n    user?: 'me' | 'friends';\r\n    sort?: 'created' | 'updated' | 'order' | '_created_at' | '_updated_at';\r\n    order?: 'ascending' | 'descending';\r\n    releaseStatus?: 'public' | 'private' | 'hidden' | 'all';\r\n    featured?: boolean;\r\n}) => Promise<{\r\n    json: any;\r\n    params: any;\r\n}>;\r\n\r\n// Internal response types\r\ninterface GetAvatarResponse extends BaseAvatar {\r\n    // Avatar-specific additional fields\r\n    performance: {\r\n        standalonewindows: string;\r\n        'standalonewindows-sort': number;\r\n    };\r\n}\r\n\r\nexport type SaveAvatar = (params: {\r\n    id: string;\r\n    releaseStatus?: 'public' | 'private';\r\n    name?: string;\r\n    description?: string;\r\n    imageUrl?: string;\r\n    tags?: string[];\r\n}) => Promise<{\r\n    json: any;\r\n    params: any;\r\n}>;\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\favorite.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1701,1704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1701,1704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1948,1951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1948,1951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1974,1977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1974,1977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAvatar, BaseWorld } from '../common';\r\n\r\n// API functions\r\nexport type GetFavorites = (params: { n: number; offset: number }) => Promise<{\r\n    json: GetFavoritesResponseList;\r\n    params: { n: number; offset: number };\r\n}>;\r\n\r\nexport type GetFavoriteAvatars = (params: {\r\n    n: number;\r\n    offset: number;\r\n    tag: string;\r\n}) => Promise<{\r\n    json: GetFavoriteAvatarsResponseList;\r\n    params: { n: number; offset: number; tag: string };\r\n}>;\r\n\r\nexport type GetFavoriteWorlds = (params: {\r\n    n: number;\r\n    offset: number;\r\n    userId?: string;\r\n    tag?: string;\r\n}) => Promise<{\r\n    json: GetFavoriteWorldsResponseList;\r\n    params: {\r\n        n: number;\r\n        offset: number;\r\n        userId?: string;\r\n        tag?: string;\r\n    };\r\n}>;\r\n\r\nexport type AddFavorite = (params: {\r\n    type: string;\r\n    favoriteId: string;\r\n    tags: string;\r\n}) => Promise<{\r\n    json: AddFavoriteResponse;\r\n    params: {\r\n        type: string;\r\n        favoriteId: string;\r\n        tags: string;\r\n    };\r\n}>;\r\n\r\n// Type aliases\r\nexport type GetFavoritesResponseList = GetFavoritesResponseItem[] | undefined;\r\nexport type GetFavoriteAvatarsResponseList = GetFavoriteAvatarsResponseItem[];\r\nexport type GetFavoriteWorldsResponseList = GetFavoriteWorldsResponseItem[];\r\n\r\n// API response types\r\ninterface GetFavoritesResponseItem {\r\n    favoriteId: string;\r\n    id: string;\r\n    tags: string[];\r\n    type: string;\r\n}\r\n\r\ninterface GetFavoriteAvatarsResponseItem extends BaseAvatar {\r\n    // Favorite avatar specific fields\r\n    favoriteGroup: string;\r\n    favoriteId: string;\r\n    styles: {\r\n        primary: null;\r\n        secondary: null;\r\n    };\r\n    unityPackageUrlObject: Record<string, any>;\r\n}\r\n\r\ninterface GetFavoriteWorldsResponseItem extends BaseWorld {\r\n    // Favorite world specific fields\r\n    occupants?: number;\r\n    visits: number;\r\n    version: number;\r\n    urlList: string[];\r\n    defaultContentSettings: Record<string, any>;\r\n    [key: string]: any;\r\n}\r\n\r\ninterface AddFavoriteResponse {\r\n    favoriteId: string;\r\n    id: string;\r\n    type: 'world' | 'friend' | 'avatar';\r\n    tags: string[];\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\friend.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[363,366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[363,366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[496,499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[496,499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[622,625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[622,625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[869,872],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[869,872],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[921,924],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[921,924],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[939,942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[939,942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Exported API functions\r\nexport type GetFriends = (params: {\r\n    n: number;\r\n    offline: boolean;\r\n    offset: number;\r\n}) => Promise<{\r\n    json: GetFriendsResponseList;\r\n    params: {\r\n        n: number;\r\n        offline: boolean;\r\n        offset: number;\r\n    };\r\n}>;\r\n\r\nexport type SendFriendRequest = (params: { userId: string }) => Promise<{\r\n    json: any;\r\n    params: { userId: string };\r\n}>;\r\n\r\nexport type CancelFriendRequest = (params: { userId: string }) => Promise<{\r\n    json: any;\r\n    params: { userId: string };\r\n}>;\r\n\r\nexport type DeleteFriend = (params: { userId: string }) => Promise<{\r\n    json: any;\r\n    params: { userId: string };\r\n}>;\r\n\r\nexport type GetFriendStatus = (params: { userId: string }) => Promise<{\r\n    json: FriendStatusResponse;\r\n    params: { userId: string };\r\n}>;\r\n\r\nexport type DeleteHiddenFriendRequest = (\r\n    params: any,\r\n    userId: string\r\n) => Promise<{\r\n    json: any;\r\n    params: any;\r\n    userId: string;\r\n}>;\r\n\r\n// Exported interfaces\r\nexport interface FriendStatusResponse {\r\n    isFriend: boolean;\r\n    outgoingRequest: boolean;\r\n    incomingRequest: boolean;\r\n}\r\n\r\n// Type aliases\r\ntype GetFriendsResponseList = GetFriendsResponseItem[] | undefined;\r\n\r\n// Internal response types\r\ninterface GetFriendsResponseItem {\r\n    bio: string;\r\n    bioLinks: string[];\r\n    currentAvatarImageUrl: string;\r\n    currentAvatarTags: string[];\r\n    currentAvatarThumbnailImageUrl: string;\r\n    developerType: string;\r\n    displayName: string;\r\n    friendKey: string;\r\n    id: string;\r\n    imageUrl: string;\r\n    isFriend: boolean;\r\n    last_activity: string;\r\n    last_login: string;\r\n    last_mobile: string | null;\r\n    last_platform: string;\r\n    location: string;\r\n    platform: string;\r\n    profilePicOverride: string;\r\n    profilePicOverrideThumbnail: string;\r\n    status: string;\r\n    statusDescription: string;\r\n    tags: string[];\r\n    userIcon: string;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\group.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[579,582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[579,582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[727,730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[727,730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[882,885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[882,885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// API functions\r\nexport type GetGroup = (params: {\r\n    groupId: string;\r\n    includeRoles?: boolean;\r\n}) => Promise<{\r\n    json: GetGroupResponse;\r\n    params: { groupId: string; includeRoles?: boolean };\r\n}>;\r\n\r\nexport type GetCalendars = (params: {\r\n    date: string;\r\n}) => Promise<CalendarResponse>;\r\n\r\nexport type GetFollowingCalendars = (params: {\r\n    date: string;\r\n}) => Promise<CalendarResponse>;\r\n\r\nexport type GetFeaturedCalendars = (params: {\r\n    date: string;\r\n}) => Promise<CalendarResponse>;\r\n\r\n// API response types\r\ninterface GetGroupResponse {\r\n    badges: any[];\r\n    bannerId: string;\r\n    bannerUrl: string;\r\n    createdAt: string;\r\n    description: string;\r\n    discriminator: string;\r\n    galleries: any[];\r\n    iconId: string;\r\n    iconUrl: string;\r\n    id: string;\r\n    isVerified: boolean;\r\n    joinState: string;\r\n    languages: string[];\r\n    links: any[];\r\n    memberCount: number;\r\n    memberCountSyncedAt: string;\r\n    membershipStatus: string;\r\n    name: string;\r\n    onlineMemberCount: number;\r\n    // groupId\r\n    ownerId: string;\r\n    privacy: string;\r\n    rules: string;\r\n    shortCode: string;\r\n    tags: string[];\r\n}\r\n\r\n// Exported interfaces\r\n\r\n/**\r\n * Group calendar event object\r\n */\r\nexport interface GroupCalendarEvent {\r\n    accessType: 'public' | 'group' | string;\r\n    category: 'hangout' | 'education' | 'roleplaying' | string;\r\n    closeInstanceAfterEndMinutes: number;\r\n    createdAt: string;\r\n    deletedAt: string | null;\r\n    description: string;\r\n    endsAt: string;\r\n    featured: boolean;\r\n    guestEarlyJoinMinutes: number;\r\n    hostEarlyJoinMinutes: number;\r\n    id: string;\r\n    imageId: string | null;\r\n    imageUrl?: string;\r\n    interestedUserCount: number;\r\n    isDraft: boolean;\r\n    languages: string[];\r\n    ownerId: string;\r\n    platforms: string[];\r\n    roleIds: string[] | null;\r\n    startsAt: string;\r\n    tags: string[];\r\n    title: string;\r\n    type: 'event' | string;\r\n    updatedAt: string;\r\n    userInterest?: GroupCalendarUserInterest;\r\n    usesInstanceOverflow: boolean;\r\n}\r\n\r\n// Internal response types\r\ninterface CalendarResponse {\r\n    hasNext: boolean;\r\n    results: GroupCalendarEvent[];\r\n    totalCount: number;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\instance.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[532,535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[532,535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[550,553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[550,553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1096,1099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1096,1099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1974,1977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1974,1977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1998,2001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1998,2001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseWorld } from '../common';\r\n\r\n// Exported API functions\r\nexport type GetInstance = (params: {\r\n    worldId: string;\r\n    instanceId: string;\r\n}) => Promise<{\r\n    json: GetInstanceResponse;\r\n    ref: GetInstanceResponse;\r\n    params: { worldId: string; instanceId: string };\r\n}>;\r\n\r\nexport type CreateInstance = (params: {\r\n    worldId: string;\r\n    type: string;\r\n    region: string;\r\n    ownerId: string;\r\n    roleIds?: string[];\r\n    groupAccessType?: string;\r\n    queueEnabled?: boolean;\r\n}) => Promise<{\r\n    json: any;\r\n    params: any;\r\n}>;\r\n\r\nexport type GetInstanceShortName = (instance: {\r\n    worldId: string;\r\n    instanceId: string;\r\n    shortName?: string;\r\n}) => Promise<{\r\n    json: GetInstanceShortNameResponse;\r\n    instance: { worldId: string; instanceId: string };\r\n    params?: { shortName: string };\r\n}>;\r\n\r\n// Internal response types\r\ninterface GetInstanceResponse {\r\n    active: boolean;\r\n    ageGate: boolean;\r\n    canRequestInvite: boolean;\r\n    capacity: number;\r\n    clientNumber: string;\r\n    closedAt: string | null;\r\n    contentSettings: Record<string, any>;\r\n    displayName: string | null;\r\n    full: boolean;\r\n    gameServerVersion: number;\r\n    hardClose: string | null;\r\n    hasCapacityForYou: boolean;\r\n    hidden: string;\r\n    id: string;\r\n    instanceId: string;\r\n    instancePersistenceEnabled: boolean | null;\r\n    location: string;\r\n    n_users: number;\r\n    name: string;\r\n    ownerId: string;\r\n    permanent: boolean;\r\n    photonRegion: string;\r\n    platforms: {\r\n        android: number;\r\n        ios: number;\r\n        standalonewindows: number;\r\n    };\r\n    playerPersistenceEnabled: boolean;\r\n    queueEnabled: boolean;\r\n    queueSize: number;\r\n    recommendedCapacity: number;\r\n    region: string;\r\n    secureName: string;\r\n    shortName: string | null;\r\n    strict: boolean;\r\n    tags: string[];\r\n    type: string;\r\n    userCount: number;\r\n    world: BaseWorld & {\r\n        defaultContentSettings: Record<string, any>;\r\n        urlList: any[];\r\n        version: number;\r\n        visits: number;\r\n    };\r\n    worldId: string;\r\n}\r\n\r\ninterface GetInstanceShortNameResponse {\r\n    secureName: string;\r\n    shortName: string;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\notification.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[251,254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[251,254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[417,420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[417,420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[598,601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[598,601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[828,831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[828,831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1033,1036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1033,1036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1103,1106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1103,1106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Exported API functions\r\nexport type GetNotifications = (params: {\r\n    n: number;\r\n    offset: number;\r\n    sent: boolean;\r\n    type: string;\r\n    after: 'five_minutes_ago' | string;\r\n}) => Promise<{\r\n    json: NotificationResponse[];\r\n    params: any;\r\n}>;\r\n\r\nexport type GetHiddenFriendRequests = (params: {\r\n    n?: number;\r\n    offset?: number;\r\n}) => Promise<{\r\n    json: NotificationResponse[];\r\n    params: any;\r\n}>;\r\n\r\nexport type GetNotificationsV2 = (params: {\r\n    n?: number;\r\n    offset?: number;\r\n    type?: string;\r\n}) => Promise<{\r\n    json: NotificationResponse[];\r\n    params: any;\r\n}>;\r\n\r\nexport type SendNotification = (params: {\r\n    receiverUserId: string;\r\n    type: string;\r\n    message: string;\r\n    seen: boolean;\r\n    details: string;\r\n}) => Promise<{\r\n    json: NotificationResponse;\r\n    params: any;\r\n}>;\r\n\r\n// Exported interfaces\r\nexport interface NotificationResponse {\r\n    id: string;\r\n    type: string;\r\n    senderUserId: string;\r\n    receiverUserId: string;\r\n    message: string;\r\n    details: any;\r\n    seen: boolean;\r\n    created_at: string;\r\n    [key: string]: any;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\user.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[240,243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[240,243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[814,817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[814,817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":40,"column":16,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":40,"endColumn":18,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[1043,1045],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[1043,1045],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":81,"column":21,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":81,"endColumn":23,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[2144,2146],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[2144,2146],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2708,2711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2708,2711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Exported API functions\r\nexport type GetUser = (params: { userId: string }) => Promise<{\r\n    cache?: boolean;\r\n    json: GetUserResponse;\r\n    ref: VrcxUser;\r\n    params: { userId: string };\r\n}>;\r\n\r\nexport type GetCurrentUser = (params: any) => Promise<{\r\n    json: GetCurrentUserResponse;\r\n    ref: VrcxCurrentUser;\r\n    params: GetCurrentUserResponse;\r\n}>;\r\n\r\nexport type GetCachedUser = (params: { userId: string }) => Promise<{\r\n    cache?: boolean;\r\n    json: GetUserResponse;\r\n    ref: VrcxUser;\r\n    params: { userId: string };\r\n}>;\r\n\r\nexport type GetUsers = (params: {\r\n    n: number;\r\n    offset: number;\r\n    search?: string;\r\n    sort?: 'nuisanceFactor' | 'created' | '_created_at' | 'last_login';\r\n    order?: 'ascending' | 'descending';\r\n}) => Promise<{\r\n    json: UserSearchResponse;\r\n    params: any;\r\n}>;\r\n\r\nexport type AddUserTags = (params: string[]) => Promise<{\r\n    json: GetCurrentUserResponse;\r\n    params: string[];\r\n}>;\r\n\r\n// Exported interfaces\r\nexport interface VrcxUser extends GetUserResponse {\r\n    $location: {};\r\n    $location_at: number;\r\n    $online_for: number;\r\n    $travelingToTime: number;\r\n    $offline_for: number;\r\n    $active_for: number;\r\n    $isVRCPlus: boolean;\r\n    $isModerator: boolean;\r\n    $isTroll: boolean;\r\n    $isProbableTroll: boolean;\r\n    $trustLevel: string;\r\n    $trustClass: string;\r\n    $userColour: string;\r\n    $trustSortNum: number;\r\n    $languages: string[];\r\n    $joinCount: number;\r\n    $timeSpent: number;\r\n    $lastSeen: string;\r\n    $mutualCount: number;\r\n    $nickName: string;\r\n    $previousLocation: string;\r\n    $customTag: string;\r\n    $customTagColour: string;\r\n    $friendNumber: number;\r\n    $lastFetch: number;\r\n    $moderations: moderations;\r\n}\r\n\r\nexport interface moderations {\r\n    isBlocked: boolean;\r\n    isMuted: boolean;\r\n    isAvatarInteractionDisabled: boolean;\r\n    isChatBoxMuted: boolean;\r\n}\r\n\r\nexport interface VrcxCurrentUser extends GetCurrentUserResponse {\r\n    $online_for?: number;\r\n    $offline_for?: number | null;\r\n    $location_at?: number;\r\n    $travelingToTime?: number;\r\n    $previousAvatarSwapTime?: number | null;\r\n    $homeLocation?: {};\r\n    $isVRCPlus?: boolean;\r\n    $isModerator?: boolean;\r\n    $isTroll?: boolean;\r\n    $isProbableTroll?: boolean;\r\n    $trustLevel?: string;\r\n    $trustClass?: string;\r\n    $userColour?: string;\r\n    $trustSortNum?: number;\r\n    $languages?: string[];\r\n    $locationTag?: string;\r\n    $travelingToLocation?: string;\r\n}\r\n\r\n// Type aliases\r\ntype UserSearchResponse = UserSearchResponseItem[];\r\n\r\n// Internal response types\r\ninterface UserSearchResponseItem {\r\n    bio: string;\r\n    bioLinks: string[];\r\n    currentAvatarImageUrl: string;\r\n    currentAvatarTags: any[];\r\n    currentAvatarThumbnailImageUrl: string;\r\n    developerType: string;\r\n    displayName: string;\r\n    id: string;\r\n    isFriend: boolean;\r\n    last_platform: string;\r\n    profilePicOverride: string;\r\n    pronouns?: string;\r\n    status: string;\r\n    statusDescription: string;\r\n    tags: string[];\r\n    userIcon: string;\r\n}\r\n\r\ninterface GetUserResponse {\r\n    ageVerificationStatus: string;\r\n    ageVerified: boolean;\r\n    allowAvatarCopying: boolean;\r\n    badges: {\r\n        badgeDescription: string;\r\n        badgeId: string;\r\n        badgeImageUrl: string;\r\n        badgeName: string;\r\n        showcased: boolean;\r\n    }[];\r\n    bio: string;\r\n    bioLinks: string[];\r\n    currentAvatarImageUrl: string;\r\n    currentAvatarTags: string[];\r\n    currentAvatarThumbnailImageUrl: string;\r\n    date_joined: string;\r\n    developerType: string;\r\n    displayName: string;\r\n    friendKey: string;\r\n    friendRequestStatus?: string;\r\n    id: string;\r\n    instanceId?: string;\r\n    isFriend: boolean;\r\n    last_activity: string;\r\n    last_login: string;\r\n    last_mobile: string | null;\r\n    last_platform: string;\r\n    location?: string;\r\n    note?: string;\r\n    platform?: string;\r\n    profilePicOverride: string;\r\n    profilePicOverrideThumbnail: string;\r\n    pronouns: string;\r\n    state: string;\r\n    status: string;\r\n    statusDescription: string;\r\n    tags: string[];\r\n    travelingToInstance?: string;\r\n    travelingToLocation?: string;\r\n    travelingToWorld?: string;\r\n    userIcon: string;\r\n    worldId?: string;\r\n}\r\n\r\ninterface GetCurrentUserResponse extends GetUserResponse {\r\n    acceptedPrivacyVersion: number;\r\n    acceptedTOSVersion: number;\r\n    accountDeletionDate: string | null;\r\n    accountDeletionLog: string | null;\r\n    activeFriends: string[];\r\n    currentAvatar: string;\r\n    emailVerified: boolean;\r\n    fallbackAvatar: string;\r\n    friendGroupNames: string[];\r\n    friends: string[];\r\n    googleId: string;\r\n    hasBirthday: boolean;\r\n    hasEmail: boolean;\r\n    hasLoggedInFromClient: boolean;\r\n    hasPendingEmail: boolean;\r\n    hideContentFilterSettings: boolean;\r\n    homeLocation: string;\r\n    isAdult: boolean;\r\n    isBoopingEnabled: boolean;\r\n    obfuscatedEmail: string;\r\n    obfuscatedPendingEmail: string;\r\n    oculusId: string;\r\n    offlineFriends: string[];\r\n    onlineFriends: string[];\r\n    pastDisplayNames: { displayName: string; updated_at: string }[];\r\n    picoId: string;\r\n    presence?: {\r\n        avatarThumbnail: string;\r\n        currentAvatarTags: string;\r\n        debugflag: string;\r\n        displayName: string;\r\n        groups: string[];\r\n        id: string;\r\n        instance: string;\r\n        instanceType: string;\r\n        platform: string;\r\n        profilePicOverride: string;\r\n        status: string;\r\n        travelingToInstance: string;\r\n        travelingToWorld: string;\r\n        userIcon: string;\r\n        world: string;\r\n    };\r\n    queuedInstance: string | null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\api\\world.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[165,168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[165,168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[323,326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[323,326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1194,1197],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1194,1197],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2008,2011],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2008,2011],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2120,2123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2120,2123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2280,2283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2280,2283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseWorld } from '../common';\r\n\r\n// API functions\r\nexport type GetWorld = (params: { worldId: string }) => Promise<{\r\n    json: GetWorldResponse;\r\n    ref: any;\r\n    params: { worldId: string };\r\n}>;\r\n\r\nexport type GetCachedWorld = (params: { worldId: string }) => Promise<{\r\n    json: GetWorldResponse;\r\n    ref: any;\r\n    cache?: boolean;\r\n    params: { worldId: string };\r\n}>;\r\n\r\nexport type GetWorlds = (\r\n    params: {\r\n        n: number;\r\n        offset: number;\r\n        search?: string;\r\n        userId?: string;\r\n        user?: 'me' | 'friend';\r\n        sort?:\r\n            | 'popularity'\r\n            | 'heat'\r\n            | 'trust'\r\n            | 'shuffle'\r\n            | 'favorites'\r\n            | 'reportScore'\r\n            | 'reportCount'\r\n            | 'publicationDate'\r\n            | 'labsPublicationDate'\r\n            | 'created'\r\n            | '_created_at'\r\n            | 'updated'\r\n            | '_updated_at'\r\n            | 'order';\r\n        order?: 'ascending' | 'descending';\r\n        releaseStatus?: 'public' | 'private' | 'hidden' | 'all';\r\n        featured?: boolean;\r\n    },\r\n    option?: string\r\n) => Promise<{\r\n    json: WorldSearchResponse;\r\n    params: any;\r\n    option?: string;\r\n}>;\r\n\r\nexport type SaveWorld = (params: {\r\n    id: string;\r\n    name?: string;\r\n    description?: string;\r\n    imageUrl?: string;\r\n    capacity?: number;\r\n    recommendedCapacity?: number;\r\n    previewYoutubeId?: string;\r\n    urlList?: string[];\r\n    tags?: string[];\r\n}) => Promise<{\r\n    json: SaveWorldResponse;\r\n    params: {\r\n        id: string;\r\n        name?: string;\r\n        description?: string;\r\n        capacity?: number;\r\n        recommendedCapacity?: number;\r\n        previewYoutubeId?: string;\r\n    };\r\n}>;\r\n\r\n// Type aliases\r\ntype WorldSearchResponse = WorldSearchResponseItem[];\r\n\r\n// Internal response types\r\ninterface WorldSearchResponseItem extends BaseWorld {\r\n    // World search specific fields\r\n    occupants: number;\r\n    defaultContentSettings: Record<string, any>;\r\n}\r\n\r\ninterface GetWorldResponse extends BaseWorld {\r\n    // World detail specific fields\r\n    instances: any[];\r\n    occupants: number;\r\n    privateOccupants: number;\r\n    publicOccupants: number;\r\n    defaultContentSettings: Record<string, unknown>;\r\n    urlList: any[];\r\n    version: number;\r\n    visits: number;\r\n}\r\n\r\ninterface SaveWorldResponse extends BaseWorld {\r\n    description: string;\r\n    featured: boolean;\r\n    pendingUpload: boolean;\r\n    tags: string[];\r\n    thumbnailImageUrl: string;\r\n    imageUrl: string;\r\n    name: string;\r\n    authorId: string;\r\n    authorName: string;\r\n    id: string;\r\n    updated_at: string;\r\n    urlList: string[];\r\n    version: number;\r\n    visits: number;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\common.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[393,396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[393,396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1628,1631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1628,1631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Common interfaces\r\nexport interface UnityPackage {\r\n    assetVersion: number;\r\n    created_at: string;\r\n    id: string;\r\n    performanceRating?: string;\r\n    platform: string;\r\n    scanStatus?: string;\r\n    unityVersion: string;\r\n    variant: string;\r\n    impostorizerVersion?: string;\r\n    assetUrl: string;\r\n    unitySortNumber?: number;\r\n    worldSignature?: string;\r\n    [key: string]: any;\r\n}\r\n\r\n// Base content types\r\nexport interface BaseContent {\r\n    id: string;\r\n    name: string;\r\n    authorId: string;\r\n    authorName: string;\r\n    description: string;\r\n    imageUrl: string;\r\n    thumbnailImageUrl: string;\r\n    created_at: string;\r\n    updated_at: string;\r\n    releaseStatus: string;\r\n    tags: string[];\r\n    featured: boolean;\r\n    unityPackages: UnityPackage[];\r\n}\r\n\r\n// Base Avatar - core avatar properties\r\nexport interface BaseAvatar extends BaseContent {\r\n    acknowledgements: string | null;\r\n    pendingUpload: boolean;\r\n    performance: {\r\n        [platform: string]: string | number;\r\n    };\r\n    searchable: boolean;\r\n    styles: {\r\n        primary: string | null;\r\n        secondary: string | null;\r\n    };\r\n    unityPackageUrl: string;\r\n    unityPackageUrlObject: {\r\n        unityPackageUrl: string;\r\n    };\r\n    version: number;\r\n}\r\n\r\n// Base World - core world properties\r\nexport interface BaseWorld extends BaseContent {\r\n    capacity: number;\r\n    recommendedCapacity: number;\r\n    favorites: number;\r\n    heat: number;\r\n    popularity: number;\r\n    previewYoutubeId: string | null;\r\n    publicationDate: string;\r\n    labsPublicationDate: string;\r\n    organization: string;\r\n    udonProducts: any[];\r\n}","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\globals.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[182,185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[182,185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[201,204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[201,204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[538,541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[538,541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[559,562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[559,562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[580,583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[580,583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[612,615],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[612,615],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[636,639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[636,639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[666,669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[666,669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[688,691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[688,691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[717,720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[717,720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[806,809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[806,809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[840,843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[840,843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[868,871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[868,871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[898,901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[898,901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1538,1541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1538,1541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1743,1746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1743,1746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1931,1934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1931,1934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1958,1961],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1958,1961],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2045,2048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2045,2048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2941,2944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2941,2944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3188,3191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3188,3191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3259,3262],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3259,3262],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3304,3307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3304,3307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3366,3369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3366,3369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3416,3419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3416,3419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":116,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3886,3889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3886,3889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3932,3935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3932,3935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4156,4159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4156,4159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4401,4404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4401,4404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":131,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4492,4495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4492,4495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8806,8809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8806,8809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":252,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9211,9214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9211,9214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9361,9364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9361,9364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":259,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9493,9496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9493,9496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":375,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13463,13466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13463,13466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":414,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":414,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14766,14769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14766,14769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":36,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference types=\"node\" />\r\n/// <reference types=\"jest\" />\r\n\r\ndeclare global {\r\n    const WINDOWS: boolean;\r\n    const LINUX: boolean;\r\n\r\n    interface Window {\r\n        $pinia: any;\r\n        $vr: any;\r\n        $debug: AppDebug;\r\n        AppApi: AppApi;\r\n        AppApiVr: AppApiVr;\r\n        WebApi: WebApi;\r\n        VRCXStorage: VRCXStorage;\r\n        SQLite: SQLite;\r\n        LogWatcher: LogWatcher;\r\n        Discord: Discord;\r\n        AssetBundleManager: AssetBundleManager;\r\n        webApiService: webApiService;\r\n        request: any;\r\n        utils: any;\r\n        dayjs: any;\r\n        configRepository: any;\r\n        database: any;\r\n        gameLogService: any;\r\n        crypto: any;\r\n        sqliteService: any;\r\n        interopApi: {\r\n            callDotNetMethod: (\r\n                className: any,\r\n                methodName: any,\r\n                args: any\r\n            ) => Promise<any>;\r\n        };\r\n        electron: {\r\n            getArch: () => Promise<string>;\r\n            getClipboardText: () => Promise<string>;\r\n            getNoUpdater: () => Promise<boolean>;\r\n            setTrayIconNotification: (notify: boolean) => Promise<void>;\r\n            openFileDialog: () => Promise<string>;\r\n            openDirectoryDialog: () => Promise<string>;\r\n            desktopNotification: (\r\n                displayName: string,\r\n                body?: string,\r\n                image?: string\r\n            ) => Promise<void>;\r\n            onWindowPositionChanged: (\r\n                Function: (\r\n                    event: any,\r\n                    position: { x: number; y: number }\r\n                ) => void\r\n            ) => void;\r\n            onWindowSizeChanged: (\r\n                Function: (\r\n                    event: any,\r\n                    size: { width: number; height: number }\r\n                ) => void\r\n            ) => void;\r\n            onWindowStateChange: (\r\n                Function: (event: any, state: { windowState: any }) => void\r\n            ) => void;\r\n            onBrowserFocus: (Function: (event: any) => void) => void;\r\n            restartApp: () => Promise<void>;\r\n            getWristOverlayWindow: () => Promise<boolean>;\r\n            getHmdOverlayWindow: () => Promise<boolean>;\r\n            updateVr: (\r\n                active: bool,\r\n                hmdOverlay: bool,\r\n                wristOverlay: bool,\r\n                menuButton: bool,\r\n                overlayHand: int\r\n            ) => Promise<void>;\r\n            ipcRenderer: {\r\n                on(channel: string, func: (...args: unknown[]) => void);\r\n            };\r\n        };\r\n    }\r\n\r\n    interface AppDebug {\r\n        debug: boolean;\r\n        debugWebSocket: boolean;\r\n        debugUserDiff: boolean;\r\n        debugPhotonLogging: boolean;\r\n        debugGameLog: boolean;\r\n        debugWebRequests: boolean;\r\n        debugFriendState: boolean;\r\n        debugIPC: boolean;\r\n        debugVrcPlus: boolean;\r\n        errorNoty: any;\r\n        dontLogMeOut: boolean;\r\n        endpointDomain: string;\r\n        endpointDomainVrchat: string;\r\n        websocketDomain: string;\r\n        websocketDomainVrchat: string;\r\n    }\r\n\r\n    const CefSharp: {\r\n        PostMessage: (message: any) => void;\r\n        BindObjectAsync: (...args: string[]) => Promise<any>;\r\n        BindObject: (name: string) => any;\r\n        ExecuteScriptAsync: (script: string) => Promise<any>;\r\n        ExecuteScript: (script: string) => any;\r\n        RemoveObjectFromCache?: (name: string) => void;\r\n        DeleteBoundObject?: (name: string) => void;\r\n    };\r\n\r\n    const VRCXStorage: {\r\n        Get(key: string): Promise<string>;\r\n        Set(key: string, value: string): Promise<void>;\r\n        Remove(key: string): Promise<void>;\r\n        GetAll(): Promise<string>;\r\n        Flush(): Promise<void>;\r\n        Save(): Promise<void>;\r\n        Load(): Promise<void>;\r\n        GetArray(key: string): Promise<any[]>;\r\n        SetArray(key: string, value: any[]): Promise<void>;\r\n        GetObject(key: string): Promise<object>;\r\n        SetObject(key: string, value: object): Promise<void>;\r\n    };\r\n\r\n    const SQLite: {\r\n        Execute: (sql: string, args: string) => Promise<any[]>;\r\n        ExecuteJson: (sql: string, args: string) => Promise<string>;\r\n        ExecuteNonQuery: (sql: string, args: string) => Promise<number>;\r\n    };\r\n\r\n    const LogWatcher: {\r\n        Get(): Promise<Array<[string, string, string, ...any[]]>>;\r\n        SetDateTill(date: string): Promise<void>;\r\n        GetLogLines(): Array<any>;\r\n        Reset(): Promise<void>;\r\n    };\r\n\r\n    const Discord: {\r\n        SetAssets(\r\n            details: string,\r\n            state: string,\r\n            detailsUrl: string,\r\n            bigIcon: string,\r\n            bigIconText: string,\r\n            smallIcon: string,\r\n            smallIconText: string,\r\n            startTime: number,\r\n            endTime: number,\r\n            partyId: string,\r\n            partySize: number,\r\n            partyMaxSize: number,\r\n            buttonText: string,\r\n            buttonUrl: string,\r\n            appId: string,\r\n            activityType: number,\r\n            statusDisplayType: number\r\n        ): Promise<void>;\r\n        SetActive(active: boolean): Promise<boolean>;\r\n    };\r\n\r\n    const AppApi: {\r\n        // Basic App Functions\r\n        ShowDevTools(): Promise<void>;\r\n        SetVR(\r\n            active: boolean,\r\n            hmdOverlay: boolean,\r\n            wristOverlay: boolean,\r\n            menuButton: boolean,\r\n            overlayHand: number\r\n        ): Promise<void>;\r\n        RefreshVR(): Promise<void>;\r\n        RestartVR(): Promise<void>;\r\n        SetZoom(zoomLevel: number): Promise<void>;\r\n        GetZoom(): Promise<number>;\r\n        DesktopNotification(\r\n            boldText: string,\r\n            text?: string,\r\n            image?: string\r\n        ): Promise<void>;\r\n        RestartApplication(isUpgrade: boolean): Promise<void>;\r\n        CheckForUpdateExe(): Promise<boolean>;\r\n        ExecuteVrFeedFunction(key: string, json: string): Promise<void>;\r\n        ExecuteVrOverlayFunction(key: string, json: string): Promise<void>;\r\n        FocusWindow(): Promise<void>;\r\n        ChangeTheme(value: number): Promise<void>;\r\n        DoFunny(): Promise<void>;\r\n        GetClipboard(): Promise<string>;\r\n        SetStartup(enabled: boolean): Promise<void>;\r\n        CopyImageToClipboard(path: string): Promise<void>;\r\n        FlashWindow(): Promise<void>;\r\n        SetUserAgent(): Promise<void>;\r\n        SetTrayIconNotification(notify: boolean): Promise<void>;\r\n        OpenCalendarFile(icsContent: string): Promise<void>;\r\n\r\n        // Common Functions\r\n        GetColourFromUserID(userId: string): Promise<number>;\r\n        OpenLink(url: string): Promise<void>;\r\n        GetLaunchCommand(): Promise<string>;\r\n        IPCAnnounceStart(): Promise<void>;\r\n        SendIpc(type: string, data: string): Promise<void>;\r\n        CustomCss(): Promise<string>;\r\n        CustomScript(): Promise<string>;\r\n        CurrentCulture(): Promise<string>;\r\n        CurrentLanguage(): Promise<string>;\r\n        GetVersion(): Promise<string>;\r\n        VrcClosedGracefully(): Promise<boolean>;\r\n        GetColourBulk(userIds: string[]): Promise<Record<string, number>>;\r\n        SetAppLauncherSettings(\r\n            enabled: boolean,\r\n            killOnExit: boolean,\r\n            runProcessOnce: boolean\r\n        ): Promise<void>;\r\n        GetFileBase64(path: string): Promise<string | null>;\r\n        TryOpenInstanceInVrc(launchUrl: string): Promise<boolean>;\r\n\r\n        // Image Upload (Cef Only)\r\n        MD5File(blob: string): Promise<string>;\r\n        SignFile(blob: string): Promise<string>;\r\n        FileLength(blob: string): Promise<string>;\r\n\r\n        // Folders\r\n        GetVRChatAppDataLocation(): Promise<string>;\r\n        GetVRChatPhotosLocation(): Promise<string>;\r\n        GetUGCPhotoLocation(path?: string): Promise<string>;\r\n        GetVRChatScreenshotsLocation(): Promise<string>;\r\n        GetVRChatCacheLocation(): Promise<string>;\r\n        OpenVrcxAppDataFolder(): Promise<boolean>;\r\n        OpenVrcAppDataFolder(): Promise<boolean>;\r\n        OpenVrcPhotosFolder(): Promise<boolean>;\r\n        OpenUGCPhotosFolder(ugcPath?: string): Promise<boolean>;\r\n        OpenVrcScreenshotsFolder(): Promise<boolean>;\r\n        OpenCrashVrcCrashDumps(): Promise<boolean>;\r\n        OpenShortcutFolder(): Promise<void>;\r\n        OpenFolderAndSelectItem(\r\n            path: string,\r\n            isFolder?: boolean\r\n        ): Promise<void>;\r\n        OpenFolderSelectorDialog(defaultPath?: string): Promise<string>;\r\n        OpenFileSelectorDialog(\r\n            defaultPath?: string,\r\n            defaultExt?: string,\r\n            defaultFilter?: string\r\n        ): Promise<string>;\r\n\r\n        // Game Handler\r\n        OnProcessStateChanged(monitoredProcess: any): Promise<void>;\r\n        CheckGameRunning(): Promise<void>;\r\n        IsGameRunning(): Promise<boolean>;\r\n        IsSteamVRRunning(): Promise<boolean>;\r\n        QuitGame(): Promise<number>;\r\n        StartGame(arguments: string): Promise<boolean>;\r\n        StartGameFromPath(path: string, arguments: string): Promise<boolean>;\r\n\r\n        // Registry\r\n        GetVRChatRegistryKey(key: string): Promise<any>;\r\n        GetVRChatRegistryKeyString(key: string): Promise<string>;\r\n        SetVRChatRegistryKey(\r\n            key: string,\r\n            value: any,\r\n            typeInt: number\r\n        ): Promise<boolean>;\r\n        GetVRChatRegistry(): Promise<Record<string, Record<string, any>>>;\r\n        SetVRChatRegistry(json: string): Promise<void>;\r\n        HasVRChatRegistryFolder(): Promise<boolean>;\r\n        DeleteVRChatRegistryFolder(): Promise<void>;\r\n        ReadVrcRegJsonFile(filepath: string): Promise<string>;\r\n        GetVRChatRegistryJson: () => Promise<string>;\r\n\r\n        // Image Functions\r\n        PopulateImageHosts(json: string): Promise<void>;\r\n        GetImage(url: string, fileId: string, version: string): Promise<string>;\r\n        ResizeImageToFitLimits(base64data: string): Promise<string>;\r\n        CropAllPrints(ugcFolderPath: string): Promise<void>;\r\n        CropPrintImage(path: string): Promise<boolean>;\r\n        SavePrintToFile(\r\n            url: string,\r\n            ugcFolderPath: string,\r\n            monthFolder: string,\r\n            fileName: string\r\n        ): Promise<string>;\r\n        SaveStickerToFile(\r\n            url: string,\r\n            ugcFolderPath: string,\r\n            monthFolder: string,\r\n            fileName: string\r\n        ): Promise<string>;\r\n        SaveEmojiToFile(\r\n            url: string,\r\n            ugcFolderPath: string,\r\n            monthFolder: string,\r\n            fileName: string\r\n        ): Promise<string>;\r\n\r\n        // Screenshot\r\n        AddScreenshotMetadata(\r\n            path: string,\r\n            metadataString: string,\r\n            worldId: string,\r\n            changeFilename?: boolean\r\n        ): Promise<string>;\r\n        GetExtraScreenshotData(\r\n            path: string,\r\n            carouselCache: boolean\r\n        ): Promise<string>;\r\n        GetScreenshotMetadata(path: string): Promise<string>;\r\n        FindScreenshotsBySearch(\r\n            searchQuery: string,\r\n            searchType?: number\r\n        ): Promise<string>;\r\n        GetLastScreenshot(): Promise<string>;\r\n        DeleteScreenshotMetadata(path: string): Promise<boolean>;\r\n        DeleteAllScreenshotMetadata(): Promise<void>;\r\n\r\n        // Moderations\r\n        GetVRChatModerations(\r\n            currentUserId: string\r\n        ): Promise<Record<string, number> | null>;\r\n        GetVRChatUserModeration(\r\n            currentUserId: string,\r\n            userId: string\r\n        ): Promise<number>;\r\n        SetVRChatUserModeration(\r\n            currentUserId: string,\r\n            userId: string,\r\n            type: number\r\n        ): Promise<boolean>;\r\n\r\n        // VRC Config\r\n        ReadConfigFile(): Promise<string>;\r\n        ReadConfigFileSafe(): Promise<string>;\r\n        WriteConfigFile(json: string): Promise<void>;\r\n\r\n        // Update\r\n        DownloadUpdate(\r\n            fileUrl: string,\r\n            hashString: string,\r\n            downloadSize: number\r\n        ): Promise<void>;\r\n        CancelUpdate(): Promise<void>;\r\n        CheckUpdateProgress(): Promise<number>;\r\n\r\n        // Notifications\r\n        XSNotification(\r\n            title: string,\r\n            content: string,\r\n            timeout: number,\r\n            opacity: number,\r\n            image?: string\r\n        ): Promise<void>;\r\n        OVRTNotification(\r\n            hudNotification: boolean,\r\n            wristNotification: boolean,\r\n            title: string,\r\n            body: string,\r\n            timeout: number,\r\n            opacity: number,\r\n            image?: string\r\n        ): Promise<void>;\r\n    };\r\n\r\n    const AppApiVr: {\r\n        Init(): Promise<void>;\r\n        VrInit(): Promise<void>;\r\n        ToggleSystemMonitor(enabled: boolean): Promise<void>;\r\n        CpuUsage(): Promise<number>;\r\n        GetVRDevices(): Promise<string[][]>;\r\n        GetUptime(): Promise<number>;\r\n        CurrentCulture(): Promise<string>;\r\n        CustomVrScript(): Promise<string>;\r\n        GetExecuteVrFeedFunctionQueue(): Promise<Map<string, string>>;\r\n        GetExecuteVrOverlayFunctionQueue(): Promise<Map<string, string>>;\r\n    };\r\n\r\n    const WebApi: {\r\n        ClearCookies(): Promise<void>;\r\n        GetCookies(): Promise<string>;\r\n        SetCookies(cookie: string): Promise<void>;\r\n        Execute(options: any): Promise<{ Item1: number; Item2: string }>;\r\n        ExecuteJson(requestJson: string): Promise<string>;\r\n    };\r\n\r\n    const AssetBundleManager: {\r\n        SweepCache(): Promise<string>;\r\n        GetCacheSize(): Promise<number>;\r\n        GetVRChatCacheFullLocation(\r\n            fileId: string,\r\n            fileVersion: number,\r\n            variant: string,\r\n            variantVersion: number\r\n        ): Promise<string>;\r\n        CheckVRChatCache(\r\n            fileId: string,\r\n            fileVersion: number,\r\n            variant: string,\r\n            variantVersion: number\r\n        ): Promise<{ Item1: number; Item2: boolean; Item3: string }>;\r\n        DeleteCache(\r\n            fileId: string,\r\n            fileVersion: number,\r\n            variant: string,\r\n            variantVersion: number\r\n        ): Promise<void>;\r\n        DeleteAllCache: () => Promise<void>;\r\n    };\r\n\r\n    const webApiService: {\r\n        clearCookies(): Promise<void>;\r\n        getCookies(): Promise<string>;\r\n        setCookies(cookie: string): Promise<void>;\r\n        execute(options: {\r\n            url: string;\r\n            method?: string;\r\n            uploadFilePUT?: boolean;\r\n            fileData?: string;\r\n            fileMIME?: string;\r\n            headers?: Record<string, string>;\r\n            data?: any;\r\n        }): Promise<{ status: number; data: string }>;\r\n    };\r\n}\r\n\r\nexport {};\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\types\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useActivityDataFilter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useActivityDataProcessor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useActivityStats.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useChartHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useDateNavigation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useInstanceActivityData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useInstanceActivitySettings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useIntersectionObserver.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Charts\\composables\\useMutualGraphChart.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\views\\Favorites\\composables\\useFavoritesCardScaling.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\reference repos\\VRCX\\src\\vr\\vr.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\App.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nF:\\Group Guard scratch\\src\\App.tsx:121:24\n  119 |     // Check roaming mode first\n  120 |     if (isRoamingMode) {\n> 121 |       if (!isLiveMode) setIsLiveMode(true);\n      |                        ^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  122 |       return;\n  123 |     }\n  124 |","line":121,"column":24,"nodeType":null,"endLine":121,"endColumn":37},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nF:\\Group Guard scratch\\src\\App.tsx:210:35\n  208 |   useEffect(() => {\n  209 |     if (isRoamingMode) {\n> 210 |       if (currentView !== 'live') setCurrentView('live');\n      |                                   ^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  211 |     } else if (currentView === 'live' && !selectedGroup) {\n  212 |         // If we exited roaming mode and have no group, go back to main\n  213 |         setCurrentView('main');","line":210,"column":35,"nodeType":null,"endLine":210,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useMemo, useCallback, lazy, Suspense } from 'react';\nimport { AppLayout } from './components/layout/AppLayout';\nimport { TitleBar } from './components/layout/TitleBar';\nimport { GlobalModals } from './components/layout/GlobalModals';\nimport { LoginView } from './features/auth/LoginView';\nimport { useAuthStore } from './stores/authStore';\nimport { useGroupStore } from './stores/groupStore';\nimport { GlassPanel } from './components/ui/GlassPanel';\nimport { motion } from 'framer-motion';\nimport { NeonDock, type DockView } from './components/layout/NeonDock';\nimport { usePipelineInit } from './hooks/usePipelineInit';\nimport { useInstanceMonitorInit } from './hooks/useInstanceMonitorInit';\nimport { SetupView } from './features/setup/SetupView';\n\nimport { AnimatePresence } from 'framer-motion';\nimport { PageTransition } from './components/layout/PageTransition';\n\n// Lazy load heavy views for better performance\nconst DashboardView = lazy(() => import('./features/dashboard/DashboardView').then(m => ({ default: m.DashboardView })));\n\nconst GroupSelectionView = lazy(() => import('./features/groups/GroupSelectionView').then(m => ({ default: m.GroupSelectionView })));\nconst SettingsView = lazy(() => import('./features/settings/SettingsView').then(m => ({ default: m.SettingsView })));\nconst DatabaseView = lazy(() => import('./features/database/DatabaseView').then(m => ({ default: m.DatabaseView })));\nconst AutoModView = lazy(() => import('./features/automod/AutoModView').then(m => ({ default: m.AutoModView })));\nconst LiveView = lazy(() => import('./features/live/LiveView').then(m => ({ default: m.LiveView })));\n\n// Simple loading fallback\nconst ViewLoader = () => (\n  <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%', minHeight: '200px' }}>\n    <div style={{ width: 32, height: 32, border: '3px solid var(--border-color)', borderTopColor: 'var(--color-primary)', borderRadius: '50%', animation: 'spin 1s linear infinite' }} />\n    <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>\n  </div>\n);\n\n// Loading screen component for auto-login\nconst AutoLoginLoadingScreen: React.FC = () => (\n  <div style={{ \n    display: 'flex', \n    justifyContent: 'center', \n    alignItems: 'center', \n    height: '100vh',\n    background: 'radial-gradient(circle at center, hsla(var(--primary-hue), 50%, 10%, 0.4) 0%, var(--color-bg-app) 100%)'\n  }}>\n    <GlassPanel style={{ \n      width: '400px', \n      display: 'flex', \n      flexDirection: 'column', \n      gap: '1.5rem',\n      alignItems: 'center',\n      padding: '3rem'\n    }}>\n      <div style={{ textAlign: 'center' }}>\n        <div style={{ fontSize: '1rem', color: 'var(--color-primary)', letterSpacing: '0.2em', fontWeight: 600, marginBottom: '-0.3rem' }}>VRCHAT</div>\n        <h1 className=\"text-gradient\" style={{ fontSize: '2rem', fontWeight: 800, margin: 0 }}>\n          GROUP GUARD\n        </h1>\n      </div>\n      \n      {/* Animated loading spinner */}\n      <motion.div\n        animate={{ rotate: 360 }}\n        transition={{ duration: 1.5, repeat: Infinity, ease: 'linear' }}\n        style={{\n          width: '48px',\n          height: '48px',\n          borderRadius: '50%',\n          border: '3px solid var(--border-color)',\n          borderTopColor: 'var(--color-primary)',\n        }}\n      />\n      \n      <p style={{ color: 'var(--color-text-dim)', textAlign: 'center' }}>\n        Signing you in automatically...\n      </p>\n    </GlassPanel>\n  </div>\n);\n\nfunction App() {\n  const { isAuthenticated, autoLogin, status, logout } = useAuthStore();\n  const { selectedGroup, selectGroup, isRoamingMode } = useGroupStore();\n  const [isCheckingAutoLogin, setIsCheckingAutoLogin] = useState(true);\n  const [isStorageConfigured, setIsStorageConfigured] = useState<boolean | null>(null);\n  const [currentView, setCurrentView] = useState<DockView>('main');\n  const [isLogoutConfirmOpen, setIsLogoutConfirmOpen] = useState(false);\n  const [isLiveMode, setIsLiveMode] = useState(false); // Track if VRC is running basically\n\n  // Initialize Pipeline WebSocket connection and event subscriptions\n  usePipelineInit();\n  \n  // Initialize Live Log Watcher\n  useInstanceMonitorInit(isAuthenticated);\n\n  const [isUpdateReady, setIsUpdateReady] = useState(false);\n\n  // Listen for updates\n  useEffect(() => {\n    // Return unsubscribe function\n    // Listen for updates if updater API is available\n    if (window.electron?.updater) {\n      // Check initial status (in case we missed the event)\n      window.electron.updater.checkStatus().then(downloaded => {\n          if (downloaded) {\n              console.log('Update already downloaded (found via status check)');\n              setIsUpdateReady(true);\n          }\n      });\n\n      const unsubscribe = window.electron.updater.onUpdateDownloaded(() => {\n        console.log('Update downloaded event received');\n        setIsUpdateReady(true);\n      });\n      return unsubscribe;\n    }\n  }, []);\n\n  // Monitor Live Log state to toggle Live Mode UI\n  useEffect(() => {\n    // Check roaming mode first\n    if (isRoamingMode) {\n      if (!isLiveMode) setIsLiveMode(true);\n      return;\n    }\n\n    // 1. Initial check\n    const checkStatus = async () => {\n        if (!selectedGroup) {\n            setIsLiveMode(false);\n            return;\n        }\n        \n        try {\n            const currentInstanceGroupId = await window.electron.instance.getCurrentGroup();\n            setIsLiveMode(currentInstanceGroupId === selectedGroup.id);\n        } catch (e) {\n            console.error(\"Failed to check live status:\", e);\n        }\n    };\n    checkStatus();\n\n    // 2. Listen for changes\n    if (!window.electron?.instance?.onGroupChanged) return;\n\n    const unsubscribe = window.electron.instance.onGroupChanged((groupId) => {\n        if (!selectedGroup) {\n            setIsLiveMode(false);\n        } else {\n            setIsLiveMode(groupId === selectedGroup.id);\n        }\n    });\n\n    return () => {\n        unsubscribe();\n    };\n  }, [selectedGroup, isRoamingMode, isLiveMode]);\n\n  // Check storage configuration first\n  useEffect(() => {\n    const checkStorage = async () => {\n      try {\n        const status = await window.electron.storage.getStatus();\n        setIsStorageConfigured(status.configured);\n      } catch (err) {\n        console.error('Failed to check storage status:', err);\n        // Fallback to true to avoid blocking app if something weird happens, \n        // though this ideally shouldn't happen with the new service.\n        setIsStorageConfigured(true); \n      }\n    };\n    checkStorage();\n  }, []);\n\n  // Attempt auto-login only after storage is confirmed\n  useEffect(() => {\n    if (isStorageConfigured === false || isStorageConfigured === null) {\n        return;\n    }\n\n    const attemptAutoLogin = async () => {\n      setIsCheckingAutoLogin(true);\n      try {\n        // Check if we have saved credentials and attempt auto-login\n        const hasSaved = await window.electron.hasSavedCredentials();\n        if (hasSaved) {\n          console.log('Found saved credentials, attempting auto-login...');\n          const result = await autoLogin();\n          if (result.success) {\n            console.log('Auto-login successful!');\n          } else if (result.requires2FA) {\n            console.log('Auto-login requires 2FA verification');\n            // User will need to enter 2FA code - this is expected behavior\n          } else {\n            console.log('Auto-login failed, showing login screen');\n          }\n        } else {\n          console.log('No saved credentials found');\n        }\n      } catch (err) {\n        console.error('Auto-login error:', err);\n      }\n      setIsCheckingAutoLogin(false);\n    };\n    \n    attemptAutoLogin();\n  }, [autoLogin, isStorageConfigured]);\n\n  // Auto-switch to Live View when entering Roaming Mode\n  useEffect(() => {\n    if (isRoamingMode) {\n      if (currentView !== 'live') setCurrentView('live');\n    } else if (currentView === 'live' && !selectedGroup) {\n        // If we exited roaming mode and have no group, go back to main\n        setCurrentView('main');\n    }\n  }, [isRoamingMode, selectedGroup, currentView]);\n\n  // Handle View Switching - memoized to prevent re-renders\n  const handleViewChange = useCallback((view: DockView) => {\n    // Exceptions for Live view in Roaming Mode\n    if (view === 'live' && (isRoamingMode || selectedGroup)) {\n        setCurrentView('live');\n        return;\n    }\n\n    if ((view === 'moderation' || view === 'audit' || view === 'database' || view === 'live') && !selectedGroup) {\n      // If trying to access group features without a group, go to group selection\n      selectGroup(null);\n      setCurrentView('main');\n      return;\n    }\n    setCurrentView(view);\n  }, [selectedGroup, selectGroup, isRoamingMode]);\n\n  // Memoize content to prevent re-renders during transitions\n  const content = useMemo(() => {\n    switch (currentView) {\n      case 'settings':\n        return <SettingsView />;\n      case 'moderation':\n        return <AutoModView />;\n      case 'live':\n        return <LiveView />;\n      case 'audit':\n        return (\n            <GlassPanel style={{ padding: '2rem', textAlign: 'center' }}>\n                <h2>Audit Logs</h2>\n                <p style={{ color: 'var(--color-text-dim)' }}>Coming Soon</p>\n            </GlassPanel>\n        );\n      case 'database':\n        return <DatabaseView />;\n      case 'main':\n      default:\n        return selectedGroup ? <DashboardView /> : <GroupSelectionView />;\n    }\n  }, [currentView, selectedGroup]);\n\n  // --- Unified Render Logic for Epic Transitions ---\n  let currentScreen: React.ReactNode;\n  let screenKey: string;\n\n  if (isStorageConfigured === null) {\n      currentScreen = <AutoLoginLoadingScreen />;\n      screenKey = 'loading-storage';\n  } else if (isStorageConfigured === false) {\n      currentScreen = <SetupView onComplete={() => setIsStorageConfigured(true)} />;\n      screenKey = 'setup';\n  } else if ((isCheckingAutoLogin && status === 'logging-in')) {\n      currentScreen = <AutoLoginLoadingScreen />;\n      screenKey = 'loading-autologin';\n  } else if (!isAuthenticated) {\n      currentScreen = <LoginView />;\n      screenKey = 'login';\n  } else {\n      // Main Authenticated App\n      currentScreen = (\n        <AppLayout>\n          <TitleBar \n            onSettingsClick={() => setCurrentView('settings')}\n            onLogoutClick={() => setIsLogoutConfirmOpen(true)}\n          />\n\n          {/* Main Content Render - Epic Transition */}\n          <AnimatePresence mode=\"wait\">\n            <PageTransition key={currentView + (selectedGroup ? selectedGroup.id : 'home')}>\n              <Suspense fallback={<ViewLoader />}>\n                {content}\n              </Suspense>\n            </PageTransition>\n          </AnimatePresence>\n\n          {/* Neon Dock Navigation */}\n          <NeonDock \n            currentView={currentView}\n            onViewChange={handleViewChange}\n            selectedGroup={selectedGroup}\n            onGroupClick={() => {\n                selectGroup(null);\n                setCurrentView('main');\n            }}\n            isLiveMode={isLiveMode}\n          />\n          \n          <GlobalModals \n            isLogoutConfirmOpen={isLogoutConfirmOpen}\n            setIsLogoutConfirmOpen={setIsLogoutConfirmOpen}\n            onLogoutConfirm={() => {\n                logout(false);\n                setIsLogoutConfirmOpen(false);\n            }}\n            isUpdateReady={isUpdateReady}\n          />\n        </AppLayout>\n      );\n      screenKey = 'app-layout';\n  }\n\n  return (\n    <AnimatePresence mode=\"wait\">\n        <PageTransition key={screenKey}>\n            {currentScreen}\n        </PageTransition>\n    </AnimatePresence>\n  );\n}\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\AppLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\GlobalModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\NeonDock.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\PageTransition.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\ParticleBackground.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\layout\\TitleBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\GlassPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\LiveBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\Modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\NeonButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\PipelineStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\components\\ui\\RefreshTimer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\constants\\app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\context\\ThemeContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":59,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":59,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useEffect, useState } from 'react';\r\n\r\n// Define the shape of our Theme State\r\ninterface ThemeState {\r\n  primaryHue: number;\r\n  setPrimaryHue: (hue: number) => void;\r\n  accentHue: number;\r\n  setAccentHue: (hue: number) => void;\r\n  glassBlur: number;\r\n  setGlassBlur: (px: number) => void;\r\n  resetTheme: () => void;\r\n}\r\n\r\nconst ThemeContext = createContext<ThemeState | undefined>(undefined);\r\n\r\nexport const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  // Initialize from LocalStorage or Default\r\n  const [primaryHue, setPrimaryHue] = useState<number>(() => parseInt(localStorage.getItem('primaryHue') || '270'));\r\n  const [accentHue, setAccentHue] = useState<number>(() => parseInt(localStorage.getItem('accentHue') || '180'));\r\n  const [glassBlur, setGlassBlur] = useState<number>(() => parseInt(localStorage.getItem('glassBlur') || '20'));\r\n\r\n  // Sync state to CSS Variables\r\n  useEffect(() => {\r\n    const root = document.documentElement;\r\n    root.style.setProperty('--primary-hue', primaryHue.toString());\r\n    localStorage.setItem('primaryHue', primaryHue.toString());\r\n  }, [primaryHue]);\r\n\r\n  useEffect(() => {\r\n    const root = document.documentElement;\r\n    root.style.setProperty('--accent-hue', accentHue.toString());\r\n    localStorage.setItem('accentHue', accentHue.toString());\r\n  }, [accentHue]);\r\n\r\n  useEffect(() => {\r\n    const root = document.documentElement;\r\n    root.style.setProperty('--glass-blur', `${glassBlur}px`);\r\n    localStorage.setItem('glassBlur', glassBlur.toString());\r\n  }, [glassBlur]);\r\n\r\n  const resetTheme = () => {\r\n    setPrimaryHue(270);\r\n    setAccentHue(180);\r\n    setGlassBlur(20);\r\n  };\r\n\r\n  return (\r\n    <ThemeContext.Provider value={{ \r\n      primaryHue, setPrimaryHue, \r\n      accentHue, setAccentHue,\r\n      glassBlur, setGlassBlur,\r\n      resetTheme \r\n    }}>\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useTheme = () => {\r\n  const context = useContext(ThemeContext);\r\n  if (!context) {\r\n    throw new Error('useTheme must be used within a ThemeProvider');\r\n  }\r\n  return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\auth\\LoginView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\auth\\UserProfileWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\automod\\AutoModView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\automod\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\DashboardView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\components\\StatTile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\BansListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\InstancesListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\MembersListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\RequestsListDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\UserProfileDialog.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nF:\\Group Guard scratch\\src\\features\\dashboard\\dialogs\\UserProfileDialog.tsx:15:13\n  13 |     useEffect(() => {\n  14 |         if (isOpen && userId) {\n> 15 |             setLoading(true);\n     |             ^^^^^^^^^^ Avoid calling setState() directly within an effect\n  16 |             setError(null);\n  17 |             setUser(null);\n  18 |             ","line":15,"column":13,"nodeType":null,"endLine":15,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\nimport { Modal } from '../../../components/ui/Modal';\r\nimport { GlassPanel } from '../../../components/ui/GlassPanel';\r\nimport { useUserProfileStore } from '../../../stores/userProfileStore';\r\nimport type { VRChatUser } from '../../../types/electron';\r\n\r\nexport const UserProfileDialog: React.FC = () => {\r\n    const { isOpen, userId, closeProfile } = useUserProfileStore();\r\n    const [user, setUser] = useState<VRChatUser | null>(null);\r\n    const [loading, setLoading] = useState(false);\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    useEffect(() => {\r\n        if (isOpen && userId) {\r\n            setLoading(true);\r\n            setError(null);\r\n            setUser(null);\r\n            \r\n            window.electron.getUser(userId)\r\n                .then(res => {\r\n                    if (res.success && res.user) {\r\n                        setUser(res.user);\r\n                    } else {\r\n                        setError(res.error || 'Failed to load user');\r\n                    }\r\n                })\r\n                .catch(err => setError(String(err)))\r\n                .finally(() => setLoading(false));\r\n        }\r\n    }, [isOpen, userId]);\r\n\r\n    if (!isOpen) return null;\r\n\r\n    const getStatusColor = (status?: string) => {\r\n        switch (status) {\r\n            case 'active': return '#5cc9f5'; // Blue\r\n            case 'join me': return '#42b983'; // Blue-ish\r\n            case 'busy': return '#ab1a1a'; // Red\r\n            default: return '#888';\r\n        }\r\n    };\r\n    \r\n    // Status text (VRChat \"status\" is often \"active\", \"join me\", etc. \"state\" is offline/online?)\r\n    // Actually VRChat API is a bit complex here. statusDescription is the custom text.\r\n    // status is \"active\", \"join me\", \"ask me\", \"busy\", \"offline\".\r\n\r\n    return (\r\n        <Modal \r\n            isOpen={isOpen} \r\n            onClose={closeProfile} \r\n            title={user?.displayName || 'User Profile'}\r\n            width=\"600px\"\r\n        >\r\n            {loading ? (\r\n                <div style={{ padding: '40px', textAlign: 'center', color: '#888' }}>\r\n                    Loading profile...\r\n                </div>\r\n            ) : error ? (\r\n                <div style={{ padding: '20px', textAlign: 'center', color: '#ff4444' }}>\r\n                    {error}\r\n                </div>\r\n            ) : user ? (\r\n                <div style={{ padding: '10px' }}>\r\n                    {/* Header: Avatar & Basic Info */}\r\n                    <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>\r\n                        <div style={{ position: 'relative' }}>\r\n                            <img \r\n                                src={user.profilePicOverride || user.currentAvatarImageUrl || user.userIcon} \r\n                                alt={user.displayName}\r\n                                style={{ \r\n                                    width: '120px', \r\n                                    height: '120px', \r\n                                    borderRadius: '12px', \r\n                                    objectFit: 'cover',\r\n                                    border: `2px solid ${getStatusColor(user.status)}`\r\n                                }} \r\n                            />\r\n                            <div style={{ position: 'absolute', bottom: '-10px', right: '-10px', display: 'flex', alignItems: 'center', gap: '5px' }}>\r\n                                {/* Age Verified Badge */}\r\n                                {(user.ageVerified || user.tags?.includes('system_age_verified')) && (\r\n                                    <div style={{\r\n                                        background: '#fbbf24', // Amber/Gold\r\n                                        color: '#000',\r\n                                        padding: '2px 6px',\r\n                                        borderRadius: '8px',\r\n                                        fontSize: '0.75rem',\r\n                                        fontWeight: '800',\r\n                                        border: '2px solid rgba(0,0,0,0.5)'\r\n                                    }}>\r\n                                        18+\r\n                                    </div>\r\n                                )}\r\n                                \r\n                                <div style={{\r\n                                    background: getStatusColor(user.status),\r\n                                    color: 'white',\r\n                                    padding: '2px 8px',\r\n                                    borderRadius: '10px',\r\n                                    fontSize: '0.8rem',\r\n                                    fontWeight: 'bold',\r\n                                    border: '2px solid #1a1b1e' // Match background? Or dark border\r\n                                }}>\r\n                                    {user.status || 'Offline'}\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        \r\n                        <div style={{ flex: 1 }}>\r\n                            <h2 style={{ margin: '0 0 5px 0', fontSize: '1.8rem', color: '#fff' }}>\r\n                                {user.displayName}\r\n                            </h2>\r\n                            <div style={{ color: '#aaa', fontSize: '0.9rem', marginBottom: '10px' }}>\r\n                                {user.statusDescription}\r\n                            </div>\r\n                            \r\n                            <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                                {user.tags?.map(tag => (\r\n                                    <span key={tag} style={{ \r\n                                        background: 'rgba(255,255,255,0.1)', \r\n                                        padding: '2px 8px', \r\n                                        borderRadius: '4px',\r\n                                        fontSize: '0.8rem',\r\n                                        color: '#ccc'\r\n                                    }}>\r\n                                        {tag.replace('system_', '').replace(/_/g, ' ')}\r\n                                    </span>\r\n                                ))}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                    {/* Bio */}\r\n                    <GlassPanel style={{ padding: '15px', marginBottom: '15px' }}>\r\n                        <h4 style={{ marginTop: 0, color: '#888', textTransform: 'uppercase', fontSize: '0.8rem' }}>Bio</h4>\r\n                        <div style={{ whiteSpace: 'pre-wrap', lineHeight: '1.5', color: '#eee' }}>\r\n                            {user.bio || 'No bio available.'}\r\n                        </div>\r\n                        \r\n                        {user.bioLinks && user.bioLinks.length > 0 && (\r\n                            <div style={{ marginTop: '10px', display: 'flex', flexWrap: 'wrap', gap: '10px' }}>\r\n                                {user.bioLinks.map(link => (\r\n                                    <a  key={link} \r\n                                        href={link} \r\n                                        target=\"_blank\" \r\n                                        rel=\"noopener noreferrer\"\r\n                                        style={{ color: '#5cc9f5', textDecoration: 'none', fontSize: '0.9rem' }}\r\n                                    >\r\n                                        {link}\r\n                                    </a>\r\n                                ))}\r\n                            </div>\r\n                        )}\r\n                    </GlassPanel>\r\n\r\n                    {/* Details Grid */}\r\n                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>\r\n                        <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Last Login</div>\r\n                            <div>{user.last_login ? new Date(user.last_login).toLocaleDateString() : 'Unknown'}</div>\r\n                        </GlassPanel>\r\n                        <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Date Joined</div>\r\n                            <div>{user.date_joined ? new Date(user.date_joined).toLocaleDateString() : 'Unknown'}</div>\r\n                        </GlassPanel>\r\n                        <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Trust Rank</div>\r\n                            <div>{getTrustRank(user.tags)}</div>\r\n                        </GlassPanel>\r\n                         <GlassPanel style={{ padding: '15px' }}>\r\n                            <div style={{ color: '#888', fontSize: '0.8rem' }}>Location</div>\r\n                            <div>{user.location || user.state || 'Unknown'}</div>\r\n                        </GlassPanel>\r\n                    </div>\r\n\r\n                </div>\r\n            ) : null}\r\n        </Modal>\r\n    );\r\n};\r\n\r\n// Helper to deduce rank from tags because VRChat API doesn't send \"trustRank\" field directly typically, \r\n// unless we inspect tags like 'system_trust_veteran'.\r\nfunction getTrustRank(tags: string[] = []): string {\r\n    if (tags.includes('system_trust_legend')) return 'Legendary';\r\n    if (tags.includes('system_trust_veteran')) return 'Veteran';\r\n    if (tags.includes('system_trust_trusted')) return 'Trusted';\r\n    if (tags.includes('system_trust_known')) return 'Known';\r\n    if (tags.includes('system_trust_basic')) return 'User';\r\n    if (tags.includes('system_probation')) return 'Visitor (Probation)'; // or similar\r\n    // Default fallback\r\n    return 'Visitor'; \r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\dashboard\\widgets\\InstanceMonitorWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\database\\DatabaseView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\groups\\GroupSelectionView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\live\\LiveView.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6260,6263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6260,6263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\live\\dialogs\\BanUserDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\settings\\SettingsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\features\\setup\\SetupView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\useDataRefresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\useInstanceAutoRefresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\useInstanceMonitorInit.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1667,1670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1667,1670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2168,2171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2168,2171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2202,2205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2202,2205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { useEffect, useRef } from 'react';\r\nimport { useInstanceMonitorStore, type LivePlayerInfo } from '../stores/instanceMonitorStore';\r\nimport { useGroupStore } from '../stores/groupStore';\r\n\r\nexport function useInstanceMonitorInit(isAuthenticated: boolean) {\r\n  const { addPlayer, removePlayer, setWorldId, setInstanceInfo, setWorldName, setInstanceImage, clearInstance, clearLiveScan } = useInstanceMonitorStore();\r\n  const { isRoamingMode } = useGroupStore();\r\n\r\n  // Clear live scan history when exiting roaming mode\r\n  const prevRoamingRef = useRef(isRoamingMode);\r\n  useEffect(() => {\r\n    if (prevRoamingRef.current && !isRoamingMode) {\r\n        clearLiveScan();\r\n    }\r\n    prevRoamingRef.current = isRoamingMode;\r\n  }, [isRoamingMode, clearLiveScan]);\r\n\r\n  useEffect(() => {\r\n    if (!isAuthenticated) return;\r\n\r\n    console.log('[InstanceMonitor] Initializing Log Watcher...');\r\n    // Start watching logs\r\n    window.electron.logWatcher.start();\r\n\r\n    // Setup event listeners\r\n    const cleanupJoined = window.electron.logWatcher.onPlayerJoined((event) => {\r\n      const player: LivePlayerInfo = {\r\n        displayName: event.displayName,\r\n        userId: event.userId,\r\n        joinTime: new Date(event.timestamp).getTime()\r\n      };\r\n      addPlayer(player);\r\n    });\r\n\r\n    const cleanupLeft = window.electron.logWatcher.onPlayerLeft((event) => {\r\n      removePlayer(event.displayName);\r\n    });\r\n\r\n    const cleanupLocation = window.electron.logWatcher.onLocation(async (event) => {\r\n      // New location detected, clear previous instance data\r\n      clearInstance();\r\n      setWorldId(event.worldId);\r\n      \r\n      const eventAny = event as any;\r\n      if (eventAny.instanceId && eventAny.location) {\r\n          setInstanceInfo(eventAny.instanceId, eventAny.location);\r\n      }\r\n      \r\n      // Fetch world details if we can (to fix \"Unknown World\")\r\n      try {\r\n        const result = await window.electron.getWorld(event.worldId);\r\n        if (result.success && result.world) {\r\n            setWorldName(result.world.name);\r\n            // Assuming world object has imageUrl or thumbnailImageUrl\r\n            const img = (result.world as any).imageUrl || (result.world as any).thumbnailImageUrl;\r\n            if (img) setInstanceImage(img);\r\n        }\r\n      } catch (e) {\r\n        console.error('Failed to fetch world name', e);\r\n      }\r\n    });\r\n\r\n    const cleanupWorldName = window.electron.logWatcher.onWorldName((event) => {\r\n      setWorldName(event.name);\r\n    });\r\n\r\n    return () => {\r\n      cleanupJoined();\r\n      cleanupLeft();\r\n      cleanupLocation();\r\n      cleanupWorldName();\r\n      window.electron.logWatcher.stop();\r\n    };\r\n\r\n  }, [isAuthenticated, addPlayer, removePlayer, setWorldId, setWorldName, clearInstance, setInstanceInfo, setInstanceImage]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\hooks\\usePipelineInit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\auditStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\authStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\groupStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\instanceMonitorStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\pipelineStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\uiStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\stores\\userProfileStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\src\\types\\electron.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9288,9291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9288,9291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":312,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9691,9694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9691,9694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":316,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":316,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10076,10079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10076,10079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":340,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10825,10828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10825,10828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// User type from VRChat API\r\nexport interface VRChatUser {\r\n  id: string;\r\n  username: string;\r\n  displayName: string;\r\n  userIcon: string;\r\n  bio?: string;\r\n  currentAvatarImageUrl?: string;\r\n  currentAvatarThumbnailImageUrl?: string;\r\n  status?: string;\r\n  statusDescription?: string;\r\n  state?: string;\r\n  tags?: string[];\r\n  developerType?: string;\r\n  last_login?: string;\r\n  last_platform?: string;\r\n  allowAvatarCopying?: boolean;\r\n  isFriend?: boolean;\r\n  friendKey?: string;\r\n  last_activity?: string;\r\n  bioLinks?: string[];\r\n  date_joined?: string;\r\n  location?: string;\r\n  profilePicOverride?: string;\r\n  friendKey?: string;\r\n  isFriend?: boolean;\r\n  statusHistory?: string[];\r\n  ageVerified?: boolean;\r\n  // Add additional fields as needed\r\n}\r\n\r\n// Group type from VRChat API  \r\nexport interface VRChatGroup {\r\n  id: string;\r\n  name: string;\r\n  shortCode: string;\r\n  discriminator?: string;\r\n  description?: string;\r\n  iconUrl?: string;\r\n  iconId?: string;\r\n  bannerUrl?: string;\r\n  bannerId?: string;\r\n  privacy?: string;\r\n  ownerId: string;\r\n  rules?: string;\r\n  links?: string[];\r\n  languages?: string[];\r\n  memberCount: number;\r\n  memberCountSyncedAt?: string;\r\n  isVerified?: boolean;\r\n  joinState?: string;\r\n  tags?: string[];\r\n  galleries?: unknown[];\r\n  createdAt?: string;\r\n  onlineMemberCount?: number;\r\n  membershipStatus?: string;\r\n  myMember?: unknown;\r\n}\r\n\r\nexport interface LoginCredentials {\r\n  username: string;\r\n  password: string;\r\n  rememberMe?: boolean;\r\n}\r\n\r\nexport interface LoginResult {\r\n  success: boolean;\r\n  user?: VRChatUser;\r\n  requires2FA?: boolean;\r\n  twoFactorMethods?: string[];\r\n  error?: string;\r\n}\r\n\r\nexport interface AutoLoginResult {\r\n  success: boolean;\r\n  user?: VRChatUser;\r\n  requires2FA?: boolean;\r\n  noCredentials?: boolean;\r\n  error?: string;\r\n}\r\n\r\nexport interface SessionResult {\r\n  isLoggedIn: boolean;\r\n  user?: VRChatUser;\r\n}\r\n\r\nexport interface LogoutOptions {\r\n  clearSaved?: boolean;\r\n}\r\n\r\nexport interface GroupsResult {\r\n  success: boolean;\r\n  groups?: VRChatGroup[];\r\n  error?: string;\r\n}\r\n\r\nexport interface AuditLogsResult {\r\n  success: boolean;\r\n  logs?: unknown[];\r\n  error?: string;\r\n}\r\n\r\nexport interface GroupMember {\r\n  id: string; // \"gmem_...\"\r\n  groupId: string;\r\n  userId: string;\r\n  isRepresenting: boolean;\r\n  roleIds: string[];\r\n  mangerNotes?: string;\r\n  membershipStatus: string; // \"member\" | \"admin\" | \"owner\"\r\n  visibility: string;\r\n  joinedAt?: string;\r\n  bannedAt?: string;\r\n  user: VRChatUser;\r\n}\r\n\r\nexport interface GroupRequest {\r\n  id: string;\r\n  user: VRChatUser;\r\n  groupId: string;\r\n  userId: string;\r\n  createdAt: string;\r\n}\r\n\r\nexport interface GroupBan {\r\n  id: string;\r\n  user: VRChatUser;\r\n  groupId: string;\r\n  userId: string;\r\n  createdAt: string; // or bannedAt\r\n}\r\n\r\nexport interface VRChatInstance {\r\n  id?: string; // Sometimes missing in group instances - use location or instanceId\r\n  instanceId?: string;\r\n  name?: string; // Instance number like \"86267\"\r\n  displayName?: string; // Group display name\r\n  location?: string; // Full location string: worldId:instanceId\r\n  worldId?: string;\r\n  \r\n  // User counts\r\n  n_users?: number;\r\n  userCount?: number;\r\n  memberCount?: number;\r\n  capacity?: number;\r\n  \r\n  // Instance properties\r\n  ownerId?: string;\r\n  type?: string; // \"group\", \"public\", etc.\r\n  groupAccessType?: string; // \"public\", \"plus\", \"members\" for group instances\r\n  ageGate?: boolean; // 18+ age verification required\r\n  region?: string;\r\n  shortName?: string;\r\n  \r\n  // World data (nested from API)\r\n  world?: {\r\n      id?: string;\r\n      name?: string;\r\n      authorId?: string;\r\n      authorName?: string;\r\n      description?: string;\r\n      capacity?: number;\r\n      imageUrl?: string;\r\n      thumbnailImageUrl?: string;\r\n  };\r\n\r\n  // Group data (nested from API)\r\n  group?: {\r\n      id?: string;\r\n      name?: string;\r\n      shortCode?: string;\r\n      discriminator?: string;\r\n  };\r\n}\r\n\r\n// Pipeline WebSocket Event Types\r\nexport type PipelineEventType =\r\n  // Notification Events\r\n  | 'notification'\r\n  | 'notification-v2'\r\n  | 'notification-v2-update'\r\n  | 'notification-v2-delete'\r\n  | 'see-notification'\r\n  | 'hide-notification'\r\n  | 'response-notification'\r\n  | 'clear-notification'\r\n  // Friend Events\r\n  | 'friend-add'\r\n  | 'friend-delete'\r\n  | 'friend-online'\r\n  | 'friend-active'\r\n  | 'friend-offline'\r\n  | 'friend-update'\r\n  | 'friend-location'\r\n  // User Events\r\n  | 'user-update'\r\n  | 'user-location'\r\n  | 'user-badge-assigned'\r\n  | 'user-badge-unassigned'\r\n  | 'content-refresh'\r\n  // Group Events\r\n  | 'group-joined'\r\n  | 'group-left'\r\n  | 'group-member-updated'\r\n  | 'group-role-updated';\r\n\r\nexport interface PipelineEvent {\r\n  type: PipelineEventType;\r\n  content: Record<string, unknown>;\r\n  timestamp: string;\r\n}\r\n\r\nexport interface AutoModRule {\r\n    id: number;\r\n    name: string;\r\n    enabled: boolean;\r\n    type: 'AGE_CHECK' | 'TRUST_CHECK' | 'KEYWORD_BLOCK' | 'WHITELIST_CHECK' | 'BAN_EVASION_CHECK';\r\n    config: string;\r\n    actionType: 'REJECT' | 'AUTO_BLOCK' | 'NOTIFY_ONLY';\r\n    createdAt?: string;\r\n}\r\n\r\nexport interface ElectronAPI {\r\n  log: (level: 'info' | 'warn' | 'error', message: string) => void;\r\n  getVersion: () => string;\r\n  \r\n  // Auth API\r\n  login: (credentials: LoginCredentials) => Promise<LoginResult>;\r\n  verify2fa: (data: { code: string }) => Promise<LoginResult>;\r\n  checkSession: () => Promise<SessionResult>;\r\n  autoLogin: () => Promise<AutoLoginResult>;\r\n  hasSavedCredentials: () => Promise<boolean>;\r\n  loadSavedCredentials: () => Promise<{ username: string; password: string; authCookie?: string } | null>;\r\n  logout: (options?: LogoutOptions) => Promise<{ success: boolean }>;\r\n  clearCredentials: () => Promise<{ success: boolean }>;\r\n  \r\n  // Groups API\r\n  getMyGroups: () => Promise<GroupsResult>;\r\n  getGroupDetails: (groupId: string) => Promise<{ success: boolean; group?: VRChatGroup; error?: string }>;\r\n  getGroupMembers: (groupId: string, offset?: number, n?: number) => Promise<{ success: boolean; members?: GroupMember[]; error?: string }>;\r\n  getGroupRequests: (groupId: string) => Promise<{ success: boolean; requests?: GroupRequest[]; error?: string }>;\r\n  getGroupBans: (groupId: string) => Promise<{ success: boolean; bans?: GroupBan[]; error?: string }>;\r\n  getGroupInstances: (groupId: string) => Promise<{ success: boolean; instances?: VRChatInstance[]; error?: string }>;\r\n  banUser: (groupId: string, userId: string) => Promise<{ success: boolean; error?: string }>;\r\n\r\n\r\n  \r\n  // Audit API\r\n  getGroupAuditLogs: (groupId: string) => Promise<AuditLogsResult>;\r\n\r\n  // Worlds API\r\n  getWorld: (worldId: string) => Promise<{ success: boolean; world?: { id: string; name: string; capacity?: number; imageUrl?: string; authorName?: string }; error?: string }>;\r\n\r\n  // User API\r\n  getUser: (userId: string) => Promise<{ success: boolean; user?: VRChatUser; error?: string }>;\r\n  clearUserCache: (userId?: string) => Promise<{ success: boolean }>;\r\n\r\n  // Pipeline (WebSocket) API for real-time events\r\n  pipeline: {\r\n    connect: () => Promise<{ success: boolean; connected: boolean }>;\r\n    disconnect: () => Promise<{ success: boolean }>;\r\n    status: () => Promise<{ connected: boolean; connecting: boolean; reconnectAttempts: number }>;\r\n    reconnect: () => Promise<{ success: boolean }>;\r\n    \r\n    // Event listeners - return unsubscribe function\r\n    onEvent: (callback: (event: PipelineEvent) => void) => () => void;\r\n    onConnected: (callback: (data: { connected: boolean }) => void) => () => void;\r\n    onDisconnected: (callback: (data: { code: number; reason: string; willReconnect: boolean }) => void) => () => void;\r\n    onError: (callback: (data: { message: string }) => void) => () => void;\r\n  };\r\n\r\n  // Log Watcher API for live log events\r\n  logWatcher: {\r\n    start: () => Promise<{ success: boolean }>;\r\n    stop: () => Promise<{ success: boolean }>;\r\n    onPlayerJoined: (callback: (event: { displayName: string; userId?: string; timestamp: string }) => void) => () => void;\r\n    onPlayerLeft: (callback: (event: { displayName: string; userId?: string; timestamp: string }) => void) => () => void;\r\n    onLocation: (callback: (event: { worldId: string; timestamp: string }) => void) => () => void;\r\n    onWorldName: (callback: (event: { name: string; timestamp: string }) => void) => () => void;\r\n  };\r\n\r\n  // Database API for local logging\r\n  database: {\r\n      getSessions: (groupId?: string) => Promise<unknown[]>;\r\n      getSessionEvents: (filename: string) => Promise<unknown[]>;\r\n      clearSessions: () => Promise<boolean>;\r\n      rallyFromSession: (filename: string) => Promise<{\r\n          success: boolean;\r\n          invited?: number;\r\n          failed?: number;\r\n          total?: number;\r\n          error?: string;\r\n          errors?: string[];\r\n      }>;\r\n      onRallyProgress: (callback: (data: { sent: number; failed: number; total: number; done?: boolean }) => void) => () => void;\r\n  };\r\n\r\n  // Storage API\r\n  storage: {\r\n      getStatus: () => Promise<{ configured: boolean; path: string; defaultPath: string }>;\r\n      selectFolder: () => Promise<string | null>;\r\n      setPath: (path: string) => Promise<boolean>;\r\n  };\r\n\r\n  // Instance Presence API\r\n  instance: {\r\n      // NEW LIVE OPS API\r\n      scanSector: (groupId: string) => Promise<any[]>;\r\n      recruitUser: (groupId: string, userId: string) => Promise<{ success: boolean; error?: string }>;\r\n      kickUser: (groupId: string, userId: string) => Promise<{ success: boolean; error?: string }>;\r\n      // rallyForces: (groupId: string) => Promise<{ success: boolean; count?: number; error?: string }>;\r\n      getRallyTargets: (groupId: string) => Promise<{ success: boolean; targets?: any[]; error?: string }>;\r\n      inviteToCurrent: (userId: string) => Promise<{ success: boolean; error?: string }>;\r\n      closeInstance: () => Promise<{ success: boolean; error?: string }>;\r\n      getInstanceInfo: () => Promise<{ success: boolean; worldId?: string; instanceId?: string; name?: string; imageUrl?: string; error?: string }>;\r\n      onEntityUpdate: (callback: (entity: any) => void) => () => void;\r\n      \r\n      getCurrentGroup: () => Promise<string | null>;\r\n      onGroupChanged: (callback: (groupId: string | null) => void) => () => void;\r\n  };\r\n\r\n  // Updater API\r\n  updater: {\r\n      onUpdateAvailable: (callback: () => void) => () => void;\r\n      onUpdateDownloaded: (callback: () => void) => () => void;\r\n      quitAndInstall: () => void;\r\n      checkStatus: () => Promise<boolean>;\r\n  };\r\n\r\n  // Window Controls\r\n  minimize: () => void;\r\n  maximize: () => void;\r\n  close: () => void;\r\n\r\n  // AutoMod API\r\n  automod: {\r\n      getRules: () => Promise<AutoModRule[]>;\r\n      saveRule: (rule: AutoModRule) => Promise<AutoModRule>;\r\n      deleteRule: (ruleId: number) => Promise<boolean>;\r\n      checkUser: (user: any) => Promise<{ action: 'ALLOW' | 'REJECT' | 'AUTO_BLOCK' | 'NOTIFY_ONLY'; reason?: string; ruleName?: string }>;\r\n  };\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    electron: ElectronAPI;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"F:\\Group Guard scratch\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
